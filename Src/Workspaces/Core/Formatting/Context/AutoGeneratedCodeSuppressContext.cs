using System.Collections.Generic;
using Roslyn.Compilers;
using Roslyn.Compilers.Common;
using Roslyn.Utilities;

namespace Roslyn.Services.Formatting
{
    internal class AutoGeneratedCodeSuppressContext
    {
        private readonly ContextIntervalTree<SuppressWrappingData> wrappingTree;
        private readonly ContextIntervalTree<SuppressSpacingData> spacingTree;

        // hashset to prevent duplicate entries in the trees.
        private readonly HashSet<TextSpan> wrappingMap;
        private readonly HashSet<TextSpan> spacingMap;

        public AutoGeneratedCodeSuppressContext(List<ISuppressOperation> autoGeneratedOperations)
        {
            this.spacingMap = new HashSet<TextSpan>();
            this.wrappingMap = new HashSet<TextSpan>();

            this.spacingTree = new ContextIntervalTree<SuppressSpacingData>(SuppressIntervalIntrospector.Instance);
            this.wrappingTree = new ContextIntervalTree<SuppressWrappingData>(SuppressIntervalIntrospector.Instance);

            autoGeneratedOperations.Do(AddSuppressOperation);
        }

        private void AddSuppressOperation(ISuppressOperation operation)
        {
            // dont add stuff if it is empty
            if (operation == null ||
                operation.Span.IsEmpty)
            {
                return;
            }

            if (operation.Option.IsFlagOn(SuppressOption.NoSpacing) && !this.spacingMap.Contains(operation.Span))
            {
                var data = new SuppressSpacingData(operation.Span, noSpacing: true);

                this.spacingMap.Add(operation.Span);
                this.spacingTree.AddIntervalInPlace(data);
            }

            if (operation.Option.IsFlagOn(SuppressOption.NoWrapping) && !wrappingMap.Contains(operation.Span))
            {
                var data = new SuppressWrappingData(operation.Span, noWrapping: true);

                this.wrappingMap.Add(operation.Span);
                this.wrappingTree.AddIntervalInPlace(data);
            }
        }

        public bool IsWrappingSuppressed(TextSpan span)
        {
            var data = this.wrappingTree.GetSmallestEdgeInclusivelyContainingInterval(span.Start, span.Length);
            if (data == null)
            {
                return false;
            }

            return data.NoWrapping;
        }

        public bool IsSpacingSuppressed(TextSpan span)
        {
            var data = this.spacingTree.GetSmallestEdgeInclusivelyContainingInterval(span.Start, span.Length);
            if (data == null)
            {
                return false;
            }

            return data.NoSpacing;
        }
    }
}
