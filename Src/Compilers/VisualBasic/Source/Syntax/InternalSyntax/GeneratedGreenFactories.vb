' Definition of syntax node factories.
' Generated by a tool on 4/5/2012 12:49 PM
' DO NOT HAND EDIT

Imports System.Collections.Generic

Namespace Roslyn.Compilers.VisualBasic.InternalSyntax

    Friend Partial Class Syntax

        Friend Shared ReadOnly NodeTypes As ImmutableList(Of Object) = New Object() {
          GetType(SyntaxNode),
          GetType(StatementSyntax),
          GetType(ExecutableStatementSyntax),
          GetType(DeclarationStatementSyntax),
          GetType(EmptyStatementSyntax),
          GetType(EndBlockStatementSyntax),
          GetType(CompilationUnitSyntax),
          GetType(OptionStatementSyntax),
          GetType(ImportsStatementSyntax),
          GetType(ImportsClauseSyntax),
          GetType(AliasImportsClauseSyntax),
          GetType(MembersImportsClauseSyntax),
          GetType(XmlNamespaceImportsClauseSyntax),
          GetType(NamespaceBlockSyntax),
          GetType(NamespaceStatementSyntax),
          GetType(TypeBlockSyntax),
          GetType(ModuleBlockSyntax),
          GetType(StructureBlockSyntax),
          GetType(InterfaceBlockSyntax),
          GetType(ClassBlockSyntax),
          GetType(EnumBlockSyntax),
          GetType(InheritsOrImplementsStatementSyntax),
          GetType(InheritsStatementSyntax),
          GetType(ImplementsStatementSyntax),
          GetType(TypeStatementSyntax),
          GetType(ModuleStatementSyntax),
          GetType(StructureStatementSyntax),
          GetType(InterfaceStatementSyntax),
          GetType(ClassStatementSyntax),
          GetType(EnumStatementSyntax),
          GetType(TypeParameterListSyntax),
          GetType(TypeParameterSyntax),
          GetType(TypeParameterConstraintClauseSyntax),
          GetType(TypeParameterSingleConstraintClauseSyntax),
          GetType(TypeParameterMultipleConstraintClauseSyntax),
          GetType(ConstraintSyntax),
          GetType(SpecialConstraintSyntax),
          GetType(TypeConstraintSyntax),
          GetType(EnumMemberDeclarationSyntax),
          GetType(MethodBlockSyntax),
          GetType(PropertyBlockSyntax),
          GetType(EventBlockSyntax),
          GetType(MethodBaseSyntax),
          GetType(ParameterListSyntax),
          GetType(MethodStatementSyntax),
          GetType(ConstructorStatementSyntax),
          GetType(DeclareStatementSyntax),
          GetType(DelegateStatementSyntax),
          GetType(EventStatementSyntax),
          GetType(OperatorStatementSyntax),
          GetType(PropertyStatementSyntax),
          GetType(AccessorStatementSyntax),
          GetType(ImplementsClauseSyntax),
          GetType(HandlesClauseSyntax),
          GetType(HandlesClauseItemSyntax),
          GetType(IncompleteMemberSyntax),
          GetType(FieldDeclarationSyntax),
          GetType(VariableDeclaratorSyntax),
          GetType(AsClauseSyntax),
          GetType(SimpleAsClauseSyntax),
          GetType(AsNewClauseSyntax),
          GetType(ObjectCreationInitializerSyntax),
          GetType(ObjectMemberInitializerSyntax),
          GetType(ObjectCollectionInitializerSyntax),
          GetType(FieldInitializerSyntax),
          GetType(InferredFieldInitializerSyntax),
          GetType(NamedFieldInitializerSyntax),
          GetType(EqualsValueSyntax),
          GetType(ParameterSyntax),
          GetType(ModifiedIdentifierSyntax),
          GetType(ArrayRankSpecifierSyntax),
          GetType(AttributeBlockSyntax),
          GetType(AttributeSyntax),
          GetType(AttributeTargetSyntax),
          GetType(AttributesStatementSyntax),
          GetType(ExpressionStatementSyntax),
          GetType(WhileBlockSyntax),
          GetType(UsingBlockSyntax),
          GetType(SyncLockBlockSyntax),
          GetType(WithBlockSyntax),
          GetType(LocalDeclarationSyntax),
          GetType(LabelStatementSyntax),
          GetType(GoToStatementSyntax),
          GetType(LabelSyntax),
          GetType(StopOrEndStatementSyntax),
          GetType(ExitStatementSyntax),
          GetType(ContinueStatementSyntax),
          GetType(ReturnStatementSyntax),
          GetType(SingleLineIfStatementSyntax),
          GetType(SingleLineIfPartSyntax),
          GetType(SingleLineElsePartSyntax),
          GetType(MultiLineIfBlockSyntax),
          GetType(IfPartSyntax),
          GetType(ElsePartSyntax),
          GetType(IfStatementSyntax),
          GetType(ElseStatementSyntax),
          GetType(TryBlockSyntax),
          GetType(TryPartSyntax),
          GetType(CatchPartSyntax),
          GetType(FinallyPartSyntax),
          GetType(TryStatementSyntax),
          GetType(CatchStatementSyntax),
          GetType(CatchFilterClauseSyntax),
          GetType(FinallyStatementSyntax),
          GetType(ErrorStatementSyntax),
          GetType(OnErrorGoToStatementSyntax),
          GetType(OnErrorResumeNextStatementSyntax),
          GetType(ResumeStatementSyntax),
          GetType(SelectBlockSyntax),
          GetType(SelectStatementSyntax),
          GetType(CaseBlockSyntax),
          GetType(CaseStatementSyntax),
          GetType(CaseClauseSyntax),
          GetType(CaseElseClauseSyntax),
          GetType(CaseValueClauseSyntax),
          GetType(CaseRangeClauseSyntax),
          GetType(CaseRelationalClauseSyntax),
          GetType(SyncLockStatementSyntax),
          GetType(DoLoopBlockSyntax),
          GetType(DoStatementSyntax),
          GetType(LoopStatementSyntax),
          GetType(WhileUntilClauseSyntax),
          GetType(WhileStatementSyntax),
          GetType(ForBlockSyntax),
          GetType(ForStatementSyntax),
          GetType(ForStepClauseSyntax),
          GetType(ForEachStatementSyntax),
          GetType(NextStatementSyntax),
          GetType(UsingStatementSyntax),
          GetType(ThrowStatementSyntax),
          GetType(AssignmentStatementSyntax),
          GetType(CallStatementSyntax),
          GetType(AddRemoveHandlerStatementSyntax),
          GetType(RaiseEventStatementSyntax),
          GetType(WithStatementSyntax),
          GetType(ReDimStatementSyntax),
          GetType(EraseStatementSyntax),
          GetType(ExpressionSyntax),
          GetType(LiteralExpressionSyntax),
          GetType(ParenthesizedExpressionSyntax),
          GetType(InstanceExpressionSyntax),
          GetType(MeExpressionSyntax),
          GetType(MyBaseExpressionSyntax),
          GetType(MyClassExpressionSyntax),
          GetType(GetTypeExpressionSyntax),
          GetType(TypeOfExpressionSyntax),
          GetType(GetXmlNamespaceExpressionSyntax),
          GetType(MemberAccessExpressionSyntax),
          GetType(XmlMemberAccessExpressionSyntax),
          GetType(InvocationExpressionSyntax),
          GetType(NewExpressionSyntax),
          GetType(ObjectCreationExpressionSyntax),
          GetType(AnonymousObjectCreationExpressionSyntax),
          GetType(ArrayCreationExpressionSyntax),
          GetType(CollectionInitializerSyntax),
          GetType(CastExpressionSyntax),
          GetType(CTypeExpressionSyntax),
          GetType(DirectCastExpressionSyntax),
          GetType(TryCastExpressionSyntax),
          GetType(PredefinedCastExpressionSyntax),
          GetType(BinaryExpressionSyntax),
          GetType(UnaryExpressionSyntax),
          GetType(BinaryConditionalExpressionSyntax),
          GetType(TernaryConditionalExpressionSyntax),
          GetType(LambdaExpressionSyntax),
          GetType(SingleLineLambdaExpressionSyntax),
          GetType(MultiLineLambdaExpressionSyntax),
          GetType(LambdaHeaderSyntax),
          GetType(ArgumentListSyntax),
          GetType(ArgumentSyntax),
          GetType(OmittedArgumentSyntax),
          GetType(SimpleArgumentSyntax),
          GetType(NamedArgumentSyntax),
          GetType(RangeArgumentSyntax),
          GetType(QueryExpressionSyntax),
          GetType(QueryClauseSyntax),
          GetType(CollectionRangeVariableSyntax),
          GetType(ExpressionRangeVariableSyntax),
          GetType(AggregationRangeVariableSyntax),
          GetType(VariableNameEqualsSyntax),
          GetType(AggregationSyntax),
          GetType(FunctionAggregationSyntax),
          GetType(GroupAggregationSyntax),
          GetType(FromClauseSyntax),
          GetType(LetClauseSyntax),
          GetType(AggregateClauseSyntax),
          GetType(DistinctClauseSyntax),
          GetType(WhereClauseSyntax),
          GetType(PartitionWhileClauseSyntax),
          GetType(PartitionClauseSyntax),
          GetType(GroupByClauseSyntax),
          GetType(JoinClauseSyntax),
          GetType(JoinConditionSyntax),
          GetType(GroupJoinClauseSyntax),
          GetType(OrderByClauseSyntax),
          GetType(OrderingSyntax),
          GetType(SelectClauseSyntax),
          GetType(XmlNodeSyntax),
          GetType(XmlDocumentSyntax),
          GetType(XmlDeclarationSyntax),
          GetType(XmlDeclarationOptionSyntax),
          GetType(XmlElementSyntax),
          GetType(XmlTextSyntax),
          GetType(XmlElementStartTagSyntax),
          GetType(XmlElementEndTagSyntax),
          GetType(XmlEmptyElementSyntax),
          GetType(XmlAttributeSyntax),
          GetType(XmlStringSyntax),
          GetType(XmlNameSyntax),
          GetType(XmlBracketedNameSyntax),
          GetType(XmlPrefixSyntax),
          GetType(XmlCommentSyntax),
          GetType(XmlProcessingInstructionSyntax),
          GetType(XmlCDataSectionSyntax),
          GetType(XmlEmbeddedExpressionSyntax),
          GetType(TypeSyntax),
          GetType(ArrayTypeSyntax),
          GetType(NullableTypeSyntax),
          GetType(PredefinedTypeSyntax),
          GetType(NameSyntax),
          GetType(SimpleNameSyntax),
          GetType(IdentifierNameSyntax),
          GetType(GenericNameSyntax),
          GetType(QualifiedNameSyntax),
          GetType(GlobalNameSyntax),
          GetType(TypeArgumentListSyntax),
          GetType(SyntaxToken),
          GetType(KeywordSyntax),
          GetType(PunctuationSyntax),
          GetType(BadTokenSyntax),
          GetType(XmlNameTokenSyntax),
          GetType(XmlTextTokenSyntax),
          GetType(IdentifierTokenSyntax),
          GetType(IntegerLiteralTokenSyntax),
          GetType(FloatingLiteralTokenSyntax),
          GetType(DecimalLiteralTokenSyntax),
          GetType(DateLiteralTokenSyntax),
          GetType(StringLiteralTokenSyntax),
          GetType(CharacterLiteralTokenSyntax),
          GetType(StructuredTriviaSyntax),
          GetType(SkippedTokensSyntax),
          GetType(DocumentationCommentSyntax),
          GetType(DirectiveSyntax),
          GetType(SyntaxTrivia),
          GetType(DirectiveStatementSyntax),
          GetType(ConstDirectiveSyntax),
          GetType(IfDirectiveSyntax),
          GetType(ElseDirectiveSyntax),
          GetType(EndIfDirectiveSyntax),
          GetType(RegionDirectiveSyntax),
          GetType(EndRegionDirectiveSyntax),
          GetType(ExternalSourceDirectiveSyntax),
          GetType(EndExternalSourceDirective),
          GetType(ExternalChecksumDirectiveSyntax),
          GetType(ReferenceDirectiveSyntax),
          GetType(BadDirectiveSyntax)
        }.ToImmutableList()


        ''' <summary>
        ''' A class to represent an empty statement. This can occur when a colon is on a
        ''' line without anything else.
        ''' </summary>
        ''' <param name="empty">
        ''' An empty token because all non terminals must have a token.
        ''' </param>
        Friend Shared Function EmptyStatement(empty As PunctuationSyntax) As EmptyStatementSyntax
            Debug.Assert(empty IsNot Nothing AndAlso empty.Kind = SyntaxKind.EmptyToken)
            Return New EmptyStatementSyntax(SyntaxKind.EmptyStatement, empty)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndIfStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.IfKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndIfStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndUsingStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.UsingKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndUsingStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndWithStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.WithKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndWithStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndSelectStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SelectKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndSelectStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndStructureStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.StructureKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndStructureStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndEnumStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.EnumKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndEnumStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndInterfaceStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.InterfaceKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndInterfaceStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndClassStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.ClassKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndClassStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndModuleStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.ModuleKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndModuleStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndNamespaceStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.NamespaceKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndNamespaceStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndSubStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SubKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndSubStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndFunctionStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.FunctionKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndFunctionStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndGetStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.GetKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndGetStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndSetStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SetKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndSetStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndPropertyStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.PropertyKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndPropertyStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndOperatorStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.OperatorKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndOperatorStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndEventStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.EventKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndEventStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndAddHandlerStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.AddHandlerKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndAddHandlerStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndRemoveHandlerStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.RemoveHandlerKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndRemoveHandlerStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndRaiseEventStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.RaiseEventKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndRaiseEventStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndWhileStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.WhileKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndWhileStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndTryStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.TryKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndTryStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndSyncLockStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SyncLockKeyword)
            Return New EndBlockStatementSyntax(SyntaxKind.EndSyncLockStatement, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' EndBlockStatementSyntax. One of EndIfStatement, EndUsingStatement,
        ''' EndWithStatement, EndSelectStatement, EndStructureStatement, EndEnumStatement,
        ''' EndInterfaceStatement, EndClassStatement, EndModuleStatement,
        ''' EndNamespaceStatement, EndSubStatement, EndFunctionStatement, EndGetStatement,
        ''' EndSetStatement, EndPropertyStatement, EndOperatorStatement, EndEventStatement,
        ''' EndAddHandlerStatement, EndRemoveHandlerStatement, EndRaiseEventStatement,
        ''' EndWhileStatement, EndTryStatement, EndSyncLockStatement.
        ''' </param>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndBlockStatement(kind As SyntaxKind, endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(kind.IsEndBlockStatement())
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind.IsEndBlockStatementBlockKeyword)
            Return New EndBlockStatementSyntax(kind, endKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents an entire source file of VB code.
        ''' </summary>
        ''' <param name="options">
        ''' Represents the list of Option statements at the beginning of a source file.
        ''' </param>
        ''' <param name="imports">
        ''' Represents the list of Imports statements at the beginning of a source file.
        ''' </param>
        ''' <param name="attributes">
        ''' Represents the list of AttributeStatements at the beginning of a source file
        ''' that contain the Assembly and Module attributes.
        ''' </param>
        ''' <param name="members">
        ''' Represents the members of the default namespace for this source file: all the
        ''' top-level type and namespace declarations in the file. May also contain
        ''' Statements that are not valid
        ''' </param>
        ''' <param name="endOfFileToken">
        ''' Represents the end of the source file. This token may have trivia (whitespace,
        ''' comments, ...) attached to it.
        ''' </param>
        Friend Shared Function CompilationUnit(options As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.OptionStatementSyntax), [imports] As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ImportsStatementSyntax), attributes As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.AttributesStatementSyntax), members As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), endOfFileToken As PunctuationSyntax) As CompilationUnitSyntax
            Debug.Assert(endOfFileToken IsNot Nothing AndAlso endOfFileToken.Kind = SyntaxKind.EndOfFileToken)
            Return New CompilationUnitSyntax(SyntaxKind.CompilationUnit, options.Node, [imports].Node, attributes.Node, members.Node, endOfFileToken)
        End Function


        ''' <summary>
        ''' Represents an Option statement, such as "Option Strict On".
        ''' </summary>
        ''' <param name="optionKeyword">
        ''' The "Option" keyword.
        ''' </param>
        ''' <param name="nameKeyword">
        ''' The keyword that identifies the option being set: Explicit, Strict, Compare or
        ''' Infer.
        ''' </param>
        ''' <param name="valueKeyword">
        ''' The keyword that identifiers the value being set for the opition: On, Off, Text
        ''' or Binary.
        ''' </param>
        Friend Shared Function OptionStatement(optionKeyword As KeywordSyntax, nameKeyword As KeywordSyntax, valueKeyword As KeywordSyntax) As OptionStatementSyntax
            Debug.Assert(optionKeyword IsNot Nothing AndAlso optionKeyword.Kind = SyntaxKind.OptionKeyword)
            Debug.Assert(nameKeyword IsNot Nothing AndAlso nameKeyword.Kind.IsOptionStatementNameKeyword)
            Return New OptionStatementSyntax(SyntaxKind.OptionStatement, optionKeyword, nameKeyword, valueKeyword)
        End Function


        ''' <summary>
        ''' Represents an Imports statement, which has one or more imports clauses.
        ''' </summary>
        ''' <param name="importsKeyword">
        ''' The "Imports" keyword.
        ''' </param>
        ''' <param name="importsClauses">
        ''' A list of one or more import clauses. Each clause is either an alias, namespace
        ''' or XML namespace import.
        ''' </param>
        Friend Shared Function ImportsStatement(importsKeyword As KeywordSyntax, importsClauses As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ImportsClauseSyntax)) As ImportsStatementSyntax
            Debug.Assert(importsKeyword IsNot Nothing AndAlso importsKeyword.Kind = SyntaxKind.ImportsKeyword)
            Return New ImportsStatementSyntax(SyntaxKind.ImportsStatement, importsKeyword, importsClauses.Node)
        End Function


        ''' <summary>
        ''' Represents the clause of an Imports statement that defines an alias for a
        ''' namespace or type.
        ''' </summary>
        ''' <param name="alias">
        ''' The identifier that the alias is being defined for.
        ''' </param>
        ''' <param name="equalsToken">
        ''' The equals sign token.
        ''' </param>
        ''' <param name="name">
        ''' The namespace or type the alias refers to.
        ''' </param>
        Friend Shared Function AliasImportsClause([alias] As IdentifierTokenSyntax, equalsToken As PunctuationSyntax, name As NameSyntax) As AliasImportsClauseSyntax
            Debug.Assert([alias] IsNot Nothing AndAlso [alias].Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(name IsNot Nothing)
            Return New AliasImportsClauseSyntax(SyntaxKind.AliasImportsClause, [alias], equalsToken, name)
        End Function


        ''' <summary>
        ''' Represents the clause of an Imports statement that imports all members of a
        ''' namespace.
        ''' </summary>
        ''' <param name="name">
        ''' The namespace or type being imported.
        ''' </param>
        Friend Shared Function MembersImportsClause(name As NameSyntax) As MembersImportsClauseSyntax
            Debug.Assert(name IsNot Nothing)
            Return New MembersImportsClauseSyntax(SyntaxKind.MembersImportsClause, name)
        End Function


        ''' <summary>
        ''' Defines a XML namespace for XML expressions.
        ''' </summary>
        ''' <param name="xmlNamespace">
        ''' Identifies the XML namespace alias and URI.
        ''' </param>
        Friend Shared Function XmlNamespaceImportsClause(lessThanToken As PunctuationSyntax, xmlNamespace As XmlAttributeSyntax, greaterThanToken As PunctuationSyntax) As XmlNamespaceImportsClauseSyntax
            Debug.Assert(lessThanToken IsNot Nothing AndAlso lessThanToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(xmlNamespace IsNot Nothing)
            Debug.Assert(greaterThanToken IsNot Nothing AndAlso greaterThanToken.Kind = SyntaxKind.GreaterThanToken)
            Return New XmlNamespaceImportsClauseSyntax(SyntaxKind.XmlNamespaceImportsClause, lessThanToken, xmlNamespace, greaterThanToken)
        End Function


        ''' <summary>
        ''' Represents a Namespace statement, its contents and the End Namespace statement.
        ''' </summary>
        ''' <param name="begin">
        ''' The statement that begins the NamespaceBlock.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the namespace statement.
        ''' </param>
        ''' <param name="end">
        ''' The End Namespace statement that ends the block.
        ''' </param>
        Friend Shared Function NamespaceBlock(begin As NamespaceStatementSyntax, beginTerminator As PunctuationSyntax, members As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As NamespaceBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsNamespaceBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New NamespaceBlockSyntax(SyntaxKind.NamespaceBlock, begin, beginTerminator, members.Node, [end])
        End Function


        ''' <summary>
        ''' Represents the beginning statement of a namespace declaration. This node always
        ''' appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
        ''' </summary>
        ''' <param name="namespaceKeyword">
        ''' The "Namespace" keyword.
        ''' </param>
        ''' <param name="name">
        ''' A (possibly dotted) name denoting the namespace being declared.
        ''' </param>
        Friend Shared Function NamespaceStatement(namespaceKeyword As KeywordSyntax, name As NameSyntax) As NamespaceStatementSyntax
            Debug.Assert(namespaceKeyword IsNot Nothing AndAlso namespaceKeyword.Kind = SyntaxKind.NamespaceKeyword)
            Debug.Assert(name IsNot Nothing)
            Return New NamespaceStatementSyntax(SyntaxKind.NamespaceStatement, namespaceKeyword, name)
        End Function


        ''' <summary>
        ''' Represents a declaration of Module, its contents and the End statement that
        ''' ends it.
        ''' </summary>
        ''' <param name="begin">
        ''' The statement that begins the type or module.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="inherits">
        ''' A list of the Inherits declarations for the type.
        ''' </param>
        ''' <param name="implements">
        ''' A list of the Implements declarations for the type.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the type or module.
        ''' </param>
        ''' <param name="end">
        ''' The End XXX statement that ends the block.
        ''' </param>
        Friend Shared Function ModuleBlock(begin As TypeStatementSyntax, beginTerminator As PunctuationSyntax, [inherits] As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.InheritsStatementSyntax), [implements] As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ImplementsStatementSyntax), members As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As ModuleBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsModuleBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New ModuleBlockSyntax(SyntaxKind.ModuleBlock, begin, beginTerminator, [inherits].Node, [implements].Node, members.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a declaration of a Structure, its contents and the End statement
        ''' that ends it.
        ''' </summary>
        ''' <param name="begin">
        ''' The statement that begins the type or module.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="inherits">
        ''' A list of the Inherits declarations for the type.
        ''' </param>
        ''' <param name="implements">
        ''' A list of the Implements declarations for the type.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the type or module.
        ''' </param>
        ''' <param name="end">
        ''' The End XXX statement that ends the block.
        ''' </param>
        Friend Shared Function StructureBlock(begin As TypeStatementSyntax, beginTerminator As PunctuationSyntax, [inherits] As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.InheritsStatementSyntax), [implements] As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ImplementsStatementSyntax), members As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As StructureBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsStructureBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New StructureBlockSyntax(SyntaxKind.StructureBlock, begin, beginTerminator, [inherits].Node, [implements].Node, members.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a declaration of a Interface, its contents and the End statement
        ''' that ends it.
        ''' </summary>
        ''' <param name="begin">
        ''' The statement that begins the type or module.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="inherits">
        ''' A list of the Inherits declarations for the type.
        ''' </param>
        ''' <param name="implements">
        ''' A list of the Implements declarations for the type.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the type or module.
        ''' </param>
        ''' <param name="end">
        ''' The End XXX statement that ends the block.
        ''' </param>
        Friend Shared Function InterfaceBlock(begin As TypeStatementSyntax, beginTerminator As PunctuationSyntax, [inherits] As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.InheritsStatementSyntax), [implements] As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ImplementsStatementSyntax), members As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As InterfaceBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsInterfaceBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New InterfaceBlockSyntax(SyntaxKind.InterfaceBlock, begin, beginTerminator, [inherits].Node, [implements].Node, members.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a declaration of a Class its contents and the End statement that
        ''' ends it.
        ''' </summary>
        ''' <param name="begin">
        ''' The statement that begins the type or module.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="inherits">
        ''' A list of the Inherits declarations for the type.
        ''' </param>
        ''' <param name="implements">
        ''' A list of the Implements declarations for the type.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the type or module.
        ''' </param>
        ''' <param name="end">
        ''' The End XXX statement that ends the block.
        ''' </param>
        Friend Shared Function ClassBlock(begin As TypeStatementSyntax, beginTerminator As PunctuationSyntax, [inherits] As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.InheritsStatementSyntax), [implements] As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ImplementsStatementSyntax), members As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As ClassBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsClassBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New ClassBlockSyntax(SyntaxKind.ClassBlock, begin, beginTerminator, [inherits].Node, [implements].Node, members.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a declaration of an Enum, its contents and the End Enum statement
        ''' that ends it.
        ''' </summary>
        ''' <param name="begin">
        ''' The statement that begins the type or module.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the enumeration.
        ''' </param>
        ''' <param name="end">
        ''' The End XXX statement that ends the block.
        ''' </param>
        Friend Shared Function EnumBlock(begin As EnumStatementSyntax, beginTerminator As PunctuationSyntax, members As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As EnumBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsEnumBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New EnumBlockSyntax(SyntaxKind.EnumBlock, begin, beginTerminator, members.Node, [end])
        End Function


        ''' <summary>
        ''' Represents an Inherits statement in a Class, Structure or Interface.
        ''' </summary>
        ''' <param name="inheritsKeyword">
        ''' The "Inherits" keyword.
        ''' </param>
        ''' <param name="types">
        ''' A list of the types being inherited.
        ''' </param>
        Friend Shared Function InheritsStatement(inheritsKeyword As KeywordSyntax, types As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.TypeSyntax)) As InheritsStatementSyntax
            Debug.Assert(inheritsKeyword IsNot Nothing AndAlso inheritsKeyword.Kind = SyntaxKind.InheritsKeyword)
            Return New InheritsStatementSyntax(SyntaxKind.InheritsStatement, inheritsKeyword, types.Node)
        End Function


        ''' <summary>
        ''' Represents an Implements statement in a Class or Structure.
        ''' </summary>
        ''' <param name="implementsKeyword">
        ''' The "Implements" keyword.
        ''' </param>
        ''' <param name="types">
        ''' A list of the types being implemented.
        ''' </param>
        Friend Shared Function ImplementsStatement(implementsKeyword As KeywordSyntax, types As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.TypeSyntax)) As ImplementsStatementSyntax
            Debug.Assert(implementsKeyword IsNot Nothing AndAlso implementsKeyword.Kind = SyntaxKind.ImplementsKeyword)
            Return New ImplementsStatementSyntax(SyntaxKind.ImplementsStatement, implementsKeyword, types.Node)
        End Function


        ''' <summary>
        ''' Represents the beginning statement of a Module declaration. This node always
        ''' appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="keyword">
        ''' The "Module", "Class", "Interface" or "Structure" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the type being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic parameters for this type. If no
        ''' generic parameters were present, Nothing is returned.
        ''' </param>
        Friend Shared Function ModuleStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax) As ModuleStatementSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.ModuleKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New ModuleStatementSyntax(SyntaxKind.ModuleStatement, attributes.Node, modifiers.Node, keyword, identifier, typeParameterList)
        End Function


        ''' <summary>
        ''' Represents the beginning statement of a Structure declaration. This node always
        ''' appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="keyword">
        ''' The "Module", "Class", "Interface" or "Structure" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the type being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic parameters for this type. If no
        ''' generic parameters were present, Nothing is returned.
        ''' </param>
        Friend Shared Function StructureStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax) As StructureStatementSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.StructureKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New StructureStatementSyntax(SyntaxKind.StructureStatement, attributes.Node, modifiers.Node, keyword, identifier, typeParameterList)
        End Function


        ''' <summary>
        ''' Represents the beginning statement of a Interface declaration. This node always
        ''' appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="keyword">
        ''' The "Module", "Class", "Interface" or "Structure" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the type being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic parameters for this type. If no
        ''' generic parameters were present, Nothing is returned.
        ''' </param>
        Friend Shared Function InterfaceStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax) As InterfaceStatementSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.InterfaceKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New InterfaceStatementSyntax(SyntaxKind.InterfaceStatement, attributes.Node, modifiers.Node, keyword, identifier, typeParameterList)
        End Function


        ''' <summary>
        ''' Represents the beginning statement of a Class declaration. This node always
        ''' appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="keyword">
        ''' The "Module", "Class", "Interface" or "Structure" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the type being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic parameters for this type. If no
        ''' generic parameters were present, Nothing is returned.
        ''' </param>
        Friend Shared Function ClassStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax) As ClassStatementSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.ClassKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New ClassStatementSyntax(SyntaxKind.ClassStatement, attributes.Node, modifiers.Node, keyword, identifier, typeParameterList)
        End Function


        ''' <summary>
        ''' Represents the beginning statement of an Enum declaration. This node always
        ''' appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="enumKeyword">
        ''' The "Enum" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the enum being declared.
        ''' </param>
        ''' <param name="underlyingType">
        ''' Optional "As XXX" clause describing the underlying type of the enumeration. If
        ''' no As clause was specified, Nothing is returned.
        ''' </param>
        Friend Shared Function EnumStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), enumKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, underlyingType As AsClauseSyntax) As EnumStatementSyntax
            Debug.Assert(enumKeyword IsNot Nothing AndAlso enumKeyword.Kind = SyntaxKind.EnumKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New EnumStatementSyntax(SyntaxKind.EnumStatement, attributes.Node, modifiers.Node, enumKeyword, identifier, underlyingType)
        End Function


        ''' <summary>
        ''' Represents the type parameter list in a declaration.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="ofKeyword">
        ''' The "Of" keyword.
        ''' </param>
        ''' <param name="parameters">
        ''' A list of the type parameters. There must be at least one type parameter in the
        ''' list.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function TypeParameterList(openParenToken As PunctuationSyntax, ofKeyword As KeywordSyntax, parameters As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.TypeParameterSyntax), closeParenToken As PunctuationSyntax) As TypeParameterListSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(ofKeyword IsNot Nothing AndAlso ofKeyword.Kind = SyntaxKind.OfKeyword)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New TypeParameterListSyntax(SyntaxKind.TypeParameterList, openParenToken, ofKeyword, parameters.Node, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents a type parameter on a generic type declaration.
        ''' </summary>
        ''' <param name="varianceKeyword">
        ''' Represents the "In" or "Out" variance keyword on a type parameter, if present.
        ''' If no variance modifier was present, Nothing is returned.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the type parameter
        ''' </param>
        ''' <param name="typeParameterConstraintClause">
        ''' The "As" keyword, if any type constraints were supplied. If no type constraints
        ''' were supplied, Nothing is returned.
        ''' </param>
        Friend Shared Function TypeParameter(varianceKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterConstraintClause As TypeParameterConstraintClauseSyntax) As TypeParameterSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New TypeParameterSyntax(SyntaxKind.TypeParameter, varianceKeyword, identifier, typeParameterConstraintClause)
        End Function


        ''' <summary>
        ''' One of the type parameter constraints clauses. This represents a constraint
        ''' clause in the form of "As Constraint".
        ''' </summary>
        ''' <param name="asKeyword">
        ''' The "As" keyword, if any type constraints were supplied. If no type constraints
        ''' were supplied, Nothing is returned.
        ''' </param>
        ''' <param name="constraint">
        ''' A list of the supplied constraints. If no constraints were supplied, Nothing is
        ''' returned.
        ''' </param>
        Friend Shared Function TypeParameterSingleConstraintClause(asKeyword As KeywordSyntax, constraint As ConstraintSyntax) As TypeParameterSingleConstraintClauseSyntax
            Debug.Assert(asKeyword IsNot Nothing AndAlso asKeyword.Kind = SyntaxKind.AsKeyword)
            Debug.Assert(constraint IsNot Nothing)
            Return New TypeParameterSingleConstraintClauseSyntax(SyntaxKind.TypeParameterSingleConstraintClause, asKeyword, constraint)
        End Function


        ''' <summary>
        ''' One of the type parameter constraints clauses. This represents a constraint
        ''' clause in the form of "As { Constraints }".
        ''' </summary>
        ''' <param name="asKeyword">
        ''' The "As" keyword.
        ''' </param>
        ''' <param name="openBraceToken">
        ''' The "{" token.
        ''' </param>
        ''' <param name="constraints">
        ''' A list of the supplied constraints. If no constraints were supplied, an empty
        ''' list is returned.
        ''' </param>
        ''' <param name="closeBraceToken">
        ''' The "}" token.
        ''' </param>
        Friend Shared Function TypeParameterMultipleConstraintClause(asKeyword As KeywordSyntax, openBraceToken As PunctuationSyntax, constraints As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ConstraintSyntax), closeBraceToken As PunctuationSyntax) As TypeParameterMultipleConstraintClauseSyntax
            Debug.Assert(asKeyword IsNot Nothing AndAlso asKeyword.Kind = SyntaxKind.AsKeyword)
            Debug.Assert(openBraceToken IsNot Nothing AndAlso openBraceToken.Kind = SyntaxKind.OpenBraceToken)
            Debug.Assert(closeBraceToken IsNot Nothing AndAlso closeBraceToken.Kind = SyntaxKind.CloseBraceToken)
            Return New TypeParameterMultipleConstraintClauseSyntax(SyntaxKind.TypeParameterMultipleConstraintClause, asKeyword, openBraceToken, constraints.Node, closeBraceToken)
        End Function


        ''' <summary>
        ''' One of the special type parameter constraints: New, Class or Structure. Which
        ''' kind of special constraint it is can be obtained from the Kind property and is
        ''' one of: NewConstraint, ReferenceConstraint or ValueConstraint.
        ''' </summary>
        ''' <param name="constraintKeyword">
        ''' The "New", "Class" or "Structure" keyword that denotes the kind of special
        ''' constraint.
        ''' </param>
        Friend Shared Function NewConstraint(constraintKeyword As KeywordSyntax) As SpecialConstraintSyntax
            Debug.Assert(constraintKeyword IsNot Nothing AndAlso constraintKeyword.Kind.IsSpecialConstraintConstraintKeyword)
            Return New SpecialConstraintSyntax(SyntaxKind.NewConstraint, constraintKeyword)
        End Function


        ''' <summary>
        ''' One of the special type parameter constraints: New, Class or Structure. Which
        ''' kind of special constraint it is can be obtained from the Kind property and is
        ''' one of: NewConstraint, ReferenceConstraint or ValueConstraint.
        ''' </summary>
        ''' <param name="constraintKeyword">
        ''' The "New", "Class" or "Structure" keyword that denotes the kind of special
        ''' constraint.
        ''' </param>
        Friend Shared Function ClassConstraint(constraintKeyword As KeywordSyntax) As SpecialConstraintSyntax
            Debug.Assert(constraintKeyword IsNot Nothing AndAlso constraintKeyword.Kind.IsSpecialConstraintConstraintKeyword)
            Return New SpecialConstraintSyntax(SyntaxKind.ClassConstraint, constraintKeyword)
        End Function


        ''' <summary>
        ''' One of the special type parameter constraints: New, Class or Structure. Which
        ''' kind of special constraint it is can be obtained from the Kind property and is
        ''' one of: NewConstraint, ReferenceConstraint or ValueConstraint.
        ''' </summary>
        ''' <param name="constraintKeyword">
        ''' The "New", "Class" or "Structure" keyword that denotes the kind of special
        ''' constraint.
        ''' </param>
        Friend Shared Function StructureConstraint(constraintKeyword As KeywordSyntax) As SpecialConstraintSyntax
            Debug.Assert(constraintKeyword IsNot Nothing AndAlso constraintKeyword.Kind.IsSpecialConstraintConstraintKeyword)
            Return New SpecialConstraintSyntax(SyntaxKind.StructureConstraint, constraintKeyword)
        End Function


        ''' <summary>
        ''' One of the special type parameter constraints: New, Class or Structure. Which
        ''' kind of special constraint it is can be obtained from the Kind property and is
        ''' one of: NewConstraint, ReferenceConstraint or ValueConstraint.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' SpecialConstraintSyntax. One of NewConstraint, ClassConstraint,
        ''' StructureConstraint.
        ''' </param>
        ''' <param name="constraintKeyword">
        ''' The "New", "Class" or "Structure" keyword that denotes the kind of special
        ''' constraint.
        ''' </param>
        Friend Shared Function SpecialConstraint(kind As SyntaxKind, constraintKeyword As KeywordSyntax) As SpecialConstraintSyntax
            Debug.Assert(kind.IsSpecialConstraint())
            Debug.Assert(constraintKeyword IsNot Nothing AndAlso constraintKeyword.Kind.IsSpecialConstraintConstraintKeyword)
            Return New SpecialConstraintSyntax(kind, constraintKeyword)
        End Function


        ''' <summary>
        ''' Represents a type parameter constraint that is a type.
        ''' </summary>
        ''' <param name="type">
        ''' The type describing the constraint.
        ''' </param>
        Friend Shared Function TypeConstraint(type As TypeSyntax) As TypeConstraintSyntax
            Debug.Assert(type IsNot Nothing)
            Return New TypeConstraintSyntax(SyntaxKind.TypeConstraint, type)
        End Function


        ''' <summary>
        ''' Represents a name and value in an EnumDeclarationBlock.
        ''' </summary>
        ''' <param name="initializer">
        ''' An optional value for the enum member.
        ''' </param>
        Friend Shared Function EnumMemberDeclaration(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), identifier As IdentifierTokenSyntax, initializer As EqualsValueSyntax) As EnumMemberDeclarationSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New EnumMemberDeclarationSyntax(SyntaxKind.EnumMemberDeclaration, attributes.Node, identifier, initializer)
        End Function


        ''' <summary>
        ''' Represents a block member declaration: A declaration that has a beginning
        ''' declaration, a body of executable statements and an end statement. Examples
        ''' include methods, constructors, operators, property accessors and custom event
        ''' accessors.
        ''' </summary>
        ''' <param name="begin">
        ''' The declaration that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The End XXX statement that ends the block declaration.
        ''' </param>
        Friend Shared Function SubBlock(begin As MethodBaseSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsMethodBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New MethodBlockSyntax(SyntaxKind.SubBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a block member declaration: A declaration that has a beginning
        ''' declaration, a body of executable statements and an end statement. Examples
        ''' include methods, constructors, operators, property accessors and custom event
        ''' accessors.
        ''' </summary>
        ''' <param name="begin">
        ''' The declaration that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The End XXX statement that ends the block declaration.
        ''' </param>
        Friend Shared Function FunctionBlock(begin As MethodBaseSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsMethodBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New MethodBlockSyntax(SyntaxKind.FunctionBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a block member declaration: A declaration that has a beginning
        ''' declaration, a body of executable statements and an end statement. Examples
        ''' include methods, constructors, operators, property accessors and custom event
        ''' accessors.
        ''' </summary>
        ''' <param name="begin">
        ''' The declaration that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The End XXX statement that ends the block declaration.
        ''' </param>
        Friend Shared Function ConstructorBlock(begin As MethodBaseSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsMethodBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New MethodBlockSyntax(SyntaxKind.ConstructorBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a block member declaration: A declaration that has a beginning
        ''' declaration, a body of executable statements and an end statement. Examples
        ''' include methods, constructors, operators, property accessors and custom event
        ''' accessors.
        ''' </summary>
        ''' <param name="begin">
        ''' The declaration that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The End XXX statement that ends the block declaration.
        ''' </param>
        Friend Shared Function OperatorBlock(begin As MethodBaseSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsMethodBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New MethodBlockSyntax(SyntaxKind.OperatorBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a block member declaration: A declaration that has a beginning
        ''' declaration, a body of executable statements and an end statement. Examples
        ''' include methods, constructors, operators, property accessors and custom event
        ''' accessors.
        ''' </summary>
        ''' <param name="begin">
        ''' The declaration that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The End XXX statement that ends the block declaration.
        ''' </param>
        Friend Shared Function PropertyGetBlock(begin As MethodBaseSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsMethodBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New MethodBlockSyntax(SyntaxKind.PropertyGetBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a block member declaration: A declaration that has a beginning
        ''' declaration, a body of executable statements and an end statement. Examples
        ''' include methods, constructors, operators, property accessors and custom event
        ''' accessors.
        ''' </summary>
        ''' <param name="begin">
        ''' The declaration that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The End XXX statement that ends the block declaration.
        ''' </param>
        Friend Shared Function PropertySetBlock(begin As MethodBaseSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsMethodBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New MethodBlockSyntax(SyntaxKind.PropertySetBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a block member declaration: A declaration that has a beginning
        ''' declaration, a body of executable statements and an end statement. Examples
        ''' include methods, constructors, operators, property accessors and custom event
        ''' accessors.
        ''' </summary>
        ''' <param name="begin">
        ''' The declaration that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The End XXX statement that ends the block declaration.
        ''' </param>
        Friend Shared Function AddHandlerBlock(begin As MethodBaseSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsMethodBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New MethodBlockSyntax(SyntaxKind.AddHandlerBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a block member declaration: A declaration that has a beginning
        ''' declaration, a body of executable statements and an end statement. Examples
        ''' include methods, constructors, operators, property accessors and custom event
        ''' accessors.
        ''' </summary>
        ''' <param name="begin">
        ''' The declaration that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The End XXX statement that ends the block declaration.
        ''' </param>
        Friend Shared Function RemoveHandlerBlock(begin As MethodBaseSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsMethodBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New MethodBlockSyntax(SyntaxKind.RemoveHandlerBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a block member declaration: A declaration that has a beginning
        ''' declaration, a body of executable statements and an end statement. Examples
        ''' include methods, constructors, operators, property accessors and custom event
        ''' accessors.
        ''' </summary>
        ''' <param name="begin">
        ''' The declaration that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The End XXX statement that ends the block declaration.
        ''' </param>
        Friend Shared Function RaiseEventBlock(begin As MethodBaseSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsMethodBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New MethodBlockSyntax(SyntaxKind.RaiseEventBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a block member declaration: A declaration that has a beginning
        ''' declaration, a body of executable statements and an end statement. Examples
        ''' include methods, constructors, operators, property accessors and custom event
        ''' accessors.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of MethodBlockSyntax.
        ''' One of SubBlock, FunctionBlock, ConstructorBlock, OperatorBlock,
        ''' PropertyGetBlock, PropertySetBlock, AddHandlerBlock, RemoveHandlerBlock,
        ''' RaiseEventBlock.
        ''' </param>
        ''' <param name="begin">
        ''' The declaration that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The End XXX statement that ends the block declaration.
        ''' </param>
        Friend Shared Function MethodBlock(kind As SyntaxKind, begin As MethodBaseSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(kind.IsMethodBlock())
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsMethodBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New MethodBlockSyntax(kind, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a block property declaration: A declaration that has a beginning
        ''' declaration, some get or set accessor blocks and an end statement.
        ''' </summary>
        ''' <param name="begin">
        ''' The property declaration that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="accessors">
        ''' The accessor blocks contained in the property, between the Property and the End
        ''' Property statements.
        ''' </param>
        ''' <param name="end">
        ''' The End Property statement that ends the block.
        ''' </param>
        Friend Shared Function PropertyBlock(begin As PropertyStatementSyntax, beginTerminator As PunctuationSyntax, accessors As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.MethodBlockSyntax), [end] As EndBlockStatementSyntax) As PropertyBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsPropertyBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New PropertyBlockSyntax(SyntaxKind.PropertyBlock, begin, beginTerminator, accessors.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a custom event declaration: A declaration that has a beginning event
        ''' declaration, some accessor blocks and an end statement.
        ''' </summary>
        ''' <param name="begin">
        ''' The event declaration that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="accessors">
        ''' The accessor blocks contained in the custom event declaration, between the
        ''' Event statement and the End Event statement.
        ''' </param>
        ''' <param name="end">
        ''' The End Event statement that ends the block.
        ''' </param>
        Friend Shared Function EventBlock(begin As EventStatementSyntax, beginTerminator As PunctuationSyntax, accessors As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.MethodBlockSyntax), [end] As EndBlockStatementSyntax) As EventBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsEventBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New EventBlockSyntax(SyntaxKind.EventBlock, begin, beginTerminator, accessors.Node, [end])
        End Function


        ''' <summary>
        ''' Represents the parameter list in a method declaration.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token that introduces the parameter list. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="parameters">
        ''' The list of parameters. If no parameter list was present, Nothing is returned.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token that concludes the parameter list. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Shared Function ParameterList(openParenToken As PunctuationSyntax, parameters As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ParameterSyntax), closeParenToken As PunctuationSyntax) As ParameterListSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken)
        End Function


        ''' <summary>
        ''' The statement that declares a Sub or Function. If this method has a body, this
        ''' statement will be the Begin of a BlockStatement with
        ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
        ''' that BlockStatement.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this method.
        ''' If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        ''' <param name="handlesClause">
        ''' If present, a Handles clause indicated the events that this method handles.
        ''' </param>
        ''' <param name="implementsClause">
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </param>
        Friend Shared Function SubStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, handlesClause As HandlesClauseSyntax, implementsClause As ImplementsClauseSyntax) As MethodStatementSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.SubKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New MethodStatementSyntax(SyntaxKind.SubStatement, attributes.Node, modifiers.Node, keyword, identifier, typeParameterList, parameterList, asClause, handlesClause, implementsClause)
        End Function


        ''' <summary>
        ''' The statement that declares a Sub or Function. If this method has a body, this
        ''' statement will be the Begin of a BlockStatement with
        ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
        ''' that BlockStatement.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this method.
        ''' If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        ''' <param name="handlesClause">
        ''' If present, a Handles clause indicated the events that this method handles.
        ''' </param>
        ''' <param name="implementsClause">
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </param>
        Friend Shared Function FunctionStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, handlesClause As HandlesClauseSyntax, implementsClause As ImplementsClauseSyntax) As MethodStatementSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.FunctionKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New MethodStatementSyntax(SyntaxKind.FunctionStatement, attributes.Node, modifiers.Node, keyword, identifier, typeParameterList, parameterList, asClause, handlesClause, implementsClause)
        End Function


        ''' <summary>
        ''' The statement that declares a Sub or Function. If this method has a body, this
        ''' statement will be the Begin of a BlockStatement with
        ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
        ''' that BlockStatement.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' MethodStatementSyntax. One of SubStatement, FunctionStatement.
        ''' </param>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this method.
        ''' If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        ''' <param name="handlesClause">
        ''' If present, a Handles clause indicated the events that this method handles.
        ''' </param>
        ''' <param name="implementsClause">
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </param>
        Friend Shared Function MethodStatement(kind As SyntaxKind, attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, handlesClause As HandlesClauseSyntax, implementsClause As ImplementsClauseSyntax) As MethodStatementSyntax
            Debug.Assert(kind.IsMethodStatement())
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind.IsMethodStatementKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New MethodStatementSyntax(kind, attributes.Node, modifiers.Node, keyword, identifier, typeParameterList, parameterList, asClause, handlesClause, implementsClause)
        End Function


        ''' <summary>
        ''' A statement that declares a constructor. This statement will be the Begin of a
        ''' BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
        ''' will be the Body of that BlockStatement.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="newKeyword">
        ''' The "New" keyword in the constructor declaration.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function ConstructorStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, newKeyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As ConstructorStatementSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.SubKeyword)
            Debug.Assert(newKeyword IsNot Nothing AndAlso newKeyword.Kind = SyntaxKind.NewKeyword)
            Return New ConstructorStatementSyntax(SyntaxKind.ConstructorStatement, attributes.Node, modifiers.Node, keyword, newKeyword, parameterList, asClause)
        End Function


        ''' <summary>
        ''' A Declare statement that declares an external DLL method.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="declareKeyword">
        ''' The "Declare" keyword.
        ''' </param>
        ''' <param name="charsetKeyword">
        ''' If present, the keyword that defines the string translation semantics of the
        ''' external method.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="libKeyword">
        ''' The "Lib" keyword.
        ''' </param>
        ''' <param name="libraryName">
        ''' The string literal with the library name.
        ''' </param>
        ''' <param name="aliasKeyword">
        ''' If present, the "Alias" keyword. If not present, returns Nothing.
        ''' </param>
        ''' <param name="aliasName">
        ''' The string literal with the alias. If not present, returns Nothing.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function DeclareSubStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), declareKeyword As KeywordSyntax, charsetKeyword As KeywordSyntax, keyword As KeywordSyntax, identifier As IdentifierTokenSyntax, libKeyword As KeywordSyntax, libraryName As LiteralExpressionSyntax, aliasKeyword As KeywordSyntax, aliasName As LiteralExpressionSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As DeclareStatementSyntax
            Debug.Assert(declareKeyword IsNot Nothing AndAlso declareKeyword.Kind = SyntaxKind.DeclareKeyword)
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.SubKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(libKeyword IsNot Nothing AndAlso libKeyword.Kind = SyntaxKind.LibKeyword)
            Debug.Assert(libraryName IsNot Nothing)
            Return New DeclareStatementSyntax(SyntaxKind.DeclareSubStatement, attributes.Node, modifiers.Node, declareKeyword, charsetKeyword, keyword, identifier, libKeyword, libraryName, aliasKeyword, aliasName, parameterList, asClause)
        End Function


        ''' <summary>
        ''' A Declare statement that declares an external DLL method.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="declareKeyword">
        ''' The "Declare" keyword.
        ''' </param>
        ''' <param name="charsetKeyword">
        ''' If present, the keyword that defines the string translation semantics of the
        ''' external method.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="libKeyword">
        ''' The "Lib" keyword.
        ''' </param>
        ''' <param name="libraryName">
        ''' The string literal with the library name.
        ''' </param>
        ''' <param name="aliasKeyword">
        ''' If present, the "Alias" keyword. If not present, returns Nothing.
        ''' </param>
        ''' <param name="aliasName">
        ''' The string literal with the alias. If not present, returns Nothing.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function DeclareFunctionStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), declareKeyword As KeywordSyntax, charsetKeyword As KeywordSyntax, keyword As KeywordSyntax, identifier As IdentifierTokenSyntax, libKeyword As KeywordSyntax, libraryName As LiteralExpressionSyntax, aliasKeyword As KeywordSyntax, aliasName As LiteralExpressionSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As DeclareStatementSyntax
            Debug.Assert(declareKeyword IsNot Nothing AndAlso declareKeyword.Kind = SyntaxKind.DeclareKeyword)
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.FunctionKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(libKeyword IsNot Nothing AndAlso libKeyword.Kind = SyntaxKind.LibKeyword)
            Debug.Assert(libraryName IsNot Nothing)
            Return New DeclareStatementSyntax(SyntaxKind.DeclareFunctionStatement, attributes.Node, modifiers.Node, declareKeyword, charsetKeyword, keyword, identifier, libKeyword, libraryName, aliasKeyword, aliasName, parameterList, asClause)
        End Function


        ''' <summary>
        ''' A Declare statement that declares an external DLL method.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
        ''' </param>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="declareKeyword">
        ''' The "Declare" keyword.
        ''' </param>
        ''' <param name="charsetKeyword">
        ''' If present, the keyword that defines the string translation semantics of the
        ''' external method.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="libKeyword">
        ''' The "Lib" keyword.
        ''' </param>
        ''' <param name="libraryName">
        ''' The string literal with the library name.
        ''' </param>
        ''' <param name="aliasKeyword">
        ''' If present, the "Alias" keyword. If not present, returns Nothing.
        ''' </param>
        ''' <param name="aliasName">
        ''' The string literal with the alias. If not present, returns Nothing.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function DeclareStatement(kind As SyntaxKind, attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), declareKeyword As KeywordSyntax, charsetKeyword As KeywordSyntax, keyword As KeywordSyntax, identifier As IdentifierTokenSyntax, libKeyword As KeywordSyntax, libraryName As LiteralExpressionSyntax, aliasKeyword As KeywordSyntax, aliasName As LiteralExpressionSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As DeclareStatementSyntax
            Debug.Assert(kind.IsDeclareStatement())
            Debug.Assert(declareKeyword IsNot Nothing AndAlso declareKeyword.Kind = SyntaxKind.DeclareKeyword)
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind.IsDeclareStatementKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(libKeyword IsNot Nothing AndAlso libKeyword.Kind = SyntaxKind.LibKeyword)
            Debug.Assert(libraryName IsNot Nothing)
            Return New DeclareStatementSyntax(kind, attributes.Node, modifiers.Node, declareKeyword, charsetKeyword, keyword, identifier, libKeyword, libraryName, aliasKeyword, aliasName, parameterList, asClause)
        End Function


        ''' <summary>
        ''' A statement that declares a delegate type.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="delegateKeyword">
        ''' The "Delegate" keyword.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the delegate being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this
        ''' delegate. If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function DelegateSubStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), delegateKeyword As KeywordSyntax, keyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As DelegateStatementSyntax
            Debug.Assert(delegateKeyword IsNot Nothing AndAlso delegateKeyword.Kind = SyntaxKind.DelegateKeyword)
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.SubKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New DelegateStatementSyntax(SyntaxKind.DelegateSubStatement, attributes.Node, modifiers.Node, delegateKeyword, keyword, identifier, typeParameterList, parameterList, asClause)
        End Function


        ''' <summary>
        ''' A statement that declares a delegate type.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="delegateKeyword">
        ''' The "Delegate" keyword.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the delegate being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this
        ''' delegate. If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function DelegateFunctionStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), delegateKeyword As KeywordSyntax, keyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As DelegateStatementSyntax
            Debug.Assert(delegateKeyword IsNot Nothing AndAlso delegateKeyword.Kind = SyntaxKind.DelegateKeyword)
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.FunctionKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New DelegateStatementSyntax(SyntaxKind.DelegateFunctionStatement, attributes.Node, modifiers.Node, delegateKeyword, keyword, identifier, typeParameterList, parameterList, asClause)
        End Function


        ''' <summary>
        ''' A statement that declares a delegate type.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' DelegateStatementSyntax. One of DelegateSubStatement,
        ''' DelegateFunctionStatement.
        ''' </param>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="delegateKeyword">
        ''' The "Delegate" keyword.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the delegate being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this
        ''' delegate. If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function DelegateStatement(kind As SyntaxKind, attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), delegateKeyword As KeywordSyntax, keyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As DelegateStatementSyntax
            Debug.Assert(kind.IsDelegateStatement())
            Debug.Assert(delegateKeyword IsNot Nothing AndAlso delegateKeyword.Kind = SyntaxKind.DelegateKeyword)
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind.IsDelegateStatementKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New DelegateStatementSyntax(kind, attributes.Node, modifiers.Node, delegateKeyword, keyword, identifier, typeParameterList, parameterList, asClause)
        End Function


        ''' <summary>
        ''' A statement that declares an event. If the event being declared is a custom
        ''' event, this statement will be the Begin of a PropertyOrEventBlock, and the
        ''' accessors will be part of the Accessors of that node.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="customKeyword">
        ''' The optional Custom keyword for custom event declarations.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the event being declared.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        ''' <param name="implementsClause">
        ''' If present, an Implements clause indicates the interface methods that this
        ''' method implements.
        ''' </param>
        Friend Shared Function EventStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), customKeyword As KeywordSyntax, keyword As KeywordSyntax, identifier As IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, implementsClause As ImplementsClauseSyntax) As EventStatementSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.EventKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New EventStatementSyntax(SyntaxKind.EventStatement, attributes.Node, modifiers.Node, customKeyword, keyword, identifier, parameterList, asClause, implementsClause)
        End Function


        ''' <summary>
        ''' A statement that declares an operator. If this operator has a body, this
        ''' statement will be the Begin of a BlockStatement with
        ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
        ''' that BlockStatement.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="operator">
        ''' The operator being defined.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function OperatorStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, [operator] As SyntaxToken, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As OperatorStatementSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.OperatorKeyword)
            Debug.Assert([operator] IsNot Nothing AndAlso [operator].Kind.IsOperatorStatementOperator)
            Return New OperatorStatementSyntax(SyntaxKind.OperatorStatement, attributes.Node, modifiers.Node, keyword, [operator], parameterList, asClause)
        End Function


        ''' <summary>
        ''' Statement that declares a property. If this property has accessors declared,
        ''' this statement will be the Begin of a BlockNode, and the accessors will be the
        ''' Body of that node. Auto properties are property declarations without a
        ''' PropertyBlock.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the property being declared.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        ''' <param name="initializer">
        ''' If present, an "= initial-value" clause describing the initial value of the
        ''' property.
        ''' </param>
        ''' <param name="implementsClause">
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </param>
        Friend Shared Function PropertyStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, identifier As IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, initializer As EqualsValueSyntax, implementsClause As ImplementsClauseSyntax) As PropertyStatementSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.PropertyKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New PropertyStatementSyntax(SyntaxKind.PropertyStatement, attributes.Node, modifiers.Node, keyword, identifier, parameterList, asClause, initializer, implementsClause)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function GetAccessorStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As AccessorStatementSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.GetKeyword)
            Return New AccessorStatementSyntax(SyntaxKind.GetAccessorStatement, attributes.Node, modifiers.Node, keyword, parameterList, asClause)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function SetAccessorStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As AccessorStatementSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.SetKeyword)
            Return New AccessorStatementSyntax(SyntaxKind.SetAccessorStatement, attributes.Node, modifiers.Node, keyword, parameterList, asClause)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function AddHandlerAccessorStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As AccessorStatementSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.AddHandlerKeyword)
            Return New AccessorStatementSyntax(SyntaxKind.AddHandlerAccessorStatement, attributes.Node, modifiers.Node, keyword, parameterList, asClause)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function RemoveHandlerAccessorStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As AccessorStatementSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.RemoveHandlerKeyword)
            Return New AccessorStatementSyntax(SyntaxKind.RemoveHandlerAccessorStatement, attributes.Node, modifiers.Node, keyword, parameterList, asClause)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function RaiseEventHandlerAccessorStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As AccessorStatementSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.RaiseEventKeyword)
            Return New AccessorStatementSyntax(SyntaxKind.RaiseEventHandlerAccessorStatement, attributes.Node, modifiers.Node, keyword, parameterList, asClause)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' AccessorStatementSyntax. One of GetAccessorStatement, SetAccessorStatement,
        ''' AddHandlerAccessorStatement, RemoveHandlerAccessorStatement,
        ''' RaiseEventHandlerAccessorStatement.
        ''' </param>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function AccessorStatement(kind As SyntaxKind, attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As AccessorStatementSyntax
            Debug.Assert(kind.IsAccessorStatement())
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind.IsAccessorStatementKeyword)
            Return New AccessorStatementSyntax(kind, attributes.Node, modifiers.Node, keyword, parameterList, asClause)
        End Function


        ''' <summary>
        ''' Represents the "Implements ..." clause on a type member, which describes which
        ''' interface members this member implements.
        ''' </summary>
        ''' <param name="implementsKeyword">
        ''' The "Implements" keyword.
        ''' </param>
        ''' <param name="interfaceMembers">
        ''' The list of interface members being implemented.
        ''' </param>
        Friend Shared Function ImplementsClause(implementsKeyword As KeywordSyntax, interfaceMembers As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.QualifiedNameSyntax)) As ImplementsClauseSyntax
            Debug.Assert(implementsKeyword IsNot Nothing AndAlso implementsKeyword.Kind = SyntaxKind.ImplementsKeyword)
            Return New ImplementsClauseSyntax(SyntaxKind.ImplementsClause, implementsKeyword, interfaceMembers.Node)
        End Function


        ''' <summary>
        ''' Represents the "Handles ..." clause on a method declaration that describes
        ''' which events this method handles.
        ''' </summary>
        ''' <param name="handlesKeyword">
        ''' The "Handles" keyword.
        ''' </param>
        ''' <param name="events">
        ''' The list of event members being handled.
        ''' </param>
        Friend Shared Function HandlesClause(handlesKeyword As KeywordSyntax, events As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.HandlesClauseItemSyntax)) As HandlesClauseSyntax
            Debug.Assert(handlesKeyword IsNot Nothing AndAlso handlesKeyword.Kind = SyntaxKind.HandlesKeyword)
            Return New HandlesClauseSyntax(SyntaxKind.HandlesClause, handlesKeyword, events.Node)
        End Function


        ''' <summary>
        ''' Represents a single handled event in a "Handles ..." clause.
        ''' </summary>
        ''' <param name="eventContainer">
        ''' The container of the event. This can either be an simple identifier
        ''' (identifying a members of the containing type) or one of the special keywords
        ''' "Me", "MyBase" or "MyClass".
        ''' </param>
        ''' <param name="dotToken">
        ''' The "." token.
        ''' </param>
        ''' <param name="eventMember">
        ''' The event being handled. This must be a simple identifier.
        ''' </param>
        Friend Shared Function HandlesClauseItem(eventContainer As SyntaxToken, dotToken As PunctuationSyntax, eventMember As IdentifierNameSyntax) As HandlesClauseItemSyntax
            Debug.Assert(eventContainer IsNot Nothing AndAlso eventContainer.Kind.IsHandlesClauseItemEventContainer)
            Debug.Assert(dotToken IsNot Nothing AndAlso dotToken.Kind = SyntaxKind.DotToken)
            Debug.Assert(eventMember IsNot Nothing)
            Return New HandlesClauseItemSyntax(SyntaxKind.HandlesClauseItem, eventContainer, dotToken, eventMember)
        End Function


        ''' <summary>
        ''' Represents the beginning of a declaration. However, not enough syntax is
        ''' detected to classify this as a field, method, property or event. This is node
        ''' always represents a syntax error.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="missingIdentifier">
        ''' The missing identifier token for this incomplete member. Should only be used to
        ''' have a location for error reporting.
        ''' </param>
        Friend Shared Function IncompleteMember(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), missingIdentifier As IdentifierTokenSyntax) As IncompleteMemberSyntax
            Return New IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributes.Node, modifiers.Node, missingIdentifier)
        End Function


        ''' <summary>
        ''' Represents the declaration of one or more variables or constants, either as
        ''' local variables or as class/structure members. In the case of a constant, it is
        ''' represented by having "Const" in the Modifiers (although technically "Const" is
        ''' not a modifier, it is represented as one in the parse trees.)
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="declarators">
        ''' The list of variable declarator. Each declarator specifies one or more variable
        ''' names along with a type and/or initializer.
        ''' </param>
        Friend Shared Function FieldDeclaration(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), declarators As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.VariableDeclaratorSyntax)) As FieldDeclarationSyntax
            Return New FieldDeclarationSyntax(SyntaxKind.FieldDeclaration, attributes.Node, modifiers.Node, declarators.Node)
        End Function


        ''' <summary>
        ''' Represents the part of a variable or constant declaration statement that
        ''' associated one or more variable names with a type.
        ''' </summary>
        ''' <param name="names">
        ''' The names of the variables being declared. Each name might have a "?" or "()"
        ''' modifier(s) attached.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type, and possibly includes "New",
        ''' "With" or "From". If no As clause was present, Nothing is returned.
        ''' </param>
        ''' <param name="initializer">
        ''' If present, an "= initial-value" clause describing the initial value of the
        ''' variable or the value of the constant.
        ''' </param>
        Friend Shared Function VariableDeclarator(names As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ModifiedIdentifierSyntax), asClause As AsClauseSyntax, initializer As EqualsValueSyntax) As VariableDeclaratorSyntax
            Return New VariableDeclaratorSyntax(SyntaxKind.VariableDeclarator, names.Node, asClause, initializer)
        End Function


        ''' <summary>
        ''' Represents an "As {type-name}" clause that does not have an initializer or
        ''' "New". The type has optional attributes associated with it, although attributes
        ''' are not permitted in all possible places where this node occurs.
        ''' </summary>
        ''' <param name="asKeyword">
        ''' The "As" keyword.
        ''' </param>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </param>
        ''' <param name="type">
        ''' The type-name part of the As clause.
        ''' </param>
        Friend Shared Function SimpleAsClause(asKeyword As KeywordSyntax, attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), type As TypeSyntax) As SimpleAsClauseSyntax
            Debug.Assert(asKeyword IsNot Nothing AndAlso asKeyword.Kind = SyntaxKind.AsKeyword)
            Debug.Assert(type IsNot Nothing)
            Return New SimpleAsClauseSyntax(SyntaxKind.SimpleAsClause, asKeyword, attributes.Node, type)
        End Function


        ''' <summary>
        ''' Represents an "As New {type-name} [arguments] [initializers]" clause in a
        ''' declaration. The type has optional attributes associated with it, although
        ''' attributes are not permitted in many places where this node occurs (they are
        ''' permitted, for example, on automatically implemented properties.)
        ''' </summary>
        ''' <param name="asKeyword">
        ''' The "As" keyword.
        ''' </param>
        ''' <param name="newExpression">
        ''' The New expression
        ''' </param>
        Friend Shared Function AsNewClause(asKeyword As KeywordSyntax, newExpression As NewExpressionSyntax) As AsNewClauseSyntax
            Debug.Assert(asKeyword IsNot Nothing AndAlso asKeyword.Kind = SyntaxKind.AsKeyword)
            Debug.Assert(newExpression IsNot Nothing)
            Return New AsNewClauseSyntax(SyntaxKind.AsNewClause, asKeyword, newExpression)
        End Function


        ''' <summary>
        ''' Represents a "With {...} clause used to initialize a new object's members.
        ''' </summary>
        ''' <param name="withKeyword">
        ''' The "With" keyword.
        ''' </param>
        ''' <param name="openBraceToken">
        ''' The "{" token.
        ''' </param>
        ''' <param name="initializers">
        ''' The comma-separated list of field initializers.
        ''' </param>
        ''' <param name="closeBraceToken">
        ''' The "}" token.
        ''' </param>
        Friend Shared Function ObjectMemberInitializer(withKeyword As KeywordSyntax, openBraceToken As PunctuationSyntax, initializers As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.FieldInitializerSyntax), closeBraceToken As PunctuationSyntax) As ObjectMemberInitializerSyntax
            Debug.Assert(withKeyword IsNot Nothing AndAlso withKeyword.Kind = SyntaxKind.WithKeyword)
            Debug.Assert(openBraceToken IsNot Nothing AndAlso openBraceToken.Kind = SyntaxKind.OpenBraceToken)
            Debug.Assert(closeBraceToken IsNot Nothing AndAlso closeBraceToken.Kind = SyntaxKind.CloseBraceToken)
            Return New ObjectMemberInitializerSyntax(SyntaxKind.ObjectMemberInitializer, withKeyword, openBraceToken, initializers.Node, closeBraceToken)
        End Function


        ''' <summary>
        ''' Represents a "From {...} clause used to initialize a new collection object's
        ''' elements.
        ''' </summary>
        ''' <param name="fromKeyword">
        ''' The "From" keyword.
        ''' </param>
        ''' <param name="initializer">
        ''' The initializer including the braces.
        ''' </param>
        Friend Shared Function ObjectCollectionInitializer(fromKeyword As KeywordSyntax, initializer As CollectionInitializerSyntax) As ObjectCollectionInitializerSyntax
            Debug.Assert(fromKeyword IsNot Nothing AndAlso fromKeyword.Kind = SyntaxKind.FromKeyword)
            Debug.Assert(initializer IsNot Nothing)
            Return New ObjectCollectionInitializerSyntax(SyntaxKind.ObjectCollectionInitializer, fromKeyword, initializer)
        End Function


        ''' <summary>
        ''' Represent a field initializer in a With {...} initializer where the field name
        ''' is inferred from the initializer expression.
        ''' </summary>
        ''' <param name="keyKeyword">
        ''' The optional "Key" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The value being assigned.
        ''' </param>
        Friend Shared Function InferredFieldInitializer(keyKeyword As KeywordSyntax, expression As ExpressionSyntax) As InferredFieldInitializerSyntax
            Debug.Assert(expression IsNot Nothing)
            Return New InferredFieldInitializerSyntax(SyntaxKind.InferredFieldInitializer, keyKeyword, expression)
        End Function


        ''' <summary>
        ''' Represent a named field initializer in a With {...} initializer, such as ".x =
        ''' expr".
        ''' </summary>
        ''' <param name="keyKeyword">
        ''' The optional "Key" keyword.
        ''' </param>
        ''' <param name="dotToken">
        ''' The "." token.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the field being initialized.
        ''' </param>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        ''' <param name="expression">
        ''' The value being assigned to the field.
        ''' </param>
        Friend Shared Function NamedFieldInitializer(keyKeyword As KeywordSyntax, dotToken As PunctuationSyntax, identifier As IdentifierNameSyntax, equalsToken As PunctuationSyntax, expression As ExpressionSyntax) As NamedFieldInitializerSyntax
            Debug.Assert(dotToken IsNot Nothing AndAlso dotToken.Kind = SyntaxKind.DotToken)
            Debug.Assert(identifier IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(expression IsNot Nothing)
            Return New NamedFieldInitializerSyntax(SyntaxKind.NamedFieldInitializer, keyKeyword, dotToken, identifier, equalsToken, expression)
        End Function


        ''' <summary>
        ''' Represents an "= initializer" clause in a declaration for a variable,
        ''' pararameter or automatic property.
        ''' </summary>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        ''' <param name="value">
        ''' The expression used as the initial value.
        ''' </param>
        Friend Shared Function EqualsValue(equalsToken As PunctuationSyntax, value As ExpressionSyntax) As EqualsValueSyntax
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(value IsNot Nothing)
            Return New EqualsValueSyntax(SyntaxKind.EqualsValue, equalsToken, value)
        End Function


        ''' <summary>
        ''' Represent a parameter to a method, property, constructor, etc.
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this parameter. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
        ''' modify this parameter.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the parameter, including any "?" or "()" modifiers.
        ''' </param>
        ''' <param name="asClause">
        ''' If present, the "As type-name" clause describing the type of the parameter. If
        ''' no As clause is present, Nothing is returned.
        ''' </param>
        ''' <param name="default">
        ''' If present, an initializer with the default value of the parameter. If no
        ''' default value is present, Nothing is returned.
        ''' </param>
        Friend Shared Function Parameter(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, [default] As EqualsValueSyntax) As ParameterSyntax
            Debug.Assert(identifier IsNot Nothing)
            Return New ParameterSyntax(SyntaxKind.Parameter, attributes.Node, modifiers.Node, identifier, asClause, [default])
        End Function


        ''' <summary>
        ''' Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
        ''' used in parameter declarations and variable declarations.
        ''' </summary>
        ''' <param name="identifier">
        ''' The identifier that names the item being declared.
        ''' </param>
        ''' <param name="nullable">
        ''' The "?" token that indicates a nullable type.
        ''' </param>
        ''' <param name="arrayBounds">
        ''' The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
        ''' </param>
        ''' <param name="arrayRankSpecifiers">
        ''' A list of array modifiers for the type. If no array modifiers were present, an
        ''' empty list is returned.
        ''' </param>
        Friend Shared Function ModifiedIdentifier(identifier As IdentifierTokenSyntax, nullable As PunctuationSyntax, arrayBounds As ArgumentListSyntax, arrayRankSpecifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode)) As ModifiedIdentifierSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New ModifiedIdentifierSyntax(SyntaxKind.ModifiedIdentifier, identifier, nullable, arrayBounds, arrayRankSpecifiers.Node)
        End Function


        ''' <summary>
        ''' Represents a modifier that describes an array type, without bounds, such as
        ''' "()" or "(,)".
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="commaTokens">
        ''' The comma tokens in the array type. There is one less comma than the rank.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function ArrayRankSpecifier(openParenToken As PunctuationSyntax, commaTokens As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), closeParenToken As PunctuationSyntax) As ArrayRankSpecifierSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openParenToken, commaTokens.Node, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents a group of attributes within "&lt;" and "&gt;" brackets.
        ''' </summary>
        ''' <param name="lessThanToken">
        ''' The "&lt;" token.
        ''' </param>
        ''' <param name="attributes">
        ''' A comma separated list of attribute declarations in this attribute block.
        ''' </param>
        ''' <param name="greaterThanToken">
        ''' The "&gt;" token.
        ''' </param>
        Friend Shared Function AttributeBlock(lessThanToken As PunctuationSyntax, attributes As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.AttributeSyntax), greaterThanToken As PunctuationSyntax) As AttributeBlockSyntax
            Debug.Assert(lessThanToken IsNot Nothing AndAlso lessThanToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(greaterThanToken IsNot Nothing AndAlso greaterThanToken.Kind = SyntaxKind.GreaterThanToken)
            Return New AttributeBlockSyntax(SyntaxKind.AttributeBlock, lessThanToken, attributes.Node, greaterThanToken)
        End Function


        ''' <summary>
        ''' Represents a single attribute declaration within an attribute block.
        ''' </summary>
        ''' <param name="target">
        ''' Optional attribute target. Assembly|Module :
        ''' </param>
        ''' <param name="name">
        ''' The name of the attribute.
        ''' </param>
        ''' <param name="argumentList">
        ''' The argument list, if present. If no argument list was supplied, Nothing is
        ''' returned.
        ''' </param>
        Friend Shared Function Attribute(target As AttributeTargetSyntax, name As TypeSyntax, argumentList As ArgumentListSyntax) As AttributeSyntax
            Debug.Assert(name IsNot Nothing)
            Return New AttributeSyntax(SyntaxKind.Attribute, target, name, argumentList)
        End Function


        ''' <summary>
        ''' Represents a single attribute declaration within an attribute block.
        ''' </summary>
        ''' <param name="attributeModifier">
        ''' The "Assembly" or "Module" attribute modifier, is present. If no attribute
        ''' modifier is present, Nothing is returned.
        ''' </param>
        ''' <param name="colonToken">
        ''' The ":" token, if an attribute modifier is present. If no attribute modifier is
        ''' present, Nothing is returned.
        ''' </param>
        Friend Shared Function AttributeTarget(attributeModifier As KeywordSyntax, colonToken As PunctuationSyntax) As AttributeTargetSyntax
            Debug.Assert(attributeModifier IsNot Nothing AndAlso attributeModifier.Kind.IsAttributeTargetAttributeModifier)
            Debug.Assert(colonToken IsNot Nothing AndAlso colonToken.Kind = SyntaxKind.ColonToken)
            Return New AttributeTargetSyntax(SyntaxKind.AttributeTarget, attributeModifier, colonToken)
        End Function


        ''' <summary>
        ''' Represents a file-level attribute, in which the attributes have no other
        ''' syntactic element they are attached to.
        ''' </summary>
        ''' <param name="attributes">
        ''' The list of attribute blocks.
        ''' </param>
        Friend Shared Function AttributesStatement(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode)) As AttributesStatementSyntax
            Return New AttributesStatementSyntax(SyntaxKind.AttributesStatement, attributes.Node)
        End Function


        ''' <summary>
        ''' Represent an expression in a statement context.
        ''' </summary>
        ''' <param name="questionToken">
        ''' "?" token, if present.
        ''' </param>
        ''' <param name="expression">
        ''' The expression.
        ''' </param>
        Friend Shared Function ExpressionStatement(questionToken As PunctuationSyntax, expression As ExpressionSyntax) As ExpressionStatementSyntax
            Debug.Assert(expression IsNot Nothing)
            Return New ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, questionToken, expression)
        End Function


        ''' <summary>
        ''' Represents a While...End While statement, including the While, body and End
        ''' While.
        ''' </summary>
        ''' <param name="begin">
        ''' The While statement that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the While...End While. This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The End While statement that ends the block.
        ''' </param>
        Friend Shared Function WhileBlock(begin As WhileStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As WhileBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsWhileBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New WhileBlockSyntax(SyntaxKind.WhileBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents an entire Using...End Using statement, including the Using, body and
        ''' End Using statements.
        ''' </summary>
        ''' <param name="begin">
        ''' The UsingStatement that begins the Using...End Using block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the Using...End Using block. This might be an empty
        ''' list.
        ''' </param>
        ''' <param name="end">
        ''' The End Using statement that ends the block.
        ''' </param>
        Friend Shared Function UsingBlock(begin As UsingStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As UsingBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsUsingBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New UsingBlockSyntax(SyntaxKind.UsingBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a entire SyncLock...End SyncLock block, including the SyncLock
        ''' statement, the enclosed statements, and the End SyncLock statment.
        ''' </summary>
        ''' <param name="begin">
        ''' The SyncLock statement that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the SyncLock...End SyncLock statement. This might
        ''' be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The End SyncLock statement that ends the block.
        ''' </param>
        Friend Shared Function SyncLockBlock(begin As SyncLockStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As SyncLockBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsSyncLockBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New SyncLockBlockSyntax(SyntaxKind.SyncLockBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a With...End With block, include the With statement, the body of the
        ''' block and the End With statement.
        ''' </summary>
        ''' <param name="begin">
        ''' The WithStatement that begins the With...End With block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the With...End With block. This might be an empty
        ''' list.
        ''' </param>
        ''' <param name="end">
        ''' The End With statement that ends the block.
        ''' </param>
        Friend Shared Function WithBlock(begin As WithStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As WithBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsWithBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New WithBlockSyntax(SyntaxKind.WithBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents the declaration of one or more local variables or constants.
        ''' </summary>
        ''' <param name="modifiers">
        ''' The modifier token (Static, Dim or Const) that introduces this local variable
        ''' declaration.
        ''' </param>
        ''' <param name="declarators">
        ''' The list of variable declarator. Each declarator specifies one or more variable
        ''' names along with a type and/or initializer.
        ''' </param>
        Friend Shared Function LocalDeclaration(modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), declarators As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.VariableDeclaratorSyntax)) As LocalDeclarationSyntax
            Return New LocalDeclarationSyntax(SyntaxKind.LocalDeclaration, modifiers.Node, declarators.Node)
        End Function


        ''' <summary>
        ''' Represents a label statement.
        ''' </summary>
        ''' <param name="labelToken">
        ''' The name of the label. If the label is a line number, returns an IntegerLiteral
        ''' that is the line number, otherwise, returns an Identifier.
        ''' </param>
        Friend Shared Function LabelStatement(labelToken As SyntaxToken) As LabelStatementSyntax
            Debug.Assert(labelToken IsNot Nothing AndAlso labelToken.Kind.IsLabelStatementLabelToken)
            Return New LabelStatementSyntax(SyntaxKind.LabelStatement, labelToken)
        End Function


        ''' <summary>
        ''' Represents a "GoTo" statement.
        ''' </summary>
        ''' <param name="goToKeyword">
        ''' The "GoTo" keyword.
        ''' </param>
        ''' <param name="label">
        ''' The name of the label. If the label is a line number, wraps an IntegerLiteral
        ''' that is the line number, otherwise, wraps an Identifier.
        ''' </param>
        Friend Shared Function GoToStatement(goToKeyword As KeywordSyntax, label As LabelSyntax) As GoToStatementSyntax
            Debug.Assert(goToKeyword IsNot Nothing AndAlso goToKeyword.Kind = SyntaxKind.GoToKeyword)
            Debug.Assert(label IsNot Nothing)
            Return New GoToStatementSyntax(SyntaxKind.GoToStatement, goToKeyword, label)
        End Function


        ''' <summary>
        ''' A label for a GoTo, Resume, or On Error statement. An identifier, line number,
        ''' or next keyword.
        ''' </summary>
        ''' <param name="labelToken">
        ''' The label name (identifier), line number (integer literal), or next keyword
        ''' token.
        ''' </param>
        Friend Shared Function IdentifierLabel(labelToken As SyntaxToken) As LabelSyntax
            Debug.Assert(labelToken IsNot Nothing AndAlso labelToken.Kind = SyntaxKind.IdentifierToken)
            Return New LabelSyntax(SyntaxKind.IdentifierLabel, labelToken)
        End Function


        ''' <summary>
        ''' A label for a GoTo, Resume, or On Error statement. An identifier, line number,
        ''' or next keyword.
        ''' </summary>
        ''' <param name="labelToken">
        ''' The label name (identifier), line number (integer literal), or next keyword
        ''' token.
        ''' </param>
        Friend Shared Function NumericLabel(labelToken As SyntaxToken) As LabelSyntax
            Debug.Assert(labelToken IsNot Nothing AndAlso labelToken.Kind = SyntaxKind.IntegerLiteralToken)
            Return New LabelSyntax(SyntaxKind.NumericLabel, labelToken)
        End Function


        ''' <summary>
        ''' A label for a GoTo, Resume, or On Error statement. An identifier, line number,
        ''' or next keyword.
        ''' </summary>
        ''' <param name="labelToken">
        ''' The label name (identifier), line number (integer literal), or next keyword
        ''' token.
        ''' </param>
        Friend Shared Function NextLabel(labelToken As SyntaxToken) As LabelSyntax
            Debug.Assert(labelToken IsNot Nothing AndAlso labelToken.Kind = SyntaxKind.NextKeyword)
            Return New LabelSyntax(SyntaxKind.NextLabel, labelToken)
        End Function


        ''' <summary>
        ''' A label for a GoTo, Resume, or On Error statement. An identifier, line number,
        ''' or next keyword.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of LabelSyntax. One of
        ''' IdentifierLabel, NumericLabel, NextLabel.
        ''' </param>
        ''' <param name="labelToken">
        ''' The label name (identifier), line number (integer literal), or next keyword
        ''' token.
        ''' </param>
        Friend Shared Function Label(kind As SyntaxKind, labelToken As SyntaxToken) As LabelSyntax
            Debug.Assert(kind.IsLabel())
            Debug.Assert(labelToken IsNot Nothing AndAlso labelToken.Kind.IsLabelLabelToken)
            Return New LabelSyntax(kind, labelToken)
        End Function


        ''' <summary>
        ''' Represents a "Stop" or "End" statement. The Kind can be used to determine which
        ''' kind of statement this is.
        ''' </summary>
        ''' <param name="stopOrEndKeyword">
        ''' The "Stop" or "End" keyword.
        ''' </param>
        Friend Shared Function StopStatement(stopOrEndKeyword As KeywordSyntax) As StopOrEndStatementSyntax
            Debug.Assert(stopOrEndKeyword IsNot Nothing AndAlso stopOrEndKeyword.Kind.IsStopOrEndStatementStopOrEndKeyword)
            Return New StopOrEndStatementSyntax(SyntaxKind.StopStatement, stopOrEndKeyword)
        End Function


        ''' <summary>
        ''' Represents a "Stop" or "End" statement. The Kind can be used to determine which
        ''' kind of statement this is.
        ''' </summary>
        ''' <param name="stopOrEndKeyword">
        ''' The "Stop" or "End" keyword.
        ''' </param>
        Friend Shared Function EndStatement(stopOrEndKeyword As KeywordSyntax) As StopOrEndStatementSyntax
            Debug.Assert(stopOrEndKeyword IsNot Nothing AndAlso stopOrEndKeyword.Kind.IsStopOrEndStatementStopOrEndKeyword)
            Return New StopOrEndStatementSyntax(SyntaxKind.EndStatement, stopOrEndKeyword)
        End Function


        ''' <summary>
        ''' Represents a "Stop" or "End" statement. The Kind can be used to determine which
        ''' kind of statement this is.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' StopOrEndStatementSyntax. One of StopStatement, EndStatement.
        ''' </param>
        ''' <param name="stopOrEndKeyword">
        ''' The "Stop" or "End" keyword.
        ''' </param>
        Friend Shared Function StopOrEndStatement(kind As SyntaxKind, stopOrEndKeyword As KeywordSyntax) As StopOrEndStatementSyntax
            Debug.Assert(kind.IsStopOrEndStatement())
            Debug.Assert(stopOrEndKeyword IsNot Nothing AndAlso stopOrEndKeyword.Kind.IsStopOrEndStatementStopOrEndKeyword)
            Return New StopOrEndStatementSyntax(kind, stopOrEndKeyword)
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitDoStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.DoKeyword)
            Return New ExitStatementSyntax(SyntaxKind.ExitDoStatement, exitKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitForStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.ForKeyword)
            Return New ExitStatementSyntax(SyntaxKind.ExitForStatement, exitKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitSubStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SubKeyword)
            Return New ExitStatementSyntax(SyntaxKind.ExitSubStatement, exitKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitFunctionStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.FunctionKeyword)
            Return New ExitStatementSyntax(SyntaxKind.ExitFunctionStatement, exitKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitOperatorStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.OperatorKeyword)
            Return New ExitStatementSyntax(SyntaxKind.ExitOperatorStatement, exitKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitPropertyStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.PropertyKeyword)
            Return New ExitStatementSyntax(SyntaxKind.ExitPropertyStatement, exitKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitTryStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.TryKeyword)
            Return New ExitStatementSyntax(SyntaxKind.ExitTryStatement, exitKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitSelectStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SelectKeyword)
            Return New ExitStatementSyntax(SyntaxKind.ExitSelectStatement, exitKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitWhileStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.WhileKeyword)
            Return New ExitStatementSyntax(SyntaxKind.ExitWhileStatement, exitKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of ExitStatementSyntax.
        ''' One of ExitDoStatement, ExitForStatement, ExitSubStatement,
        ''' ExitFunctionStatement, ExitOperatorStatement, ExitPropertyStatement,
        ''' ExitTryStatement, ExitSelectStatement, ExitWhileStatement.
        ''' </param>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitStatement(kind As SyntaxKind, exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(kind.IsExitStatement())
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind.IsExitStatementBlockKeyword)
            Return New ExitStatementSyntax(kind, exitKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents a "Continue (block)" statement. THe kind of block referenced can be
        ''' determined by examining the Kind.
        ''' </summary>
        ''' <param name="continueKeyword">
        ''' The "Continue" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The "Do", "For" or "While" keyword that identifies the kind of loop being
        ''' continued.
        ''' </param>
        Friend Shared Function ContinueWhileStatement(continueKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ContinueStatementSyntax
            Debug.Assert(continueKeyword IsNot Nothing AndAlso continueKeyword.Kind = SyntaxKind.ContinueKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.WhileKeyword)
            Return New ContinueStatementSyntax(SyntaxKind.ContinueWhileStatement, continueKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents a "Continue (block)" statement. THe kind of block referenced can be
        ''' determined by examining the Kind.
        ''' </summary>
        ''' <param name="continueKeyword">
        ''' The "Continue" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The "Do", "For" or "While" keyword that identifies the kind of loop being
        ''' continued.
        ''' </param>
        Friend Shared Function ContinueDoStatement(continueKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ContinueStatementSyntax
            Debug.Assert(continueKeyword IsNot Nothing AndAlso continueKeyword.Kind = SyntaxKind.ContinueKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.DoKeyword)
            Return New ContinueStatementSyntax(SyntaxKind.ContinueDoStatement, continueKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents a "Continue (block)" statement. THe kind of block referenced can be
        ''' determined by examining the Kind.
        ''' </summary>
        ''' <param name="continueKeyword">
        ''' The "Continue" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The "Do", "For" or "While" keyword that identifies the kind of loop being
        ''' continued.
        ''' </param>
        Friend Shared Function ContinueForStatement(continueKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ContinueStatementSyntax
            Debug.Assert(continueKeyword IsNot Nothing AndAlso continueKeyword.Kind = SyntaxKind.ContinueKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.ForKeyword)
            Return New ContinueStatementSyntax(SyntaxKind.ContinueForStatement, continueKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents a "Continue (block)" statement. THe kind of block referenced can be
        ''' determined by examining the Kind.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' ContinueStatementSyntax. One of ContinueWhileStatement, ContinueDoStatement,
        ''' ContinueForStatement.
        ''' </param>
        ''' <param name="continueKeyword">
        ''' The "Continue" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The "Do", "For" or "While" keyword that identifies the kind of loop being
        ''' continued.
        ''' </param>
        Friend Shared Function ContinueStatement(kind As SyntaxKind, continueKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ContinueStatementSyntax
            Debug.Assert(kind.IsContinueStatement())
            Debug.Assert(continueKeyword IsNot Nothing AndAlso continueKeyword.Kind = SyntaxKind.ContinueKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind.IsContinueStatementBlockKeyword)
            Return New ContinueStatementSyntax(kind, continueKeyword, blockKeyword)
        End Function


        ''' <summary>
        ''' Represents a "Return" statement.
        ''' </summary>
        ''' <param name="returnKeyword">
        ''' The "Return" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being returned, if present.
        ''' </param>
        Friend Shared Function ReturnStatement(returnKeyword As KeywordSyntax, expression As ExpressionSyntax) As ReturnStatementSyntax
            Debug.Assert(returnKeyword IsNot Nothing AndAlso returnKeyword.Kind = SyntaxKind.ReturnKeyword)
            Return New ReturnStatementSyntax(SyntaxKind.ReturnStatement, returnKeyword, expression)
        End Function


        ''' <summary>
        ''' Represents a line If-Then-Else statement.
        ''' </summary>
        ''' <param name="ifPart">
        ''' The If part of the statement.
        ''' </param>
        ''' <param name="elsePart">
        ''' The Else part of the statement. If there is no Else part, Nothing is returned.
        ''' </param>
        Friend Shared Function SingleLineIfStatement(ifPart As SingleLineIfPartSyntax, elsePart As SingleLineElsePartSyntax) As SingleLineIfStatementSyntax
            Debug.Assert(ifPart IsNot Nothing)
            Return New SingleLineIfStatementSyntax(SyntaxKind.SingleLineIfStatement, ifPart, elsePart)
        End Function


        ''' <summary>
        ''' Represents part of a single line If statement, consisting of a beginning
        ''' if-statement, followed by a body of statement controlled by that beginning
        ''' statement. The Kind property returns if this is an SingleLineIf.
        ''' </summary>
        ''' <param name="begin">
        ''' The statement that introduces this part of the If...Then...Else...End If. This
        ''' must be an IfStatement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements controlled by this If or Else If. This might be an empty list.
        ''' </param>
        Friend Shared Function SingleLineIfPart(begin As IfStatementSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax)) As SingleLineIfPartSyntax
            Debug.Assert(begin IsNot Nothing)
            Return New SingleLineIfPartSyntax(SyntaxKind.SingleLineIfPart, begin, statements.Node)
        End Function


        ''' <summary>
        ''' Represents the Else part of an If statement, consisting of a Else statement,
        ''' followed by a body of statement controlled by that Else.
        ''' </summary>
        ''' <param name="begin">
        ''' The Else statement that introduces this part.
        ''' </param>
        ''' <param name="statements">
        ''' The statements controlled by the Else.This might be an empty list.
        ''' </param>
        Friend Shared Function SingleLineElsePart(begin As ElseStatementSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax)) As SingleLineElsePartSyntax
            Debug.Assert(begin IsNot Nothing)
            Return New SingleLineElsePartSyntax(SyntaxKind.SingleLineElsePart, begin, statements.Node)
        End Function


        ''' <summary>
        ''' Represents a block If...Then...Else...EndIf Statement. The Kind property can be
        ''' used to determine if it is a block or line If.
        ''' </summary>
        ''' <param name="ifPart">
        ''' The If part of the statement.
        ''' </param>
        ''' <param name="elseIfParts">
        ''' A list of the "ElseIf" parts of the statement. If there are no ElseIf parts,
        ''' then an empty list is returned.
        ''' </param>
        ''' <param name="elsePart">
        ''' The Else part of the statement. If there is no Else part, Nothing is returned.
        ''' </param>
        ''' <param name="end">
        ''' If this is a block if, returns the "End If" statement.
        ''' </param>
        Friend Shared Function MultiLineIfBlock(ifPart As IfPartSyntax, elseIfParts As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), elsePart As ElsePartSyntax, [end] As EndBlockStatementSyntax) As MultiLineIfBlockSyntax
            Debug.Assert(ifPart IsNot Nothing)
            Debug.Assert([end] IsNot Nothing)
            Return New MultiLineIfBlockSyntax(SyntaxKind.MultiLineIfBlock, ifPart, elseIfParts.Node, elsePart, [end])
        End Function


        ''' <summary>
        ''' Represents part of an If statement, consisting of a beginning statement (If or
        ''' ElseIf), followed by a body of statement controlled by that beginning
        ''' statement. The Kind property returns if this is an If or ElseIf.
        ''' </summary>
        ''' <param name="begin">
        ''' The statement that introduces this part of the If...Then...Else...End If. This
        ''' must be an IfStatement.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements controlled by this If or Else If. This might be an empty list.
        ''' </param>
        Friend Shared Function IfPart(begin As IfStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax)) As IfPartSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsIfPartBeginTerminator)
            Return New IfPartSyntax(SyntaxKind.IfPart, begin, beginTerminator, statements.Node)
        End Function


        ''' <summary>
        ''' Represents part of an If statement, consisting of a beginning statement (If or
        ''' ElseIf), followed by a body of statement controlled by that beginning
        ''' statement. The Kind property returns if this is an If or ElseIf.
        ''' </summary>
        ''' <param name="begin">
        ''' The statement that introduces this part of the If...Then...Else...End If. This
        ''' must be an IfStatement.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements controlled by this If or Else If. This might be an empty list.
        ''' </param>
        Friend Shared Function ElseIfPart(begin As IfStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax)) As IfPartSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsIfPartBeginTerminator)
            Return New IfPartSyntax(SyntaxKind.ElseIfPart, begin, beginTerminator, statements.Node)
        End Function


        ''' <summary>
        ''' Represents the Else part of an If statement, consisting of a Else statement,
        ''' followed by a body of statement controlled by that Else.
        ''' </summary>
        ''' <param name="begin">
        ''' The Else statement that introduces this part.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements controlled by the Else. This might be an empty list.
        ''' </param>
        Friend Shared Function ElsePart(begin As ElseStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax)) As ElsePartSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsElsePartBeginTerminator)
            Return New ElsePartSyntax(SyntaxKind.ElsePart, begin, beginTerminator, statements.Node)
        End Function


        ''' <summary>
        ''' Represents the If part or ElseIf part of a If...End If block (or line If). This
        ''' statement is always the Begin of a IfPart. The Kind can be examined to
        ''' determine if this is an If or an ElseIf statement.
        ''' </summary>
        ''' <param name="elseKeyword">
        ''' If this ElseIf was written as "Else If", contains the "Else" keyword. Otherwise
        ''' returns Nothing.
        ''' </param>
        ''' <param name="ifOrElseIfKeyword">
        ''' The "If" or "ElseIf" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression that is being tested.
        ''' </param>
        ''' <param name="thenKeyword">
        ''' The "Then" keyword.
        ''' </param>
        Friend Shared Function IfStatement(elseKeyword As KeywordSyntax, ifOrElseIfKeyword As KeywordSyntax, condition As ExpressionSyntax, thenKeyword As KeywordSyntax) As IfStatementSyntax
            Debug.Assert(ifOrElseIfKeyword IsNot Nothing AndAlso ifOrElseIfKeyword.Kind.IsIfStatementIfOrElseIfKeyword)
            Debug.Assert(condition IsNot Nothing)
            Return New IfStatementSyntax(SyntaxKind.IfStatement, elseKeyword, ifOrElseIfKeyword, condition, thenKeyword)
        End Function


        ''' <summary>
        ''' Represents the If part or ElseIf part of a If...End If block (or line If). This
        ''' statement is always the Begin of a IfPart. The Kind can be examined to
        ''' determine if this is an If or an ElseIf statement.
        ''' </summary>
        ''' <param name="elseKeyword">
        ''' If this ElseIf was written as "Else If", contains the "Else" keyword. Otherwise
        ''' returns Nothing.
        ''' </param>
        ''' <param name="ifOrElseIfKeyword">
        ''' The "If" or "ElseIf" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression that is being tested.
        ''' </param>
        ''' <param name="thenKeyword">
        ''' The "Then" keyword.
        ''' </param>
        Friend Shared Function ElseIfStatement(elseKeyword As KeywordSyntax, ifOrElseIfKeyword As KeywordSyntax, condition As ExpressionSyntax, thenKeyword As KeywordSyntax) As IfStatementSyntax
            Debug.Assert(ifOrElseIfKeyword IsNot Nothing AndAlso ifOrElseIfKeyword.Kind.IsIfStatementIfOrElseIfKeyword)
            Debug.Assert(condition IsNot Nothing)
            Return New IfStatementSyntax(SyntaxKind.ElseIfStatement, elseKeyword, ifOrElseIfKeyword, condition, thenKeyword)
        End Function


        ''' <summary>
        ''' Represents the Else part of a If...End If block (or line If). This statement is
        ''' always the Begin of a ElsePart.
        ''' </summary>
        ''' <param name="elseKeyword">
        ''' The "Else" keyword
        ''' </param>
        Friend Shared Function ElseStatement(elseKeyword As KeywordSyntax) As ElseStatementSyntax
            Debug.Assert(elseKeyword IsNot Nothing AndAlso elseKeyword.Kind = SyntaxKind.ElseKeyword)
            Return New ElseStatementSyntax(SyntaxKind.ElseStatement, elseKeyword)
        End Function


        ''' <summary>
        ''' Represents an entire Try...Catch...Finally...End Try statement.
        ''' </summary>
        ''' <param name="tryPart">
        ''' The Try part of the statement.
        ''' </param>
        ''' <param name="catchParts">
        ''' A list of the Catch parts of the statement. If there are no Catch parts, then
        ''' an empty list is returned.
        ''' </param>
        ''' <param name="finallyPart">
        ''' The Finally part of the statement, if present.
        ''' </param>
        ''' <param name="end">
        ''' The "End Try" statement.
        ''' </param>
        Friend Shared Function TryBlock(tryPart As TryPartSyntax, catchParts As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), finallyPart As FinallyPartSyntax, [end] As EndBlockStatementSyntax) As TryBlockSyntax
            Debug.Assert(tryPart IsNot Nothing)
            Debug.Assert([end] IsNot Nothing)
            Return New TryBlockSyntax(SyntaxKind.TryBlock, tryPart, catchParts.Node, finallyPart, [end])
        End Function


        ''' <summary>
        ''' Represents part of an Try...Catch...Finally...End Try statement, consisting of
        ''' a beginning statement (Try, Catch or Finally), followed by a body of statements
        ''' controlled by that beginning statement. The Kind property returns which kind of
        ''' part this is.
        ''' </summary>
        ''' <param name="begin">
        ''' The TryStatement that introduces this part of the Try...Catch...Finally...End
        ''' Try.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements inside the Try part of the Try...Catch...Finally...End Try. This
        ''' might be an empty list.
        ''' </param>
        Friend Shared Function TryPart(begin As TryStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax)) As TryPartSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsTryPartBeginTerminator)
            Return New TryPartSyntax(SyntaxKind.TryPart, begin, beginTerminator, statements.Node)
        End Function


        ''' <summary>
        ''' Represents a Catch part of an Try...Catch...Finally...End Try statement,
        ''' consisting of a Catch statement, followed by a body of statements controlled by
        ''' that Catch statement. The Kind property returns which kind of part this is.
        ''' </summary>
        ''' <param name="begin">
        ''' The CatchStatement that introduces this part.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements controlled by the Catch statement. This might be an empty list.
        ''' </param>
        Friend Shared Function CatchPart(begin As CatchStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax)) As CatchPartSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsCatchPartBeginTerminator)
            Return New CatchPartSyntax(SyntaxKind.CatchPart, begin, beginTerminator, statements.Node)
        End Function


        ''' <summary>
        ''' Represents the Finally part of an Try...Catch...Finally...End Try statement,
        ''' consisting of a Finally statement, followed by a body of statements controlled
        ''' by the Finally.
        ''' </summary>
        ''' <param name="begin">
        ''' The FinallyStatement that introduces the Finally part of a Try.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements inside the Finally part of the Try...Catch...Finally...End Try.
        ''' This might be an empty list.
        ''' </param>
        Friend Shared Function FinallyPart(begin As FinallyStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax)) As FinallyPartSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsFinallyPartBeginTerminator)
            Return New FinallyPartSyntax(SyntaxKind.FinallyPart, begin, beginTerminator, statements.Node)
        End Function


        ''' <summary>
        ''' Represents the Try part part of a Try...Catch...Finally...End Try. This
        ''' statement is always the Begin of a TryPart.
        ''' </summary>
        ''' <param name="tryKeyword">
        ''' The "Try" keyword
        ''' </param>
        Friend Shared Function TryStatement(tryKeyword As KeywordSyntax) As TryStatementSyntax
            Debug.Assert(tryKeyword IsNot Nothing AndAlso tryKeyword.Kind = SyntaxKind.TryKeyword)
            Return New TryStatementSyntax(SyntaxKind.TryStatement, tryKeyword)
        End Function


        ''' <summary>
        ''' Represents the Catch part part of a Try...Catch...Finally...End Try. This
        ''' statement is always the Begin of a CatchPart.
        ''' </summary>
        ''' <param name="catchKeyword">
        ''' The "Catch" keyword.
        ''' </param>
        ''' <param name="identifierName">
        ''' The identifier representing the exception that was caught, if present.
        ''' </param>
        ''' <param name="asClause">
        ''' The As clause that defines the type of exception being caught.
        ''' </param>
        ''' <param name="whenClause">
        ''' The "When" clause, if present.
        ''' </param>
        Friend Shared Function CatchStatement(catchKeyword As KeywordSyntax, identifierName As IdentifierNameSyntax, asClause As SimpleAsClauseSyntax, whenClause As CatchFilterClauseSyntax) As CatchStatementSyntax
            Debug.Assert(catchKeyword IsNot Nothing AndAlso catchKeyword.Kind = SyntaxKind.CatchKeyword)
            Return New CatchStatementSyntax(SyntaxKind.CatchStatement, catchKeyword, identifierName, asClause, whenClause)
        End Function


        ''' <summary>
        ''' Represents the When/Filter clause of a Catch statement
        ''' </summary>
        ''' <param name="whenKeyword">
        ''' The "When" keyword
        ''' </param>
        ''' <param name="filter">
        ''' The filter expression
        ''' </param>
        Friend Shared Function CatchFilterClause(whenKeyword As KeywordSyntax, filter As ExpressionSyntax) As CatchFilterClauseSyntax
            Debug.Assert(whenKeyword IsNot Nothing AndAlso whenKeyword.Kind = SyntaxKind.WhenKeyword)
            Debug.Assert(filter IsNot Nothing)
            Return New CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, whenKeyword, filter)
        End Function


        ''' <summary>
        ''' Represents the Finally part part of a Try...Catch...Finally...End Try. This
        ''' statement is always the Begin of a FinallyPart.
        ''' </summary>
        ''' <param name="finallyKeyword">
        ''' The "Finally" keyword.
        ''' </param>
        Friend Shared Function FinallyStatement(finallyKeyword As KeywordSyntax) As FinallyStatementSyntax
            Debug.Assert(finallyKeyword IsNot Nothing AndAlso finallyKeyword.Kind = SyntaxKind.FinallyKeyword)
            Return New FinallyStatementSyntax(SyntaxKind.FinallyStatement, finallyKeyword)
        End Function


        ''' <summary>
        ''' Represents the "Error" statement.
        ''' </summary>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="errorNumber">
        ''' The expression that represents the error number.
        ''' </param>
        Friend Shared Function ErrorStatement(errorKeyword As KeywordSyntax, errorNumber As ExpressionSyntax) As ErrorStatementSyntax
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(errorNumber IsNot Nothing)
            Return New ErrorStatementSyntax(SyntaxKind.ErrorStatement, errorKeyword, errorNumber)
        End Function


        ''' <summary>
        ''' Represents an OnError Goto statement.
        ''' </summary>
        ''' <param name="onKeyword">
        ''' The "On" keyword
        ''' </param>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="goToKeyword">
        ''' The "GoTo" keyword
        ''' </param>
        ''' <param name="minus">
        ''' An optional minus for On Error Goto -1
        ''' </param>
        ''' <param name="label">
        ''' The name of the label. If the label is a line number, 0 or -1, wraps an
        ''' IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
        ''' </param>
        Friend Shared Function OnErrorGoToZeroStatement(onKeyword As KeywordSyntax, errorKeyword As KeywordSyntax, goToKeyword As KeywordSyntax, minus As PunctuationSyntax, label As LabelSyntax) As OnErrorGoToStatementSyntax
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(goToKeyword IsNot Nothing AndAlso goToKeyword.Kind = SyntaxKind.GoToKeyword)
            Debug.Assert(label IsNot Nothing)
            Return New OnErrorGoToStatementSyntax(SyntaxKind.OnErrorGoToZeroStatement, onKeyword, errorKeyword, goToKeyword, minus, label)
        End Function


        ''' <summary>
        ''' Represents an OnError Goto statement.
        ''' </summary>
        ''' <param name="onKeyword">
        ''' The "On" keyword
        ''' </param>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="goToKeyword">
        ''' The "GoTo" keyword
        ''' </param>
        ''' <param name="minus">
        ''' An optional minus for On Error Goto -1
        ''' </param>
        ''' <param name="label">
        ''' The name of the label. If the label is a line number, 0 or -1, wraps an
        ''' IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
        ''' </param>
        Friend Shared Function OnErrorGoToMinusOneStatement(onKeyword As KeywordSyntax, errorKeyword As KeywordSyntax, goToKeyword As KeywordSyntax, minus As PunctuationSyntax, label As LabelSyntax) As OnErrorGoToStatementSyntax
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(goToKeyword IsNot Nothing AndAlso goToKeyword.Kind = SyntaxKind.GoToKeyword)
            Debug.Assert(label IsNot Nothing)
            Return New OnErrorGoToStatementSyntax(SyntaxKind.OnErrorGoToMinusOneStatement, onKeyword, errorKeyword, goToKeyword, minus, label)
        End Function


        ''' <summary>
        ''' Represents an OnError Goto statement.
        ''' </summary>
        ''' <param name="onKeyword">
        ''' The "On" keyword
        ''' </param>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="goToKeyword">
        ''' The "GoTo" keyword
        ''' </param>
        ''' <param name="minus">
        ''' An optional minus for On Error Goto -1
        ''' </param>
        ''' <param name="label">
        ''' The name of the label. If the label is a line number, 0 or -1, wraps an
        ''' IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
        ''' </param>
        Friend Shared Function OnErrorGoToLabelStatement(onKeyword As KeywordSyntax, errorKeyword As KeywordSyntax, goToKeyword As KeywordSyntax, minus As PunctuationSyntax, label As LabelSyntax) As OnErrorGoToStatementSyntax
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(goToKeyword IsNot Nothing AndAlso goToKeyword.Kind = SyntaxKind.GoToKeyword)
            Debug.Assert(label IsNot Nothing)
            Return New OnErrorGoToStatementSyntax(SyntaxKind.OnErrorGoToLabelStatement, onKeyword, errorKeyword, goToKeyword, minus, label)
        End Function


        ''' <summary>
        ''' Represents an OnError Goto statement.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' OnErrorGoToStatementSyntax. One of OnErrorGoToZeroStatement,
        ''' OnErrorGoToMinusOneStatement, OnErrorGoToLabelStatement.
        ''' </param>
        ''' <param name="onKeyword">
        ''' The "On" keyword
        ''' </param>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="goToKeyword">
        ''' The "GoTo" keyword
        ''' </param>
        ''' <param name="minus">
        ''' An optional minus for On Error Goto -1
        ''' </param>
        ''' <param name="label">
        ''' The name of the label. If the label is a line number, 0 or -1, wraps an
        ''' IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
        ''' </param>
        Friend Shared Function OnErrorGoToStatement(kind As SyntaxKind, onKeyword As KeywordSyntax, errorKeyword As KeywordSyntax, goToKeyword As KeywordSyntax, minus As PunctuationSyntax, label As LabelSyntax) As OnErrorGoToStatementSyntax
            Debug.Assert(kind.IsOnErrorGoToStatement())
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(goToKeyword IsNot Nothing AndAlso goToKeyword.Kind = SyntaxKind.GoToKeyword)
            Debug.Assert(label IsNot Nothing)
            Return New OnErrorGoToStatementSyntax(kind, onKeyword, errorKeyword, goToKeyword, minus, label)
        End Function


        ''' <summary>
        ''' Represents an OnError Resume Next statement.
        ''' </summary>
        ''' <param name="onKeyword">
        ''' The "On" keyword
        ''' </param>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="resumeKeyword">
        ''' The "Resume" keyword.
        ''' </param>
        ''' <param name="nextKeyword">
        ''' The "Next"
        ''' </param>
        Friend Shared Function OnErrorResumeNextStatement(onKeyword As KeywordSyntax, errorKeyword As KeywordSyntax, resumeKeyword As KeywordSyntax, nextKeyword As KeywordSyntax) As OnErrorResumeNextStatementSyntax
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(resumeKeyword IsNot Nothing AndAlso resumeKeyword.Kind = SyntaxKind.ResumeKeyword)
            Debug.Assert(nextKeyword IsNot Nothing AndAlso nextKeyword.Kind = SyntaxKind.NextKeyword)
            Return New OnErrorResumeNextStatementSyntax(SyntaxKind.OnErrorResumeNextStatement, onKeyword, errorKeyword, resumeKeyword, nextKeyword)
        End Function


        ''' <summary>
        ''' Represents a "Resume" statement. The Kind property can be used to determine if
        ''' this is a "Resume", "Resume Next" or "Resume label" statement.
        ''' </summary>
        ''' <param name="resumeKeyword">
        ''' The "Resume" keyword.
        ''' </param>
        ''' <param name="label">
        ''' The label. The value of this depends on the Kind. If Kind=Resume, returns
        ''' Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
        ''' wraps an Identifier or IntegerLiteralToken with the label or line number.
        ''' </param>
        Friend Shared Function ResumeStatement(resumeKeyword As KeywordSyntax, label As LabelSyntax) As ResumeStatementSyntax
            Debug.Assert(resumeKeyword IsNot Nothing AndAlso resumeKeyword.Kind = SyntaxKind.ResumeKeyword)
            Return New ResumeStatementSyntax(SyntaxKind.ResumeStatement, resumeKeyword, label)
        End Function


        ''' <summary>
        ''' Represents a "Resume" statement. The Kind property can be used to determine if
        ''' this is a "Resume", "Resume Next" or "Resume label" statement.
        ''' </summary>
        ''' <param name="resumeKeyword">
        ''' The "Resume" keyword.
        ''' </param>
        ''' <param name="label">
        ''' The label. The value of this depends on the Kind. If Kind=Resume, returns
        ''' Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
        ''' wraps an Identifier or IntegerLiteralToken with the label or line number.
        ''' </param>
        Friend Shared Function ResumeLabelStatement(resumeKeyword As KeywordSyntax, label As LabelSyntax) As ResumeStatementSyntax
            Debug.Assert(resumeKeyword IsNot Nothing AndAlso resumeKeyword.Kind = SyntaxKind.ResumeKeyword)
            Return New ResumeStatementSyntax(SyntaxKind.ResumeLabelStatement, resumeKeyword, label)
        End Function


        ''' <summary>
        ''' Represents a "Resume" statement. The Kind property can be used to determine if
        ''' this is a "Resume", "Resume Next" or "Resume label" statement.
        ''' </summary>
        ''' <param name="resumeKeyword">
        ''' The "Resume" keyword.
        ''' </param>
        ''' <param name="label">
        ''' The label. The value of this depends on the Kind. If Kind=Resume, returns
        ''' Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
        ''' wraps an Identifier or IntegerLiteralToken with the label or line number.
        ''' </param>
        Friend Shared Function ResumeNextStatement(resumeKeyword As KeywordSyntax, label As LabelSyntax) As ResumeStatementSyntax
            Debug.Assert(resumeKeyword IsNot Nothing AndAlso resumeKeyword.Kind = SyntaxKind.ResumeKeyword)
            Return New ResumeStatementSyntax(SyntaxKind.ResumeNextStatement, resumeKeyword, label)
        End Function


        ''' <summary>
        ''' Represents a Select Case block, including the Select Case that begins it, the
        ''' contains Case blocks and the End Select.
        ''' </summary>
        ''' <param name="begin">
        ''' The Select Case statement that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="caseBlocks">
        ''' A list of the contained Case blocks.
        ''' </param>
        ''' <param name="end">
        ''' The End Select statement that ends the block.
        ''' </param>
        Friend Shared Function SelectBlock(begin As SelectStatementSyntax, beginTerminator As PunctuationSyntax, caseBlocks As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), [end] As EndBlockStatementSyntax) As SelectBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsSelectBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New SelectBlockSyntax(SyntaxKind.SelectBlock, begin, beginTerminator, caseBlocks.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a Select Case statement. This statement always occurs as the Begin
        ''' of a SelectBlock.
        ''' </summary>
        ''' <param name="selectKeyword">
        ''' The "Select" keyword.
        ''' </param>
        ''' <param name="caseKeyword">
        ''' The "Case" keyword, if present.
        ''' </param>
        ''' <param name="expression">
        ''' The value that branching is based on.
        ''' </param>
        Friend Shared Function SelectStatement(selectKeyword As KeywordSyntax, caseKeyword As KeywordSyntax, expression As ExpressionSyntax) As SelectStatementSyntax
            Debug.Assert(selectKeyword IsNot Nothing AndAlso selectKeyword.Kind = SyntaxKind.SelectKeyword)
            Debug.Assert(expression IsNot Nothing)
            Return New SelectStatementSyntax(SyntaxKind.SelectStatement, selectKeyword, caseKeyword, expression)
        End Function


        ''' <summary>
        ''' Represents a case statement and its subsequent block.
        ''' </summary>
        ''' <param name="begin">
        ''' The statement that begins the case block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the case block. This might be an empty list.
        ''' </param>
        Friend Shared Function CaseBlock(begin As CaseStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax)) As CaseBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsCaseBlockBeginTerminator)
            Return New CaseBlockSyntax(SyntaxKind.CaseBlock, begin, beginTerminator, statements.Node)
        End Function


        ''' <summary>
        ''' Represents a case statement and its subsequent block.
        ''' </summary>
        ''' <param name="begin">
        ''' The statement that begins the case block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the case block. This might be an empty list.
        ''' </param>
        Friend Shared Function CaseElseBlock(begin As CaseStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax)) As CaseBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsCaseBlockBeginTerminator)
            Return New CaseBlockSyntax(SyntaxKind.CaseElseBlock, begin, beginTerminator, statements.Node)
        End Function


        ''' <summary>
        ''' Represents a Case or Case Else statement. This statement is always the Begin of
        ''' a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
        ''' Kind=Case.
        ''' </summary>
        ''' <param name="caseKeyword">
        ''' The "Case" keyword
        ''' </param>
        ''' <param name="cases">
        ''' A list of clauses associated with this Case. If Kind=CaseElse, then this list
        ''' has exactly one child, which is a CaseElseClause.
        ''' </param>
        Friend Shared Function CaseStatement(caseKeyword As KeywordSyntax, cases As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.CaseClauseSyntax)) As CaseStatementSyntax
            Debug.Assert(caseKeyword IsNot Nothing AndAlso caseKeyword.Kind = SyntaxKind.CaseKeyword)
            Return New CaseStatementSyntax(SyntaxKind.CaseStatement, caseKeyword, cases.Node)
        End Function


        ''' <summary>
        ''' Represents a Case or Case Else statement. This statement is always the Begin of
        ''' a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
        ''' Kind=Case.
        ''' </summary>
        ''' <param name="caseKeyword">
        ''' The "Case" keyword
        ''' </param>
        ''' <param name="cases">
        ''' A list of clauses associated with this Case. If Kind=CaseElse, then this list
        ''' has exactly one child, which is a CaseElseClause.
        ''' </param>
        Friend Shared Function CaseElseStatement(caseKeyword As KeywordSyntax, cases As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.CaseClauseSyntax)) As CaseStatementSyntax
            Debug.Assert(caseKeyword IsNot Nothing AndAlso caseKeyword.Kind = SyntaxKind.CaseKeyword)
            Return New CaseStatementSyntax(SyntaxKind.CaseElseStatement, caseKeyword, cases.Node)
        End Function


        ''' <summary>
        ''' The "Else" part in a Case Else statement.
        ''' </summary>
        ''' <param name="elseKeyword">
        ''' The "Else" keyword.
        ''' </param>
        Friend Shared Function CaseElseClause(elseKeyword As KeywordSyntax) As CaseElseClauseSyntax
            Debug.Assert(elseKeyword IsNot Nothing AndAlso elseKeyword.Kind = SyntaxKind.ElseKeyword)
            Return New CaseElseClauseSyntax(SyntaxKind.CaseElseClause, elseKeyword)
        End Function


        ''' <summary>
        ''' Represents a single value in a Case.
        ''' </summary>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function CaseValueClause(value As ExpressionSyntax) As CaseValueClauseSyntax
            Debug.Assert(value IsNot Nothing)
            Return New CaseValueClauseSyntax(SyntaxKind.CaseValueClause, value)
        End Function


        ''' <summary>
        ''' Represents a range "expression To expression" in a Case.
        ''' </summary>
        ''' <param name="lowerBound">
        ''' The lower bound of the range.
        ''' </param>
        ''' <param name="toKeyword">
        ''' The "To" keyword
        ''' </param>
        ''' <param name="upperBound">
        ''' The upper bound of the range.
        ''' </param>
        Friend Shared Function CaseRangeClause(lowerBound As ExpressionSyntax, toKeyword As KeywordSyntax, upperBound As ExpressionSyntax) As CaseRangeClauseSyntax
            Debug.Assert(lowerBound IsNot Nothing)
            Debug.Assert(toKeyword IsNot Nothing AndAlso toKeyword.Kind = SyntaxKind.ToKeyword)
            Debug.Assert(upperBound IsNot Nothing)
            Return New CaseRangeClauseSyntax(SyntaxKind.CaseRangeClause, lowerBound, toKeyword, upperBound)
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function CaseEqualsClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As CaseRelationalClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(value IsNot Nothing)
            Return New CaseRelationalClauseSyntax(SyntaxKind.CaseEqualsClause, isKeyword, operatorToken, value)
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function CaseNotEqualsClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As CaseRelationalClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanGreaterThanToken)
            Debug.Assert(value IsNot Nothing)
            Return New CaseRelationalClauseSyntax(SyntaxKind.CaseNotEqualsClause, isKeyword, operatorToken, value)
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function CaseLessThanClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As CaseRelationalClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(value IsNot Nothing)
            Return New CaseRelationalClauseSyntax(SyntaxKind.CaseLessThanClause, isKeyword, operatorToken, value)
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function CaseLessThanOrEqualClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As CaseRelationalClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanEqualsToken)
            Debug.Assert(value IsNot Nothing)
            Return New CaseRelationalClauseSyntax(SyntaxKind.CaseLessThanOrEqualClause, isKeyword, operatorToken, value)
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function CaseGreaterThanOrEqualClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As CaseRelationalClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanEqualsToken)
            Debug.Assert(value IsNot Nothing)
            Return New CaseRelationalClauseSyntax(SyntaxKind.CaseGreaterThanOrEqualClause, isKeyword, operatorToken, value)
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function CaseGreaterThanClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As CaseRelationalClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanToken)
            Debug.Assert(value IsNot Nothing)
            Return New CaseRelationalClauseSyntax(SyntaxKind.CaseGreaterThanClause, isKeyword, operatorToken, value)
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' CaseRelationalClauseSyntax. One of CaseEqualsClause, CaseNotEqualsClause,
        ''' CaseLessThanClause, CaseLessThanOrEqualClause, CaseGreaterThanOrEqualClause,
        ''' CaseGreaterThanClause.
        ''' </param>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function CaseRelationalClause(kind As SyntaxKind, isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As CaseRelationalClauseSyntax
            Debug.Assert(kind.IsCaseRelationalClause())
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsCaseRelationalClauseOperatorToken)
            Debug.Assert(value IsNot Nothing)
            Return New CaseRelationalClauseSyntax(kind, isKeyword, operatorToken, value)
        End Function


        ''' <summary>
        ''' Represents the "SyncLock" statement. This statement always occurs as the Begin
        ''' of a SyncLockBlock.
        ''' </summary>
        ''' <param name="syncLockKeyword">
        ''' The "SyncLock" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being synchronized on.
        ''' </param>
        Friend Shared Function SyncLockStatement(syncLockKeyword As KeywordSyntax, expression As ExpressionSyntax) As SyncLockStatementSyntax
            Debug.Assert(syncLockKeyword IsNot Nothing AndAlso syncLockKeyword.Kind = SyntaxKind.SyncLockKeyword)
            Debug.Assert(expression IsNot Nothing)
            Return New SyncLockStatementSyntax(SyntaxKind.SyncLockStatement, syncLockKeyword, expression)
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a top-test, bottom-test or infinite loop.
        ''' </summary>
        ''' <param name="begin">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Shared Function DoLoopTopTestBlock(begin As DoStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsDoLoopBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New DoLoopBlockSyntax(SyntaxKind.DoLoopTopTestBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a top-test, bottom-test or infinite loop.
        ''' </summary>
        ''' <param name="begin">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Shared Function DoLoopBottomTestBlock(begin As DoStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsDoLoopBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New DoLoopBlockSyntax(SyntaxKind.DoLoopBottomTestBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a top-test, bottom-test or infinite loop.
        ''' </summary>
        ''' <param name="begin">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Shared Function DoLoopForeverBlock(begin As DoStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsDoLoopBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New DoLoopBlockSyntax(SyntaxKind.DoLoopForeverBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a top-test, bottom-test or infinite loop.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of DoLoopBlockSyntax.
        ''' One of DoLoopTopTestBlock, DoLoopBottomTestBlock, DoLoopForeverBlock.
        ''' </param>
        ''' <param name="begin">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Shared Function DoLoopBlock(kind As SyntaxKind, begin As DoStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(kind.IsDoLoopBlock())
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsDoLoopBlockBeginTerminator)
            Debug.Assert([end] IsNot Nothing)
            Return New DoLoopBlockSyntax(kind, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' The Do statement that begins a Do-Loop block. This statement always occurs as
        ''' the Begin of a DoLoopBlock.
        ''' </summary>
        ''' <param name="doKeyword">
        ''' The "Do" keyword.
        ''' </param>
        ''' <param name="whileUntilClause">
        ''' The "While expression" or "Until expression" part of the Do statement, if
        ''' present.
        ''' </param>
        Friend Shared Function DoStatement(doKeyword As KeywordSyntax, whileUntilClause As WhileUntilClauseSyntax) As DoStatementSyntax
            Debug.Assert(doKeyword IsNot Nothing AndAlso doKeyword.Kind = SyntaxKind.DoKeyword)
            Return New DoStatementSyntax(SyntaxKind.DoStatement, doKeyword, whileUntilClause)
        End Function


        ''' <summary>
        ''' The Loop statement that ends a Do-Loop block. This statement always occurs as
        ''' the End of a DoLoopBlock.
        ''' </summary>
        ''' <param name="loopKeyword">
        ''' The "Loop" keyword.
        ''' </param>
        ''' <param name="whileUntilClause">
        ''' The "While expression" or "Until expression" part of the Loop statement, if
        ''' present.
        ''' </param>
        Friend Shared Function LoopStatement(loopKeyword As KeywordSyntax, whileUntilClause As WhileUntilClauseSyntax) As LoopStatementSyntax
            Debug.Assert(loopKeyword IsNot Nothing AndAlso loopKeyword.Kind = SyntaxKind.LoopKeyword)
            Return New LoopStatementSyntax(SyntaxKind.LoopStatement, loopKeyword, whileUntilClause)
        End Function


        ''' <summary>
        ''' Represents a "While expression" or "Until expression" in a Do or Loop
        ''' statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
        ''' indicate which kind of clause.
        ''' </summary>
        ''' <param name="whileOrUntilKeyword">
        ''' The "While" or "Until" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression after the While or Until.
        ''' </param>
        Friend Shared Function WhileClause(whileOrUntilKeyword As KeywordSyntax, condition As ExpressionSyntax) As WhileUntilClauseSyntax
            Debug.Assert(whileOrUntilKeyword IsNot Nothing AndAlso whileOrUntilKeyword.Kind = SyntaxKind.WhileKeyword)
            Debug.Assert(condition IsNot Nothing)
            Return New WhileUntilClauseSyntax(SyntaxKind.WhileClause, whileOrUntilKeyword, condition)
        End Function


        ''' <summary>
        ''' Represents a "While expression" or "Until expression" in a Do or Loop
        ''' statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
        ''' indicate which kind of clause.
        ''' </summary>
        ''' <param name="whileOrUntilKeyword">
        ''' The "While" or "Until" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression after the While or Until.
        ''' </param>
        Friend Shared Function UntilClause(whileOrUntilKeyword As KeywordSyntax, condition As ExpressionSyntax) As WhileUntilClauseSyntax
            Debug.Assert(whileOrUntilKeyword IsNot Nothing AndAlso whileOrUntilKeyword.Kind = SyntaxKind.UntilKeyword)
            Debug.Assert(condition IsNot Nothing)
            Return New WhileUntilClauseSyntax(SyntaxKind.UntilClause, whileOrUntilKeyword, condition)
        End Function


        ''' <summary>
        ''' Represents a "While expression" or "Until expression" in a Do or Loop
        ''' statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
        ''' indicate which kind of clause.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' WhileUntilClauseSyntax. One of WhileClause, UntilClause.
        ''' </param>
        ''' <param name="whileOrUntilKeyword">
        ''' The "While" or "Until" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression after the While or Until.
        ''' </param>
        Friend Shared Function WhileUntilClause(kind As SyntaxKind, whileOrUntilKeyword As KeywordSyntax, condition As ExpressionSyntax) As WhileUntilClauseSyntax
            Debug.Assert(kind.IsWhileUntilClause())
            Debug.Assert(whileOrUntilKeyword IsNot Nothing AndAlso whileOrUntilKeyword.Kind.IsWhileUntilClauseWhileOrUntilKeyword)
            Debug.Assert(condition IsNot Nothing)
            Return New WhileUntilClauseSyntax(kind, whileOrUntilKeyword, condition)
        End Function


        ''' <summary>
        ''' The While statement that begins a While...End While block. This statement
        ''' always occurs as the Begin of a WhileBlock.
        ''' </summary>
        ''' <param name="whileKeyword">
        ''' The "While" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression that controls the While loop.
        ''' </param>
        Friend Shared Function WhileStatement(whileKeyword As KeywordSyntax, condition As ExpressionSyntax) As WhileStatementSyntax
            Debug.Assert(whileKeyword IsNot Nothing AndAlso whileKeyword.Kind = SyntaxKind.WhileKeyword)
            Debug.Assert(condition IsNot Nothing)
            Return New WhileStatementSyntax(SyntaxKind.WhileStatement, whileKeyword, condition)
        End Function


        ''' <summary>
        ''' Represents a For or For Each block, including the introducting statement, the
        ''' body and the "Next" (which can be omitted if a containing For has a Next with
        ''' multiple variables).
        ''' </summary>
        ''' <param name="begin">
        ''' The For or For Each statement that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the For or For Each loop. This might be an empty
        ''' list.
        ''' </param>
        ''' <param name="end">
        ''' The Next statement that ends the block. If two For statements are ended by a
        ''' single Next statement, the inner For will not have an EndStatment.
        ''' </param>
        Friend Shared Function ForBlock(begin As ExecutableStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As NextStatementSyntax) As ForBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsForBlockBeginTerminator)
            Return New ForBlockSyntax(SyntaxKind.ForBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a For or For Each block, including the introducting statement, the
        ''' body and the "Next" (which can be omitted if a containing For has a Next with
        ''' multiple variables).
        ''' </summary>
        ''' <param name="begin">
        ''' The For or For Each statement that begins the block.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the For or For Each loop. This might be an empty
        ''' list.
        ''' </param>
        ''' <param name="end">
        ''' The Next statement that ends the block. If two For statements are ended by a
        ''' single Next statement, the inner For will not have an EndStatment.
        ''' </param>
        Friend Shared Function ForEachBlock(begin As ExecutableStatementSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As NextStatementSyntax) As ForBlockSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(beginTerminator IsNot Nothing AndAlso beginTerminator.Kind.IsForBlockBeginTerminator)
            Return New ForBlockSyntax(SyntaxKind.ForEachBlock, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' The For statement that begins a For-Next block. This statement always occurs as
        ''' the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
        ''' corresponding Next statement. However, multiple nested For statements are ended
        ''' by a single Next statement with multiple variables, then the inner For
        ''' statements will have End set to Nothing, and the Next statement is the End of
        ''' the outermost For statement that is being ended.
        ''' </summary>
        ''' <param name="forKeyword">
        ''' The "For" keyword.
        ''' </param>
        ''' <param name="controlVariable">
        ''' If the For or For Each statement is of a form that does not declare a new loop
        ''' control variable, this is the expression that denotes the loop control
        ''' variable. If this loop is of a form that does declare a new control variable,
        ''' this is a VariableDeclarator that has the variable being declared.
        ''' </param>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        ''' <param name="fromValue">
        ''' The expression denoting the initial value of the iteration.
        ''' </param>
        ''' <param name="toKeyword">
        ''' The "To" keyword.
        ''' </param>
        ''' <param name="toValue">
        ''' The expression denoting the final value of the iteration.
        ''' </param>
        ''' <param name="stepClause">
        ''' The optional Step clause.
        ''' </param>
        Friend Shared Function ForStatement(forKeyword As KeywordSyntax, controlVariable As SyntaxNode, equalsToken As PunctuationSyntax, fromValue As ExpressionSyntax, toKeyword As KeywordSyntax, toValue As ExpressionSyntax, stepClause As ForStepClauseSyntax) As ForStatementSyntax
            Debug.Assert(forKeyword IsNot Nothing AndAlso forKeyword.Kind = SyntaxKind.ForKeyword)
            Debug.Assert(controlVariable IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(fromValue IsNot Nothing)
            Debug.Assert(toKeyword IsNot Nothing AndAlso toKeyword.Kind = SyntaxKind.ToKeyword)
            Debug.Assert(toValue IsNot Nothing)
            Return New ForStatementSyntax(SyntaxKind.ForStatement, forKeyword, controlVariable, equalsToken, fromValue, toKeyword, toValue, stepClause)
        End Function


        ''' <summary>
        ''' The Step clause in a For Statement.
        ''' </summary>
        ''' <param name="stepKeyword">
        ''' The "Step" keyword.
        ''' </param>
        ''' <param name="stepValue">
        ''' The expression denoting the step increment.
        ''' </param>
        Friend Shared Function ForStepClause(stepKeyword As KeywordSyntax, stepValue As ExpressionSyntax) As ForStepClauseSyntax
            Debug.Assert(stepKeyword IsNot Nothing AndAlso stepKeyword.Kind = SyntaxKind.StepKeyword)
            Debug.Assert(stepValue IsNot Nothing)
            Return New ForStepClauseSyntax(SyntaxKind.ForStepClause, stepKeyword, stepValue)
        End Function


        ''' <summary>
        ''' The For Each statement that begins a For Each-Next block. This statement always
        ''' occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
        ''' Body of that ForBlock. Most of the time, the End of that ForBlock is the
        ''' corresponding Next statement. However, multiple nested For statements are ended
        ''' by a single Next statement with multiple variables, then the inner For
        ''' statements will have End set to Nothing, and the Next statement is the End of
        ''' the outermost For statement that is being ended.
        ''' </summary>
        ''' <param name="forKeyword">
        ''' The "For" keyword.
        ''' </param>
        ''' <param name="eachKeyword">
        ''' The "Each" keyword.
        ''' </param>
        ''' <param name="controlVariable">
        ''' If the For or For Each statement is of a form that does not declare a new loop
        ''' control variable, this is the expression that denotes the loop control
        ''' variable. If this loop is of a form that does declare a new control variable,
        ''' this is a VariableDeclarator that has the variable being declared.
        ''' </param>
        ''' <param name="inKeyword">
        ''' The "In" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression denoting the collection to iterate over.
        ''' </param>
        Friend Shared Function ForEachStatement(forKeyword As KeywordSyntax, eachKeyword As KeywordSyntax, controlVariable As SyntaxNode, inKeyword As KeywordSyntax, expression As ExpressionSyntax) As ForEachStatementSyntax
            Debug.Assert(forKeyword IsNot Nothing AndAlso forKeyword.Kind = SyntaxKind.ForKeyword)
            Debug.Assert(eachKeyword IsNot Nothing AndAlso eachKeyword.Kind = SyntaxKind.EachKeyword)
            Debug.Assert(controlVariable IsNot Nothing)
            Debug.Assert(inKeyword IsNot Nothing AndAlso inKeyword.Kind = SyntaxKind.InKeyword)
            Debug.Assert(expression IsNot Nothing)
            Return New ForEachStatementSyntax(SyntaxKind.ForEachStatement, forKeyword, eachKeyword, controlVariable, inKeyword, expression)
        End Function


        ''' <summary>
        ''' The Next statement that ends a For-Next or For Each-Next block. This statement
        ''' always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
        ''' and the body of the For-Next is the Body of that ForBlock. The Begin of that
        ''' ForBlock has the corresponding For or For Each statement.
        ''' </summary>
        ''' <param name="nextKeyword">
        ''' The "Next" keyword.
        ''' </param>
        ''' <param name="controlVariables">
        ''' The variables in the Next statement, if present
        ''' </param>
        Friend Shared Function NextStatement(nextKeyword As KeywordSyntax, controlVariables As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ExpressionSyntax)) As NextStatementSyntax
            Debug.Assert(nextKeyword IsNot Nothing AndAlso nextKeyword.Kind = SyntaxKind.NextKeyword)
            Return New NextStatementSyntax(SyntaxKind.NextStatement, nextKeyword, controlVariables.Node)
        End Function


        ''' <summary>
        ''' The Using statement that begins a Using block. This statement always occurs as
        ''' the Begin of a UsingBlock, and the body of the Using is the Body of that
        ''' UsingBlock.
        ''' </summary>
        ''' <param name="usingKeyword">
        ''' The "Using" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' If the Using statement is of a form that does not declare a new variable, this
        ''' is the expression used in the using. Otherwise, Nothing is returned.
        ''' </param>
        ''' <param name="variables">
        ''' If the Using statement is of a form that declares one or more new variables,
        ''' this is the list of variable declarations. Otherwise, Nothing is returned.
        ''' </param>
        Friend Shared Function UsingStatement(usingKeyword As KeywordSyntax, expression As ExpressionSyntax, variables As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.VariableDeclaratorSyntax)) As UsingStatementSyntax
            Debug.Assert(usingKeyword IsNot Nothing AndAlso usingKeyword.Kind = SyntaxKind.UsingKeyword)
            Return New UsingStatementSyntax(SyntaxKind.UsingStatement, usingKeyword, expression, variables.Node)
        End Function


        ''' <summary>
        ''' Represents a Throw statement.
        ''' </summary>
        ''' <param name="throwKeyword">
        ''' The "Throw" keyword
        ''' </param>
        ''' <param name="expression">
        ''' The expression denoting the value being thrown.
        ''' </param>
        Friend Shared Function ThrowStatement(throwKeyword As KeywordSyntax, expression As ExpressionSyntax) As ThrowStatementSyntax
            Debug.Assert(throwKeyword IsNot Nothing AndAlso throwKeyword.Kind = SyntaxKind.ThrowKeyword)
            Return New ThrowStatementSyntax(SyntaxKind.ThrowStatement, throwKeyword, expression)
        End Function


        ''' <summary>
        ''' Represents an assignment or compound assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function AssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsAssignmentStatementOperatorToken)
            Debug.Assert(right IsNot Nothing)
            Return New AssignmentStatementSyntax(SyntaxKind.AssignmentStatement, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents an assignment or compound assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function MidAssignment(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsAssignmentStatementOperatorToken)
            Debug.Assert(right IsNot Nothing)
            Return New AssignmentStatementSyntax(SyntaxKind.MidAssignment, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents an assignment or compound assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function AddAssignment(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsAssignmentStatementOperatorToken)
            Debug.Assert(right IsNot Nothing)
            Return New AssignmentStatementSyntax(SyntaxKind.AddAssignment, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents an assignment or compound assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function SubtractAssignment(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsAssignmentStatementOperatorToken)
            Debug.Assert(right IsNot Nothing)
            Return New AssignmentStatementSyntax(SyntaxKind.SubtractAssignment, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents an assignment or compound assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function MultiplyAssignment(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsAssignmentStatementOperatorToken)
            Debug.Assert(right IsNot Nothing)
            Return New AssignmentStatementSyntax(SyntaxKind.MultiplyAssignment, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents an assignment or compound assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function DivideAssignment(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsAssignmentStatementOperatorToken)
            Debug.Assert(right IsNot Nothing)
            Return New AssignmentStatementSyntax(SyntaxKind.DivideAssignment, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents an assignment or compound assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function IntegerDivideAssignment(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsAssignmentStatementOperatorToken)
            Debug.Assert(right IsNot Nothing)
            Return New AssignmentStatementSyntax(SyntaxKind.IntegerDivideAssignment, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents an assignment or compound assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function PowerAssignment(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsAssignmentStatementOperatorToken)
            Debug.Assert(right IsNot Nothing)
            Return New AssignmentStatementSyntax(SyntaxKind.PowerAssignment, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents an assignment or compound assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function LeftShiftAssignment(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsAssignmentStatementOperatorToken)
            Debug.Assert(right IsNot Nothing)
            Return New AssignmentStatementSyntax(SyntaxKind.LeftShiftAssignment, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents an assignment or compound assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function RightShiftAssignment(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsAssignmentStatementOperatorToken)
            Debug.Assert(right IsNot Nothing)
            Return New AssignmentStatementSyntax(SyntaxKind.RightShiftAssignment, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents an assignment or compound assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function ConcatenateAssignment(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsAssignmentStatementOperatorToken)
            Debug.Assert(right IsNot Nothing)
            Return New AssignmentStatementSyntax(SyntaxKind.ConcatenateAssignment, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represent an call statement (also known as a invocation statement).
        ''' </summary>
        ''' <param name="callKeyword">
        ''' The "Call" keyword, if present.
        ''' </param>
        ''' <param name="invocation">
        ''' The expression denoting the call. This could be an Invocation or a MemberAccess
        ''' (in the case where no parentheses were supplied.)
        ''' </param>
        Friend Shared Function CallStatement(callKeyword As KeywordSyntax, invocation As ExpressionSyntax) As CallStatementSyntax
            Debug.Assert(invocation IsNot Nothing)
            Return New CallStatementSyntax(SyntaxKind.CallStatement, callKeyword, invocation)
        End Function


        ''' <summary>
        ''' Represents an AddHandler or RemoveHandler statement. The Kind property
        ''' determines which one.
        ''' </summary>
        ''' <param name="addHandlerOrRemoveHandlerKeyword">
        ''' The "AddHandler" or "RemoveHandler" keyword.
        ''' </param>
        ''' <param name="eventExpression">
        ''' The event being accessed.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="delegateExpression">
        ''' The delegate being added or removed.
        ''' </param>
        Friend Shared Function AddHandlerStatement(addHandlerOrRemoveHandlerKeyword As KeywordSyntax, eventExpression As ExpressionSyntax, commaToken As PunctuationSyntax, delegateExpression As ExpressionSyntax) As AddRemoveHandlerStatementSyntax
            Debug.Assert(addHandlerOrRemoveHandlerKeyword IsNot Nothing AndAlso addHandlerOrRemoveHandlerKeyword.Kind = SyntaxKind.AddHandlerKeyword)
            Debug.Assert(eventExpression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(delegateExpression IsNot Nothing)
            Return New AddRemoveHandlerStatementSyntax(SyntaxKind.AddHandlerStatement, addHandlerOrRemoveHandlerKeyword, eventExpression, commaToken, delegateExpression)
        End Function


        ''' <summary>
        ''' Represents an AddHandler or RemoveHandler statement. The Kind property
        ''' determines which one.
        ''' </summary>
        ''' <param name="addHandlerOrRemoveHandlerKeyword">
        ''' The "AddHandler" or "RemoveHandler" keyword.
        ''' </param>
        ''' <param name="eventExpression">
        ''' The event being accessed.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="delegateExpression">
        ''' The delegate being added or removed.
        ''' </param>
        Friend Shared Function RemoveHandlerStatement(addHandlerOrRemoveHandlerKeyword As KeywordSyntax, eventExpression As ExpressionSyntax, commaToken As PunctuationSyntax, delegateExpression As ExpressionSyntax) As AddRemoveHandlerStatementSyntax
            Debug.Assert(addHandlerOrRemoveHandlerKeyword IsNot Nothing AndAlso addHandlerOrRemoveHandlerKeyword.Kind = SyntaxKind.RemoveHandlerKeyword)
            Debug.Assert(eventExpression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(delegateExpression IsNot Nothing)
            Return New AddRemoveHandlerStatementSyntax(SyntaxKind.RemoveHandlerStatement, addHandlerOrRemoveHandlerKeyword, eventExpression, commaToken, delegateExpression)
        End Function


        ''' <summary>
        ''' Represents an AddHandler or RemoveHandler statement. The Kind property
        ''' determines which one.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' AddRemoveHandlerStatementSyntax. One of AddHandlerStatement,
        ''' RemoveHandlerStatement.
        ''' </param>
        ''' <param name="addHandlerOrRemoveHandlerKeyword">
        ''' The "AddHandler" or "RemoveHandler" keyword.
        ''' </param>
        ''' <param name="eventExpression">
        ''' The event being accessed.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="delegateExpression">
        ''' The delegate being added or removed.
        ''' </param>
        Friend Shared Function AddRemoveHandlerStatement(kind As SyntaxKind, addHandlerOrRemoveHandlerKeyword As KeywordSyntax, eventExpression As ExpressionSyntax, commaToken As PunctuationSyntax, delegateExpression As ExpressionSyntax) As AddRemoveHandlerStatementSyntax
            Debug.Assert(kind.IsAddRemoveHandlerStatement())
            Debug.Assert(addHandlerOrRemoveHandlerKeyword IsNot Nothing AndAlso addHandlerOrRemoveHandlerKeyword.Kind.IsAddRemoveHandlerStatementAddHandlerOrRemoveHandlerKeyword)
            Debug.Assert(eventExpression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(delegateExpression IsNot Nothing)
            Return New AddRemoveHandlerStatementSyntax(kind, addHandlerOrRemoveHandlerKeyword, eventExpression, commaToken, delegateExpression)
        End Function


        ''' <summary>
        ''' Represent a RaiseEvent statement.
        ''' </summary>
        ''' <param name="raiseEventKeyword">
        ''' The "RaiseEvent" keyword
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the event being raised.
        ''' </param>
        ''' <param name="argumentList">
        ''' The argument list, if present.
        ''' </param>
        Friend Shared Function RaiseEventStatement(raiseEventKeyword As KeywordSyntax, identifier As IdentifierNameSyntax, argumentList As ArgumentListSyntax) As RaiseEventStatementSyntax
            Debug.Assert(raiseEventKeyword IsNot Nothing AndAlso raiseEventKeyword.Kind = SyntaxKind.RaiseEventKeyword)
            Debug.Assert(identifier IsNot Nothing)
            Return New RaiseEventStatementSyntax(SyntaxKind.RaiseEventStatement, raiseEventKeyword, identifier, argumentList)
        End Function


        ''' <summary>
        ''' Represents a "With" statement. This statement always occurs as the
        ''' BeginStatement of a WithBlock, and the body of the With is the Body of that
        ''' WithBlock.
        ''' </summary>
        ''' <param name="withKeyword">
        ''' The "With" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression that is the operand of the With statement.
        ''' </param>
        Friend Shared Function WithStatement(withKeyword As KeywordSyntax, expression As ExpressionSyntax) As WithStatementSyntax
            Debug.Assert(withKeyword IsNot Nothing AndAlso withKeyword.Kind = SyntaxKind.WithKeyword)
            Debug.Assert(expression IsNot Nothing)
            Return New WithStatementSyntax(SyntaxKind.WithStatement, withKeyword, expression)
        End Function


        ''' <summary>
        ''' Represents a ReDim statement.
        ''' </summary>
        ''' <param name="reDimKeyword">
        ''' The "ReDim" keyword.
        ''' </param>
        ''' <param name="preserveKeyword">
        ''' Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
        ''' Kind=RedimPreserve.
        ''' </param>
        ''' <param name="clauses">
        ''' The list of ReDim clauses. Each clause is a Invocation node with an argument
        ''' list denoting the new bounds for the array.
        ''' </param>
        Friend Shared Function ReDimStatement(reDimKeyword As KeywordSyntax, preserveKeyword As KeywordSyntax, clauses As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.InvocationExpressionSyntax)) As ReDimStatementSyntax
            Debug.Assert(reDimKeyword IsNot Nothing AndAlso reDimKeyword.Kind = SyntaxKind.ReDimKeyword)
            Return New ReDimStatementSyntax(SyntaxKind.ReDimStatement, reDimKeyword, preserveKeyword, clauses.Node)
        End Function


        ''' <summary>
        ''' Represents a ReDim statement.
        ''' </summary>
        ''' <param name="reDimKeyword">
        ''' The "ReDim" keyword.
        ''' </param>
        ''' <param name="preserveKeyword">
        ''' Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
        ''' Kind=RedimPreserve.
        ''' </param>
        ''' <param name="clauses">
        ''' The list of ReDim clauses. Each clause is a Invocation node with an argument
        ''' list denoting the new bounds for the array.
        ''' </param>
        Friend Shared Function ReDimPreserveStatement(reDimKeyword As KeywordSyntax, preserveKeyword As KeywordSyntax, clauses As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.InvocationExpressionSyntax)) As ReDimStatementSyntax
            Debug.Assert(reDimKeyword IsNot Nothing AndAlso reDimKeyword.Kind = SyntaxKind.ReDimKeyword)
            Return New ReDimStatementSyntax(SyntaxKind.ReDimPreserveStatement, reDimKeyword, preserveKeyword, clauses.Node)
        End Function


        ''' <summary>
        ''' Represents an "Erase" statement.
        ''' </summary>
        ''' <param name="eraseKeyword">
        ''' The "Erase" keyword.
        ''' </param>
        ''' <param name="expressions">
        ''' A list of expressions denoting the arrays to erase.
        ''' </param>
        Friend Shared Function EraseStatement(eraseKeyword As KeywordSyntax, expressions As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ExpressionSyntax)) As EraseStatementSyntax
            Debug.Assert(eraseKeyword IsNot Nothing AndAlso eraseKeyword.Kind = SyntaxKind.EraseKeyword)
            Return New EraseStatementSyntax(SyntaxKind.EraseStatement, eraseKeyword, expressions.Node)
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function CharacterLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso token.Kind.IsLiteralExpressionToken)
            Return New LiteralExpressionSyntax(SyntaxKind.CharacterLiteralExpression, token)
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function TrueLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso token.Kind.IsLiteralExpressionToken)
            Return New LiteralExpressionSyntax(SyntaxKind.TrueLiteralExpression, token)
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function FalseLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso token.Kind.IsLiteralExpressionToken)
            Return New LiteralExpressionSyntax(SyntaxKind.FalseLiteralExpression, token)
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function NumericLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso token.Kind.IsLiteralExpressionToken)
            Return New LiteralExpressionSyntax(SyntaxKind.NumericLiteralExpression, token)
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function DateLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso token.Kind.IsLiteralExpressionToken)
            Return New LiteralExpressionSyntax(SyntaxKind.DateLiteralExpression, token)
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function StringLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso token.Kind.IsLiteralExpressionToken)
            Return New LiteralExpressionSyntax(SyntaxKind.StringLiteralExpression, token)
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function NothingLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso token.Kind.IsLiteralExpressionToken)
            Return New LiteralExpressionSyntax(SyntaxKind.NothingLiteralExpression, token)
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' LiteralExpressionSyntax. One of CharacterLiteralExpression,
        ''' TrueLiteralExpression, FalseLiteralExpression, NumericLiteralExpression,
        ''' DateLiteralExpression, StringLiteralExpression, NothingLiteralExpression.
        ''' </param>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function LiteralExpression(kind As SyntaxKind, token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(kind.IsLiteralExpression())
            Debug.Assert(token IsNot Nothing AndAlso token.Kind.IsLiteralExpressionToken)
            Return New LiteralExpressionSyntax(kind, token)
        End Function


        ''' <summary>
        ''' Represents a parenthesized expression.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token
        ''' </param>
        ''' <param name="expression">
        ''' The expression inside the parentheses.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token
        ''' </param>
        Friend Shared Function ParenthesizedExpression(openParenToken As PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As PunctuationSyntax) As ParenthesizedExpressionSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken)
        End Function


        ''' <summary>
        ''' Identifies the special instance "Me"
        ''' </summary>
        ''' <param name="keyword">
        ''' The "Me", "MyClass" or "MyBase" keyword.
        ''' </param>
        Friend Shared Function MeExpression(keyword As KeywordSyntax) As MeExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.MeKeyword)
            Return New MeExpressionSyntax(SyntaxKind.MeExpression, keyword)
        End Function


        ''' <summary>
        ''' Identifies the special instance "MyBase"
        ''' </summary>
        ''' <param name="keyword">
        ''' The "Me", "MyClass" or "MyBase" keyword.
        ''' </param>
        Friend Shared Function MyBaseExpression(keyword As KeywordSyntax) As MyBaseExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.MyBaseKeyword)
            Return New MyBaseExpressionSyntax(SyntaxKind.MyBaseExpression, keyword)
        End Function


        ''' <summary>
        ''' Identifies the special instance "MyClass"
        ''' </summary>
        ''' <param name="keyword">
        ''' The "Me", "MyClass" or "MyBase" keyword.
        ''' </param>
        Friend Shared Function MyClassExpression(keyword As KeywordSyntax) As MyClassExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.MyClassKeyword)
            Return New MyClassExpressionSyntax(SyntaxKind.MyClassExpression, keyword)
        End Function


        ''' <summary>
        ''' Represents a GetType expression.
        ''' </summary>
        ''' <param name="getTypeKeyword">
        ''' The "GetType" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="type">
        ''' The type to get the Type object for. This can be an open generic type.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function GetTypeExpression(getTypeKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, type As TypeSyntax, closeParenToken As PunctuationSyntax) As GetTypeExpressionSyntax
            Debug.Assert(getTypeKeyword IsNot Nothing AndAlso getTypeKeyword.Kind = SyntaxKind.GetTypeKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(type IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New GetTypeExpressionSyntax(SyntaxKind.GetTypeExpression, getTypeKeyword, openParenToken, type, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents a TypeOf...Is or IsNot expression.
        ''' </summary>
        ''' <param name="typeOfKeyword">
        ''' The "TypeOf" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being tested.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "Is" or "IsNot" keyword.
        ''' </param>
        ''' <param name="type">
        ''' The name of the type being tested against.
        ''' </param>
        Friend Shared Function TypeOfIsExpression(typeOfKeyword As KeywordSyntax, expression As ExpressionSyntax, operatorToken As KeywordSyntax, type As TypeSyntax) As TypeOfExpressionSyntax
            Debug.Assert(typeOfKeyword IsNot Nothing AndAlso typeOfKeyword.Kind = SyntaxKind.TypeOfKeyword)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.IsKeyword)
            Debug.Assert(type IsNot Nothing)
            Return New TypeOfExpressionSyntax(SyntaxKind.TypeOfIsExpression, typeOfKeyword, expression, operatorToken, type)
        End Function


        ''' <summary>
        ''' Represents a TypeOf...Is or IsNot expression.
        ''' </summary>
        ''' <param name="typeOfKeyword">
        ''' The "TypeOf" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being tested.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "Is" or "IsNot" keyword.
        ''' </param>
        ''' <param name="type">
        ''' The name of the type being tested against.
        ''' </param>
        Friend Shared Function TypeOfIsNotExpression(typeOfKeyword As KeywordSyntax, expression As ExpressionSyntax, operatorToken As KeywordSyntax, type As TypeSyntax) As TypeOfExpressionSyntax
            Debug.Assert(typeOfKeyword IsNot Nothing AndAlso typeOfKeyword.Kind = SyntaxKind.TypeOfKeyword)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.IsNotKeyword)
            Debug.Assert(type IsNot Nothing)
            Return New TypeOfExpressionSyntax(SyntaxKind.TypeOfIsNotExpression, typeOfKeyword, expression, operatorToken, type)
        End Function


        ''' <summary>
        ''' Represents a TypeOf...Is or IsNot expression.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' TypeOfExpressionSyntax. One of TypeOfIsExpression, TypeOfIsNotExpression.
        ''' </param>
        ''' <param name="typeOfKeyword">
        ''' The "TypeOf" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being tested.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "Is" or "IsNot" keyword.
        ''' </param>
        ''' <param name="type">
        ''' The name of the type being tested against.
        ''' </param>
        Friend Shared Function TypeOfExpression(kind As SyntaxKind, typeOfKeyword As KeywordSyntax, expression As ExpressionSyntax, operatorToken As KeywordSyntax, type As TypeSyntax) As TypeOfExpressionSyntax
            Debug.Assert(kind.IsTypeOfExpression())
            Debug.Assert(typeOfKeyword IsNot Nothing AndAlso typeOfKeyword.Kind = SyntaxKind.TypeOfKeyword)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsTypeOfExpressionOperatorToken)
            Debug.Assert(type IsNot Nothing)
            Return New TypeOfExpressionSyntax(kind, typeOfKeyword, expression, operatorToken, type)
        End Function


        ''' <summary>
        ''' Represents a GetXmlNamespace expression.
        ''' </summary>
        ''' <param name="getXmlNamespaceKeyword">
        ''' The "GetXmlNamespace" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="name">
        ''' The Xml namespace name being referenced.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function GetXmlNamespaceExpression(getXmlNamespaceKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, name As XmlNameTokenSyntax, closeParenToken As PunctuationSyntax) As GetXmlNamespaceExpressionSyntax
            Debug.Assert(getXmlNamespaceKeyword IsNot Nothing AndAlso getXmlNamespaceKeyword.Kind = SyntaxKind.GetXmlNamespaceKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New GetXmlNamespaceExpressionSyntax(SyntaxKind.GetXmlNamespaceExpression, getXmlNamespaceKeyword, openParenToken, name, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents member access (.name) or dictionary access (!name). The Kind
        ''' property determines which kind of access.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression on the left-hand-side of the "." or "!" token.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "." or "!" token.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the "." or "!" token.
        ''' </param>
        Friend Shared Function MemberAccessExpression(expression As ExpressionSyntax, operatorToken As PunctuationSyntax, name As SimpleNameSyntax) As MemberAccessExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsMemberAccessExpressionOperatorToken)
            Debug.Assert(name IsNot Nothing)
            Return New MemberAccessExpressionSyntax(SyntaxKind.MemberAccessExpression, expression, operatorToken, name)
        End Function


        ''' <summary>
        ''' Represents member access (.name) or dictionary access (!name). The Kind
        ''' property determines which kind of access.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression on the left-hand-side of the "." or "!" token.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "." or "!" token.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the "." or "!" token.
        ''' </param>
        Friend Shared Function DictionaryAccess(expression As ExpressionSyntax, operatorToken As PunctuationSyntax, name As SimpleNameSyntax) As MemberAccessExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsMemberAccessExpressionOperatorToken)
            Debug.Assert(name IsNot Nothing)
            Return New MemberAccessExpressionSyntax(SyntaxKind.DictionaryAccess, expression, operatorToken, name)
        End Function


        ''' <summary>
        ''' Represents an XML member element access (node.&lt;Element&gt;), attribute
        ''' access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
        ''' Kind property determines which kind of access.
        ''' </summary>
        ''' <param name="base">
        ''' The expression on the left-hand-side of the ".", ".@" or "..." .
        ''' </param>
        ''' <param name="token1">
        ''' The initial dot "." part of the separator.
        ''' </param>
        ''' <param name="token2">
        ''' The "@" part of .@ or the second "." of "...".
        ''' </param>
        ''' <param name="token3">
        ''' The third "." in a "..." separator.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the ".", ".@" or "..."
        ''' </param>
        Friend Shared Function XmlElementAccessExpression(base As ExpressionSyntax, token1 As PunctuationSyntax, token2 As PunctuationSyntax, token3 As PunctuationSyntax, name As XmlNodeSyntax) As XmlMemberAccessExpressionSyntax
            Debug.Assert(token1 IsNot Nothing AndAlso token1.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)
            Return New XmlMemberAccessExpressionSyntax(SyntaxKind.XmlElementAccessExpression, base, token1, token2, token3, name)
        End Function


        ''' <summary>
        ''' Represents an XML member element access (node.&lt;Element&gt;), attribute
        ''' access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
        ''' Kind property determines which kind of access.
        ''' </summary>
        ''' <param name="base">
        ''' The expression on the left-hand-side of the ".", ".@" or "..." .
        ''' </param>
        ''' <param name="token1">
        ''' The initial dot "." part of the separator.
        ''' </param>
        ''' <param name="token2">
        ''' The "@" part of .@ or the second "." of "...".
        ''' </param>
        ''' <param name="token3">
        ''' The third "." in a "..." separator.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the ".", ".@" or "..."
        ''' </param>
        Friend Shared Function XmlDescendantAccessExpression(base As ExpressionSyntax, token1 As PunctuationSyntax, token2 As PunctuationSyntax, token3 As PunctuationSyntax, name As XmlNodeSyntax) As XmlMemberAccessExpressionSyntax
            Debug.Assert(token1 IsNot Nothing AndAlso token1.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)
            Return New XmlMemberAccessExpressionSyntax(SyntaxKind.XmlDescendantAccessExpression, base, token1, token2, token3, name)
        End Function


        ''' <summary>
        ''' Represents an XML member element access (node.&lt;Element&gt;), attribute
        ''' access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
        ''' Kind property determines which kind of access.
        ''' </summary>
        ''' <param name="base">
        ''' The expression on the left-hand-side of the ".", ".@" or "..." .
        ''' </param>
        ''' <param name="token1">
        ''' The initial dot "." part of the separator.
        ''' </param>
        ''' <param name="token2">
        ''' The "@" part of .@ or the second "." of "...".
        ''' </param>
        ''' <param name="token3">
        ''' The third "." in a "..." separator.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the ".", ".@" or "..."
        ''' </param>
        Friend Shared Function XmlAttributeAccessExpression(base As ExpressionSyntax, token1 As PunctuationSyntax, token2 As PunctuationSyntax, token3 As PunctuationSyntax, name As XmlNodeSyntax) As XmlMemberAccessExpressionSyntax
            Debug.Assert(token1 IsNot Nothing AndAlso token1.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)
            Return New XmlMemberAccessExpressionSyntax(SyntaxKind.XmlAttributeAccessExpression, base, token1, token2, token3, name)
        End Function


        ''' <summary>
        ''' Represents an XML member element access (node.&lt;Element&gt;), attribute
        ''' access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
        ''' Kind property determines which kind of access.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' XmlMemberAccessExpressionSyntax. One of XmlElementAccessExpression,
        ''' XmlDescendantAccessExpression, XmlAttributeAccessExpression.
        ''' </param>
        ''' <param name="base">
        ''' The expression on the left-hand-side of the ".", ".@" or "..." .
        ''' </param>
        ''' <param name="token1">
        ''' The initial dot "." part of the separator.
        ''' </param>
        ''' <param name="token2">
        ''' The "@" part of .@ or the second "." of "...".
        ''' </param>
        ''' <param name="token3">
        ''' The third "." in a "..." separator.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the ".", ".@" or "..."
        ''' </param>
        Friend Shared Function XmlMemberAccessExpression(kind As SyntaxKind, base As ExpressionSyntax, token1 As PunctuationSyntax, token2 As PunctuationSyntax, token3 As PunctuationSyntax, name As XmlNodeSyntax) As XmlMemberAccessExpressionSyntax
            Debug.Assert(kind.IsXmlMemberAccessExpression())
            Debug.Assert(token1 IsNot Nothing AndAlso token1.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)
            Return New XmlMemberAccessExpressionSyntax(kind, base, token1, token2, token3, name)
        End Function


        ''' <summary>
        ''' Represents an invocation expression consisting of an invocation target and an
        ''' optional argument list or an array, parameterized property or object default
        ''' property index.
        ''' </summary>
        ''' <param name="expression">
        ''' The target of the call or index expression.
        ''' </param>
        ''' <param name="argumentList">
        ''' The argument list.
        ''' </param>
        Friend Shared Function InvocationExpression(expression As ExpressionSyntax, argumentList As ArgumentListSyntax) As InvocationExpressionSyntax
            Debug.Assert(expression IsNot Nothing)
            Return New InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, argumentList)
        End Function


        ''' <summary>
        ''' Represents a New expression that creates a new non-array object, possibly with
        ''' a "With" or "From" clause.
        ''' </summary>
        ''' <param name="newKeyword">
        ''' The "New" keyword.
        ''' </param>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </param>
        ''' <param name="type">
        ''' The type of the object being initialized.
        ''' </param>
        ''' <param name="argumentList">
        ''' The argument list, if present. If no argument list was supplied, Nothing is
        ''' returned.
        ''' </param>
        ''' <param name="initializer">
        ''' An optional From or With clause to initialize the new object.
        ''' </param>
        Friend Shared Function ObjectCreationExpression(newKeyword As KeywordSyntax, attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), type As TypeSyntax, argumentList As ArgumentListSyntax, initializer As ObjectCreationInitializerSyntax) As ObjectCreationExpressionSyntax
            Debug.Assert(newKeyword IsNot Nothing AndAlso newKeyword.Kind = SyntaxKind.NewKeyword)
            Debug.Assert(type IsNot Nothing)
            Return New ObjectCreationExpressionSyntax(SyntaxKind.ObjectCreationExpression, newKeyword, attributes.Node, type, argumentList, initializer)
        End Function


        ''' <summary>
        ''' Represents a New expression that create an object of anonymous type.
        ''' </summary>
        ''' <param name="newKeyword">
        ''' The "New" keyword.
        ''' </param>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </param>
        ''' <param name="initializer">
        ''' The With clause to initialize the new object.
        ''' </param>
        Friend Shared Function AnonymousObjectCreationExpression(newKeyword As KeywordSyntax, attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), initializer As ObjectMemberInitializerSyntax) As AnonymousObjectCreationExpressionSyntax
            Debug.Assert(newKeyword IsNot Nothing AndAlso newKeyword.Kind = SyntaxKind.NewKeyword)
            Debug.Assert(initializer IsNot Nothing)
            Return New AnonymousObjectCreationExpressionSyntax(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, attributes.Node, initializer)
        End Function


        ''' <summary>
        ''' Represents an expression that creates a new array.
        ''' </summary>
        ''' <param name="newKeyword">
        ''' The "New" keyword.
        ''' </param>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </param>
        ''' <param name="type">
        ''' The element type of the array being created.
        ''' </param>
        ''' <param name="arrayBounds">
        ''' The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
        ''' </param>
        ''' <param name="rankSpecifiers">
        ''' A list of array modifiers such as "()" or "(,)". If no array modifiers were
        ''' present, an empty list is returned.
        ''' </param>
        ''' <param name="initializer">
        ''' The initializer including the braces.
        ''' </param>
        Friend Shared Function ArrayCreationExpression(newKeyword As KeywordSyntax, attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), type As TypeSyntax, arrayBounds As ArgumentListSyntax, rankSpecifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), initializer As CollectionInitializerSyntax) As ArrayCreationExpressionSyntax
            Debug.Assert(newKeyword IsNot Nothing AndAlso newKeyword.Kind = SyntaxKind.NewKeyword)
            Debug.Assert(type IsNot Nothing)
            Debug.Assert(initializer IsNot Nothing)
            Return New ArrayCreationExpressionSyntax(SyntaxKind.ArrayCreationExpression, newKeyword, attributes.Node, type, arrayBounds, rankSpecifiers.Node, initializer)
        End Function


        ''' <summary>
        ''' Represents an expression that creates a new array wihout naming the element
        ''' type.
        ''' </summary>
        ''' <param name="openBraceToken">
        ''' The "{" token.
        ''' </param>
        ''' <param name="initializers">
        ''' The list of initializers between the braces.
        ''' </param>
        ''' <param name="closeBraceToken">
        ''' The "}" token.
        ''' </param>
        Friend Shared Function CollectionInitializer(openBraceToken As PunctuationSyntax, initializers As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ExpressionSyntax), closeBraceToken As PunctuationSyntax) As CollectionInitializerSyntax
            Debug.Assert(openBraceToken IsNot Nothing AndAlso openBraceToken.Kind = SyntaxKind.OpenBraceToken)
            Debug.Assert(closeBraceToken IsNot Nothing AndAlso closeBraceToken.Kind = SyntaxKind.CloseBraceToken)
            Return New CollectionInitializerSyntax(SyntaxKind.CollectionInitializer, openBraceToken, initializers.Node, closeBraceToken)
        End Function


        ''' <param name="keyword">
        ''' The "CType", "DirectCast" or "TryCast" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being cast.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="type">
        ''' The type the expression is being cast to.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function CTypeExpression(keyword As KeywordSyntax, openParenToken As PunctuationSyntax, expression As ExpressionSyntax, commaToken As PunctuationSyntax, type As TypeSyntax, closeParenToken As PunctuationSyntax) As CTypeExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.CTypeKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(type IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New CTypeExpressionSyntax(SyntaxKind.CTypeExpression, keyword, openParenToken, expression, commaToken, type, closeParenToken)
        End Function


        ''' <param name="keyword">
        ''' The "CType", "DirectCast" or "TryCast" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being cast.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="type">
        ''' The type the expression is being cast to.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function DirectCastExpression(keyword As KeywordSyntax, openParenToken As PunctuationSyntax, expression As ExpressionSyntax, commaToken As PunctuationSyntax, type As TypeSyntax, closeParenToken As PunctuationSyntax) As DirectCastExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.DirectCastKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(type IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New DirectCastExpressionSyntax(SyntaxKind.DirectCastExpression, keyword, openParenToken, expression, commaToken, type, closeParenToken)
        End Function


        ''' <param name="keyword">
        ''' The "CType", "DirectCast" or "TryCast" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being cast.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="type">
        ''' The type the expression is being cast to.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function TryCastExpression(keyword As KeywordSyntax, openParenToken As PunctuationSyntax, expression As ExpressionSyntax, commaToken As PunctuationSyntax, type As TypeSyntax, closeParenToken As PunctuationSyntax) As TryCastExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.TryCastKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(type IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New TryCastExpressionSyntax(SyntaxKind.TryCastExpression, keyword, openParenToken, expression, commaToken, type, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents a cast to a pre-defined type using a pre-defined cast expression,
        ''' such as CInt or CLng.
        ''' </summary>
        ''' <param name="keyword">
        ''' The keyword that was used in the cast operation.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being cast.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function PredefinedCastExpression(keyword As KeywordSyntax, openParenToken As PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As PunctuationSyntax) As PredefinedCastExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind.IsPredefinedCastExpressionKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New PredefinedCastExpressionSyntax(SyntaxKind.PredefinedCastExpression, keyword, openParenToken, expression, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function AddExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.PlusToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.AddExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function SubtractExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.MinusToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.SubtractExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function MultiplyExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AsteriskToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.MultiplyExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function DivideExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.SlashToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.DivideExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function IntegerDivideExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.BackslashToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.IntegerDivideExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function PowerExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.CaretToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.PowerExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function LeftShiftExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanLessThanToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.LeftShiftExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function RightShiftExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanGreaterThanToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.RightShiftExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function ConcatenateExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AmpersandToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.ConcatenateExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function ModuloExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.ModKeyword)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.ModuloExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function EqualsExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.EqualsExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function NotEqualsExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanGreaterThanToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.NotEqualsExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function LessThanExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.LessThanExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function LessThanOrEqualExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanEqualsToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.LessThanOrEqualExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function GreaterThanOrEqualExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanEqualsToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.GreaterThanOrEqualExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function GreaterThanExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.GreaterThanExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function IsExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.IsKeyword)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.IsExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function IsNotExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.IsNotKeyword)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.IsNotExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function LikeExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LikeKeyword)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.LikeExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function OrExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.OrKeyword)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.OrExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function XorExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.XorKeyword)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.XorExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function AndExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AndKeyword)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.AndExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function OrElseExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.OrElseKeyword)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.OrElseExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function AndAlsoExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AndAlsoKeyword)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(SyntaxKind.AndAlsoExpression, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' BinaryExpressionSyntax. One of AddExpression, SubtractExpression,
        ''' MultiplyExpression, DivideExpression, IntegerDivideExpression, PowerExpression,
        ''' LeftShiftExpression, RightShiftExpression, ConcatenateExpression,
        ''' ModuloExpression, EqualsExpression, NotEqualsExpression, LessThanExpression,
        ''' LessThanOrEqualExpression, GreaterThanOrEqualExpression, GreaterThanExpression,
        ''' IsExpression, IsNotExpression, LikeExpression, OrExpression, XorExpression,
        ''' AndExpression, OrElseExpression, AndAlsoExpression.
        ''' </param>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function BinaryExpression(kind As SyntaxKind, left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(kind.IsBinaryExpression())
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsBinaryExpressionOperatorToken)
            Debug.Assert(right IsNot Nothing)
            Return New BinaryExpressionSyntax(kind, left, operatorToken, right)
        End Function


        ''' <summary>
        ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
        ''' </summary>
        ''' <param name="operatorToken">
        ''' The token that is the operator.
        ''' </param>
        ''' <param name="operand">
        ''' The expression being operated on.
        ''' </param>
        Friend Shared Function PlusExpression(operatorToken As SyntaxToken, operand As ExpressionSyntax) As UnaryExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.PlusToken)
            Debug.Assert(operand IsNot Nothing)
            Return New UnaryExpressionSyntax(SyntaxKind.PlusExpression, operatorToken, operand)
        End Function


        ''' <summary>
        ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
        ''' </summary>
        ''' <param name="operatorToken">
        ''' The token that is the operator.
        ''' </param>
        ''' <param name="operand">
        ''' The expression being operated on.
        ''' </param>
        Friend Shared Function NegateExpression(operatorToken As SyntaxToken, operand As ExpressionSyntax) As UnaryExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.MinusToken)
            Debug.Assert(operand IsNot Nothing)
            Return New UnaryExpressionSyntax(SyntaxKind.NegateExpression, operatorToken, operand)
        End Function


        ''' <summary>
        ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
        ''' </summary>
        ''' <param name="operatorToken">
        ''' The token that is the operator.
        ''' </param>
        ''' <param name="operand">
        ''' The expression being operated on.
        ''' </param>
        Friend Shared Function NotExpression(operatorToken As SyntaxToken, operand As ExpressionSyntax) As UnaryExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.NotKeyword)
            Debug.Assert(operand IsNot Nothing)
            Return New UnaryExpressionSyntax(SyntaxKind.NotExpression, operatorToken, operand)
        End Function


        ''' <summary>
        ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
        ''' </summary>
        ''' <param name="operatorToken">
        ''' The token that is the operator.
        ''' </param>
        ''' <param name="operand">
        ''' The expression being operated on.
        ''' </param>
        Friend Shared Function AddressOfExpression(operatorToken As SyntaxToken, operand As ExpressionSyntax) As UnaryExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AddressOfKeyword)
            Debug.Assert(operand IsNot Nothing)
            Return New UnaryExpressionSyntax(SyntaxKind.AddressOfExpression, operatorToken, operand)
        End Function


        ''' <summary>
        ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' UnaryExpressionSyntax. One of PlusExpression, NegateExpression, NotExpression,
        ''' AddressOfExpression.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The token that is the operator.
        ''' </param>
        ''' <param name="operand">
        ''' The expression being operated on.
        ''' </param>
        Friend Shared Function UnaryExpression(kind As SyntaxKind, operatorToken As SyntaxToken, operand As ExpressionSyntax) As UnaryExpressionSyntax
            Debug.Assert(kind.IsUnaryExpression())
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind.IsUnaryExpressionOperatorToken)
            Debug.Assert(operand IsNot Nothing)
            Return New UnaryExpressionSyntax(kind, operatorToken, operand)
        End Function


        ''' <summary>
        ''' Represents a conditional expression, If(condition, true-expr, false-expr) or
        ''' If(expr, nothing-expr).
        ''' </summary>
        ''' <param name="ifKeyword">
        ''' The "If" keyword
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token
        ''' </param>
        ''' <param name="firstExpression">
        ''' The first expression inside the parentheses.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="secondExpression">
        ''' The second expression inside the parentheses.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token
        ''' </param>
        Friend Shared Function BinaryConditionalExpression(ifKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, firstExpression As ExpressionSyntax, commaToken As PunctuationSyntax, secondExpression As ExpressionSyntax, closeParenToken As PunctuationSyntax) As BinaryConditionalExpressionSyntax
            Debug.Assert(ifKeyword IsNot Nothing AndAlso ifKeyword.Kind = SyntaxKind.IfKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(firstExpression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(secondExpression IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New BinaryConditionalExpressionSyntax(SyntaxKind.BinaryConditionalExpression, ifKeyword, openParenToken, firstExpression, commaToken, secondExpression, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents a conditional expression, If(condition, true-expr, false-expr) or
        ''' If(expr, nothing-expr).
        ''' </summary>
        ''' <param name="ifKeyword">
        ''' The "If" keyword
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token
        ''' </param>
        ''' <param name="condition">
        ''' The first expression inside the parentheses.
        ''' </param>
        ''' <param name="firstCommaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="whenTrue">
        ''' The second expression inside the parentheses.
        ''' </param>
        ''' <param name="secondCommaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="whenFalse">
        ''' The second expression inside the parentheses.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token
        ''' </param>
        Friend Shared Function TernaryConditionalExpression(ifKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, condition As ExpressionSyntax, firstCommaToken As PunctuationSyntax, whenTrue As ExpressionSyntax, secondCommaToken As PunctuationSyntax, whenFalse As ExpressionSyntax, closeParenToken As PunctuationSyntax) As TernaryConditionalExpressionSyntax
            Debug.Assert(ifKeyword IsNot Nothing AndAlso ifKeyword.Kind = SyntaxKind.IfKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(condition IsNot Nothing)
            Debug.Assert(firstCommaToken IsNot Nothing AndAlso firstCommaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(whenTrue IsNot Nothing)
            Debug.Assert(secondCommaToken IsNot Nothing AndAlso secondCommaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(whenFalse IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New TernaryConditionalExpressionSyntax(SyntaxKind.TernaryConditionalExpression, ifKeyword, openParenToken, condition, firstCommaToken, whenTrue, secondCommaToken, whenFalse, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents a single line lambda expression.
        ''' </summary>
        ''' <param name="begin">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement. Optional only
        ''' for single line lambdas.
        ''' </param>
        ''' <param name="body">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' Statement (single-line Sub lambda) or Expression (single-line Function).
        ''' </param>
        Friend Shared Function SingleLineFunctionLambdaExpression(begin As LambdaHeaderSyntax, beginTerminator As PunctuationSyntax, body As SyntaxNode) As SingleLineLambdaExpressionSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(body IsNot Nothing)
            Return New SingleLineLambdaExpressionSyntax(SyntaxKind.SingleLineFunctionLambdaExpression, begin, beginTerminator, body)
        End Function


        ''' <summary>
        ''' Represents a single line lambda expression.
        ''' </summary>
        ''' <param name="begin">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement. Optional only
        ''' for single line lambdas.
        ''' </param>
        ''' <param name="body">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' Statement (single-line Sub lambda) or Expression (single-line Function).
        ''' </param>
        Friend Shared Function SingleLineSubLambdaExpression(begin As LambdaHeaderSyntax, beginTerminator As PunctuationSyntax, body As SyntaxNode) As SingleLineLambdaExpressionSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(body IsNot Nothing)
            Return New SingleLineLambdaExpressionSyntax(SyntaxKind.SingleLineSubLambdaExpression, begin, beginTerminator, body)
        End Function


        ''' <summary>
        ''' Represents a single line lambda expression.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' SingleLineLambdaExpressionSyntax. One of SingleLineFunctionLambdaExpression,
        ''' SingleLineSubLambdaExpression.
        ''' </param>
        ''' <param name="begin">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement. Optional only
        ''' for single line lambdas.
        ''' </param>
        ''' <param name="body">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' Statement (single-line Sub lambda) or Expression (single-line Function).
        ''' </param>
        Friend Shared Function SingleLineLambdaExpression(kind As SyntaxKind, begin As LambdaHeaderSyntax, beginTerminator As PunctuationSyntax, body As SyntaxNode) As SingleLineLambdaExpressionSyntax
            Debug.Assert(kind.IsSingleLineLambdaExpression())
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert(body IsNot Nothing)
            Return New SingleLineLambdaExpressionSyntax(kind, begin, beginTerminator, body)
        End Function


        ''' <summary>
        ''' Represents a multi-line lambda expression.
        ''' </summary>
        ''' <param name="begin">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement. Optional only
        ''' for single line lambdas.
        ''' </param>
        ''' <param name="statements">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
        ''' Expression (single-line Function). This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' Returns the "End Sub" or "End Function" statement if this is a multi-line
        ''' lambda.
        ''' </param>
        Friend Shared Function MultiLineFunctionLambdaExpression(begin As LambdaHeaderSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As MultiLineLambdaExpressionSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert([end] IsNot Nothing)
            Return New MultiLineLambdaExpressionSyntax(SyntaxKind.MultiLineFunctionLambdaExpression, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a multi-line lambda expression.
        ''' </summary>
        ''' <param name="begin">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement. Optional only
        ''' for single line lambdas.
        ''' </param>
        ''' <param name="statements">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
        ''' Expression (single-line Function). This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' Returns the "End Sub" or "End Function" statement if this is a multi-line
        ''' lambda.
        ''' </param>
        Friend Shared Function MultiLineSubLambdaExpression(begin As LambdaHeaderSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As MultiLineLambdaExpressionSyntax
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert([end] IsNot Nothing)
            Return New MultiLineLambdaExpressionSyntax(SyntaxKind.MultiLineSubLambdaExpression, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents a multi-line lambda expression.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' MultiLineLambdaExpressionSyntax. One of MultiLineFunctionLambdaExpression,
        ''' MultiLineSubLambdaExpression.
        ''' </param>
        ''' <param name="begin">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="beginTerminator">
        ''' The statement terminator token that ended the Begin statement. Optional only
        ''' for single line lambdas.
        ''' </param>
        ''' <param name="statements">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
        ''' Expression (single-line Function). This might be an empty list.
        ''' </param>
        ''' <param name="end">
        ''' Returns the "End Sub" or "End Function" statement if this is a multi-line
        ''' lambda.
        ''' </param>
        Friend Shared Function MultiLineLambdaExpression(kind As SyntaxKind, begin As LambdaHeaderSyntax, beginTerminator As PunctuationSyntax, statements As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.StatementSyntax), [end] As EndBlockStatementSyntax) As MultiLineLambdaExpressionSyntax
            Debug.Assert(kind.IsMultiLineLambdaExpression())
            Debug.Assert(begin IsNot Nothing)
            Debug.Assert([end] IsNot Nothing)
            Return New MultiLineLambdaExpressionSyntax(kind, begin, beginTerminator, statements.Node, [end])
        End Function


        ''' <summary>
        ''' Represents the header part of a lambda expression
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function SubLambdaHeader(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As LambdaHeaderSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.SubKeyword)
            Return New LambdaHeaderSyntax(SyntaxKind.SubLambdaHeader, attributes.Node, modifiers.Node, keyword, parameterList, asClause)
        End Function


        ''' <summary>
        ''' Represents the header part of a lambda expression
        ''' </summary>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function FunctionLambdaHeader(attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As LambdaHeaderSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.FunctionKeyword)
            Return New LambdaHeaderSyntax(SyntaxKind.FunctionLambdaHeader, attributes.Node, modifiers.Node, keyword, parameterList, asClause)
        End Function


        ''' <summary>
        ''' Represents the header part of a lambda expression
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of LambdaHeaderSyntax.
        ''' One of SubLambdaHeader, FunctionLambdaHeader.
        ''' </param>
        ''' <param name="attributes">
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="keyword">
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function LambdaHeader(kind As SyntaxKind, attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), modifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), keyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax) As LambdaHeaderSyntax
            Debug.Assert(kind.IsLambdaHeader())
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind.IsLambdaHeaderKeyword)
            Return New LambdaHeaderSyntax(kind, attributes.Node, modifiers.Node, keyword, parameterList, asClause)
        End Function


        ''' <summary>
        ''' Represents a parenthesized argument list.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="arguments">
        ''' The list of arguments. This may be empty. Ommitted argument are represented by
        ''' an OmittedArgumentSyntax node.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function ArgumentList(openParenToken As PunctuationSyntax, arguments As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ArgumentSyntax), closeParenToken As PunctuationSyntax) As ArgumentListSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents an omitted argument in an argument list. An omitted argument is not
        ''' considered a syntax error but a valid case when no argument is required.
        ''' </summary>
        ''' <param name="empty">
        ''' An empty token because all non terminals must have a token.
        ''' </param>
        Friend Shared Function OmittedArgument(empty As PunctuationSyntax) As OmittedArgumentSyntax
            Debug.Assert(empty IsNot Nothing AndAlso empty.Kind = SyntaxKind.EmptyToken)
            Return New OmittedArgumentSyntax(SyntaxKind.OmittedArgument, empty)
        End Function


        ''' <summary>
        ''' Represents a simple argument that is just an expression.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression that is the argument.
        ''' </param>
        Friend Shared Function SimpleArgument(expression As ExpressionSyntax) As SimpleArgumentSyntax
            Debug.Assert(expression IsNot Nothing)
            Return New SimpleArgumentSyntax(SyntaxKind.SimpleArgument, expression)
        End Function


        ''' <summary>
        ''' Represents a named argument, such as "Value:=7".
        ''' </summary>
        ''' <param name="identifierName">
        ''' The name used to identify the named argument.
        ''' </param>
        ''' <param name="colonEqualsToken">
        ''' The ":=" token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression that is the named argument.
        ''' </param>
        Friend Shared Function NamedArgument(identifierName As IdentifierNameSyntax, colonEqualsToken As PunctuationSyntax, expression As ExpressionSyntax) As NamedArgumentSyntax
            Debug.Assert(identifierName IsNot Nothing)
            Debug.Assert(colonEqualsToken IsNot Nothing AndAlso colonEqualsToken.Kind = SyntaxKind.ColonEqualsToken)
            Debug.Assert(expression IsNot Nothing)
            Return New NamedArgumentSyntax(SyntaxKind.NamedArgument, identifierName, colonEqualsToken, expression)
        End Function


        ''' <summary>
        ''' Represents a range argument, such as "0 to 5", used in array bounds. The
        ''' "Value" property represents the upper bound of the range.
        ''' </summary>
        ''' <param name="lowerBound">
        ''' The lower bound of the range. This is typically the integer constant zero.
        ''' </param>
        ''' <param name="toKeyword">
        ''' The "To" keyword.
        ''' </param>
        ''' <param name="upperBound">
        ''' The upper bound of the range.
        ''' </param>
        Friend Shared Function RangeArgument(lowerBound As ExpressionSyntax, toKeyword As KeywordSyntax, upperBound As ExpressionSyntax) As RangeArgumentSyntax
            Debug.Assert(lowerBound IsNot Nothing)
            Debug.Assert(toKeyword IsNot Nothing AndAlso toKeyword.Kind = SyntaxKind.ToKeyword)
            Debug.Assert(upperBound IsNot Nothing)
            Return New RangeArgumentSyntax(SyntaxKind.RangeArgument, lowerBound, toKeyword, upperBound)
        End Function


        ''' <summary>
        ''' This class represents a query expression. A query expression is composed of one
        ''' or more query operators in a row. The first query operator must be a From or
        ''' Aggregate.
        ''' </summary>
        ''' <param name="clauses">
        ''' A list of all the query operators in this query expression. This list always
        ''' contains at least one operator.
        ''' </param>
        Friend Shared Function QueryExpression(clauses As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode)) As QueryExpressionSyntax
            Return New QueryExpressionSyntax(SyntaxKind.QueryExpression, clauses.Node)
        End Function


        ''' <summary>
        ''' Describes a single variable of the form "x [As Type] In expression" for use in
        ''' query expressions.
        ''' </summary>
        ''' <param name="identifier">
        ''' The name of the range variable being defined.
        ''' </param>
        ''' <param name="asClause">
        ''' Describes the type of the variable being defined.
        ''' </param>
        ''' <param name="inKeyword">
        ''' The "In" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression that serves as the source of items for the range variable.
        ''' </param>
        Friend Shared Function CollectionRangeVariable(identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, inKeyword As KeywordSyntax, expression As ExpressionSyntax) As CollectionRangeVariableSyntax
            Debug.Assert(identifier IsNot Nothing)
            Debug.Assert(inKeyword IsNot Nothing AndAlso inKeyword.Kind = SyntaxKind.InKeyword)
            Debug.Assert(expression IsNot Nothing)
            Return New CollectionRangeVariableSyntax(SyntaxKind.CollectionRangeVariable, identifier, asClause, inKeyword, expression)
        End Function


        ''' <summary>
        ''' Describes a single variable of the form "[x [As Type] =] expression" for use in
        ''' query expressions.
        ''' </summary>
        ''' <param name="nameEquals">
        ''' The optional name and type of the expression range variable. If ommitted, the
        ''' name of the expression range variable is inferred from the expression.
        ''' </param>
        ''' <param name="expression">
        ''' The expression used to initialize the expression variable.
        ''' </param>
        Friend Shared Function ExpressionRangeVariable(nameEquals As VariableNameEqualsSyntax, expression As ExpressionSyntax) As ExpressionRangeVariableSyntax
            Debug.Assert(expression IsNot Nothing)
            Return New ExpressionRangeVariableSyntax(SyntaxKind.ExpressionRangeVariable, nameEquals, expression)
        End Function


        ''' <summary>
        ''' Describes a single variable of the form "[x [As Type] =] aggregation-function"
        ''' for use in the Into clause of Aggregate or Group By or Group Join query
        ''' operators.
        ''' </summary>
        ''' <param name="nameEquals">
        ''' The optional name and type of the expression range variable. If ommitted, the
        ''' name of the expression range variable is inferred from the aggregation
        ''' expression.
        ''' </param>
        ''' <param name="aggregation">
        ''' The name of the aggregation function. The "Group" aggregation function is
        ''' represented by the identifier "Group".
        ''' </param>
        Friend Shared Function AggregationRangeVariable(nameEquals As VariableNameEqualsSyntax, aggregation As AggregationSyntax) As AggregationRangeVariableSyntax
            Debug.Assert(aggregation IsNot Nothing)
            Return New AggregationRangeVariableSyntax(SyntaxKind.AggregationRangeVariable, nameEquals, aggregation)
        End Function


        ''' <summary>
        ''' Represents the name and optional type of an expression range variable.
        ''' </summary>
        ''' <param name="identifier">
        ''' The name of the variable being defined.
        ''' </param>
        ''' <param name="asClause">
        ''' Describes the type of the variable being defined.
        ''' </param>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        Friend Shared Function VariableNameEquals(identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, equalsToken As PunctuationSyntax) As VariableNameEqualsSyntax
            Debug.Assert(identifier IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Return New VariableNameEqualsSyntax(SyntaxKind.VariableNameEquals, identifier, asClause, equalsToken)
        End Function


        ''' <summary>
        ''' Represents an invocation of an Aggregation function in the aggregation range
        ''' variable declaration of a Group By, Group Join or Aggregate query operator.
        ''' </summary>
        ''' <param name="functionName">
        ''' The name of the aggregation function.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token if present.
        ''' </param>
        ''' <param name="argument">
        ''' The argument to the aggregation function.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token, if present.
        ''' </param>
        Friend Shared Function FunctionAggregation(functionName As IdentifierTokenSyntax, openParenToken As PunctuationSyntax, argument As ExpressionSyntax, closeParenToken As PunctuationSyntax) As FunctionAggregationSyntax
            Debug.Assert(functionName IsNot Nothing AndAlso functionName.Kind = SyntaxKind.IdentifierToken)
            Return New FunctionAggregationSyntax(SyntaxKind.FunctionAggregation, functionName, openParenToken, argument, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents the use of "Group" as the aggregation function in the in the
        ''' aggregation range variable declaration of a Group By or Group Join query
        ''' operator.
        ''' </summary>
        ''' <param name="groupKeyword">
        ''' The "Group" keyword.
        ''' </param>
        Friend Shared Function GroupAggregation(groupKeyword As KeywordSyntax) As GroupAggregationSyntax
            Debug.Assert(groupKeyword IsNot Nothing AndAlso groupKeyword.Kind = SyntaxKind.GroupKeyword)
            Return New GroupAggregationSyntax(SyntaxKind.GroupAggregation, groupKeyword)
        End Function


        ''' <summary>
        ''' Represents a "From" query operator. If this is the beginning of a query, the
        ''' Source will be Nothing. Otherwise, the Source will be the part of the query to
        ''' the left of the From.
        ''' </summary>
        ''' <param name="fromKeyword">
        ''' The "From" keyword.
        ''' </param>
        ''' <param name="variables">
        ''' The list of collection variables declared by this From operator.
        ''' </param>
        Friend Shared Function FromClause(fromKeyword As KeywordSyntax, variables As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.CollectionRangeVariableSyntax)) As FromClauseSyntax
            Debug.Assert(fromKeyword IsNot Nothing AndAlso fromKeyword.Kind = SyntaxKind.FromKeyword)
            Return New FromClauseSyntax(SyntaxKind.FromClause, fromKeyword, variables.Node)
        End Function


        ''' <summary>
        ''' Represents a "Let" query operator.
        ''' </summary>
        ''' <param name="letKeyword">
        ''' The "Let" keyword.
        ''' </param>
        ''' <param name="variables">
        ''' The list of expression range variable being defined by the Let operator.
        ''' </param>
        Friend Shared Function LetClause(letKeyword As KeywordSyntax, variables As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ExpressionRangeVariableSyntax)) As LetClauseSyntax
            Debug.Assert(letKeyword IsNot Nothing AndAlso letKeyword.Kind = SyntaxKind.LetKeyword)
            Return New LetClauseSyntax(SyntaxKind.LetClause, letKeyword, variables.Node)
        End Function


        ''' <summary>
        ''' Represents an Aggregate query operator.
        ''' </summary>
        ''' <param name="aggregateKeyword">
        ''' The "Aggregate" keyword.
        ''' </param>
        ''' <param name="variables">
        ''' The list of collection range variables declared by this Aggregate operator.
        ''' </param>
        ''' <param name="additionalQueryOperators">
        ''' A list of additional query operators. It may be empty.
        ''' </param>
        ''' <param name="intoKeyword">
        ''' The "Into" keyword.
        ''' </param>
        ''' <param name="aggregationVariables">
        ''' The list of new variables being defined by the aggregation.
        ''' </param>
        Friend Shared Function AggregateClause(aggregateKeyword As KeywordSyntax, variables As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.CollectionRangeVariableSyntax), additionalQueryOperators As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), intoKeyword As KeywordSyntax, aggregationVariables As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.AggregationRangeVariableSyntax)) As AggregateClauseSyntax
            Debug.Assert(aggregateKeyword IsNot Nothing AndAlso aggregateKeyword.Kind = SyntaxKind.AggregateKeyword)
            Debug.Assert(intoKeyword IsNot Nothing AndAlso intoKeyword.Kind = SyntaxKind.IntoKeyword)
            Return New AggregateClauseSyntax(SyntaxKind.AggregateClause, aggregateKeyword, variables.Node, additionalQueryOperators.Node, intoKeyword, aggregationVariables.Node)
        End Function


        ''' <summary>
        ''' Represents the "Distinct" query operator.
        ''' </summary>
        ''' <param name="distinctKeyword">
        ''' The "Distinct" keyword.
        ''' </param>
        Friend Shared Function DistinctClause(distinctKeyword As KeywordSyntax) As DistinctClauseSyntax
            Debug.Assert(distinctKeyword IsNot Nothing AndAlso distinctKeyword.Kind = SyntaxKind.DistinctKeyword)
            Return New DistinctClauseSyntax(SyntaxKind.DistinctClause, distinctKeyword)
        End Function


        ''' <summary>
        ''' Represents a "Where" query operator.
        ''' </summary>
        ''' <param name="whereKeyword">
        ''' The "Where" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression used for filtering.
        ''' </param>
        Friend Shared Function WhereClause(whereKeyword As KeywordSyntax, condition As ExpressionSyntax) As WhereClauseSyntax
            Debug.Assert(whereKeyword IsNot Nothing AndAlso whereKeyword.Kind = SyntaxKind.WhereKeyword)
            Debug.Assert(condition IsNot Nothing)
            Return New WhereClauseSyntax(SyntaxKind.WhereClause, whereKeyword, condition)
        End Function


        ''' <summary>
        ''' Represents a "Skip While" or "Take While" query operator. The Kind property
        ''' tells which.
        ''' </summary>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="whileKeyword">
        ''' The "While" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression used for partitioning.
        ''' </param>
        Friend Shared Function SkipWhileClause(skipOrTakeKeyword As KeywordSyntax, whileKeyword As KeywordSyntax, condition As ExpressionSyntax) As PartitionWhileClauseSyntax
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso skipOrTakeKeyword.Kind = SyntaxKind.SkipKeyword)
            Debug.Assert(whileKeyword IsNot Nothing AndAlso whileKeyword.Kind = SyntaxKind.WhileKeyword)
            Debug.Assert(condition IsNot Nothing)
            Return New PartitionWhileClauseSyntax(SyntaxKind.SkipWhileClause, skipOrTakeKeyword, whileKeyword, condition)
        End Function


        ''' <summary>
        ''' Represents a "Skip While" or "Take While" query operator. The Kind property
        ''' tells which.
        ''' </summary>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="whileKeyword">
        ''' The "While" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression used for partitioning.
        ''' </param>
        Friend Shared Function TakeWhileClause(skipOrTakeKeyword As KeywordSyntax, whileKeyword As KeywordSyntax, condition As ExpressionSyntax) As PartitionWhileClauseSyntax
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso skipOrTakeKeyword.Kind = SyntaxKind.TakeKeyword)
            Debug.Assert(whileKeyword IsNot Nothing AndAlso whileKeyword.Kind = SyntaxKind.WhileKeyword)
            Debug.Assert(condition IsNot Nothing)
            Return New PartitionWhileClauseSyntax(SyntaxKind.TakeWhileClause, skipOrTakeKeyword, whileKeyword, condition)
        End Function


        ''' <summary>
        ''' Represents a "Skip While" or "Take While" query operator. The Kind property
        ''' tells which.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' PartitionWhileClauseSyntax. One of SkipWhileClause, TakeWhileClause.
        ''' </param>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="whileKeyword">
        ''' The "While" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression used for partitioning.
        ''' </param>
        Friend Shared Function PartitionWhileClause(kind As SyntaxKind, skipOrTakeKeyword As KeywordSyntax, whileKeyword As KeywordSyntax, condition As ExpressionSyntax) As PartitionWhileClauseSyntax
            Debug.Assert(kind.IsPartitionWhileClause())
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso skipOrTakeKeyword.Kind.IsPartitionWhileClauseSkipOrTakeKeyword)
            Debug.Assert(whileKeyword IsNot Nothing AndAlso whileKeyword.Kind = SyntaxKind.WhileKeyword)
            Debug.Assert(condition IsNot Nothing)
            Return New PartitionWhileClauseSyntax(kind, skipOrTakeKeyword, whileKeyword, condition)
        End Function


        ''' <summary>
        ''' Represents a "Skip" or "Take" query operator. The Kind property tells which.
        ''' </summary>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="count">
        ''' Represents the expression with the number of items to take or skip.
        ''' </param>
        Friend Shared Function SkipClause(skipOrTakeKeyword As KeywordSyntax, count As ExpressionSyntax) As PartitionClauseSyntax
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso skipOrTakeKeyword.Kind = SyntaxKind.SkipKeyword)
            Debug.Assert(count IsNot Nothing)
            Return New PartitionClauseSyntax(SyntaxKind.SkipClause, skipOrTakeKeyword, count)
        End Function


        ''' <summary>
        ''' Represents a "Skip" or "Take" query operator. The Kind property tells which.
        ''' </summary>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="count">
        ''' Represents the expression with the number of items to take or skip.
        ''' </param>
        Friend Shared Function TakeClause(skipOrTakeKeyword As KeywordSyntax, count As ExpressionSyntax) As PartitionClauseSyntax
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso skipOrTakeKeyword.Kind = SyntaxKind.TakeKeyword)
            Debug.Assert(count IsNot Nothing)
            Return New PartitionClauseSyntax(SyntaxKind.TakeClause, skipOrTakeKeyword, count)
        End Function


        ''' <summary>
        ''' Represents a "Skip" or "Take" query operator. The Kind property tells which.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of
        ''' PartitionClauseSyntax. One of SkipClause, TakeClause.
        ''' </param>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="count">
        ''' Represents the expression with the number of items to take or skip.
        ''' </param>
        Friend Shared Function PartitionClause(kind As SyntaxKind, skipOrTakeKeyword As KeywordSyntax, count As ExpressionSyntax) As PartitionClauseSyntax
            Debug.Assert(kind.IsPartitionClause())
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso skipOrTakeKeyword.Kind.IsPartitionClauseSkipOrTakeKeyword)
            Debug.Assert(count IsNot Nothing)
            Return New PartitionClauseSyntax(kind, skipOrTakeKeyword, count)
        End Function


        ''' <summary>
        ''' Represents the "Group By" query operator.
        ''' </summary>
        ''' <param name="groupKeyword">
        ''' The "Group" keyword.
        ''' </param>
        ''' <param name="items">
        ''' The optional list of variables being grouped; the contents of the Group clause.
        ''' If none were specified, an empty list is returned.
        ''' </param>
        ''' <param name="byKeyword">
        ''' The "By" keyword.
        ''' </param>
        ''' <param name="keys">
        ''' The key values being used for grouping.
        ''' </param>
        ''' <param name="aggregationVariables">
        ''' The list of new variables that calculate aggregations.
        ''' </param>
        Friend Shared Function GroupByClause(groupKeyword As KeywordSyntax, items As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ExpressionRangeVariableSyntax), byKeyword As KeywordSyntax, keys As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ExpressionRangeVariableSyntax), intoKeyword As KeywordSyntax, aggregationVariables As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.AggregationRangeVariableSyntax)) As GroupByClauseSyntax
            Debug.Assert(groupKeyword IsNot Nothing AndAlso groupKeyword.Kind = SyntaxKind.GroupKeyword)
            Debug.Assert(byKeyword IsNot Nothing AndAlso byKeyword.Kind = SyntaxKind.ByKeyword)
            Debug.Assert(intoKeyword IsNot Nothing AndAlso intoKeyword.Kind = SyntaxKind.IntoKeyword)
            Return New GroupByClauseSyntax(SyntaxKind.GroupByClause, groupKeyword, items.Node, byKeyword, keys.Node, intoKeyword, aggregationVariables.Node)
        End Function


        ''' <summary>
        ''' Represents a Join query operator.
        ''' </summary>
        ''' <param name="joinKeyword">
        ''' The "Join" keyword.
        ''' </param>
        ''' <param name="joinedVariables">
        ''' Defines the collection range variables being joined to.
        ''' </param>
        ''' <param name="additionalJoins">
        ''' An additional Join or Group Join query operator.
        ''' </param>
        ''' <param name="onKeyword">
        ''' The "On" keyword.
        ''' </param>
        ''' <param name="joinConditions">
        ''' The conditions indicating what expressions to compare during the join. Each
        ''' condition is a JoinCondition, and the separators are "And" keywords.
        ''' </param>
        Friend Shared Function JoinClause(joinKeyword As KeywordSyntax, joinedVariables As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.CollectionRangeVariableSyntax), additionalJoins As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), onKeyword As KeywordSyntax, joinConditions As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.JoinConditionSyntax)) As JoinClauseSyntax
            Debug.Assert(joinKeyword IsNot Nothing AndAlso joinKeyword.Kind = SyntaxKind.JoinKeyword)
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Return New JoinClauseSyntax(SyntaxKind.JoinClause, joinKeyword, joinedVariables.Node, additionalJoins.Node, onKeyword, joinConditions.Node)
        End Function


        ''' <summary>
        ''' Represents the "expression Equals expression" condition in a Join.
        ''' </summary>
        ''' <param name="left">
        ''' The left expression in the Join condition.
        ''' </param>
        ''' <param name="equalsKeyword">
        ''' The "Equals" keyword.
        ''' </param>
        ''' <param name="right">
        ''' The right expression in the Join condition.
        ''' </param>
        Friend Shared Function JoinCondition(left As ExpressionSyntax, equalsKeyword As KeywordSyntax, right As ExpressionSyntax) As JoinConditionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(equalsKeyword IsNot Nothing AndAlso equalsKeyword.Kind = SyntaxKind.EqualsKeyword)
            Debug.Assert(right IsNot Nothing)
            Return New JoinConditionSyntax(SyntaxKind.JoinCondition, left, equalsKeyword, right)
        End Function


        ''' <summary>
        ''' Represents the "Group Join" query operator.
        ''' </summary>
        ''' <param name="groupKeyword">
        ''' The "Group" keyword.
        ''' </param>
        ''' <param name="joinKeyword">
        ''' The "Join" keyword.
        ''' </param>
        ''' <param name="joinedVariables">
        ''' Defines the collection range variables being joined to.
        ''' </param>
        ''' <param name="additionalJoins">
        ''' An additional Join or Group Join query operator.
        ''' </param>
        ''' <param name="onKeyword">
        ''' The "On" keyword.
        ''' </param>
        ''' <param name="joinConditions">
        ''' The conditions indicating what expressions to compare during the join. Each
        ''' condition is a JoinCondition, and the separators are "And" keywords.
        ''' </param>
        ''' <param name="intoKeyword">
        ''' The "Into" keyword.
        ''' </param>
        ''' <param name="aggregationVariables">
        ''' The list of new variables that calculate aggregations.
        ''' </param>
        Friend Shared Function GroupJoinClause(groupKeyword As KeywordSyntax, joinKeyword As KeywordSyntax, joinedVariables As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.CollectionRangeVariableSyntax), additionalJoins As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), onKeyword As KeywordSyntax, joinConditions As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.JoinConditionSyntax), intoKeyword As KeywordSyntax, aggregationVariables As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.AggregationRangeVariableSyntax)) As GroupJoinClauseSyntax
            Debug.Assert(groupKeyword IsNot Nothing AndAlso groupKeyword.Kind = SyntaxKind.GroupKeyword)
            Debug.Assert(joinKeyword IsNot Nothing AndAlso joinKeyword.Kind = SyntaxKind.JoinKeyword)
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(intoKeyword IsNot Nothing AndAlso intoKeyword.Kind = SyntaxKind.IntoKeyword)
            Return New GroupJoinClauseSyntax(SyntaxKind.GroupJoinClause, groupKeyword, joinKeyword, joinedVariables.Node, additionalJoins.Node, onKeyword, joinConditions.Node, intoKeyword, aggregationVariables.Node)
        End Function


        ''' <summary>
        ''' Represents the "Order By" query operator.
        ''' </summary>
        ''' <param name="orderKeyword">
        ''' The "Order" keyword
        ''' </param>
        ''' <param name="byKeyword">
        ''' The "By" keyword.
        ''' </param>
        ''' <param name="orderings">
        ''' The list of OrderExpression's to sort by.
        ''' </param>
        Friend Shared Function OrderByClause(orderKeyword As KeywordSyntax, byKeyword As KeywordSyntax, orderings As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.OrderingSyntax)) As OrderByClauseSyntax
            Debug.Assert(orderKeyword IsNot Nothing AndAlso orderKeyword.Kind = SyntaxKind.OrderKeyword)
            Debug.Assert(byKeyword IsNot Nothing AndAlso byKeyword.Kind = SyntaxKind.ByKeyword)
            Return New OrderByClauseSyntax(SyntaxKind.OrderByClause, orderKeyword, byKeyword, orderings.Node)
        End Function


        ''' <summary>
        ''' An expression to order by, plus an optional ordering. The Kind indicates
        ''' whether to order in ascending or descending order.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression to sort by.
        ''' </param>
        ''' <param name="ascendingOrDescendingKeyword">
        ''' The "Ascending" or "Descending" keyword, if present. To determine whether to
        ''' sort in ascending or descending order, checking the Kind property is easier.
        ''' </param>
        Friend Shared Function AscendingOrdering(expression As ExpressionSyntax, ascendingOrDescendingKeyword As KeywordSyntax) As OrderingSyntax
            Debug.Assert(expression IsNot Nothing)
            Return New OrderingSyntax(SyntaxKind.AscendingOrdering, expression, ascendingOrDescendingKeyword)
        End Function


        ''' <summary>
        ''' An expression to order by, plus an optional ordering. The Kind indicates
        ''' whether to order in ascending or descending order.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression to sort by.
        ''' </param>
        ''' <param name="ascendingOrDescendingKeyword">
        ''' The "Ascending" or "Descending" keyword, if present. To determine whether to
        ''' sort in ascending or descending order, checking the Kind property is easier.
        ''' </param>
        Friend Shared Function DescendingOrdering(expression As ExpressionSyntax, ascendingOrDescendingKeyword As KeywordSyntax) As OrderingSyntax
            Debug.Assert(expression IsNot Nothing)
            Return New OrderingSyntax(SyntaxKind.DescendingOrdering, expression, ascendingOrDescendingKeyword)
        End Function


        ''' <summary>
        ''' An expression to order by, plus an optional ordering. The Kind indicates
        ''' whether to order in ascending or descending order.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of OrderingSyntax. One
        ''' of AscendingOrdering, DescendingOrdering.
        ''' </param>
        ''' <param name="expression">
        ''' The expression to sort by.
        ''' </param>
        ''' <param name="ascendingOrDescendingKeyword">
        ''' The "Ascending" or "Descending" keyword, if present. To determine whether to
        ''' sort in ascending or descending order, checking the Kind property is easier.
        ''' </param>
        Friend Shared Function Ordering(kind As SyntaxKind, expression As ExpressionSyntax, ascendingOrDescendingKeyword As KeywordSyntax) As OrderingSyntax
            Debug.Assert(kind.IsOrdering())
            Debug.Assert(expression IsNot Nothing)
            Return New OrderingSyntax(kind, expression, ascendingOrDescendingKeyword)
        End Function


        ''' <summary>
        ''' Represents the "Select" query operator.
        ''' </summary>
        ''' <param name="selectKeyword">
        ''' The "Select" keyword.
        ''' </param>
        ''' <param name="variables">
        ''' The list of expression range variables being defined by the Select query
        ''' operator.
        ''' </param>
        Friend Shared Function SelectClause(selectKeyword As KeywordSyntax, variables As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.ExpressionRangeVariableSyntax)) As SelectClauseSyntax
            Debug.Assert(selectKeyword IsNot Nothing AndAlso selectKeyword.Kind = SyntaxKind.SelectKeyword)
            Return New SelectClauseSyntax(SyntaxKind.SelectClause, selectKeyword, variables.Node)
        End Function


        ''' <summary>
        ''' Represents and XML Document literal expression.
        ''' </summary>
        Friend Shared Function XmlDocument(declaration As XmlDeclarationSyntax, precedingMisc As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), root As XmlNodeSyntax, followingMisc As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode)) As XmlDocumentSyntax
            Debug.Assert(declaration IsNot Nothing)
            Debug.Assert(root IsNot Nothing)
            Return New XmlDocumentSyntax(SyntaxKind.XmlDocument, declaration, precedingMisc.Node, root, followingMisc.Node)
        End Function


        ''' <summary>
        ''' Represents the XML declaration prologue in an XML literal expression.
        ''' </summary>
        Friend Shared Function XmlDeclaration(lessThanQuestionToken As PunctuationSyntax, xmlKeyword As KeywordSyntax, version As XmlDeclarationOptionSyntax, encoding As XmlDeclarationOptionSyntax, standalone As XmlDeclarationOptionSyntax, questionGreaterThanToken As PunctuationSyntax) As XmlDeclarationSyntax
            Debug.Assert(lessThanQuestionToken IsNot Nothing AndAlso lessThanQuestionToken.Kind = SyntaxKind.LessThanQuestionToken)
            Debug.Assert(xmlKeyword IsNot Nothing AndAlso xmlKeyword.Kind = SyntaxKind.XmlKeyword)
            Debug.Assert(version IsNot Nothing)
            Debug.Assert(questionGreaterThanToken IsNot Nothing AndAlso questionGreaterThanToken.Kind = SyntaxKind.QuestionGreaterThanToken)
            Return New XmlDeclarationSyntax(SyntaxKind.XmlDeclaration, lessThanQuestionToken, xmlKeyword, version, encoding, standalone, questionGreaterThanToken)
        End Function


        ''' <summary>
        ''' Represents an XML document prologue option - version, encoding, standalone or
        ''' whitespace in an XML literal expression.
        ''' </summary>
        Friend Shared Function XmlDeclarationOption(name As XmlNameTokenSyntax, equals As PunctuationSyntax, value As XmlStringSyntax) As XmlDeclarationOptionSyntax
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.XmlNameToken)
            Debug.Assert(equals IsNot Nothing AndAlso equals.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(value IsNot Nothing)
            Return New XmlDeclarationOptionSyntax(SyntaxKind.XmlDeclarationOption, name, equals, value)
        End Function


        ''' <summary>
        ''' Represents an XML element with content in an XML literal expression.
        ''' </summary>
        Friend Shared Function XmlElement(startTag As XmlElementStartTagSyntax, content As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), endTag As XmlElementEndTagSyntax) As XmlElementSyntax
            Debug.Assert(startTag IsNot Nothing)
            Debug.Assert(endTag IsNot Nothing)
            Return New XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag)
        End Function


        ''' <summary>
        ''' Represents Xml text.
        ''' </summary>
        ''' <param name="textTokens">
        ''' A list of all the text tokens in the Xml text. This list always contains at
        ''' least one token.
        ''' </param>
        Friend Shared Function XmlText(textTokens As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode)) As XmlTextSyntax
            Return New XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node)
        End Function


        ''' <summary>
        ''' Represents the start tag of an XML element of the form &lt;element&gt;.
        ''' </summary>
        Friend Shared Function XmlElementStartTag(lessThanToken As PunctuationSyntax, name As XmlNodeSyntax, attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), greaterThanToken As PunctuationSyntax) As XmlElementStartTagSyntax
            Debug.Assert(lessThanToken IsNot Nothing AndAlso lessThanToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(greaterThanToken IsNot Nothing AndAlso greaterThanToken.Kind = SyntaxKind.GreaterThanToken)
            Return New XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken)
        End Function


        ''' <summary>
        ''' Represents the end tag of an XML element of the form &lt;/element&gt;.
        ''' </summary>
        Friend Shared Function XmlElementEndTag(lessThanSlashToken As PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As PunctuationSyntax) As XmlElementEndTagSyntax
            Debug.Assert(lessThanSlashToken IsNot Nothing AndAlso lessThanSlashToken.Kind = SyntaxKind.LessThanSlashToken)
            Debug.Assert(greaterThanToken IsNot Nothing AndAlso greaterThanToken.Kind = SyntaxKind.GreaterThanToken)
            Return New XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken)
        End Function


        ''' <summary>
        ''' Represents an empty XML element of the form &lt;element /&gt;
        ''' </summary>
        Friend Shared Function XmlEmptyElement(lessThanToken As PunctuationSyntax, name As XmlNodeSyntax, attributes As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), slashGreaterThanToken As PunctuationSyntax) As XmlEmptyElementSyntax
            Debug.Assert(lessThanToken IsNot Nothing AndAlso lessThanToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(slashGreaterThanToken IsNot Nothing AndAlso slashGreaterThanToken.Kind = SyntaxKind.SlashGreaterThanToken)
            Return New XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken)
        End Function


        ''' <summary>
        ''' Represents an XML attribute in an XML literal expression.
        ''' </summary>
        Friend Shared Function XmlAttribute(name As XmlNodeSyntax, equalsToken As PunctuationSyntax, value As XmlNodeSyntax) As XmlAttributeSyntax
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(value IsNot Nothing)
            Return New XmlAttributeSyntax(SyntaxKind.XmlAttribute, name, equalsToken, value)
        End Function


        ''' <summary>
        ''' Represents a string of XML characters embedded as the content of an XML
        ''' element.
        ''' </summary>
        Friend Shared Function XmlString(startQuoteToken As PunctuationSyntax, textTokens As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), endQuoteToken As PunctuationSyntax) As XmlStringSyntax
            Debug.Assert(startQuoteToken IsNot Nothing AndAlso startQuoteToken.Kind.IsXmlStringStartQuoteToken)
            Debug.Assert(endQuoteToken IsNot Nothing AndAlso endQuoteToken.Kind.IsXmlStringEndQuoteToken)
            Return New XmlStringSyntax(SyntaxKind.XmlString, startQuoteToken, textTokens.Node, endQuoteToken)
        End Function


        ''' <summary>
        ''' Represents an XML name of the form 'name' or 'namespace:name' appearing in
        ''' source as part of an XML literal or member access expression or an XML
        ''' namespace import clause.
        ''' </summary>
        Friend Shared Function XmlName(prefix As XmlPrefixSyntax, localName As XmlNameTokenSyntax) As XmlNameSyntax
            Debug.Assert(localName IsNot Nothing AndAlso localName.Kind = SyntaxKind.XmlNameToken)
            Return New XmlNameSyntax(SyntaxKind.XmlName, prefix, localName)
        End Function


        ''' <summary>
        ''' Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
        ''' of an XML literal or member access expression or an XML namespace import
        ''' clause.
        ''' </summary>
        Friend Shared Function XmlBracketedName(lessThanToken As PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As PunctuationSyntax) As XmlBracketedNameSyntax
            Debug.Assert(lessThanToken IsNot Nothing AndAlso lessThanToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(greaterThanToken IsNot Nothing AndAlso greaterThanToken.Kind = SyntaxKind.GreaterThanToken)
            Return New XmlBracketedNameSyntax(SyntaxKind.XmlBracketedName, lessThanToken, name, greaterThanToken)
        End Function


        ''' <summary>
        ''' Represents and XML namespace prefix of the form 'prefix:' as in xml:ns="".
        ''' </summary>
        Friend Shared Function XmlPrefix(name As XmlNameTokenSyntax, colonToken As PunctuationSyntax) As XmlPrefixSyntax
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.XmlNameToken)
            Debug.Assert(colonToken IsNot Nothing AndAlso colonToken.Kind = SyntaxKind.ColonToken)
            Return New XmlPrefixSyntax(SyntaxKind.XmlPrefix, name, colonToken)
        End Function


        ''' <summary>
        ''' Represents an XML comment of the form &lt;-- Comment --&gt; appearing in an XML
        ''' literal expression.
        ''' </summary>
        Friend Shared Function XmlComment(lessThanMinusMinusToken As PunctuationSyntax, textTokens As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), minusMinusGreaterThanToken As PunctuationSyntax) As XmlCommentSyntax
            Debug.Assert(lessThanMinusMinusToken IsNot Nothing AndAlso lessThanMinusMinusToken.Kind = SyntaxKind.LessThanMinusMinusToken)
            Debug.Assert(minusMinusGreaterThanToken IsNot Nothing AndAlso minusMinusGreaterThanToken.Kind = SyntaxKind.MinusMinusGreaterThanToken)
            Return New XmlCommentSyntax(SyntaxKind.XmlComment, lessThanMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken)
        End Function


        ''' <summary>
        ''' Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
        ''' XMLProcessingValue ?&gt;'.
        ''' </summary>
        Friend Shared Function XmlProcessingInstruction(lessThanQuestionToken As PunctuationSyntax, name As XmlNameTokenSyntax, textTokens As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), questionGreaterThanToken As PunctuationSyntax) As XmlProcessingInstructionSyntax
            Debug.Assert(lessThanQuestionToken IsNot Nothing AndAlso lessThanQuestionToken.Kind = SyntaxKind.LessThanQuestionToken)
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.XmlNameToken)
            Debug.Assert(questionGreaterThanToken IsNot Nothing AndAlso questionGreaterThanToken.Kind = SyntaxKind.QuestionGreaterThanToken)
            Return New XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, lessThanQuestionToken, name, textTokens.Node, questionGreaterThanToken)
        End Function


        ''' <summary>
        ''' Represents an XML CDATA section in an XML literal expression.
        ''' </summary>
        Friend Shared Function XmlCDataSection(beginCDataToken As PunctuationSyntax, textTokens As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode), endCDataToken As PunctuationSyntax) As XmlCDataSectionSyntax
            Debug.Assert(beginCDataToken IsNot Nothing AndAlso beginCDataToken.Kind = SyntaxKind.BeginCDataToken)
            Debug.Assert(endCDataToken IsNot Nothing AndAlso endCDataToken.Kind = SyntaxKind.EndCDataToken)
            Return New XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, beginCDataToken, textTokens.Node, endCDataToken)
        End Function


        ''' <summary>
        ''' Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
        ''' obj.Name =%&gt;&lt;/name&gt;'.
        ''' </summary>
        Friend Shared Function XmlEmbeddedExpression(lessThanPercentEqualsToken As PunctuationSyntax, expression As ExpressionSyntax, percentGreaterThanToken As PunctuationSyntax) As XmlEmbeddedExpressionSyntax
            Debug.Assert(lessThanPercentEqualsToken IsNot Nothing AndAlso lessThanPercentEqualsToken.Kind = SyntaxKind.LessThanPercentEqualsToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(percentGreaterThanToken IsNot Nothing AndAlso percentGreaterThanToken.Kind = SyntaxKind.PercentGreaterThanToken)
            Return New XmlEmbeddedExpressionSyntax(SyntaxKind.XmlEmbeddedExpression, lessThanPercentEqualsToken, expression, percentGreaterThanToken)
        End Function


        ''' <summary>
        ''' Represents an array type, such as "A() or "A(,)", without bounds specified for
        ''' the array.
        ''' </summary>
        ''' <param name="elementType">
        ''' The type of the elements of the array.
        ''' </param>
        ''' <param name="rankSpecifiers">
        ''' Represents the list of "()" or "(,,)" modifiers on the array type.
        ''' </param>
        Friend Shared Function ArrayType(elementType As TypeSyntax, rankSpecifiers As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode)) As ArrayTypeSyntax
            Debug.Assert(elementType IsNot Nothing)
            Return New ArrayTypeSyntax(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node)
        End Function


        ''' <summary>
        ''' A type name that represents a nullable type, such as "Integer?".
        ''' </summary>
        ''' <param name="elementType">
        ''' The kind of type that is this type is a nullable of. Cannot be an array type or
        ''' a nullable type.
        ''' </param>
        ''' <param name="questionMarkToken">
        ''' The "?" token.
        ''' </param>
        Friend Shared Function NullableType(elementType As TypeSyntax, questionMarkToken As PunctuationSyntax) As NullableTypeSyntax
            Debug.Assert(elementType IsNot Nothing)
            Debug.Assert(questionMarkToken IsNot Nothing AndAlso questionMarkToken.Kind = SyntaxKind.QuestionToken)
            Return New NullableTypeSyntax(SyntaxKind.NullableType, elementType, questionMarkToken)
        End Function


        ''' <summary>
        ''' Represents an occurrence of a Visual Basic built-in type such as Integer or
        ''' String in source code.
        ''' </summary>
        ''' <param name="keyword">
        ''' The keyword that was used to describe the built-in type.
        ''' </param>
        Friend Shared Function PredefinedType(keyword As KeywordSyntax) As PredefinedTypeSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind.IsPredefinedTypeKeyword)
            Return New PredefinedTypeSyntax(SyntaxKind.PredefinedType, keyword)
        End Function


        ''' <summary>
        ''' Represents a type name consisting of a single identifier (which might include
        ''' brackets or a type character).
        ''' </summary>
        ''' <param name="identifier">
        ''' The identifier in the name.
        ''' </param>
        Friend Shared Function IdentifierName(identifier As IdentifierTokenSyntax) As IdentifierNameSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier)
        End Function


        ''' <summary>
        ''' Represents a simple type name with one or more generic arguments, such as "X(Of
        ''' Y, Z).
        ''' </summary>
        ''' <param name="identifier">
        ''' The identifier in the name.
        ''' </param>
        ''' <param name="typeArgumentList">
        ''' The generic argument list.
        ''' </param>
        Friend Shared Function GenericName(identifier As IdentifierTokenSyntax, typeArgumentList As TypeArgumentListSyntax) As GenericNameSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(typeArgumentList IsNot Nothing)
            Return New GenericNameSyntax(SyntaxKind.GenericName, identifier, typeArgumentList)
        End Function


        ''' <summary>
        ''' Represents a qualified type name, for example X.Y or X(Of Z).Y.
        ''' </summary>
        ''' <param name="left">
        ''' The part of the name that appears to the left of the dot. This can itself be
        ''' any name.
        ''' </param>
        ''' <param name="dotToken">
        ''' The "." token that separates the names.
        ''' </param>
        ''' <param name="right">
        ''' The part of the name that appears to the right of the dot. This must be a
        ''' simple identifier.
        ''' </param>
        Friend Shared Function QualifiedName(left As NameSyntax, dotToken As PunctuationSyntax, right As SimpleNameSyntax) As QualifiedNameSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(dotToken IsNot Nothing AndAlso dotToken.Kind = SyntaxKind.DotToken)
            Debug.Assert(right IsNot Nothing)
            Return New QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right)
        End Function


        ''' <summary>
        ''' Represents a name in the global namespace.
        ''' </summary>
        ''' <param name="globalKeyword">
        ''' The "Global" keyword.
        ''' </param>
        Friend Shared Function GlobalName(globalKeyword As KeywordSyntax) As GlobalNameSyntax
            Debug.Assert(globalKeyword IsNot Nothing AndAlso globalKeyword.Kind = SyntaxKind.GlobalKeyword)
            Return New GlobalNameSyntax(SyntaxKind.GlobalName, globalKeyword)
        End Function


        ''' <summary>
        ''' Represents a parenthesized list of generic type arguments.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="ofKeyword">
        ''' The "Of" keyword.
        ''' </param>
        ''' <param name="arguments">
        ''' A list of all the type arguments.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function TypeArgumentList(openParenToken As PunctuationSyntax, ofKeyword As KeywordSyntax, arguments As InternalSyntax.SeparatedSyntaxList(of InternalSyntax.TypeSyntax), closeParenToken As PunctuationSyntax) As TypeArgumentListSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(ofKeyword IsNot Nothing AndAlso ofKeyword.Kind = SyntaxKind.OfKeyword)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, openParenToken, ofKeyword, arguments.Node, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents an Xml NCName per Namespaces in XML 1.0
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function XmlNameToken(text as String, possibleKeywordKind As SyntaxKind, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode) As XmlNameTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New XmlNameTokenSyntax(SyntaxKind.XmlNameToken, text, leadingTrivia, trailingTrivia, possibleKeywordKind)
        End Function


        ''' <summary>
        ''' Represents character data in Xml content also known as PCData or in an Xml
        ''' attribute value. All text is here for now even text that does not need
        ''' normalization such as comment, pi and cdata text.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function XmlTextLiteralToken(text as String, value As String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode) As XmlTextTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New XmlTextTokenSyntax(SyntaxKind.XmlTextLiteralToken, text, leadingTrivia, trailingTrivia, value)
        End Function


        ''' <summary>
        ''' Represents character data in Xml content also known as PCData or in an Xml
        ''' attribute value. All text is here for now even text that does not need
        ''' normalization such as comment, pi and cdata text.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function XmlEntityLiteralToken(text as String, value As String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode) As XmlTextTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New XmlTextTokenSyntax(SyntaxKind.XmlEntityLiteralToken, text, leadingTrivia, trailingTrivia, value)
        End Function


        ''' <summary>
        ''' Represents character data in Xml content also known as PCData or in an Xml
        ''' attribute value. All text is here for now even text that does not need
        ''' normalization such as comment, pi and cdata text.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function DocCommentLineBreakToken(text as String, value As String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode) As XmlTextTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New XmlTextTokenSyntax(SyntaxKind.DocCommentLineBreakToken, text, leadingTrivia, trailingTrivia, value)
        End Function


        ''' <summary>
        ''' Represents character data in Xml content also known as PCData or in an Xml
        ''' attribute value. All text is here for now even text that does not need
        ''' normalization such as comment, pi and cdata text.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of XmlTextTokenSyntax.
        ''' One of XmlTextLiteralToken, XmlEntityLiteralToken, DocCommentLineBreakToken.
        ''' </param>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function XmlTextToken(kind As SyntaxKind, text as String, value As String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode) As XmlTextTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Debug.Assert(kind.IsXmlTextToken())
            Return New XmlTextTokenSyntax(kind, text, leadingTrivia, trailingTrivia, value)
        End Function


        ''' <summary>
        ''' Represents a Decimal literal token.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function DecimalLiteralToken(text as String, typeSuffix As TypeCharacter, value As System.Decimal, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode) As DecimalLiteralTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New DecimalLiteralTokenSyntax(SyntaxKind.DecimalLiteralToken, text, leadingTrivia, trailingTrivia, typeSuffix, value)
        End Function


        ''' <summary>
        ''' Represents an Date literal token.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function DateLiteralToken(text as String, value As DateTime, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode) As DateLiteralTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New DateLiteralTokenSyntax(SyntaxKind.DateLiteralToken, text, leadingTrivia, trailingTrivia, value)
        End Function


        ''' <summary>
        ''' Represents an string literal token.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function StringLiteralToken(text as String, value As String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode) As StringLiteralTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New StringLiteralTokenSyntax(SyntaxKind.StringLiteralToken, text, leadingTrivia, trailingTrivia, value)
        End Function


        ''' <summary>
        ''' Represents an string literal token.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function CharacterLiteralToken(text as String, value As Char, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode) As CharacterLiteralTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New CharacterLiteralTokenSyntax(SyntaxKind.CharacterLiteralToken, text, leadingTrivia, trailingTrivia, value)
        End Function


        ''' <summary>
        ''' Represents tokens that were skipped by the parser as part of error recovery,
        ''' and thus are not part of any syntactic structure.
        ''' </summary>
        ''' <param name="tokens">
        ''' The list of tokens that were skipped by the parser.
        ''' </param>
        Friend Shared Function SkippedTokens(tokens As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode)) As SkippedTokensSyntax
            Return New SkippedTokensSyntax(SyntaxKind.SkippedTokens, tokens.Node)
        End Function


        ''' <summary>
        ''' Represents a documentation comment e.g. ''' &lt;Summary&gt; apearing in source.
        ''' </summary>
        Friend Shared Function DocumentationComment(content As InternalSyntax.SyntaxList(of InternalSyntax.SyntaxNode)) As DocumentationCommentSyntax
            Return New DocumentationCommentSyntax(SyntaxKind.DocumentationComment, content.Node)
        End Function


        ''' <summary>
        ''' Represents a preprocessor directive
        ''' </summary>
        ''' <param name="terminator">
        ''' The statement terminator token that ended the Directive.
        ''' </param>
        Friend Shared Function Directive(directiveParameter As DirectiveStatementSyntax, terminator As PunctuationSyntax) As DirectiveSyntax
            Debug.Assert(directiveParameter IsNot Nothing)
            Debug.Assert(terminator IsNot Nothing AndAlso terminator.Kind.IsDirectiveTerminator)
            Return New DirectiveSyntax(SyntaxKind.Directive, directiveParameter, terminator)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function WhitespaceTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.WhitespaceTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function EndOfLineTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.EndOfLineTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function ColonTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.ColonTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function CommentTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.CommentTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function LineContinuationTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.LineContinuationTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function ImplicitLineContinuationTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.ImplicitLineContinuationTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function DocumentationCommentExteriorTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.DocumentationCommentExteriorTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function DisabledTextTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.DisabledTextTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="kind">
        ''' A <cref c="SyntaxKind"/> representing the specific kind of SyntaxTrivia. One of
        ''' WhitespaceTrivia, EndOfLineTrivia, ColonTrivia, CommentTrivia,
        ''' LineContinuationTrivia, ImplicitLineContinuationTrivia,
        ''' DocumentationCommentExteriorTrivia, DisabledTextTrivia.
        ''' </param>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function SyntaxTrivia(kind As SyntaxKind, text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Debug.Assert(kind.IsSyntaxTrivia())
            Return New SyntaxTrivia(kind, text)
        End Function


        ''' <summary>
        ''' Represents a #Const pre-processing constant declaration appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        ''' <param name="constKeyword">
        ''' The "Const" keyword.
        ''' </param>
        ''' <param name="name">
        ''' The name of the pre-processing constant being defined.
        ''' </param>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        ''' <param name="value">
        ''' An expression representing the value of the pre-processing constant being
        ''' defined.
        ''' </param>
        Friend Shared Function ConstDirective(hashToken As PunctuationSyntax, constKeyword As KeywordSyntax, name As IdentifierTokenSyntax, equalsToken As PunctuationSyntax, value As ExpressionSyntax) As ConstDirectiveSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(constKeyword IsNot Nothing AndAlso constKeyword.Kind = SyntaxKind.ConstKeyword)
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(value IsNot Nothing)
            Return New ConstDirectiveSyntax(SyntaxKind.ConstDirective, hashToken, constKeyword, name, equalsToken, value)
        End Function


        ''' <summary>
        ''' Represents the beginning of an #If pre-processing directive appearing in
        ''' source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function IfDirective(hashToken As PunctuationSyntax, elseKeyword As KeywordSyntax, ifOrElseIfKeyword As KeywordSyntax, condition As ExpressionSyntax, thenKeyword As KeywordSyntax) As IfDirectiveSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(ifOrElseIfKeyword IsNot Nothing AndAlso ifOrElseIfKeyword.Kind.IsIfDirectiveIfOrElseIfKeyword)
            Debug.Assert(condition IsNot Nothing)
            Return New IfDirectiveSyntax(SyntaxKind.IfDirective, hashToken, elseKeyword, ifOrElseIfKeyword, condition, thenKeyword)
        End Function


        ''' <summary>
        ''' Represents the beginning of an #If pre-processing directive appearing in
        ''' source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function ElseIfDirective(hashToken As PunctuationSyntax, elseKeyword As KeywordSyntax, ifOrElseIfKeyword As KeywordSyntax, condition As ExpressionSyntax, thenKeyword As KeywordSyntax) As IfDirectiveSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(ifOrElseIfKeyword IsNot Nothing AndAlso ifOrElseIfKeyword.Kind.IsIfDirectiveIfOrElseIfKeyword)
            Debug.Assert(condition IsNot Nothing)
            Return New IfDirectiveSyntax(SyntaxKind.ElseIfDirective, hashToken, elseKeyword, ifOrElseIfKeyword, condition, thenKeyword)
        End Function


        ''' <summary>
        ''' Represents an #Else pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function ElseDirective(hashToken As PunctuationSyntax, elseKeyword As KeywordSyntax) As ElseDirectiveSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(elseKeyword IsNot Nothing AndAlso elseKeyword.Kind = SyntaxKind.ElseKeyword)
            Return New ElseDirectiveSyntax(SyntaxKind.ElseDirective, hashToken, elseKeyword)
        End Function


        ''' <summary>
        ''' Represents an #End If pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function EndIfDirective(hashToken As PunctuationSyntax, endKeyword As KeywordSyntax, ifKeyword As KeywordSyntax) As EndIfDirectiveSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(ifKeyword IsNot Nothing AndAlso ifKeyword.Kind = SyntaxKind.IfKeyword)
            Return New EndIfDirectiveSyntax(SyntaxKind.EndIfDirective, hashToken, endKeyword, ifKeyword)
        End Function


        ''' <summary>
        ''' Represents the beginning of a #Region directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        ''' <param name="regionKeyword">
        ''' The "Region" keyword.
        ''' </param>
        ''' <param name="name">
        ''' The label of the code region being defined.
        ''' </param>
        Friend Shared Function RegionDirective(hashToken As PunctuationSyntax, regionKeyword As KeywordSyntax, name As StringLiteralTokenSyntax) As RegionDirectiveSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(regionKeyword IsNot Nothing AndAlso regionKeyword.Kind = SyntaxKind.RegionKeyword)
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.StringLiteralToken)
            Return New RegionDirectiveSyntax(SyntaxKind.RegionDirective, hashToken, regionKeyword, name)
        End Function


        ''' <summary>
        ''' Represents an #End Region directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        ''' <param name="endKeyword">
        ''' The "End" keyword.
        ''' </param>
        ''' <param name="regionKeyword">
        ''' The "Region" keyword.
        ''' </param>
        Friend Shared Function EndRegionDirective(hashToken As PunctuationSyntax, endKeyword As KeywordSyntax, regionKeyword As KeywordSyntax) As EndRegionDirectiveSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(regionKeyword IsNot Nothing AndAlso regionKeyword.Kind = SyntaxKind.RegionKeyword)
            Return New EndRegionDirectiveSyntax(SyntaxKind.EndRegionDirective, hashToken, endKeyword, regionKeyword)
        End Function


        ''' <summary>
        ''' Represents the beginning of a #ExternalSource pre-processing directive
        ''' appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function ExternalSourceDirective(hashToken As PunctuationSyntax, externalSourceKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, externalSource As StringLiteralTokenSyntax, commaToken As PunctuationSyntax, lineStart As IntegerLiteralTokenSyntax, closeParenToken As PunctuationSyntax) As ExternalSourceDirectiveSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(externalSourceKeyword IsNot Nothing AndAlso externalSourceKeyword.Kind = SyntaxKind.ExternalSourceKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(externalSource IsNot Nothing AndAlso externalSource.Kind = SyntaxKind.StringLiteralToken)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(lineStart IsNot Nothing AndAlso lineStart.Kind = SyntaxKind.IntegerLiteralToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New ExternalSourceDirectiveSyntax(SyntaxKind.ExternalSourceDirective, hashToken, externalSourceKeyword, openParenToken, externalSource, commaToken, lineStart, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents an #End ExternalSource pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function EndExternalSourceDirective(hashToken As PunctuationSyntax, endKeyword As KeywordSyntax, externalSourceKeyword As KeywordSyntax) As EndExternalSourceDirective
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(externalSourceKeyword IsNot Nothing AndAlso externalSourceKeyword.Kind = SyntaxKind.ExternalSourceKeyword)
            Return New EndExternalSourceDirective(SyntaxKind.EndExternalSourceDirective, hashToken, endKeyword, externalSourceKeyword)
        End Function


        ''' <summary>
        ''' Represents an #ExternalChecksum pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function ExternalChecksumDirective(hashToken As PunctuationSyntax, externalChecksumKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, externalSource As StringLiteralTokenSyntax, firstCommaToken As PunctuationSyntax, guid As StringLiteralTokenSyntax, secondCommaToken As PunctuationSyntax, checksum As StringLiteralTokenSyntax, closeParenToken As PunctuationSyntax) As ExternalChecksumDirectiveSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(externalChecksumKeyword IsNot Nothing AndAlso externalChecksumKeyword.Kind = SyntaxKind.ExternalChecksumKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(externalSource IsNot Nothing AndAlso externalSource.Kind = SyntaxKind.StringLiteralToken)
            Debug.Assert(firstCommaToken IsNot Nothing AndAlso firstCommaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(guid IsNot Nothing AndAlso guid.Kind = SyntaxKind.StringLiteralToken)
            Debug.Assert(secondCommaToken IsNot Nothing AndAlso secondCommaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(checksum IsNot Nothing AndAlso checksum.Kind = SyntaxKind.StringLiteralToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New ExternalChecksumDirectiveSyntax(SyntaxKind.ExternalChecksumDirective, hashToken, externalChecksumKeyword, openParenToken, externalSource, firstCommaToken, guid, secondCommaToken, checksum, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents an #r directive appearing in scripts.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function ReferenceDirective(hashToken As PunctuationSyntax, referenceKeyword As KeywordSyntax, file As StringLiteralTokenSyntax) As ReferenceDirectiveSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(referenceKeyword IsNot Nothing AndAlso referenceKeyword.Kind = SyntaxKind.ReferenceKeyword)
            Debug.Assert(file IsNot Nothing AndAlso file.Kind = SyntaxKind.StringLiteralToken)
            Return New ReferenceDirectiveSyntax(SyntaxKind.ReferenceDirective, hashToken, referenceKeyword, file)
        End Function


        ''' <summary>
        ''' Represents an unrecognized pre-processing directive. This occurs when the
        ''' parser encounters a hash '#' token at the beginning of a physical line but does
        ''' recognize the text that follows as a valid Visual Basic pre-processing
        ''' directive.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function BadDirective(hashToken As PunctuationSyntax) As BadDirectiveSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Return New BadDirectiveSyntax(SyntaxKind.BadDirective, hashToken)
        End Function

    End Class
End Namespace
