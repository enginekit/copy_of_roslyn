' <auto-generated />

Imports System
Imports System.Collections
Imports System.Collections.Generic
Imports System.Diagnostics
Imports System.Linq
Imports System.Runtime.CompilerServices
Imports System.Threading
Imports System.Text
Imports Roslyn.Compilers.Internal
Imports Roslyn.Compilers.Collections

Namespace Roslyn.Compilers.VisualBasic
    Friend Enum BoundKind as Byte
        TypeArguments
        OmittedArgument
        LValuePlaceholderRValueWrapper
        WithLValueExpressionPlaceholder
        WithRValueExpressionPlaceholder
        ValuePlaceholder
        BadExpression
        BadStatement
        Parenthesized
        BadVariable
        ArrayAccess
        ArrayLength
        [GetType]
        TypeExpression
        TypeOrValueExpression
        NamespaceExpression
        UnaryOperator
        UserDefinedUnaryOperator
        NullableIsTrueOperator
        BinaryOperator
        CompoundAssignmentTargetPlaceholder
        AssignmentOperator
        ReferenceAssignment
        AddressOfOperator
        TernaryConditionalExpression
        BinaryConditionalExpression
        Conversion
        UserDefinedConversion
        [DirectCast]
        [TryCast]
        [TypeOf]
        SequencePoint
        SequencePointExpression
        SequencePointWithSpan
        NoOpStatement
        MethodGroup
        PropertyGroup
        ReturnStatement
        ThrowStatement
        RedimStatement
        RedimClause
        [Call]
        Attribute
        LateCall
        ObjectCreationExpression
        AnonymousTypeCreationExpression
        AnonymousTypePropertyAccess
        AnonymousTypeFieldInitializer
        NewT
        DelegateCreationExpression
        ArrayCreation
        ArrayInitialization
        FieldAccess
        PropertyAccess
        EventAccess
        Block
        LocalDeclaration
        AsNewLocalDeclarations
        DimStatement
        Initializer
        FieldOrPropertyInitializer
        GlobalStatementInitializer
        Sequence
        ExpressionStatement
        IfStatement
        SelectStatement
        CaseBlock
        CaseStatement
        CaseValueClause
        CaseRangeClause
        CaseRelationalClause
        DoLoopStatement
        WhileStatement
        ForToStatement
        ForEachStatement
        ExitStatement
        ContinueStatement
        TryStatement
        CatchBlock
        Literal
        MeReference
        MyBaseReference
        MyClassReference
        PreviousSubmissionReference
        HostObjectMemberReference
        Local
        Parameter
        ByRefArgumentPlaceholder
        ByRefArgumentWithCopyBack
        LabelStatement
        Label
        GotoStatement
        StatementList
        ConditionalGoto
        WithStatement
        UnboundLambda
        Lambda
        QueryExpression
        QuerySource
        ToQueryableCollectionConversion
        QueryableSource
        QueryClause
        Ordering
        QueryLambda
        RangeVariableAssignment
        GroupTypeInferenceLambda
        AggregateClause
        GroupAggregation
        RangeVariable
        AddHandlerStatement
        RemoveHandlerStatement
        RaiseEventStatement
        UsingStatement
        SyncLockStatement
        XmlName
        XmlDocument
        XmlDeclaration
        XmlProcessingInstruction
        XmlComment
        XmlAttribute
        XmlElement
        XmlMemberAccess
        XmlEmbeddedExpression
    End Enum









    Friend MustInherit Partial Class BoundExpression
        Inherits BoundNode

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(kind, syntax, hasErrors)
            Me._Type = type
        End Sub

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, type As TypeSymbol)
            MyBase.New(kind, syntax)
            Me._Type = type
        End Sub


        Private ReadOnly _Type As TypeSymbol
        Public ReadOnly Property Type As TypeSymbol
            Get
                Return _Type
            End Get
        End Property
    End Class

    Friend NotInheritable Partial Class BoundTypeArguments
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, arguments As ReadOnlyArray(Of TypeSymbol), hasErrors As Boolean)
            MyBase.New(BoundKind.TypeArguments, syntax, Nothing, hasErrors)

            Debug.Assert(Not (arguments.IsNull), "Field 'arguments' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Arguments = arguments
        End Sub

        Public Sub New(syntax As SyntaxNode, arguments As ReadOnlyArray(Of TypeSymbol))
            MyBase.New(BoundKind.TypeArguments, syntax, Nothing)

            Debug.Assert(Not (arguments.IsNull), "Field 'arguments' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Arguments = arguments
        End Sub


        Private ReadOnly _Arguments As ReadOnlyArray(Of TypeSymbol)
        Public ReadOnly Property Arguments As ReadOnlyArray(Of TypeSymbol)
            Get
                Return _Arguments
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitTypeArguments(Me)
        End Function

        Public Function Update(arguments As ReadOnlyArray(Of TypeSymbol)) As BoundTypeArguments
            If arguments <> Me.Arguments Then
                Dim result = New BoundTypeArguments(Me.Syntax, arguments, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundOmittedArgument
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, hasErrors As Boolean)
            MyBase.New(BoundKind.OmittedArgument, syntax, Nothing, hasErrors)
        End Sub

        Public Sub New(syntax As SyntaxNode)
            MyBase.New(BoundKind.OmittedArgument, syntax, Nothing)
        End Sub


        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitOmittedArgument(Me)
        End Function

        Public Function Update() As BoundOmittedArgument
            Return Me
        End Function
    End Class

    Friend MustInherit Partial Class BoundValuePlaceholderBase
        Inherits BoundExpression

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(kind, syntax, type, hasErrors)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

        End Sub

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, type As TypeSymbol)
            MyBase.New(kind, syntax, type)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

        End Sub

    End Class

    Friend NotInheritable Partial Class BoundLValuePlaceholderRValueWrapper
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, placeholder As BoundValuePlaceholderBase, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.LValuePlaceholderRValueWrapper, syntax, type, hasErrors OrElse placeholder.NonNullAndHasErrors())

            Debug.Assert(placeholder IsNot Nothing, "Field 'placeholder' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Placeholder = placeholder
        End Sub


        Private ReadOnly _Placeholder As BoundValuePlaceholderBase
        Public ReadOnly Property Placeholder As BoundValuePlaceholderBase
            Get
                Return _Placeholder
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitLValuePlaceholderRValueWrapper(Me)
        End Function

        Public Function Update(placeholder As BoundValuePlaceholderBase, type As TypeSymbol) As BoundLValuePlaceholderRValueWrapper
            If placeholder IsNot Me.Placeholder OrElse type IsNot Me.Type Then
                Dim result = New BoundLValuePlaceholderRValueWrapper(Me.Syntax, placeholder, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend MustInherit Partial Class BoundWithExpressionPlaceholderBase
        Inherits BoundValuePlaceholderBase

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, draftSubstitutor As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(kind, syntax, type, hasErrors)

            Debug.Assert(draftSubstitutor IsNot Nothing, "Field 'draftSubstitutor' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._DraftSubstitutor = draftSubstitutor
        End Sub


        Private ReadOnly _DraftSubstitutor As BoundExpression
        Public ReadOnly Property DraftSubstitutor As BoundExpression
            Get
                Return _DraftSubstitutor
            End Get
        End Property
    End Class

    Friend NotInheritable Partial Class BoundWithLValueExpressionPlaceholder
        Inherits BoundWithExpressionPlaceholderBase

        Public Sub New(syntax As SyntaxNode, draftSubstitutor As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.WithLValueExpressionPlaceholder, syntax, draftSubstitutor, type, hasErrors OrElse draftSubstitutor.NonNullAndHasErrors())

            Debug.Assert(draftSubstitutor IsNot Nothing, "Field 'draftSubstitutor' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

        End Sub


        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitWithLValueExpressionPlaceholder(Me)
        End Function

        Public Function Update(draftSubstitutor As BoundExpression, type As TypeSymbol) As BoundWithLValueExpressionPlaceholder
            If draftSubstitutor IsNot Me.DraftSubstitutor OrElse type IsNot Me.Type Then
                Dim result = New BoundWithLValueExpressionPlaceholder(Me.Syntax, draftSubstitutor, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundWithRValueExpressionPlaceholder
        Inherits BoundWithExpressionPlaceholderBase

        Public Sub New(syntax As SyntaxNode, draftSubstitutor As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.WithRValueExpressionPlaceholder, syntax, draftSubstitutor, type, hasErrors OrElse draftSubstitutor.NonNullAndHasErrors())

            Debug.Assert(draftSubstitutor IsNot Nothing, "Field 'draftSubstitutor' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

        End Sub


        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitWithRValueExpressionPlaceholder(Me)
        End Function

        Public Function Update(draftSubstitutor As BoundExpression, type As TypeSymbol) As BoundWithRValueExpressionPlaceholder
            If draftSubstitutor IsNot Me.DraftSubstitutor OrElse type IsNot Me.Type Then
                Dim result = New BoundWithRValueExpressionPlaceholder(Me.Syntax, draftSubstitutor, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundValuePlaceholder
        Inherits BoundValuePlaceholderBase

        Public Sub New(syntax As SyntaxNode, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.ValuePlaceholder, syntax, type, hasErrors)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")


            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub

        Public Sub New(syntax As SyntaxNode, type As TypeSymbol)
            MyBase.New(BoundKind.ValuePlaceholder, syntax, type)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")


            Validate()
        End Sub


        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitValuePlaceholder(Me)
        End Function

        Public Function Update(type As TypeSymbol) As BoundValuePlaceholder
            If type IsNot Me.Type Then
                Dim result = New BoundValuePlaceholder(Me.Syntax, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundBadExpression
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, resultKind As LookupResultKind, symbols As ReadOnlyArray(Of Symbol), childBoundNodes As ReadOnlyArray(Of BoundNode), type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.BadExpression, syntax, type, hasErrors OrElse childBoundNodes.NonNullAndHasErrors())

            Debug.Assert(Not (symbols.IsNull), "Field 'symbols' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (childBoundNodes.IsNull), "Field 'childBoundNodes' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._ResultKind = resultKind
            Me._Symbols = symbols
            Me._ChildBoundNodes = childBoundNodes
        End Sub


        Private ReadOnly _ResultKind As LookupResultKind
        Public Overrides ReadOnly Property ResultKind As LookupResultKind
            Get
                Return _ResultKind
            End Get
        End Property

        Private ReadOnly _Symbols As ReadOnlyArray(Of Symbol)
        Public ReadOnly Property Symbols As ReadOnlyArray(Of Symbol)
            Get
                Return _Symbols
            End Get
        End Property

        Private ReadOnly _ChildBoundNodes As ReadOnlyArray(Of BoundNode)
        Public ReadOnly Property ChildBoundNodes As ReadOnlyArray(Of BoundNode)
            Get
                Return _ChildBoundNodes
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitBadExpression(Me)
        End Function

        Public Function Update(resultKind As LookupResultKind, symbols As ReadOnlyArray(Of Symbol), childBoundNodes As ReadOnlyArray(Of BoundNode), type As TypeSymbol) As BoundBadExpression
            If resultKind <> Me.ResultKind OrElse symbols <> Me.Symbols OrElse childBoundNodes <> Me.ChildBoundNodes OrElse type IsNot Me.Type Then
                Dim result = New BoundBadExpression(Me.Syntax, resultKind, symbols, childBoundNodes, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundBadStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, childBoundNodes As ReadOnlyArray(Of BoundNode), Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.BadStatement, syntax, hasErrors OrElse childBoundNodes.NonNullAndHasErrors())

            Debug.Assert(Not (childBoundNodes.IsNull), "Field 'childBoundNodes' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._ChildBoundNodes = childBoundNodes
        End Sub


        Private ReadOnly _ChildBoundNodes As ReadOnlyArray(Of BoundNode)
        Public ReadOnly Property ChildBoundNodes As ReadOnlyArray(Of BoundNode)
            Get
                Return _ChildBoundNodes
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitBadStatement(Me)
        End Function

        Public Function Update(childBoundNodes As ReadOnlyArray(Of BoundNode)) As BoundBadStatement
            If childBoundNodes <> Me.ChildBoundNodes Then
                Dim result = New BoundBadStatement(Me.Syntax, childBoundNodes, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundParenthesized
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, expression As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.Parenthesized, syntax, type, hasErrors OrElse expression.NonNullAndHasErrors())

            Debug.Assert(expression IsNot Nothing, "Field 'expression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Expression = expression

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _Expression As BoundExpression
        Public ReadOnly Property Expression As BoundExpression
            Get
                Return _Expression
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitParenthesized(Me)
        End Function

        Public Function Update(expression As BoundExpression, type As TypeSymbol) As BoundParenthesized
            If expression IsNot Me.Expression OrElse type IsNot Me.Type Then
                Dim result = New BoundParenthesized(Me.Syntax, expression, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundBadVariable
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, expression As BoundExpression, isLValue As Boolean, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.BadVariable, syntax, type, hasErrors OrElse expression.NonNullAndHasErrors())

            Debug.Assert(expression IsNot Nothing, "Field 'expression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Expression = expression
            Me._IsLValue = isLValue
        End Sub


        Private ReadOnly _Expression As BoundExpression
        Public ReadOnly Property Expression As BoundExpression
            Get
                Return _Expression
            End Get
        End Property

        Private ReadOnly _IsLValue As Boolean
        Public Overrides ReadOnly Property IsLValue As Boolean
            Get
                Return _IsLValue
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitBadVariable(Me)
        End Function

        Public Function Update(expression As BoundExpression, isLValue As Boolean, type As TypeSymbol) As BoundBadVariable
            If expression IsNot Me.Expression OrElse isLValue <> Me.IsLValue OrElse type IsNot Me.Type Then
                Dim result = New BoundBadVariable(Me.Syntax, expression, isLValue, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundArrayAccess
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, expression As BoundExpression, indices As ReadOnlyArray(Of BoundExpression), isLValue As Boolean, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.ArrayAccess, syntax, type, hasErrors OrElse expression.NonNullAndHasErrors() OrElse indices.NonNullAndHasErrors())

            Debug.Assert(expression IsNot Nothing, "Field 'expression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (indices.IsNull), "Field 'indices' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Expression = expression
            Me._Indices = indices
            Me._IsLValue = isLValue
        End Sub


        Private ReadOnly _Expression As BoundExpression
        Public ReadOnly Property Expression As BoundExpression
            Get
                Return _Expression
            End Get
        End Property

        Private ReadOnly _Indices As ReadOnlyArray(Of BoundExpression)
        Public ReadOnly Property Indices As ReadOnlyArray(Of BoundExpression)
            Get
                Return _Indices
            End Get
        End Property

        Private ReadOnly _IsLValue As Boolean
        Public Overrides ReadOnly Property IsLValue As Boolean
            Get
                Return _IsLValue
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitArrayAccess(Me)
        End Function

        Public Function Update(expression As BoundExpression, indices As ReadOnlyArray(Of BoundExpression), isLValue As Boolean, type As TypeSymbol) As BoundArrayAccess
            If expression IsNot Me.Expression OrElse indices <> Me.Indices OrElse isLValue <> Me.IsLValue OrElse type IsNot Me.Type Then
                Dim result = New BoundArrayAccess(Me.Syntax, expression, indices, isLValue, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundArrayLength
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, expression As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.ArrayLength, syntax, type, hasErrors OrElse expression.NonNullAndHasErrors())

            Debug.Assert(expression IsNot Nothing, "Field 'expression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Expression = expression
        End Sub


        Private ReadOnly _Expression As BoundExpression
        Public ReadOnly Property Expression As BoundExpression
            Get
                Return _Expression
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitArrayLength(Me)
        End Function

        Public Function Update(expression As BoundExpression, type As TypeSymbol) As BoundArrayLength
            If expression IsNot Me.Expression OrElse type IsNot Me.Type Then
                Dim result = New BoundArrayLength(Me.Syntax, expression, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundGetType
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, sourceType As BoundTypeExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.GetType, syntax, type, hasErrors OrElse sourceType.NonNullAndHasErrors())

            Debug.Assert(sourceType IsNot Nothing, "Field 'sourceType' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._SourceType = sourceType
        End Sub


        Private ReadOnly _SourceType As BoundTypeExpression
        Public ReadOnly Property SourceType As BoundTypeExpression
            Get
                Return _SourceType
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitGetType(Me)
        End Function

        Public Function Update(sourceType As BoundTypeExpression, type As TypeSymbol) As BoundGetType
            If sourceType IsNot Me.SourceType OrElse type IsNot Me.Type Then
                Dim result = New BoundGetType(Me.Syntax, sourceType, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundTypeExpression
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, aliasOpt As AliasSymbol, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.TypeExpression, syntax, type, hasErrors)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._AliasOpt = aliasOpt
        End Sub

        Public Sub New(syntax As SyntaxNode, aliasOpt As AliasSymbol, type As TypeSymbol)
            MyBase.New(BoundKind.TypeExpression, syntax, type)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._AliasOpt = aliasOpt
        End Sub


        Private ReadOnly _AliasOpt As AliasSymbol
        Public ReadOnly Property AliasOpt As AliasSymbol
            Get
                Return _AliasOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitTypeExpression(Me)
        End Function

        Public Function Update(aliasOpt As AliasSymbol, type As TypeSymbol) As BoundTypeExpression
            If aliasOpt IsNot Me.AliasOpt OrElse type IsNot Me.Type Then
                Dim result = New BoundTypeExpression(Me.Syntax, aliasOpt, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundTypeOrValueExpression
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.TypeOrValueExpression, syntax, type, hasErrors)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

        End Sub

        Public Sub New(syntax As SyntaxNode, type As TypeSymbol)
            MyBase.New(BoundKind.TypeOrValueExpression, syntax, type)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

        End Sub


        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitTypeOrValueExpression(Me)
        End Function

        Public Function Update(type As TypeSymbol) As BoundTypeOrValueExpression
            If type IsNot Me.Type Then
                Dim result = New BoundTypeOrValueExpression(Me.Syntax, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundNamespaceExpression
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, aliasOpt As AliasSymbol, namespaceSymbol As NamespaceSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.NamespaceExpression, syntax, Nothing, hasErrors)

            Debug.Assert(namespaceSymbol IsNot Nothing, "Field 'namespaceSymbol' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._AliasOpt = aliasOpt
            Me._NamespaceSymbol = namespaceSymbol
        End Sub

        Public Sub New(syntax As SyntaxNode, aliasOpt As AliasSymbol, namespaceSymbol As NamespaceSymbol)
            MyBase.New(BoundKind.NamespaceExpression, syntax, Nothing)

            Debug.Assert(namespaceSymbol IsNot Nothing, "Field 'namespaceSymbol' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._AliasOpt = aliasOpt
            Me._NamespaceSymbol = namespaceSymbol
        End Sub


        Private ReadOnly _AliasOpt As AliasSymbol
        Public ReadOnly Property AliasOpt As AliasSymbol
            Get
                Return _AliasOpt
            End Get
        End Property

        Private ReadOnly _NamespaceSymbol As NamespaceSymbol
        Public ReadOnly Property NamespaceSymbol As NamespaceSymbol
            Get
                Return _NamespaceSymbol
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitNamespaceExpression(Me)
        End Function

        Public Function Update(aliasOpt As AliasSymbol, namespaceSymbol As NamespaceSymbol) As BoundNamespaceExpression
            If aliasOpt IsNot Me.AliasOpt OrElse namespaceSymbol IsNot Me.NamespaceSymbol Then
                Dim result = New BoundNamespaceExpression(Me.Syntax, aliasOpt, namespaceSymbol, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundUnaryOperator
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, operatorKind As UnaryOperatorKind, operand As BoundExpression, checked As Boolean, constantValueOpt As ConstantValue, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.UnaryOperator, syntax, type, hasErrors OrElse operand.NonNullAndHasErrors())

            Debug.Assert(operand IsNot Nothing, "Field 'operand' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._OperatorKind = operatorKind
            Me._Operand = operand
            Me._Checked = checked
            Me._ConstantValueOpt = constantValueOpt

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _OperatorKind As UnaryOperatorKind
        Public ReadOnly Property OperatorKind As UnaryOperatorKind
            Get
                Return _OperatorKind
            End Get
        End Property

        Private ReadOnly _Operand As BoundExpression
        Public ReadOnly Property Operand As BoundExpression
            Get
                Return _Operand
            End Get
        End Property

        Private ReadOnly _Checked As Boolean
        Public ReadOnly Property Checked As Boolean
            Get
                Return _Checked
            End Get
        End Property

        Private ReadOnly _ConstantValueOpt As ConstantValue
        Public Overrides ReadOnly Property ConstantValueOpt As ConstantValue
            Get
                Return _ConstantValueOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitUnaryOperator(Me)
        End Function

        Public Function Update(operatorKind As UnaryOperatorKind, operand As BoundExpression, checked As Boolean, constantValueOpt As ConstantValue, type As TypeSymbol) As BoundUnaryOperator
            If operatorKind <> Me.OperatorKind OrElse operand IsNot Me.Operand OrElse checked <> Me.Checked OrElse constantValueOpt IsNot Me.ConstantValueOpt OrElse type IsNot Me.Type Then
                Dim result = New BoundUnaryOperator(Me.Syntax, operatorKind, operand, checked, constantValueOpt, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundUserDefinedUnaryOperator
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, operatorKind As UnaryOperatorKind, underlyingExpression As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.UserDefinedUnaryOperator, syntax, type, hasErrors OrElse underlyingExpression.NonNullAndHasErrors())

            Debug.Assert(underlyingExpression IsNot Nothing, "Field 'underlyingExpression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._OperatorKind = operatorKind
            Me._UnderlyingExpression = underlyingExpression

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _OperatorKind As UnaryOperatorKind
        Public ReadOnly Property OperatorKind As UnaryOperatorKind
            Get
                Return _OperatorKind
            End Get
        End Property

        Private ReadOnly _UnderlyingExpression As BoundExpression
        Public ReadOnly Property UnderlyingExpression As BoundExpression
            Get
                Return _UnderlyingExpression
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitUserDefinedUnaryOperator(Me)
        End Function

        Public Function Update(operatorKind As UnaryOperatorKind, underlyingExpression As BoundExpression, type As TypeSymbol) As BoundUserDefinedUnaryOperator
            If operatorKind <> Me.OperatorKind OrElse underlyingExpression IsNot Me.UnderlyingExpression OrElse type IsNot Me.Type Then
                Dim result = New BoundUserDefinedUnaryOperator(Me.Syntax, operatorKind, underlyingExpression, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundNullableIsTrueOperator
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, operand As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.NullableIsTrueOperator, syntax, type, hasErrors OrElse operand.NonNullAndHasErrors())

            Debug.Assert(operand IsNot Nothing, "Field 'operand' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Operand = operand

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _Operand As BoundExpression
        Public ReadOnly Property Operand As BoundExpression
            Get
                Return _Operand
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitNullableIsTrueOperator(Me)
        End Function

        Public Function Update(operand As BoundExpression, type As TypeSymbol) As BoundNullableIsTrueOperator
            If operand IsNot Me.Operand OrElse type IsNot Me.Type Then
                Dim result = New BoundNullableIsTrueOperator(Me.Syntax, operand, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundBinaryOperator
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, operatorKind As BinaryOperatorKind, left As BoundExpression, right As BoundExpression, checked As Boolean, constantValueOpt As ConstantValue, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.BinaryOperator, syntax, type, hasErrors OrElse left.NonNullAndHasErrors() OrElse right.NonNullAndHasErrors())

            Debug.Assert(left IsNot Nothing, "Field 'left' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(right IsNot Nothing, "Field 'right' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._OperatorKind = operatorKind
            Me._Left = left
            Me._Right = right
            Me._Checked = checked
            Me._ConstantValueOpt = constantValueOpt

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _OperatorKind As BinaryOperatorKind
        Public ReadOnly Property OperatorKind As BinaryOperatorKind
            Get
                Return _OperatorKind
            End Get
        End Property

        Private ReadOnly _Left As BoundExpression
        Public ReadOnly Property Left As BoundExpression
            Get
                Return _Left
            End Get
        End Property

        Private ReadOnly _Right As BoundExpression
        Public ReadOnly Property Right As BoundExpression
            Get
                Return _Right
            End Get
        End Property

        Private ReadOnly _Checked As Boolean
        Public ReadOnly Property Checked As Boolean
            Get
                Return _Checked
            End Get
        End Property

        Private ReadOnly _ConstantValueOpt As ConstantValue
        Public Overrides ReadOnly Property ConstantValueOpt As ConstantValue
            Get
                Return _ConstantValueOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitBinaryOperator(Me)
        End Function

        Public Function Update(operatorKind As BinaryOperatorKind, left As BoundExpression, right As BoundExpression, checked As Boolean, constantValueOpt As ConstantValue, type As TypeSymbol) As BoundBinaryOperator
            If operatorKind <> Me.OperatorKind OrElse left IsNot Me.Left OrElse right IsNot Me.Right OrElse checked <> Me.Checked OrElse constantValueOpt IsNot Me.ConstantValueOpt OrElse type IsNot Me.Type Then
                Dim result = New BoundBinaryOperator(Me.Syntax, operatorKind, left, right, checked, constantValueOpt, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundCompoundAssignmentTargetPlaceholder
        Inherits BoundValuePlaceholderBase

        Public Sub New(syntax As SyntaxNode, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.CompoundAssignmentTargetPlaceholder, syntax, type, hasErrors)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

        End Sub

        Public Sub New(syntax As SyntaxNode, type As TypeSymbol)
            MyBase.New(BoundKind.CompoundAssignmentTargetPlaceholder, syntax, type)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

        End Sub


        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitCompoundAssignmentTargetPlaceholder(Me)
        End Function

        Public Function Update(type As TypeSymbol) As BoundCompoundAssignmentTargetPlaceholder
            If type IsNot Me.Type Then
                Dim result = New BoundCompoundAssignmentTargetPlaceholder(Me.Syntax, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundAssignmentOperator
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, left As BoundExpression, leftOnTheRightOpt As BoundCompoundAssignmentTargetPlaceholder, right As BoundExpression, suppressObjectClone As Boolean, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.AssignmentOperator, syntax, type, hasErrors OrElse left.NonNullAndHasErrors() OrElse leftOnTheRightOpt.NonNullAndHasErrors() OrElse right.NonNullAndHasErrors())

            Debug.Assert(left IsNot Nothing, "Field 'left' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(right IsNot Nothing, "Field 'right' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Left = left
            Me._LeftOnTheRightOpt = leftOnTheRightOpt
            Me._Right = right
            Me._SuppressObjectClone = suppressObjectClone

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _Left As BoundExpression
        Public ReadOnly Property Left As BoundExpression
            Get
                Return _Left
            End Get
        End Property

        Private ReadOnly _LeftOnTheRightOpt As BoundCompoundAssignmentTargetPlaceholder
        Public ReadOnly Property LeftOnTheRightOpt As BoundCompoundAssignmentTargetPlaceholder
            Get
                Return _LeftOnTheRightOpt
            End Get
        End Property

        Private ReadOnly _Right As BoundExpression
        Public ReadOnly Property Right As BoundExpression
            Get
                Return _Right
            End Get
        End Property

        Private ReadOnly _SuppressObjectClone As Boolean
        Public ReadOnly Property SuppressObjectClone As Boolean
            Get
                Return _SuppressObjectClone
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitAssignmentOperator(Me)
        End Function

        Public Function Update(left As BoundExpression, leftOnTheRightOpt As BoundCompoundAssignmentTargetPlaceholder, right As BoundExpression, suppressObjectClone As Boolean, type As TypeSymbol) As BoundAssignmentOperator
            If left IsNot Me.Left OrElse leftOnTheRightOpt IsNot Me.LeftOnTheRightOpt OrElse right IsNot Me.Right OrElse suppressObjectClone <> Me.SuppressObjectClone OrElse type IsNot Me.Type Then
                Dim result = New BoundAssignmentOperator(Me.Syntax, left, leftOnTheRightOpt, right, suppressObjectClone, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundReferenceAssignment
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, byRefLocal As BoundLocal, lValue As BoundExpression, isLValue As Boolean, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.ReferenceAssignment, syntax, type, hasErrors OrElse byRefLocal.NonNullAndHasErrors() OrElse lValue.NonNullAndHasErrors())

            Debug.Assert(byRefLocal IsNot Nothing, "Field 'byRefLocal' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._ByRefLocal = byRefLocal
            Me._LValue = lValue
            Me._IsLValue = isLValue

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _ByRefLocal As BoundLocal
        Public ReadOnly Property ByRefLocal As BoundLocal
            Get
                Return _ByRefLocal
            End Get
        End Property

        Private ReadOnly _LValue As BoundExpression
        Public ReadOnly Property LValue As BoundExpression
            Get
                Return _LValue
            End Get
        End Property

        Private ReadOnly _IsLValue As Boolean
        Public Overrides ReadOnly Property IsLValue As Boolean
            Get
                Return _IsLValue
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitReferenceAssignment(Me)
        End Function

        Public Function Update(byRefLocal As BoundLocal, lValue As BoundExpression, isLValue As Boolean, type As TypeSymbol) As BoundReferenceAssignment
            If byRefLocal IsNot Me.ByRefLocal OrElse lValue IsNot Me.LValue OrElse isLValue <> Me.IsLValue OrElse type IsNot Me.Type Then
                Dim result = New BoundReferenceAssignment(Me.Syntax, byRefLocal, lValue, isLValue, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundAddressOfOperator
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, binder As Binder, methodGroup As BoundMethodGroup, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.AddressOfOperator, syntax, Nothing, hasErrors OrElse methodGroup.NonNullAndHasErrors())

            Debug.Assert(binder IsNot Nothing, "Field 'binder' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(methodGroup IsNot Nothing, "Field 'methodGroup' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Binder = binder
            Me._MethodGroup = methodGroup
        End Sub


        Private ReadOnly _Binder As Binder
        Public ReadOnly Property Binder As Binder
            Get
                Return _Binder
            End Get
        End Property

        Private ReadOnly _MethodGroup As BoundMethodGroup
        Public ReadOnly Property MethodGroup As BoundMethodGroup
            Get
                Return _MethodGroup
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitAddressOfOperator(Me)
        End Function

        Public Function Update(binder As Binder, methodGroup As BoundMethodGroup) As BoundAddressOfOperator
            If binder IsNot Me.Binder OrElse methodGroup IsNot Me.MethodGroup Then
                Dim result = New BoundAddressOfOperator(Me.Syntax, binder, methodGroup, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundTernaryConditionalExpression
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, condition As BoundExpression, whenTrue As BoundExpression, whenFalse As BoundExpression, constantValueOpt As ConstantValue, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.TernaryConditionalExpression, syntax, type, hasErrors OrElse condition.NonNullAndHasErrors() OrElse whenTrue.NonNullAndHasErrors() OrElse whenFalse.NonNullAndHasErrors())

            Debug.Assert(condition IsNot Nothing, "Field 'condition' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(whenTrue IsNot Nothing, "Field 'whenTrue' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(whenFalse IsNot Nothing, "Field 'whenFalse' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Condition = condition
            Me._WhenTrue = whenTrue
            Me._WhenFalse = whenFalse
            Me._ConstantValueOpt = constantValueOpt

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _Condition As BoundExpression
        Public ReadOnly Property Condition As BoundExpression
            Get
                Return _Condition
            End Get
        End Property

        Private ReadOnly _WhenTrue As BoundExpression
        Public ReadOnly Property WhenTrue As BoundExpression
            Get
                Return _WhenTrue
            End Get
        End Property

        Private ReadOnly _WhenFalse As BoundExpression
        Public ReadOnly Property WhenFalse As BoundExpression
            Get
                Return _WhenFalse
            End Get
        End Property

        Private ReadOnly _ConstantValueOpt As ConstantValue
        Public Overrides ReadOnly Property ConstantValueOpt As ConstantValue
            Get
                Return _ConstantValueOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitTernaryConditionalExpression(Me)
        End Function

        Public Function Update(condition As BoundExpression, whenTrue As BoundExpression, whenFalse As BoundExpression, constantValueOpt As ConstantValue, type As TypeSymbol) As BoundTernaryConditionalExpression
            If condition IsNot Me.Condition OrElse whenTrue IsNot Me.WhenTrue OrElse whenFalse IsNot Me.WhenFalse OrElse constantValueOpt IsNot Me.ConstantValueOpt OrElse type IsNot Me.Type Then
                Dim result = New BoundTernaryConditionalExpression(Me.Syntax, condition, whenTrue, whenFalse, constantValueOpt, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundBinaryConditionalExpression
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, testExpression As BoundExpression, convertedTestExpression As BoundExpression, testExpressionPlaceholder As BoundValuePlaceholder, elseExpression As BoundExpression, constantValueOpt As ConstantValue, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.BinaryConditionalExpression, syntax, type, hasErrors OrElse testExpression.NonNullAndHasErrors() OrElse convertedTestExpression.NonNullAndHasErrors() OrElse testExpressionPlaceholder.NonNullAndHasErrors() OrElse elseExpression.NonNullAndHasErrors())

            Debug.Assert(testExpression IsNot Nothing, "Field 'testExpression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(elseExpression IsNot Nothing, "Field 'elseExpression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._TestExpression = testExpression
            Me._ConvertedTestExpression = convertedTestExpression
            Me._TestExpressionPlaceholder = testExpressionPlaceholder
            Me._ElseExpression = elseExpression
            Me._ConstantValueOpt = constantValueOpt

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _TestExpression As BoundExpression
        Public ReadOnly Property TestExpression As BoundExpression
            Get
                Return _TestExpression
            End Get
        End Property

        Private ReadOnly _ConvertedTestExpression As BoundExpression
        Public ReadOnly Property ConvertedTestExpression As BoundExpression
            Get
                Return _ConvertedTestExpression
            End Get
        End Property

        Private ReadOnly _TestExpressionPlaceholder As BoundValuePlaceholder
        Public ReadOnly Property TestExpressionPlaceholder As BoundValuePlaceholder
            Get
                Return _TestExpressionPlaceholder
            End Get
        End Property

        Private ReadOnly _ElseExpression As BoundExpression
        Public ReadOnly Property ElseExpression As BoundExpression
            Get
                Return _ElseExpression
            End Get
        End Property

        Private ReadOnly _ConstantValueOpt As ConstantValue
        Public Overrides ReadOnly Property ConstantValueOpt As ConstantValue
            Get
                Return _ConstantValueOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitBinaryConditionalExpression(Me)
        End Function

        Public Function Update(testExpression As BoundExpression, convertedTestExpression As BoundExpression, testExpressionPlaceholder As BoundValuePlaceholder, elseExpression As BoundExpression, constantValueOpt As ConstantValue, type As TypeSymbol) As BoundBinaryConditionalExpression
            If testExpression IsNot Me.TestExpression OrElse convertedTestExpression IsNot Me.ConvertedTestExpression OrElse testExpressionPlaceholder IsNot Me.TestExpressionPlaceholder OrElse elseExpression IsNot Me.ElseExpression OrElse constantValueOpt IsNot Me.ConstantValueOpt OrElse type IsNot Me.Type Then
                Dim result = New BoundBinaryConditionalExpression(Me.Syntax, testExpression, convertedTestExpression, testExpressionPlaceholder, elseExpression, constantValueOpt, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundConversion
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, operand As BoundExpression, conversionKind As ConversionKind, checked As Boolean, explicitCastInCode As Boolean, constantValueOpt As ConstantValue, constructorOpt As MethodSymbol, relaxationLambdaOpt As BoundLambda, relaxationReceiverTempOpt As TempLocalSymbol, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.Conversion, syntax, type, hasErrors OrElse operand.NonNullAndHasErrors() OrElse relaxationLambdaOpt.NonNullAndHasErrors())

            Debug.Assert(operand IsNot Nothing, "Field 'operand' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Operand = operand
            Me._ConversionKind = conversionKind
            Me._Checked = checked
            Me._ExplicitCastInCode = explicitCastInCode
            Me._ConstantValueOpt = constantValueOpt
            Me._ConstructorOpt = constructorOpt
            Me._RelaxationLambdaOpt = relaxationLambdaOpt
            Me._RelaxationReceiverTempOpt = relaxationReceiverTempOpt

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _Operand As BoundExpression
        Public ReadOnly Property Operand As BoundExpression
            Get
                Return _Operand
            End Get
        End Property

        Private ReadOnly _ConversionKind As ConversionKind
        Public ReadOnly Property ConversionKind As ConversionKind
            Get
                Return _ConversionKind
            End Get
        End Property

        Private ReadOnly _Checked As Boolean
        Public ReadOnly Property Checked As Boolean
            Get
                Return _Checked
            End Get
        End Property

        Private ReadOnly _ExplicitCastInCode As Boolean
        Public ReadOnly Property ExplicitCastInCode As Boolean
            Get
                Return _ExplicitCastInCode
            End Get
        End Property

        Private ReadOnly _ConstantValueOpt As ConstantValue
        Public Overrides ReadOnly Property ConstantValueOpt As ConstantValue
            Get
                Return _ConstantValueOpt
            End Get
        End Property

        Private ReadOnly _ConstructorOpt As MethodSymbol
        Public ReadOnly Property ConstructorOpt As MethodSymbol
            Get
                Return _ConstructorOpt
            End Get
        End Property

        Private ReadOnly _RelaxationLambdaOpt As BoundLambda
        Public ReadOnly Property RelaxationLambdaOpt As BoundLambda
            Get
                Return _RelaxationLambdaOpt
            End Get
        End Property

        Private ReadOnly _RelaxationReceiverTempOpt As TempLocalSymbol
        Public ReadOnly Property RelaxationReceiverTempOpt As TempLocalSymbol
            Get
                Return _RelaxationReceiverTempOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitConversion(Me)
        End Function

        Public Function Update(operand As BoundExpression, conversionKind As ConversionKind, checked As Boolean, explicitCastInCode As Boolean, constantValueOpt As ConstantValue, constructorOpt As MethodSymbol, relaxationLambdaOpt As BoundLambda, relaxationReceiverTempOpt As TempLocalSymbol, type As TypeSymbol) As BoundConversion
            If operand IsNot Me.Operand OrElse conversionKind <> Me.ConversionKind OrElse checked <> Me.Checked OrElse explicitCastInCode <> Me.ExplicitCastInCode OrElse constantValueOpt IsNot Me.ConstantValueOpt OrElse constructorOpt IsNot Me.ConstructorOpt OrElse relaxationLambdaOpt IsNot Me.RelaxationLambdaOpt OrElse relaxationReceiverTempOpt IsNot Me.RelaxationReceiverTempOpt OrElse type IsNot Me.Type Then
                Dim result = New BoundConversion(Me.Syntax, operand, conversionKind, checked, explicitCastInCode, constantValueOpt, constructorOpt, relaxationLambdaOpt, relaxationReceiverTempOpt, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundUserDefinedConversion
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, underlyingExpression As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.UserDefinedConversion, syntax, type, hasErrors OrElse underlyingExpression.NonNullAndHasErrors())

            Debug.Assert(underlyingExpression IsNot Nothing, "Field 'underlyingExpression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._UnderlyingExpression = underlyingExpression

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _UnderlyingExpression As BoundExpression
        Public ReadOnly Property UnderlyingExpression As BoundExpression
            Get
                Return _UnderlyingExpression
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitUserDefinedConversion(Me)
        End Function

        Public Function Update(underlyingExpression As BoundExpression, type As TypeSymbol) As BoundUserDefinedConversion
            If underlyingExpression IsNot Me.UnderlyingExpression OrElse type IsNot Me.Type Then
                Dim result = New BoundUserDefinedConversion(Me.Syntax, underlyingExpression, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundDirectCast
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, operand As BoundExpression, conversionKind As ConversionKind, constantValueOpt As ConstantValue, relaxationLambdaOpt As BoundLambda, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.DirectCast, syntax, type, hasErrors OrElse operand.NonNullAndHasErrors() OrElse relaxationLambdaOpt.NonNullAndHasErrors())

            Debug.Assert(operand IsNot Nothing, "Field 'operand' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Operand = operand
            Me._ConversionKind = conversionKind
            Me._ConstantValueOpt = constantValueOpt
            Me._RelaxationLambdaOpt = relaxationLambdaOpt

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _Operand As BoundExpression
        Public ReadOnly Property Operand As BoundExpression
            Get
                Return _Operand
            End Get
        End Property

        Private ReadOnly _ConversionKind As ConversionKind
        Public ReadOnly Property ConversionKind As ConversionKind
            Get
                Return _ConversionKind
            End Get
        End Property

        Private ReadOnly _ConstantValueOpt As ConstantValue
        Public Overrides ReadOnly Property ConstantValueOpt As ConstantValue
            Get
                Return _ConstantValueOpt
            End Get
        End Property

        Private ReadOnly _RelaxationLambdaOpt As BoundLambda
        Public ReadOnly Property RelaxationLambdaOpt As BoundLambda
            Get
                Return _RelaxationLambdaOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitDirectCast(Me)
        End Function

        Public Function Update(operand As BoundExpression, conversionKind As ConversionKind, constantValueOpt As ConstantValue, relaxationLambdaOpt As BoundLambda, type As TypeSymbol) As BoundDirectCast
            If operand IsNot Me.Operand OrElse conversionKind <> Me.ConversionKind OrElse constantValueOpt IsNot Me.ConstantValueOpt OrElse relaxationLambdaOpt IsNot Me.RelaxationLambdaOpt OrElse type IsNot Me.Type Then
                Dim result = New BoundDirectCast(Me.Syntax, operand, conversionKind, constantValueOpt, relaxationLambdaOpt, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundTryCast
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, operand As BoundExpression, conversionKind As ConversionKind, constantValueOpt As ConstantValue, relaxationLambdaOpt As BoundLambda, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.TryCast, syntax, type, hasErrors OrElse operand.NonNullAndHasErrors() OrElse relaxationLambdaOpt.NonNullAndHasErrors())

            Debug.Assert(operand IsNot Nothing, "Field 'operand' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Operand = operand
            Me._ConversionKind = conversionKind
            Me._ConstantValueOpt = constantValueOpt
            Me._RelaxationLambdaOpt = relaxationLambdaOpt

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _Operand As BoundExpression
        Public ReadOnly Property Operand As BoundExpression
            Get
                Return _Operand
            End Get
        End Property

        Private ReadOnly _ConversionKind As ConversionKind
        Public ReadOnly Property ConversionKind As ConversionKind
            Get
                Return _ConversionKind
            End Get
        End Property

        Private ReadOnly _ConstantValueOpt As ConstantValue
        Public Overrides ReadOnly Property ConstantValueOpt As ConstantValue
            Get
                Return _ConstantValueOpt
            End Get
        End Property

        Private ReadOnly _RelaxationLambdaOpt As BoundLambda
        Public ReadOnly Property RelaxationLambdaOpt As BoundLambda
            Get
                Return _RelaxationLambdaOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitTryCast(Me)
        End Function

        Public Function Update(operand As BoundExpression, conversionKind As ConversionKind, constantValueOpt As ConstantValue, relaxationLambdaOpt As BoundLambda, type As TypeSymbol) As BoundTryCast
            If operand IsNot Me.Operand OrElse conversionKind <> Me.ConversionKind OrElse constantValueOpt IsNot Me.ConstantValueOpt OrElse relaxationLambdaOpt IsNot Me.RelaxationLambdaOpt OrElse type IsNot Me.Type Then
                Dim result = New BoundTryCast(Me.Syntax, operand, conversionKind, constantValueOpt, relaxationLambdaOpt, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundTypeOf
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, operand As BoundExpression, isTypeOfIsNotExpression As Boolean, targetType As TypeSymbol, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.TypeOf, syntax, type, hasErrors OrElse operand.NonNullAndHasErrors())

            Debug.Assert(operand IsNot Nothing, "Field 'operand' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(targetType IsNot Nothing, "Field 'targetType' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Operand = operand
            Me._IsTypeOfIsNotExpression = isTypeOfIsNotExpression
            Me._TargetType = targetType
        End Sub


        Private ReadOnly _Operand As BoundExpression
        Public ReadOnly Property Operand As BoundExpression
            Get
                Return _Operand
            End Get
        End Property

        Private ReadOnly _IsTypeOfIsNotExpression As Boolean
        Public ReadOnly Property IsTypeOfIsNotExpression As Boolean
            Get
                Return _IsTypeOfIsNotExpression
            End Get
        End Property

        Private ReadOnly _TargetType As TypeSymbol
        Public ReadOnly Property TargetType As TypeSymbol
            Get
                Return _TargetType
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitTypeOf(Me)
        End Function

        Public Function Update(operand As BoundExpression, isTypeOfIsNotExpression As Boolean, targetType As TypeSymbol, type As TypeSymbol) As BoundTypeOf
            If operand IsNot Me.Operand OrElse isTypeOfIsNotExpression <> Me.IsTypeOfIsNotExpression OrElse targetType IsNot Me.TargetType OrElse type IsNot Me.Type Then
                Dim result = New BoundTypeOf(Me.Syntax, operand, isTypeOfIsNotExpression, targetType, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend MustInherit Partial Class BoundStatement
        Inherits BoundNode

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, hasErrors As Boolean)
            MyBase.New(kind, syntax, hasErrors)
        End Sub

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode)
            MyBase.New(kind, syntax)
        End Sub

    End Class

    Friend NotInheritable Partial Class BoundSequencePoint
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, statementOpt As BoundStatement, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.SequencePoint, syntax, hasErrors OrElse statementOpt.NonNullAndHasErrors())
            Me._StatementOpt = statementOpt
        End Sub


        Private ReadOnly _StatementOpt As BoundStatement
        Public ReadOnly Property StatementOpt As BoundStatement
            Get
                Return _StatementOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitSequencePoint(Me)
        End Function

        Public Function Update(statementOpt As BoundStatement) As BoundSequencePoint
            If statementOpt IsNot Me.StatementOpt Then
                Dim result = New BoundSequencePoint(Me.Syntax, statementOpt, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundSequencePointExpression
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, expression As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.SequencePointExpression, syntax, type, hasErrors OrElse expression.NonNullAndHasErrors())

            Debug.Assert(expression IsNot Nothing, "Field 'expression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Expression = expression
        End Sub


        Private ReadOnly _Expression As BoundExpression
        Public ReadOnly Property Expression As BoundExpression
            Get
                Return _Expression
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitSequencePointExpression(Me)
        End Function

        Public Function Update(expression As BoundExpression, type As TypeSymbol) As BoundSequencePointExpression
            If expression IsNot Me.Expression OrElse type IsNot Me.Type Then
                Dim result = New BoundSequencePointExpression(Me.Syntax, expression, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundSequencePointWithSpan
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, statementOpt As BoundStatement, sequenceSpan As TextSpan, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.SequencePointWithSpan, syntax, hasErrors OrElse statementOpt.NonNullAndHasErrors())
            Me._StatementOpt = statementOpt
            Me._SequenceSpan = sequenceSpan
        End Sub


        Private ReadOnly _StatementOpt As BoundStatement
        Public ReadOnly Property StatementOpt As BoundStatement
            Get
                Return _StatementOpt
            End Get
        End Property

        Private ReadOnly _SequenceSpan As TextSpan
        Public ReadOnly Property SequenceSpan As TextSpan
            Get
                Return _SequenceSpan
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitSequencePointWithSpan(Me)
        End Function

        Public Function Update(statementOpt As BoundStatement, sequenceSpan As TextSpan) As BoundSequencePointWithSpan
            If statementOpt IsNot Me.StatementOpt OrElse sequenceSpan <> Me.SequenceSpan Then
                Dim result = New BoundSequencePointWithSpan(Me.Syntax, statementOpt, sequenceSpan, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundNoOpStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, hasErrors As Boolean)
            MyBase.New(BoundKind.NoOpStatement, syntax, hasErrors)
        End Sub

        Public Sub New(syntax As SyntaxNode)
            MyBase.New(BoundKind.NoOpStatement, syntax)
        End Sub


        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitNoOpStatement(Me)
        End Function
    End Class

    Friend MustInherit Partial Class BoundMethodOrPropertyGroup
        Inherits BoundExpression

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, receiverOpt As BoundExpression, qualificationKind As QualificationKind, Optional hasErrors As Boolean = False)
            MyBase.New(kind, syntax, Nothing, hasErrors)
            Me._ReceiverOpt = receiverOpt
            Me._QualificationKind = qualificationKind
        End Sub


        Private ReadOnly _ReceiverOpt As BoundExpression
        Public ReadOnly Property ReceiverOpt As BoundExpression
            Get
                Return _ReceiverOpt
            End Get
        End Property

        Private ReadOnly _QualificationKind As QualificationKind
        Public ReadOnly Property QualificationKind As QualificationKind
            Get
                Return _QualificationKind
            End Get
        End Property
    End Class

    Friend NotInheritable Partial Class BoundMethodGroup
        Inherits BoundMethodOrPropertyGroup

        Public Sub New(syntax As SyntaxNode, typeArgumentsOpt As BoundTypeArguments, methods As ReadOnlyArray(of MethodSymbol), pendingExtensionMethodsOpt As ExtensionMethodGroup, resultKind As LookupResultKind, receiverOpt As BoundExpression, qualificationKind As QualificationKind, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.MethodGroup, syntax, receiverOpt, qualificationKind, hasErrors OrElse typeArgumentsOpt.NonNullAndHasErrors() OrElse receiverOpt.NonNullAndHasErrors())

            Debug.Assert(Not (methods.IsNull), "Field 'methods' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._TypeArgumentsOpt = typeArgumentsOpt
            Me._Methods = methods
            Me._PendingExtensionMethodsOpt = pendingExtensionMethodsOpt
            Me._ResultKind = resultKind
        End Sub


        Private ReadOnly _TypeArgumentsOpt As BoundTypeArguments
        Public ReadOnly Property TypeArgumentsOpt As BoundTypeArguments
            Get
                Return _TypeArgumentsOpt
            End Get
        End Property

        Private ReadOnly _Methods As ReadOnlyArray(of MethodSymbol)
        Public ReadOnly Property Methods As ReadOnlyArray(of MethodSymbol)
            Get
                Return _Methods
            End Get
        End Property

        Private ReadOnly _PendingExtensionMethodsOpt As ExtensionMethodGroup
        Public ReadOnly Property PendingExtensionMethodsOpt As ExtensionMethodGroup
            Get
                Return _PendingExtensionMethodsOpt
            End Get
        End Property

        Private ReadOnly _ResultKind As LookupResultKind
        Public Overrides ReadOnly Property ResultKind As LookupResultKind
            Get
                Return _ResultKind
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitMethodGroup(Me)
        End Function

        Public Function Update(typeArgumentsOpt As BoundTypeArguments, methods As ReadOnlyArray(of MethodSymbol), pendingExtensionMethodsOpt As ExtensionMethodGroup, resultKind As LookupResultKind, receiverOpt As BoundExpression, qualificationKind As QualificationKind) As BoundMethodGroup
            If typeArgumentsOpt IsNot Me.TypeArgumentsOpt OrElse methods <> Me.Methods OrElse pendingExtensionMethodsOpt IsNot Me.PendingExtensionMethodsOpt OrElse resultKind <> Me.ResultKind OrElse receiverOpt IsNot Me.ReceiverOpt OrElse qualificationKind <> Me.QualificationKind Then
                Dim result = New BoundMethodGroup(Me.Syntax, typeArgumentsOpt, methods, pendingExtensionMethodsOpt, resultKind, receiverOpt, qualificationKind, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundPropertyGroup
        Inherits BoundMethodOrPropertyGroup

        Public Sub New(syntax As SyntaxNode, properties As ReadOnlyArray(of PropertySymbol), resultKind As LookupResultKind, receiverOpt As BoundExpression, qualificationKind As QualificationKind, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.PropertyGroup, syntax, receiverOpt, qualificationKind, hasErrors OrElse receiverOpt.NonNullAndHasErrors())

            Debug.Assert(Not (properties.IsNull), "Field 'properties' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Properties = properties
            Me._ResultKind = resultKind
        End Sub


        Private ReadOnly _Properties As ReadOnlyArray(of PropertySymbol)
        Public ReadOnly Property Properties As ReadOnlyArray(of PropertySymbol)
            Get
                Return _Properties
            End Get
        End Property

        Private ReadOnly _ResultKind As LookupResultKind
        Public Overrides ReadOnly Property ResultKind As LookupResultKind
            Get
                Return _ResultKind
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitPropertyGroup(Me)
        End Function

        Public Function Update(properties As ReadOnlyArray(of PropertySymbol), resultKind As LookupResultKind, receiverOpt As BoundExpression, qualificationKind As QualificationKind) As BoundPropertyGroup
            If properties <> Me.Properties OrElse resultKind <> Me.ResultKind OrElse receiverOpt IsNot Me.ReceiverOpt OrElse qualificationKind <> Me.QualificationKind Then
                Dim result = New BoundPropertyGroup(Me.Syntax, properties, resultKind, receiverOpt, qualificationKind, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundReturnStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, expressionOpt As BoundExpression, functionLocalOpt As LocalSymbol, exitLabelOpt As LabelSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.ReturnStatement, syntax, hasErrors OrElse expressionOpt.NonNullAndHasErrors())
            Me._ExpressionOpt = expressionOpt
            Me._FunctionLocalOpt = functionLocalOpt
            Me._ExitLabelOpt = exitLabelOpt
        End Sub


        Private ReadOnly _ExpressionOpt As BoundExpression
        Public ReadOnly Property ExpressionOpt As BoundExpression
            Get
                Return _ExpressionOpt
            End Get
        End Property

        Private ReadOnly _FunctionLocalOpt As LocalSymbol
        Public ReadOnly Property FunctionLocalOpt As LocalSymbol
            Get
                Return _FunctionLocalOpt
            End Get
        End Property

        Private ReadOnly _ExitLabelOpt As LabelSymbol
        Public ReadOnly Property ExitLabelOpt As LabelSymbol
            Get
                Return _ExitLabelOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitReturnStatement(Me)
        End Function

        Public Function Update(expressionOpt As BoundExpression, functionLocalOpt As LocalSymbol, exitLabelOpt As LabelSymbol) As BoundReturnStatement
            If expressionOpt IsNot Me.ExpressionOpt OrElse functionLocalOpt IsNot Me.FunctionLocalOpt OrElse exitLabelOpt IsNot Me.ExitLabelOpt Then
                Dim result = New BoundReturnStatement(Me.Syntax, expressionOpt, functionLocalOpt, exitLabelOpt, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundThrowStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, expressionOpt As BoundExpression, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.ThrowStatement, syntax, hasErrors OrElse expressionOpt.NonNullAndHasErrors())
            Me._ExpressionOpt = expressionOpt
        End Sub


        Private ReadOnly _ExpressionOpt As BoundExpression
        Public ReadOnly Property ExpressionOpt As BoundExpression
            Get
                Return _ExpressionOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitThrowStatement(Me)
        End Function

        Public Function Update(expressionOpt As BoundExpression) As BoundThrowStatement
            If expressionOpt IsNot Me.ExpressionOpt Then
                Dim result = New BoundThrowStatement(Me.Syntax, expressionOpt, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundRedimStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, clauses As ReadOnlyArray(Of BoundRedimClause), Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.RedimStatement, syntax, hasErrors OrElse clauses.NonNullAndHasErrors())

            Debug.Assert(Not (clauses.IsNull), "Field 'clauses' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Clauses = clauses
        End Sub


        Private ReadOnly _Clauses As ReadOnlyArray(Of BoundRedimClause)
        Public ReadOnly Property Clauses As ReadOnlyArray(Of BoundRedimClause)
            Get
                Return _Clauses
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitRedimStatement(Me)
        End Function

        Public Function Update(clauses As ReadOnlyArray(Of BoundRedimClause)) As BoundRedimStatement
            If clauses <> Me.Clauses Then
                Dim result = New BoundRedimStatement(Me.Syntax, clauses, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundRedimClause
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, operand As BoundExpression, indices As ReadOnlyArray(Of BoundExpression), arrayTypeOpt As ArrayTypeSymbol, copyArrayUtilityMethodOpt As MethodSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.RedimClause, syntax, hasErrors OrElse operand.NonNullAndHasErrors() OrElse indices.NonNullAndHasErrors())

            Debug.Assert(operand IsNot Nothing, "Field 'operand' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (indices.IsNull), "Field 'indices' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Operand = operand
            Me._Indices = indices
            Me._ArrayTypeOpt = arrayTypeOpt
            Me._CopyArrayUtilityMethodOpt = copyArrayUtilityMethodOpt
        End Sub


        Private ReadOnly _Operand As BoundExpression
        Public ReadOnly Property Operand As BoundExpression
            Get
                Return _Operand
            End Get
        End Property

        Private ReadOnly _Indices As ReadOnlyArray(Of BoundExpression)
        Public ReadOnly Property Indices As ReadOnlyArray(Of BoundExpression)
            Get
                Return _Indices
            End Get
        End Property

        Private ReadOnly _ArrayTypeOpt As ArrayTypeSymbol
        Public ReadOnly Property ArrayTypeOpt As ArrayTypeSymbol
            Get
                Return _ArrayTypeOpt
            End Get
        End Property

        Private ReadOnly _CopyArrayUtilityMethodOpt As MethodSymbol
        Public ReadOnly Property CopyArrayUtilityMethodOpt As MethodSymbol
            Get
                Return _CopyArrayUtilityMethodOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitRedimClause(Me)
        End Function

        Public Function Update(operand As BoundExpression, indices As ReadOnlyArray(Of BoundExpression), arrayTypeOpt As ArrayTypeSymbol, copyArrayUtilityMethodOpt As MethodSymbol) As BoundRedimClause
            If operand IsNot Me.Operand OrElse indices <> Me.Indices OrElse arrayTypeOpt IsNot Me.ArrayTypeOpt OrElse copyArrayUtilityMethodOpt IsNot Me.CopyArrayUtilityMethodOpt Then
                Dim result = New BoundRedimClause(Me.Syntax, operand, indices, arrayTypeOpt, copyArrayUtilityMethodOpt, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundCall
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, method As MethodSymbol, methodGroupOpt As BoundMethodGroup, receiverOpt As BoundExpression, arguments As ReadOnlyArray(of BoundExpression), constantValueOpt As ConstantValue, suppressObjectClone As Boolean, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.Call, syntax, type, hasErrors OrElse methodGroupOpt.NonNullAndHasErrors() OrElse receiverOpt.NonNullAndHasErrors() OrElse arguments.NonNullAndHasErrors())

            Debug.Assert(method IsNot Nothing, "Field 'method' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (arguments.IsNull), "Field 'arguments' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Method = method
            Me._MethodGroupOpt = methodGroupOpt
            Me._ReceiverOpt = receiverOpt
            Me._Arguments = arguments
            Me._ConstantValueOpt = constantValueOpt
            Me._SuppressObjectClone = suppressObjectClone

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _Method As MethodSymbol
        Public ReadOnly Property Method As MethodSymbol
            Get
                Return _Method
            End Get
        End Property

        Private ReadOnly _MethodGroupOpt As BoundMethodGroup
        Public ReadOnly Property MethodGroupOpt As BoundMethodGroup
            Get
                Return _MethodGroupOpt
            End Get
        End Property

        Private ReadOnly _ReceiverOpt As BoundExpression
        Public ReadOnly Property ReceiverOpt As BoundExpression
            Get
                Return _ReceiverOpt
            End Get
        End Property

        Private ReadOnly _Arguments As ReadOnlyArray(of BoundExpression)
        Public ReadOnly Property Arguments As ReadOnlyArray(of BoundExpression)
            Get
                Return _Arguments
            End Get
        End Property

        Private ReadOnly _ConstantValueOpt As ConstantValue
        Public Overrides ReadOnly Property ConstantValueOpt As ConstantValue
            Get
                Return _ConstantValueOpt
            End Get
        End Property

        Private ReadOnly _SuppressObjectClone As Boolean
        Public ReadOnly Property SuppressObjectClone As Boolean
            Get
                Return _SuppressObjectClone
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitCall(Me)
        End Function

        Public Function Update(method As MethodSymbol, methodGroupOpt As BoundMethodGroup, receiverOpt As BoundExpression, arguments As ReadOnlyArray(of BoundExpression), constantValueOpt As ConstantValue, suppressObjectClone As Boolean, type As TypeSymbol) As BoundCall
            If method IsNot Me.Method OrElse methodGroupOpt IsNot Me.MethodGroupOpt OrElse receiverOpt IsNot Me.ReceiverOpt OrElse arguments <> Me.Arguments OrElse constantValueOpt IsNot Me.ConstantValueOpt OrElse suppressObjectClone <> Me.SuppressObjectClone OrElse type IsNot Me.Type Then
                Dim result = New BoundCall(Me.Syntax, method, methodGroupOpt, receiverOpt, arguments, constantValueOpt, suppressObjectClone, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundAttribute
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, constructor As MethodSymbol, constructorArguments As ReadOnlyArray(of BoundExpression), namedArguments As ReadOnlyArray(Of BoundExpression), resultKind As LookupResultKind, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.Attribute, syntax, type, hasErrors OrElse constructorArguments.NonNullAndHasErrors() OrElse namedArguments.NonNullAndHasErrors())

            Debug.Assert(Not (constructorArguments.IsNull), "Field 'constructorArguments' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (namedArguments.IsNull), "Field 'namedArguments' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Constructor = constructor
            Me._ConstructorArguments = constructorArguments
            Me._NamedArguments = namedArguments
            Me._ResultKind = resultKind
        End Sub


        Private ReadOnly _Constructor As MethodSymbol
        Public ReadOnly Property Constructor As MethodSymbol
            Get
                Return _Constructor
            End Get
        End Property

        Private ReadOnly _ConstructorArguments As ReadOnlyArray(of BoundExpression)
        Public ReadOnly Property ConstructorArguments As ReadOnlyArray(of BoundExpression)
            Get
                Return _ConstructorArguments
            End Get
        End Property

        Private ReadOnly _NamedArguments As ReadOnlyArray(Of BoundExpression)
        Public ReadOnly Property NamedArguments As ReadOnlyArray(Of BoundExpression)
            Get
                Return _NamedArguments
            End Get
        End Property

        Private ReadOnly _ResultKind As LookupResultKind
        Public Overrides ReadOnly Property ResultKind As LookupResultKind
            Get
                Return _ResultKind
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitAttribute(Me)
        End Function

        Public Function Update(constructor As MethodSymbol, constructorArguments As ReadOnlyArray(of BoundExpression), namedArguments As ReadOnlyArray(Of BoundExpression), resultKind As LookupResultKind, type As TypeSymbol) As BoundAttribute
            If constructor IsNot Me.Constructor OrElse constructorArguments <> Me.ConstructorArguments OrElse namedArguments <> Me.NamedArguments OrElse resultKind <> Me.ResultKind OrElse type IsNot Me.Type Then
                Dim result = New BoundAttribute(Me.Syntax, constructor, constructorArguments, namedArguments, resultKind, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundLateCall
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, receiver As BoundExpression, methodName As String, originalMethodGroupOpt As BoundMethodGroup, arguments As ReadOnlyArray(of BoundExpression), argumentNames As ReadOnlyArray(of string), type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.LateCall, syntax, type, hasErrors OrElse receiver.NonNullAndHasErrors() OrElse originalMethodGroupOpt.NonNullAndHasErrors() OrElse arguments.NonNullAndHasErrors())

            Debug.Assert(receiver IsNot Nothing, "Field 'receiver' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(methodName IsNot Nothing, "Field 'methodName' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (arguments.IsNull), "Field 'arguments' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (argumentNames.IsNull), "Field 'argumentNames' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Receiver = receiver
            Me._MethodName = methodName
            Me._OriginalMethodGroupOpt = originalMethodGroupOpt
            Me._Arguments = arguments
            Me._ArgumentNames = argumentNames
        End Sub


        Private ReadOnly _Receiver As BoundExpression
        Public ReadOnly Property Receiver As BoundExpression
            Get
                Return _Receiver
            End Get
        End Property

        Private ReadOnly _MethodName As String
        Public ReadOnly Property MethodName As String
            Get
                Return _MethodName
            End Get
        End Property

        Private ReadOnly _OriginalMethodGroupOpt As BoundMethodGroup
        Public ReadOnly Property OriginalMethodGroupOpt As BoundMethodGroup
            Get
                Return _OriginalMethodGroupOpt
            End Get
        End Property

        Private ReadOnly _Arguments As ReadOnlyArray(of BoundExpression)
        Public ReadOnly Property Arguments As ReadOnlyArray(of BoundExpression)
            Get
                Return _Arguments
            End Get
        End Property

        Private ReadOnly _ArgumentNames As ReadOnlyArray(of string)
        Public ReadOnly Property ArgumentNames As ReadOnlyArray(of string)
            Get
                Return _ArgumentNames
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitLateCall(Me)
        End Function

        Public Function Update(receiver As BoundExpression, methodName As String, originalMethodGroupOpt As BoundMethodGroup, arguments As ReadOnlyArray(of BoundExpression), argumentNames As ReadOnlyArray(of string), type As TypeSymbol) As BoundLateCall
            If receiver IsNot Me.Receiver OrElse methodName IsNot Me.MethodName OrElse originalMethodGroupOpt IsNot Me.OriginalMethodGroupOpt OrElse arguments <> Me.Arguments OrElse argumentNames <> Me.ArgumentNames OrElse type IsNot Me.Type Then
                Dim result = New BoundLateCall(Me.Syntax, receiver, methodName, originalMethodGroupOpt, arguments, argumentNames, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundObjectCreationExpression
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, constructorOpt As MethodSymbol, arguments As ReadOnlyArray(of BoundExpression), type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.ObjectCreationExpression, syntax, type, hasErrors OrElse arguments.NonNullAndHasErrors())

            Debug.Assert(Not (arguments.IsNull), "Field 'arguments' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._ConstructorOpt = constructorOpt
            Me._Arguments = arguments
        End Sub


        Private ReadOnly _ConstructorOpt As MethodSymbol
        Public ReadOnly Property ConstructorOpt As MethodSymbol
            Get
                Return _ConstructorOpt
            End Get
        End Property

        Private ReadOnly _Arguments As ReadOnlyArray(of BoundExpression)
        Public ReadOnly Property Arguments As ReadOnlyArray(of BoundExpression)
            Get
                Return _Arguments
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitObjectCreationExpression(Me)
        End Function

        Public Function Update(constructorOpt As MethodSymbol, arguments As ReadOnlyArray(of BoundExpression), type As TypeSymbol) As BoundObjectCreationExpression
            If constructorOpt IsNot Me.ConstructorOpt OrElse arguments <> Me.Arguments OrElse type IsNot Me.Type Then
                Dim result = New BoundObjectCreationExpression(Me.Syntax, constructorOpt, arguments, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundAnonymousTypeCreationExpression
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, binderOpt As Binder.AnonymousTypeCreationBinder, declarations As ReadOnlyArray(of BoundAnonymousTypePropertyAccess), arguments As ReadOnlyArray(of BoundExpression), type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.AnonymousTypeCreationExpression, syntax, type, hasErrors OrElse declarations.NonNullAndHasErrors() OrElse arguments.NonNullAndHasErrors())

            Debug.Assert(Not (declarations.IsNull), "Field 'declarations' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (arguments.IsNull), "Field 'arguments' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._BinderOpt = binderOpt
            Me._Declarations = declarations
            Me._Arguments = arguments
        End Sub


        Private ReadOnly _BinderOpt As Binder.AnonymousTypeCreationBinder
        Public ReadOnly Property BinderOpt As Binder.AnonymousTypeCreationBinder
            Get
                Return _BinderOpt
            End Get
        End Property

        Private ReadOnly _Declarations As ReadOnlyArray(of BoundAnonymousTypePropertyAccess)
        Public ReadOnly Property Declarations As ReadOnlyArray(of BoundAnonymousTypePropertyAccess)
            Get
                Return _Declarations
            End Get
        End Property

        Private ReadOnly _Arguments As ReadOnlyArray(of BoundExpression)
        Public ReadOnly Property Arguments As ReadOnlyArray(of BoundExpression)
            Get
                Return _Arguments
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitAnonymousTypeCreationExpression(Me)
        End Function

        Public Function Update(binderOpt As Binder.AnonymousTypeCreationBinder, declarations As ReadOnlyArray(of BoundAnonymousTypePropertyAccess), arguments As ReadOnlyArray(of BoundExpression), type As TypeSymbol) As BoundAnonymousTypeCreationExpression
            If binderOpt IsNot Me.BinderOpt OrElse declarations <> Me.Declarations OrElse arguments <> Me.Arguments OrElse type IsNot Me.Type Then
                Dim result = New BoundAnonymousTypeCreationExpression(Me.Syntax, binderOpt, declarations, arguments, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundAnonymousTypePropertyAccess
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, binder As Binder.AnonymousTypeCreationBinder, propertyIndex As Integer, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.AnonymousTypePropertyAccess, syntax, type, hasErrors)

            Debug.Assert(binder IsNot Nothing, "Field 'binder' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Binder = binder
            Me._PropertyIndex = propertyIndex
        End Sub

        Public Sub New(syntax As SyntaxNode, binder As Binder.AnonymousTypeCreationBinder, propertyIndex As Integer, type As TypeSymbol)
            MyBase.New(BoundKind.AnonymousTypePropertyAccess, syntax, type)

            Debug.Assert(binder IsNot Nothing, "Field 'binder' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Binder = binder
            Me._PropertyIndex = propertyIndex
        End Sub


        Private ReadOnly _Binder As Binder.AnonymousTypeCreationBinder
        Public ReadOnly Property Binder As Binder.AnonymousTypeCreationBinder
            Get
                Return _Binder
            End Get
        End Property

        Private ReadOnly _PropertyIndex As Integer
        Public ReadOnly Property PropertyIndex As Integer
            Get
                Return _PropertyIndex
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitAnonymousTypePropertyAccess(Me)
        End Function

        Public Function Update(binder As Binder.AnonymousTypeCreationBinder, propertyIndex As Integer, type As TypeSymbol) As BoundAnonymousTypePropertyAccess
            If binder IsNot Me.Binder OrElse propertyIndex <> Me.PropertyIndex OrElse type IsNot Me.Type Then
                Dim result = New BoundAnonymousTypePropertyAccess(Me.Syntax, binder, propertyIndex, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundAnonymousTypeFieldInitializer
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, binder As Binder.AnonymousTypeFieldInitializerBinder, value As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.AnonymousTypeFieldInitializer, syntax, type, hasErrors OrElse value.NonNullAndHasErrors())

            Debug.Assert(binder IsNot Nothing, "Field 'binder' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(value IsNot Nothing, "Field 'value' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Binder = binder
            Me._Value = value
        End Sub


        Private ReadOnly _Binder As Binder.AnonymousTypeFieldInitializerBinder
        Public ReadOnly Property Binder As Binder.AnonymousTypeFieldInitializerBinder
            Get
                Return _Binder
            End Get
        End Property

        Private ReadOnly _Value As BoundExpression
        Public ReadOnly Property Value As BoundExpression
            Get
                Return _Value
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitAnonymousTypeFieldInitializer(Me)
        End Function

        Public Function Update(binder As Binder.AnonymousTypeFieldInitializerBinder, value As BoundExpression, type As TypeSymbol) As BoundAnonymousTypeFieldInitializer
            If binder IsNot Me.Binder OrElse value IsNot Me.Value OrElse type IsNot Me.Type Then
                Dim result = New BoundAnonymousTypeFieldInitializer(Me.Syntax, binder, value, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundNewT
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.NewT, syntax, type, hasErrors)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")


            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub

        Public Sub New(syntax As SyntaxNode, type As TypeSymbol)
            MyBase.New(BoundKind.NewT, syntax, type)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")


            Validate()
        End Sub


        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitNewT(Me)
        End Function

        Public Function Update(type As TypeSymbol) As BoundNewT
            If type IsNot Me.Type Then
                Dim result = New BoundNewT(Me.Syntax, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundDelegateCreationExpression
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, receiverOpt As BoundExpression, method As MethodSymbol, relaxationLambdaOpt As BoundLambda, relaxationReceiverTempOpt As TempLocalSymbol, methodGroupOpt As BoundMethodGroup, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.DelegateCreationExpression, syntax, type, hasErrors OrElse receiverOpt.NonNullAndHasErrors() OrElse relaxationLambdaOpt.NonNullAndHasErrors() OrElse methodGroupOpt.NonNullAndHasErrors())

            Debug.Assert(method IsNot Nothing, "Field 'method' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._ReceiverOpt = receiverOpt
            Me._Method = method
            Me._RelaxationLambdaOpt = relaxationLambdaOpt
            Me._RelaxationReceiverTempOpt = relaxationReceiverTempOpt
            Me._MethodGroupOpt = methodGroupOpt
        End Sub


        Private ReadOnly _ReceiverOpt As BoundExpression
        Public ReadOnly Property ReceiverOpt As BoundExpression
            Get
                Return _ReceiverOpt
            End Get
        End Property

        Private ReadOnly _Method As MethodSymbol
        Public ReadOnly Property Method As MethodSymbol
            Get
                Return _Method
            End Get
        End Property

        Private ReadOnly _RelaxationLambdaOpt As BoundLambda
        Public ReadOnly Property RelaxationLambdaOpt As BoundLambda
            Get
                Return _RelaxationLambdaOpt
            End Get
        End Property

        Private ReadOnly _RelaxationReceiverTempOpt As TempLocalSymbol
        Public ReadOnly Property RelaxationReceiverTempOpt As TempLocalSymbol
            Get
                Return _RelaxationReceiverTempOpt
            End Get
        End Property

        Private ReadOnly _MethodGroupOpt As BoundMethodGroup
        Public ReadOnly Property MethodGroupOpt As BoundMethodGroup
            Get
                Return _MethodGroupOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitDelegateCreationExpression(Me)
        End Function

        Public Function Update(receiverOpt As BoundExpression, method As MethodSymbol, relaxationLambdaOpt As BoundLambda, relaxationReceiverTempOpt As TempLocalSymbol, methodGroupOpt As BoundMethodGroup, type As TypeSymbol) As BoundDelegateCreationExpression
            If receiverOpt IsNot Me.ReceiverOpt OrElse method IsNot Me.Method OrElse relaxationLambdaOpt IsNot Me.RelaxationLambdaOpt OrElse relaxationReceiverTempOpt IsNot Me.RelaxationReceiverTempOpt OrElse methodGroupOpt IsNot Me.MethodGroupOpt OrElse type IsNot Me.Type Then
                Dim result = New BoundDelegateCreationExpression(Me.Syntax, receiverOpt, method, relaxationLambdaOpt, relaxationReceiverTempOpt, methodGroupOpt, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundArrayCreation
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, isParamArrayArgument As Boolean, bounds As ReadOnlyArray(Of BoundExpression), initializerOpt As BoundArrayInitialization, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.ArrayCreation, syntax, type, hasErrors OrElse bounds.NonNullAndHasErrors() OrElse initializerOpt.NonNullAndHasErrors())

            Debug.Assert(Not (bounds.IsNull), "Field 'bounds' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._IsParamArrayArgument = isParamArrayArgument
            Me._Bounds = bounds
            Me._InitializerOpt = initializerOpt
        End Sub


        Private ReadOnly _IsParamArrayArgument As Boolean
        Public ReadOnly Property IsParamArrayArgument As Boolean
            Get
                Return _IsParamArrayArgument
            End Get
        End Property

        Private ReadOnly _Bounds As ReadOnlyArray(Of BoundExpression)
        Public ReadOnly Property Bounds As ReadOnlyArray(Of BoundExpression)
            Get
                Return _Bounds
            End Get
        End Property

        Private ReadOnly _InitializerOpt As BoundArrayInitialization
        Public ReadOnly Property InitializerOpt As BoundArrayInitialization
            Get
                Return _InitializerOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitArrayCreation(Me)
        End Function

        Public Function Update(isParamArrayArgument As Boolean, bounds As ReadOnlyArray(Of BoundExpression), initializerOpt As BoundArrayInitialization, type As TypeSymbol) As BoundArrayCreation
            If isParamArrayArgument <> Me.IsParamArrayArgument OrElse bounds <> Me.Bounds OrElse initializerOpt IsNot Me.InitializerOpt OrElse type IsNot Me.Type Then
                Dim result = New BoundArrayCreation(Me.Syntax, isParamArrayArgument, bounds, initializerOpt, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundArrayInitialization
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, initializers As ReadOnlyArray(Of BoundExpression), type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.ArrayInitialization, syntax, type, hasErrors OrElse initializers.NonNullAndHasErrors())

            Debug.Assert(Not (initializers.IsNull), "Field 'initializers' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Initializers = initializers
        End Sub


        Private ReadOnly _Initializers As ReadOnlyArray(Of BoundExpression)
        Public ReadOnly Property Initializers As ReadOnlyArray(Of BoundExpression)
            Get
                Return _Initializers
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitArrayInitialization(Me)
        End Function

        Public Function Update(initializers As ReadOnlyArray(Of BoundExpression), type As TypeSymbol) As BoundArrayInitialization
            If initializers <> Me.Initializers OrElse type IsNot Me.Type Then
                Dim result = New BoundArrayInitialization(Me.Syntax, initializers, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundFieldAccess
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, receiverOpt As BoundExpression, fieldSymbol As FieldSymbol, isLValue As Boolean, constantsInProgressOpt As ConstantFieldsInProgress, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.FieldAccess, syntax, type, hasErrors OrElse receiverOpt.NonNullAndHasErrors())

            Debug.Assert(fieldSymbol IsNot Nothing, "Field 'fieldSymbol' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._ReceiverOpt = receiverOpt
            Me._FieldSymbol = fieldSymbol
            Me._IsLValue = isLValue
            Me._ConstantsInProgressOpt = constantsInProgressOpt

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _ReceiverOpt As BoundExpression
        Public ReadOnly Property ReceiverOpt As BoundExpression
            Get
                Return _ReceiverOpt
            End Get
        End Property

        Private ReadOnly _FieldSymbol As FieldSymbol
        Public ReadOnly Property FieldSymbol As FieldSymbol
            Get
                Return _FieldSymbol
            End Get
        End Property

        Private ReadOnly _IsLValue As Boolean
        Public Overrides ReadOnly Property IsLValue As Boolean
            Get
                Return _IsLValue
            End Get
        End Property

        Private ReadOnly _ConstantsInProgressOpt As ConstantFieldsInProgress
        Public ReadOnly Property ConstantsInProgressOpt As ConstantFieldsInProgress
            Get
                Return _ConstantsInProgressOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitFieldAccess(Me)
        End Function

        Public Function Update(receiverOpt As BoundExpression, fieldSymbol As FieldSymbol, isLValue As Boolean, constantsInProgressOpt As ConstantFieldsInProgress, type As TypeSymbol) As BoundFieldAccess
            If receiverOpt IsNot Me.ReceiverOpt OrElse fieldSymbol IsNot Me.FieldSymbol OrElse isLValue <> Me.IsLValue OrElse constantsInProgressOpt IsNot Me.ConstantsInProgressOpt OrElse type IsNot Me.Type Then
                Dim result = New BoundFieldAccess(Me.Syntax, receiverOpt, fieldSymbol, isLValue, constantsInProgressOpt, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundPropertyAccess
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, propertySymbol As PropertySymbol, propertyGroupOpt As BoundPropertyGroup, accessKind As PropertyAccessKind, receiverOpt As BoundExpression, arguments As ReadOnlyArray(of BoundExpression), type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.PropertyAccess, syntax, type, hasErrors OrElse propertyGroupOpt.NonNullAndHasErrors() OrElse receiverOpt.NonNullAndHasErrors() OrElse arguments.NonNullAndHasErrors())

            Debug.Assert(propertySymbol IsNot Nothing, "Field 'propertySymbol' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (arguments.IsNull), "Field 'arguments' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._PropertySymbol = propertySymbol
            Me._PropertyGroupOpt = propertyGroupOpt
            Me._AccessKind = accessKind
            Me._ReceiverOpt = receiverOpt
            Me._Arguments = arguments
        End Sub


        Private ReadOnly _PropertySymbol As PropertySymbol
        Public ReadOnly Property PropertySymbol As PropertySymbol
            Get
                Return _PropertySymbol
            End Get
        End Property

        Private ReadOnly _PropertyGroupOpt As BoundPropertyGroup
        Public ReadOnly Property PropertyGroupOpt As BoundPropertyGroup
            Get
                Return _PropertyGroupOpt
            End Get
        End Property

        Private ReadOnly _AccessKind As PropertyAccessKind
        Public ReadOnly Property AccessKind As PropertyAccessKind
            Get
                Return _AccessKind
            End Get
        End Property

        Private ReadOnly _ReceiverOpt As BoundExpression
        Public ReadOnly Property ReceiverOpt As BoundExpression
            Get
                Return _ReceiverOpt
            End Get
        End Property

        Private ReadOnly _Arguments As ReadOnlyArray(of BoundExpression)
        Public ReadOnly Property Arguments As ReadOnlyArray(of BoundExpression)
            Get
                Return _Arguments
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitPropertyAccess(Me)
        End Function

        Public Function Update(propertySymbol As PropertySymbol, propertyGroupOpt As BoundPropertyGroup, accessKind As PropertyAccessKind, receiverOpt As BoundExpression, arguments As ReadOnlyArray(of BoundExpression), type As TypeSymbol) As BoundPropertyAccess
            If propertySymbol IsNot Me.PropertySymbol OrElse propertyGroupOpt IsNot Me.PropertyGroupOpt OrElse accessKind <> Me.AccessKind OrElse receiverOpt IsNot Me.ReceiverOpt OrElse arguments <> Me.Arguments OrElse type IsNot Me.Type Then
                Dim result = New BoundPropertyAccess(Me.Syntax, propertySymbol, propertyGroupOpt, accessKind, receiverOpt, arguments, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundEventAccess
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, receiverOpt As BoundExpression, eventSymbol As EventSymbol, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.EventAccess, syntax, type, hasErrors OrElse receiverOpt.NonNullAndHasErrors())

            Debug.Assert(eventSymbol IsNot Nothing, "Field 'eventSymbol' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._ReceiverOpt = receiverOpt
            Me._EventSymbol = eventSymbol
        End Sub


        Private ReadOnly _ReceiverOpt As BoundExpression
        Public ReadOnly Property ReceiverOpt As BoundExpression
            Get
                Return _ReceiverOpt
            End Get
        End Property

        Private ReadOnly _EventSymbol As EventSymbol
        Public ReadOnly Property EventSymbol As EventSymbol
            Get
                Return _EventSymbol
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitEventAccess(Me)
        End Function

        Public Function Update(receiverOpt As BoundExpression, eventSymbol As EventSymbol, type As TypeSymbol) As BoundEventAccess
            If receiverOpt IsNot Me.ReceiverOpt OrElse eventSymbol IsNot Me.EventSymbol OrElse type IsNot Me.Type Then
                Dim result = New BoundEventAccess(Me.Syntax, receiverOpt, eventSymbol, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundBlock
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, statementListSyntax As SeparatedSyntaxList(Of StatementSyntax), localsOpt As ReadOnlyArray(Of LocalSymbol), statements As ReadOnlyArray(Of BoundStatement), Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.Block, syntax, hasErrors OrElse statements.NonNullAndHasErrors())

            Debug.Assert(Not (statements.IsNull), "Field 'statements' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._StatementListSyntax = statementListSyntax
            Me._LocalsOpt = localsOpt
            Me._Statements = statements
        End Sub


        Private ReadOnly _StatementListSyntax As SeparatedSyntaxList(Of StatementSyntax)
        Public ReadOnly Property StatementListSyntax As SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return _StatementListSyntax
            End Get
        End Property

        Private ReadOnly _LocalsOpt As ReadOnlyArray(Of LocalSymbol)
        Public ReadOnly Property LocalsOpt As ReadOnlyArray(Of LocalSymbol)
            Get
                Return _LocalsOpt
            End Get
        End Property

        Private ReadOnly _Statements As ReadOnlyArray(Of BoundStatement)
        Public ReadOnly Property Statements As ReadOnlyArray(Of BoundStatement)
            Get
                Return _Statements
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitBlock(Me)
        End Function

        Public Function Update(statementListSyntax As SeparatedSyntaxList(Of StatementSyntax), localsOpt As ReadOnlyArray(Of LocalSymbol), statements As ReadOnlyArray(Of BoundStatement)) As BoundBlock
            If statementListSyntax <> Me.StatementListSyntax OrElse localsOpt <> Me.LocalsOpt OrElse statements <> Me.Statements Then
                Dim result = New BoundBlock(Me.Syntax, statementListSyntax, localsOpt, statements, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend MustInherit Partial Class BoundLocalDeclarationBase
        Inherits BoundStatement

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, hasErrors As Boolean)
            MyBase.New(kind, syntax, hasErrors)
        End Sub

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode)
            MyBase.New(kind, syntax)
        End Sub

    End Class

    Friend NotInheritable Partial Class BoundLocalDeclaration
        Inherits BoundLocalDeclarationBase

        Public Sub New(syntax As SyntaxNode, localSymbol As LocalSymbol, initializerOpt As BoundExpression, initializedByAsNew As Boolean, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.LocalDeclaration, syntax, hasErrors OrElse initializerOpt.NonNullAndHasErrors())

            Debug.Assert(localSymbol IsNot Nothing, "Field 'localSymbol' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._LocalSymbol = localSymbol
            Me._InitializerOpt = initializerOpt
            Me._InitializedByAsNew = initializedByAsNew
        End Sub


        Private ReadOnly _LocalSymbol As LocalSymbol
        Public ReadOnly Property LocalSymbol As LocalSymbol
            Get
                Return _LocalSymbol
            End Get
        End Property

        Private ReadOnly _InitializerOpt As BoundExpression
        Public ReadOnly Property InitializerOpt As BoundExpression
            Get
                Return _InitializerOpt
            End Get
        End Property

        Private ReadOnly _InitializedByAsNew As Boolean
        Public ReadOnly Property InitializedByAsNew As Boolean
            Get
                Return _InitializedByAsNew
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitLocalDeclaration(Me)
        End Function

        Public Function Update(localSymbol As LocalSymbol, initializerOpt As BoundExpression, initializedByAsNew As Boolean) As BoundLocalDeclaration
            If localSymbol IsNot Me.LocalSymbol OrElse initializerOpt IsNot Me.InitializerOpt OrElse initializedByAsNew <> Me.InitializedByAsNew Then
                Dim result = New BoundLocalDeclaration(Me.Syntax, localSymbol, initializerOpt, initializedByAsNew, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundAsNewLocalDeclarations
        Inherits BoundLocalDeclarationBase

        Public Sub New(syntax As SyntaxNode, localDeclarations As ReadOnlyArray(of BoundLocalDeclaration), initializer As BoundExpression, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.AsNewLocalDeclarations, syntax, hasErrors OrElse localDeclarations.NonNullAndHasErrors() OrElse initializer.NonNullAndHasErrors())

            Debug.Assert(Not (localDeclarations.IsNull), "Field 'localDeclarations' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(initializer IsNot Nothing, "Field 'initializer' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._LocalDeclarations = localDeclarations
            Me._Initializer = initializer
        End Sub


        Private ReadOnly _LocalDeclarations As ReadOnlyArray(of BoundLocalDeclaration)
        Public ReadOnly Property LocalDeclarations As ReadOnlyArray(of BoundLocalDeclaration)
            Get
                Return _LocalDeclarations
            End Get
        End Property

        Private ReadOnly _Initializer As BoundExpression
        Public ReadOnly Property Initializer As BoundExpression
            Get
                Return _Initializer
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitAsNewLocalDeclarations(Me)
        End Function

        Public Function Update(localDeclarations As ReadOnlyArray(of BoundLocalDeclaration), initializer As BoundExpression) As BoundAsNewLocalDeclarations
            If localDeclarations <> Me.LocalDeclarations OrElse initializer IsNot Me.Initializer Then
                Dim result = New BoundAsNewLocalDeclarations(Me.Syntax, localDeclarations, initializer, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundDimStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, localDeclarations As ReadOnlyArray(of BoundLocalDeclarationBase), initializerOpt As BoundExpression, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.DimStatement, syntax, hasErrors OrElse localDeclarations.NonNullAndHasErrors() OrElse initializerOpt.NonNullAndHasErrors())

            Debug.Assert(Not (localDeclarations.IsNull), "Field 'localDeclarations' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._LocalDeclarations = localDeclarations
            Me._InitializerOpt = initializerOpt
        End Sub


        Private ReadOnly _LocalDeclarations As ReadOnlyArray(of BoundLocalDeclarationBase)
        Public ReadOnly Property LocalDeclarations As ReadOnlyArray(of BoundLocalDeclarationBase)
            Get
                Return _LocalDeclarations
            End Get
        End Property

        Private ReadOnly _InitializerOpt As BoundExpression
        Public ReadOnly Property InitializerOpt As BoundExpression
            Get
                Return _InitializerOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitDimStatement(Me)
        End Function

        Public Function Update(localDeclarations As ReadOnlyArray(of BoundLocalDeclarationBase), initializerOpt As BoundExpression) As BoundDimStatement
            If localDeclarations <> Me.LocalDeclarations OrElse initializerOpt IsNot Me.InitializerOpt Then
                Dim result = New BoundDimStatement(Me.Syntax, localDeclarations, initializerOpt, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend Partial Class BoundInitializer
        Inherits BoundNode

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, hasErrors As Boolean)
            MyBase.New(kind, syntax, hasErrors)
        End Sub

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode)
            MyBase.New(kind, syntax)
        End Sub

        Public Sub New(syntax As SyntaxNode, hasErrors As Boolean)
            MyBase.New(BoundKind.Initializer, syntax, hasErrors)
        End Sub

        Public Sub New(syntax As SyntaxNode)
            MyBase.New(BoundKind.Initializer, syntax)
        End Sub


        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitInitializer(Me)
        End Function
    End Class

    Friend NotInheritable Partial Class BoundFieldOrPropertyInitializer
        Inherits BoundInitializer

        Public Sub New(syntax As SyntaxNode, fieldOrProperty As BoundExpression, initialValue As BoundExpression, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.FieldOrPropertyInitializer, syntax, hasErrors OrElse fieldOrProperty.NonNullAndHasErrors() OrElse initialValue.NonNullAndHasErrors())

            Debug.Assert(fieldOrProperty IsNot Nothing, "Field 'fieldOrProperty' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(initialValue IsNot Nothing, "Field 'initialValue' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._FieldOrProperty = fieldOrProperty
            Me._InitialValue = initialValue
        End Sub


        Private ReadOnly _FieldOrProperty As BoundExpression
        Public ReadOnly Property FieldOrProperty As BoundExpression
            Get
                Return _FieldOrProperty
            End Get
        End Property

        Private ReadOnly _InitialValue As BoundExpression
        Public ReadOnly Property InitialValue As BoundExpression
            Get
                Return _InitialValue
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitFieldOrPropertyInitializer(Me)
        End Function

        Public Function Update(fieldOrProperty As BoundExpression, initialValue As BoundExpression) As BoundFieldOrPropertyInitializer
            If fieldOrProperty IsNot Me.FieldOrProperty OrElse initialValue IsNot Me.InitialValue Then
                Dim result = New BoundFieldOrPropertyInitializer(Me.Syntax, fieldOrProperty, initialValue, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundGlobalStatementInitializer
        Inherits BoundInitializer

        Public Sub New(syntax As SyntaxNode, statement As BoundStatement, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.GlobalStatementInitializer, syntax, hasErrors OrElse statement.NonNullAndHasErrors())

            Debug.Assert(statement IsNot Nothing, "Field 'statement' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Statement = statement
        End Sub


        Private ReadOnly _Statement As BoundStatement
        Public ReadOnly Property Statement As BoundStatement
            Get
                Return _Statement
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitGlobalStatementInitializer(Me)
        End Function

        Public Function Update(statement As BoundStatement) As BoundGlobalStatementInitializer
            If statement IsNot Me.Statement Then
                Dim result = New BoundGlobalStatementInitializer(Me.Syntax, statement, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundSequence
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, localsOpt As ReadOnlyArray(Of LocalSymbol), sideEffects As ReadOnlyArray(Of BoundExpression), valueOpt As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.Sequence, syntax, type, hasErrors OrElse sideEffects.NonNullAndHasErrors() OrElse valueOpt.NonNullAndHasErrors())

            Debug.Assert(Not (sideEffects.IsNull), "Field 'sideEffects' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._LocalsOpt = localsOpt
            Me._SideEffects = sideEffects
            Me._ValueOpt = valueOpt
        End Sub


        Private ReadOnly _LocalsOpt As ReadOnlyArray(Of LocalSymbol)
        Public ReadOnly Property LocalsOpt As ReadOnlyArray(Of LocalSymbol)
            Get
                Return _LocalsOpt
            End Get
        End Property

        Private ReadOnly _SideEffects As ReadOnlyArray(Of BoundExpression)
        Public ReadOnly Property SideEffects As ReadOnlyArray(Of BoundExpression)
            Get
                Return _SideEffects
            End Get
        End Property

        Private ReadOnly _ValueOpt As BoundExpression
        Public ReadOnly Property ValueOpt As BoundExpression
            Get
                Return _ValueOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitSequence(Me)
        End Function

        Public Function Update(localsOpt As ReadOnlyArray(Of LocalSymbol), sideEffects As ReadOnlyArray(Of BoundExpression), valueOpt As BoundExpression, type As TypeSymbol) As BoundSequence
            If localsOpt <> Me.LocalsOpt OrElse sideEffects <> Me.SideEffects OrElse valueOpt IsNot Me.ValueOpt OrElse type IsNot Me.Type Then
                Dim result = New BoundSequence(Me.Syntax, localsOpt, sideEffects, valueOpt, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundExpressionStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, expression As BoundExpression, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.ExpressionStatement, syntax, hasErrors OrElse expression.NonNullAndHasErrors())

            Debug.Assert(expression IsNot Nothing, "Field 'expression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Expression = expression
        End Sub


        Private ReadOnly _Expression As BoundExpression
        Public ReadOnly Property Expression As BoundExpression
            Get
                Return _Expression
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitExpressionStatement(Me)
        End Function

        Public Function Update(expression As BoundExpression) As BoundExpressionStatement
            If expression IsNot Me.Expression Then
                Dim result = New BoundExpressionStatement(Me.Syntax, expression, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundIfStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, condition As BoundExpression, consequence As BoundStatement, alternativeOpt As BoundStatement, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.IfStatement, syntax, hasErrors OrElse condition.NonNullAndHasErrors() OrElse consequence.NonNullAndHasErrors() OrElse alternativeOpt.NonNullAndHasErrors())

            Debug.Assert(condition IsNot Nothing, "Field 'condition' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(consequence IsNot Nothing, "Field 'consequence' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Condition = condition
            Me._Consequence = consequence
            Me._AlternativeOpt = alternativeOpt
        End Sub


        Private ReadOnly _Condition As BoundExpression
        Public ReadOnly Property Condition As BoundExpression
            Get
                Return _Condition
            End Get
        End Property

        Private ReadOnly _Consequence As BoundStatement
        Public ReadOnly Property Consequence As BoundStatement
            Get
                Return _Consequence
            End Get
        End Property

        Private ReadOnly _AlternativeOpt As BoundStatement
        Public ReadOnly Property AlternativeOpt As BoundStatement
            Get
                Return _AlternativeOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitIfStatement(Me)
        End Function

        Public Function Update(condition As BoundExpression, consequence As BoundStatement, alternativeOpt As BoundStatement) As BoundIfStatement
            If condition IsNot Me.Condition OrElse consequence IsNot Me.Consequence OrElse alternativeOpt IsNot Me.AlternativeOpt Then
                Dim result = New BoundIfStatement(Me.Syntax, condition, consequence, alternativeOpt, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundSelectStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, expressionStatement As BoundExpressionStatement, exprPlaceholderOpt As BoundValuePlaceholder, caseBlocks As ReadOnlyArray(Of BoundCaseBlock), recommendSwitchTable As Boolean, exitLabel As LabelSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.SelectStatement, syntax, hasErrors OrElse expressionStatement.NonNullAndHasErrors() OrElse exprPlaceholderOpt.NonNullAndHasErrors() OrElse caseBlocks.NonNullAndHasErrors())

            Debug.Assert(expressionStatement IsNot Nothing, "Field 'expressionStatement' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (caseBlocks.IsNull), "Field 'caseBlocks' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(exitLabel IsNot Nothing, "Field 'exitLabel' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._ExpressionStatement = expressionStatement
            Me._ExprPlaceholderOpt = exprPlaceholderOpt
            Me._CaseBlocks = caseBlocks
            Me._RecommendSwitchTable = recommendSwitchTable
            Me._ExitLabel = exitLabel
        End Sub


        Private ReadOnly _ExpressionStatement As BoundExpressionStatement
        Public ReadOnly Property ExpressionStatement As BoundExpressionStatement
            Get
                Return _ExpressionStatement
            End Get
        End Property

        Private ReadOnly _ExprPlaceholderOpt As BoundValuePlaceholder
        Public ReadOnly Property ExprPlaceholderOpt As BoundValuePlaceholder
            Get
                Return _ExprPlaceholderOpt
            End Get
        End Property

        Private ReadOnly _CaseBlocks As ReadOnlyArray(Of BoundCaseBlock)
        Public ReadOnly Property CaseBlocks As ReadOnlyArray(Of BoundCaseBlock)
            Get
                Return _CaseBlocks
            End Get
        End Property

        Private ReadOnly _RecommendSwitchTable As Boolean
        Public ReadOnly Property RecommendSwitchTable As Boolean
            Get
                Return _RecommendSwitchTable
            End Get
        End Property

        Private ReadOnly _ExitLabel As LabelSymbol
        Public ReadOnly Property ExitLabel As LabelSymbol
            Get
                Return _ExitLabel
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitSelectStatement(Me)
        End Function

        Public Function Update(expressionStatement As BoundExpressionStatement, exprPlaceholderOpt As BoundValuePlaceholder, caseBlocks As ReadOnlyArray(Of BoundCaseBlock), recommendSwitchTable As Boolean, exitLabel As LabelSymbol) As BoundSelectStatement
            If expressionStatement IsNot Me.ExpressionStatement OrElse exprPlaceholderOpt IsNot Me.ExprPlaceholderOpt OrElse caseBlocks <> Me.CaseBlocks OrElse recommendSwitchTable <> Me.RecommendSwitchTable OrElse exitLabel IsNot Me.ExitLabel Then
                Dim result = New BoundSelectStatement(Me.Syntax, expressionStatement, exprPlaceholderOpt, caseBlocks, recommendSwitchTable, exitLabel, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundCaseBlock
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, caseStatement As BoundCaseStatement, body As BoundBlock, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.CaseBlock, syntax, hasErrors OrElse caseStatement.NonNullAndHasErrors() OrElse body.NonNullAndHasErrors())

            Debug.Assert(caseStatement IsNot Nothing, "Field 'caseStatement' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(body IsNot Nothing, "Field 'body' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._CaseStatement = caseStatement
            Me._Body = body
        End Sub


        Private ReadOnly _CaseStatement As BoundCaseStatement
        Public ReadOnly Property CaseStatement As BoundCaseStatement
            Get
                Return _CaseStatement
            End Get
        End Property

        Private ReadOnly _Body As BoundBlock
        Public ReadOnly Property Body As BoundBlock
            Get
                Return _Body
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitCaseBlock(Me)
        End Function

        Public Function Update(caseStatement As BoundCaseStatement, body As BoundBlock) As BoundCaseBlock
            If caseStatement IsNot Me.CaseStatement OrElse body IsNot Me.Body Then
                Dim result = New BoundCaseBlock(Me.Syntax, caseStatement, body, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundCaseStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, caseClauses As ReadOnlyArray(Of BoundCaseClause), conditionOpt As BoundExpression, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.CaseStatement, syntax, hasErrors OrElse caseClauses.NonNullAndHasErrors() OrElse conditionOpt.NonNullAndHasErrors())

            Debug.Assert(Not (caseClauses.IsNull), "Field 'caseClauses' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._CaseClauses = caseClauses
            Me._ConditionOpt = conditionOpt
        End Sub


        Private ReadOnly _CaseClauses As ReadOnlyArray(Of BoundCaseClause)
        Public ReadOnly Property CaseClauses As ReadOnlyArray(Of BoundCaseClause)
            Get
                Return _CaseClauses
            End Get
        End Property

        Private ReadOnly _ConditionOpt As BoundExpression
        Public ReadOnly Property ConditionOpt As BoundExpression
            Get
                Return _ConditionOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitCaseStatement(Me)
        End Function

        Public Function Update(caseClauses As ReadOnlyArray(Of BoundCaseClause), conditionOpt As BoundExpression) As BoundCaseStatement
            If caseClauses <> Me.CaseClauses OrElse conditionOpt IsNot Me.ConditionOpt Then
                Dim result = New BoundCaseStatement(Me.Syntax, caseClauses, conditionOpt, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend MustInherit Partial Class BoundCaseClause
        Inherits BoundNode

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, hasErrors As Boolean)
            MyBase.New(kind, syntax, hasErrors)
        End Sub

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode)
            MyBase.New(kind, syntax)
        End Sub

    End Class

    Friend NotInheritable Partial Class BoundCaseValueClause
        Inherits BoundCaseClause

        Public Sub New(syntax As SyntaxNode, valueOpt As BoundExpression, conditionOpt As BoundExpression, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.CaseValueClause, syntax, hasErrors OrElse valueOpt.NonNullAndHasErrors() OrElse conditionOpt.NonNullAndHasErrors())
            Me._ValueOpt = valueOpt
            Me._ConditionOpt = conditionOpt
        End Sub


        Private ReadOnly _ValueOpt As BoundExpression
        Public ReadOnly Property ValueOpt As BoundExpression
            Get
                Return _ValueOpt
            End Get
        End Property

        Private ReadOnly _ConditionOpt As BoundExpression
        Public ReadOnly Property ConditionOpt As BoundExpression
            Get
                Return _ConditionOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitCaseValueClause(Me)
        End Function

        Public Function Update(valueOpt As BoundExpression, conditionOpt As BoundExpression) As BoundCaseValueClause
            If valueOpt IsNot Me.ValueOpt OrElse conditionOpt IsNot Me.ConditionOpt Then
                Dim result = New BoundCaseValueClause(Me.Syntax, valueOpt, conditionOpt, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundCaseRangeClause
        Inherits BoundCaseClause

        Public Sub New(syntax As SyntaxNode, lowerBoundOpt As BoundExpression, upperBoundOpt As BoundExpression, lowerBoundConditionOpt As BoundExpression, upperBoundConditionOpt As BoundExpression, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.CaseRangeClause, syntax, hasErrors OrElse lowerBoundOpt.NonNullAndHasErrors() OrElse upperBoundOpt.NonNullAndHasErrors() OrElse lowerBoundConditionOpt.NonNullAndHasErrors() OrElse upperBoundConditionOpt.NonNullAndHasErrors())
            Me._LowerBoundOpt = lowerBoundOpt
            Me._UpperBoundOpt = upperBoundOpt
            Me._LowerBoundConditionOpt = lowerBoundConditionOpt
            Me._UpperBoundConditionOpt = upperBoundConditionOpt
        End Sub


        Private ReadOnly _LowerBoundOpt As BoundExpression
        Public ReadOnly Property LowerBoundOpt As BoundExpression
            Get
                Return _LowerBoundOpt
            End Get
        End Property

        Private ReadOnly _UpperBoundOpt As BoundExpression
        Public ReadOnly Property UpperBoundOpt As BoundExpression
            Get
                Return _UpperBoundOpt
            End Get
        End Property

        Private ReadOnly _LowerBoundConditionOpt As BoundExpression
        Public ReadOnly Property LowerBoundConditionOpt As BoundExpression
            Get
                Return _LowerBoundConditionOpt
            End Get
        End Property

        Private ReadOnly _UpperBoundConditionOpt As BoundExpression
        Public ReadOnly Property UpperBoundConditionOpt As BoundExpression
            Get
                Return _UpperBoundConditionOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitCaseRangeClause(Me)
        End Function

        Public Function Update(lowerBoundOpt As BoundExpression, upperBoundOpt As BoundExpression, lowerBoundConditionOpt As BoundExpression, upperBoundConditionOpt As BoundExpression) As BoundCaseRangeClause
            If lowerBoundOpt IsNot Me.LowerBoundOpt OrElse upperBoundOpt IsNot Me.UpperBoundOpt OrElse lowerBoundConditionOpt IsNot Me.LowerBoundConditionOpt OrElse upperBoundConditionOpt IsNot Me.UpperBoundConditionOpt Then
                Dim result = New BoundCaseRangeClause(Me.Syntax, lowerBoundOpt, upperBoundOpt, lowerBoundConditionOpt, upperBoundConditionOpt, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundCaseRelationalClause
        Inherits BoundCaseClause

        Public Sub New(syntax As SyntaxNode, operatorKind As BinaryOperatorKind, operandOpt As BoundExpression, conditionOpt As BoundExpression, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.CaseRelationalClause, syntax, hasErrors OrElse operandOpt.NonNullAndHasErrors() OrElse conditionOpt.NonNullAndHasErrors())
            Me._OperatorKind = operatorKind
            Me._OperandOpt = operandOpt
            Me._ConditionOpt = conditionOpt
        End Sub


        Private ReadOnly _OperatorKind As BinaryOperatorKind
        Public ReadOnly Property OperatorKind As BinaryOperatorKind
            Get
                Return _OperatorKind
            End Get
        End Property

        Private ReadOnly _OperandOpt As BoundExpression
        Public ReadOnly Property OperandOpt As BoundExpression
            Get
                Return _OperandOpt
            End Get
        End Property

        Private ReadOnly _ConditionOpt As BoundExpression
        Public ReadOnly Property ConditionOpt As BoundExpression
            Get
                Return _ConditionOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitCaseRelationalClause(Me)
        End Function

        Public Function Update(operatorKind As BinaryOperatorKind, operandOpt As BoundExpression, conditionOpt As BoundExpression) As BoundCaseRelationalClause
            If operatorKind <> Me.OperatorKind OrElse operandOpt IsNot Me.OperandOpt OrElse conditionOpt IsNot Me.ConditionOpt Then
                Dim result = New BoundCaseRelationalClause(Me.Syntax, operatorKind, operandOpt, conditionOpt, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend MustInherit Partial Class BoundLoopStatement
        Inherits BoundStatement

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, continueLabel As LabelSymbol, exitLabel As LabelSymbol, hasErrors As Boolean)
            MyBase.New(kind, syntax, hasErrors)

            Debug.Assert(continueLabel IsNot Nothing, "Field 'continueLabel' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(exitLabel IsNot Nothing, "Field 'exitLabel' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._ContinueLabel = continueLabel
            Me._ExitLabel = exitLabel
        End Sub

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, continueLabel As LabelSymbol, exitLabel As LabelSymbol)
            MyBase.New(kind, syntax)

            Debug.Assert(continueLabel IsNot Nothing, "Field 'continueLabel' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(exitLabel IsNot Nothing, "Field 'exitLabel' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._ContinueLabel = continueLabel
            Me._ExitLabel = exitLabel
        End Sub


        Private ReadOnly _ContinueLabel As LabelSymbol
        Public ReadOnly Property ContinueLabel As LabelSymbol
            Get
                Return _ContinueLabel
            End Get
        End Property

        Private ReadOnly _ExitLabel As LabelSymbol
        Public ReadOnly Property ExitLabel As LabelSymbol
            Get
                Return _ExitLabel
            End Get
        End Property
    End Class

    Friend NotInheritable Partial Class BoundDoLoopStatement
        Inherits BoundLoopStatement

        Public Sub New(syntax As SyntaxNode, topConditionOpt As BoundExpression, bottomConditionOpt As BoundExpression, topConditionIsUntil As Boolean, bottomConditionIsUntil As Boolean, body As BoundStatement, continueLabel As LabelSymbol, exitLabel As LabelSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.DoLoopStatement, syntax, continueLabel, exitLabel, hasErrors OrElse topConditionOpt.NonNullAndHasErrors() OrElse bottomConditionOpt.NonNullAndHasErrors() OrElse body.NonNullAndHasErrors())

            Debug.Assert(body IsNot Nothing, "Field 'body' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(continueLabel IsNot Nothing, "Field 'continueLabel' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(exitLabel IsNot Nothing, "Field 'exitLabel' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._TopConditionOpt = topConditionOpt
            Me._BottomConditionOpt = bottomConditionOpt
            Me._TopConditionIsUntil = topConditionIsUntil
            Me._BottomConditionIsUntil = bottomConditionIsUntil
            Me._Body = body
        End Sub


        Private ReadOnly _TopConditionOpt As BoundExpression
        Public ReadOnly Property TopConditionOpt As BoundExpression
            Get
                Return _TopConditionOpt
            End Get
        End Property

        Private ReadOnly _BottomConditionOpt As BoundExpression
        Public ReadOnly Property BottomConditionOpt As BoundExpression
            Get
                Return _BottomConditionOpt
            End Get
        End Property

        Private ReadOnly _TopConditionIsUntil As Boolean
        Public ReadOnly Property TopConditionIsUntil As Boolean
            Get
                Return _TopConditionIsUntil
            End Get
        End Property

        Private ReadOnly _BottomConditionIsUntil As Boolean
        Public ReadOnly Property BottomConditionIsUntil As Boolean
            Get
                Return _BottomConditionIsUntil
            End Get
        End Property

        Private ReadOnly _Body As BoundStatement
        Public ReadOnly Property Body As BoundStatement
            Get
                Return _Body
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitDoLoopStatement(Me)
        End Function

        Public Function Update(topConditionOpt As BoundExpression, bottomConditionOpt As BoundExpression, topConditionIsUntil As Boolean, bottomConditionIsUntil As Boolean, body As BoundStatement, continueLabel As LabelSymbol, exitLabel As LabelSymbol) As BoundDoLoopStatement
            If topConditionOpt IsNot Me.TopConditionOpt OrElse bottomConditionOpt IsNot Me.BottomConditionOpt OrElse topConditionIsUntil <> Me.TopConditionIsUntil OrElse bottomConditionIsUntil <> Me.BottomConditionIsUntil OrElse body IsNot Me.Body OrElse continueLabel IsNot Me.ContinueLabel OrElse exitLabel IsNot Me.ExitLabel Then
                Dim result = New BoundDoLoopStatement(Me.Syntax, topConditionOpt, bottomConditionOpt, topConditionIsUntil, bottomConditionIsUntil, body, continueLabel, exitLabel, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundWhileStatement
        Inherits BoundLoopStatement

        Public Sub New(syntax As SyntaxNode, condition As BoundExpression, body As BoundStatement, continueLabel As LabelSymbol, exitLabel As LabelSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.WhileStatement, syntax, continueLabel, exitLabel, hasErrors OrElse condition.NonNullAndHasErrors() OrElse body.NonNullAndHasErrors())

            Debug.Assert(condition IsNot Nothing, "Field 'condition' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(body IsNot Nothing, "Field 'body' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(continueLabel IsNot Nothing, "Field 'continueLabel' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(exitLabel IsNot Nothing, "Field 'exitLabel' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Condition = condition
            Me._Body = body
        End Sub


        Private ReadOnly _Condition As BoundExpression
        Public ReadOnly Property Condition As BoundExpression
            Get
                Return _Condition
            End Get
        End Property

        Private ReadOnly _Body As BoundStatement
        Public ReadOnly Property Body As BoundStatement
            Get
                Return _Body
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitWhileStatement(Me)
        End Function

        Public Function Update(condition As BoundExpression, body As BoundStatement, continueLabel As LabelSymbol, exitLabel As LabelSymbol) As BoundWhileStatement
            If condition IsNot Me.Condition OrElse body IsNot Me.Body OrElse continueLabel IsNot Me.ContinueLabel OrElse exitLabel IsNot Me.ExitLabel Then
                Dim result = New BoundWhileStatement(Me.Syntax, condition, body, continueLabel, exitLabel, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend MustInherit Partial Class BoundForStatement
        Inherits BoundLoopStatement

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, declaredOrInferredLocalOpt As LocalSymbol, controlVariable As BoundExpression, body As BoundStatement, nextVariablesOpt As ReadOnlyArray(Of BoundExpression), continueLabel As LabelSymbol, exitLabel As LabelSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(kind, syntax, continueLabel, exitLabel, hasErrors)

            Debug.Assert(controlVariable IsNot Nothing, "Field 'controlVariable' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(body IsNot Nothing, "Field 'body' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(continueLabel IsNot Nothing, "Field 'continueLabel' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(exitLabel IsNot Nothing, "Field 'exitLabel' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._DeclaredOrInferredLocalOpt = declaredOrInferredLocalOpt
            Me._ControlVariable = controlVariable
            Me._Body = body
            Me._NextVariablesOpt = nextVariablesOpt
        End Sub


        Private ReadOnly _DeclaredOrInferredLocalOpt As LocalSymbol
        Public ReadOnly Property DeclaredOrInferredLocalOpt As LocalSymbol
            Get
                Return _DeclaredOrInferredLocalOpt
            End Get
        End Property

        Private ReadOnly _ControlVariable As BoundExpression
        Public ReadOnly Property ControlVariable As BoundExpression
            Get
                Return _ControlVariable
            End Get
        End Property

        Private ReadOnly _Body As BoundStatement
        Public ReadOnly Property Body As BoundStatement
            Get
                Return _Body
            End Get
        End Property

        Private ReadOnly _NextVariablesOpt As ReadOnlyArray(Of BoundExpression)
        Public ReadOnly Property NextVariablesOpt As ReadOnlyArray(Of BoundExpression)
            Get
                Return _NextVariablesOpt
            End Get
        End Property
    End Class

    Friend NotInheritable Partial Class BoundForToStatement
        Inherits BoundForStatement

        Public Sub New(syntax As SyntaxNode, initialValue As BoundExpression, limitValue As BoundExpression, stepValue As BoundExpression, checked As Boolean, declaredOrInferredLocalOpt As LocalSymbol, controlVariable As BoundExpression, body As BoundStatement, nextVariablesOpt As ReadOnlyArray(Of BoundExpression), continueLabel As LabelSymbol, exitLabel As LabelSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.ForToStatement, syntax, declaredOrInferredLocalOpt, controlVariable, body, nextVariablesOpt, continueLabel, exitLabel, hasErrors OrElse initialValue.NonNullAndHasErrors() OrElse limitValue.NonNullAndHasErrors() OrElse stepValue.NonNullAndHasErrors() OrElse controlVariable.NonNullAndHasErrors() OrElse body.NonNullAndHasErrors() OrElse nextVariablesOpt.NonNullAndHasErrors())

            Debug.Assert(initialValue IsNot Nothing, "Field 'initialValue' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(limitValue IsNot Nothing, "Field 'limitValue' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(stepValue IsNot Nothing, "Field 'stepValue' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(controlVariable IsNot Nothing, "Field 'controlVariable' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(body IsNot Nothing, "Field 'body' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(continueLabel IsNot Nothing, "Field 'continueLabel' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(exitLabel IsNot Nothing, "Field 'exitLabel' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._InitialValue = initialValue
            Me._LimitValue = limitValue
            Me._StepValue = stepValue
            Me._Checked = checked
        End Sub


        Private ReadOnly _InitialValue As BoundExpression
        Public ReadOnly Property InitialValue As BoundExpression
            Get
                Return _InitialValue
            End Get
        End Property

        Private ReadOnly _LimitValue As BoundExpression
        Public ReadOnly Property LimitValue As BoundExpression
            Get
                Return _LimitValue
            End Get
        End Property

        Private ReadOnly _StepValue As BoundExpression
        Public ReadOnly Property StepValue As BoundExpression
            Get
                Return _StepValue
            End Get
        End Property

        Private ReadOnly _Checked As Boolean
        Public ReadOnly Property Checked As Boolean
            Get
                Return _Checked
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitForToStatement(Me)
        End Function

        Public Function Update(initialValue As BoundExpression, limitValue As BoundExpression, stepValue As BoundExpression, checked As Boolean, declaredOrInferredLocalOpt As LocalSymbol, controlVariable As BoundExpression, body As BoundStatement, nextVariablesOpt As ReadOnlyArray(Of BoundExpression), continueLabel As LabelSymbol, exitLabel As LabelSymbol) As BoundForToStatement
            If initialValue IsNot Me.InitialValue OrElse limitValue IsNot Me.LimitValue OrElse stepValue IsNot Me.StepValue OrElse checked <> Me.Checked OrElse declaredOrInferredLocalOpt IsNot Me.DeclaredOrInferredLocalOpt OrElse controlVariable IsNot Me.ControlVariable OrElse body IsNot Me.Body OrElse nextVariablesOpt <> Me.NextVariablesOpt OrElse continueLabel IsNot Me.ContinueLabel OrElse exitLabel IsNot Me.ExitLabel Then
                Dim result = New BoundForToStatement(Me.Syntax, initialValue, limitValue, stepValue, checked, declaredOrInferredLocalOpt, controlVariable, body, nextVariablesOpt, continueLabel, exitLabel, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundForEachStatement
        Inherits BoundForStatement

        Public Sub New(syntax As SyntaxNode, collection As BoundExpression, enumeratorInfo As ForEachEnumeratorInfo, declaredOrInferredLocalOpt As LocalSymbol, controlVariable As BoundExpression, body As BoundStatement, nextVariablesOpt As ReadOnlyArray(Of BoundExpression), continueLabel As LabelSymbol, exitLabel As LabelSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.ForEachStatement, syntax, declaredOrInferredLocalOpt, controlVariable, body, nextVariablesOpt, continueLabel, exitLabel, hasErrors OrElse collection.NonNullAndHasErrors() OrElse controlVariable.NonNullAndHasErrors() OrElse body.NonNullAndHasErrors() OrElse nextVariablesOpt.NonNullAndHasErrors())

            Debug.Assert(collection IsNot Nothing, "Field 'collection' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(enumeratorInfo IsNot Nothing, "Field 'enumeratorInfo' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(controlVariable IsNot Nothing, "Field 'controlVariable' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(body IsNot Nothing, "Field 'body' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(continueLabel IsNot Nothing, "Field 'continueLabel' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(exitLabel IsNot Nothing, "Field 'exitLabel' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Collection = collection
            Me._EnumeratorInfo = enumeratorInfo
        End Sub


        Private ReadOnly _Collection As BoundExpression
        Public ReadOnly Property Collection As BoundExpression
            Get
                Return _Collection
            End Get
        End Property

        Private ReadOnly _EnumeratorInfo As ForEachEnumeratorInfo
        Public ReadOnly Property EnumeratorInfo As ForEachEnumeratorInfo
            Get
                Return _EnumeratorInfo
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitForEachStatement(Me)
        End Function

        Public Function Update(collection As BoundExpression, enumeratorInfo As ForEachEnumeratorInfo, declaredOrInferredLocalOpt As LocalSymbol, controlVariable As BoundExpression, body As BoundStatement, nextVariablesOpt As ReadOnlyArray(Of BoundExpression), continueLabel As LabelSymbol, exitLabel As LabelSymbol) As BoundForEachStatement
            If collection IsNot Me.Collection OrElse enumeratorInfo IsNot Me.EnumeratorInfo OrElse declaredOrInferredLocalOpt IsNot Me.DeclaredOrInferredLocalOpt OrElse controlVariable IsNot Me.ControlVariable OrElse body IsNot Me.Body OrElse nextVariablesOpt <> Me.NextVariablesOpt OrElse continueLabel IsNot Me.ContinueLabel OrElse exitLabel IsNot Me.ExitLabel Then
                Dim result = New BoundForEachStatement(Me.Syntax, collection, enumeratorInfo, declaredOrInferredLocalOpt, controlVariable, body, nextVariablesOpt, continueLabel, exitLabel, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundExitStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, label As LabelSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.ExitStatement, syntax, hasErrors)

            Debug.Assert(label IsNot Nothing, "Field 'label' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Label = label
        End Sub

        Public Sub New(syntax As SyntaxNode, label As LabelSymbol)
            MyBase.New(BoundKind.ExitStatement, syntax)

            Debug.Assert(label IsNot Nothing, "Field 'label' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Label = label
        End Sub


        Private ReadOnly _Label As LabelSymbol
        Public ReadOnly Property Label As LabelSymbol
            Get
                Return _Label
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitExitStatement(Me)
        End Function

        Public Function Update(label As LabelSymbol) As BoundExitStatement
            If label IsNot Me.Label Then
                Dim result = New BoundExitStatement(Me.Syntax, label, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundContinueStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, label As LabelSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.ContinueStatement, syntax, hasErrors)

            Debug.Assert(label IsNot Nothing, "Field 'label' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Label = label
        End Sub

        Public Sub New(syntax As SyntaxNode, label As LabelSymbol)
            MyBase.New(BoundKind.ContinueStatement, syntax)

            Debug.Assert(label IsNot Nothing, "Field 'label' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Label = label
        End Sub


        Private ReadOnly _Label As LabelSymbol
        Public ReadOnly Property Label As LabelSymbol
            Get
                Return _Label
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitContinueStatement(Me)
        End Function

        Public Function Update(label As LabelSymbol) As BoundContinueStatement
            If label IsNot Me.Label Then
                Dim result = New BoundContinueStatement(Me.Syntax, label, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundTryStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, tryBlock As BoundBlock, catchBlocks As ReadOnlyArray(Of BoundCatchBlock), finallyBlockOpt As BoundBlock, exitLabelOpt As LabelSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.TryStatement, syntax, hasErrors OrElse tryBlock.NonNullAndHasErrors() OrElse catchBlocks.NonNullAndHasErrors() OrElse finallyBlockOpt.NonNullAndHasErrors())

            Debug.Assert(tryBlock IsNot Nothing, "Field 'tryBlock' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (catchBlocks.IsNull), "Field 'catchBlocks' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._TryBlock = tryBlock
            Me._CatchBlocks = catchBlocks
            Me._FinallyBlockOpt = finallyBlockOpt
            Me._ExitLabelOpt = exitLabelOpt
        End Sub


        Private ReadOnly _TryBlock As BoundBlock
        Public ReadOnly Property TryBlock As BoundBlock
            Get
                Return _TryBlock
            End Get
        End Property

        Private ReadOnly _CatchBlocks As ReadOnlyArray(Of BoundCatchBlock)
        Public ReadOnly Property CatchBlocks As ReadOnlyArray(Of BoundCatchBlock)
            Get
                Return _CatchBlocks
            End Get
        End Property

        Private ReadOnly _FinallyBlockOpt As BoundBlock
        Public ReadOnly Property FinallyBlockOpt As BoundBlock
            Get
                Return _FinallyBlockOpt
            End Get
        End Property

        Private ReadOnly _ExitLabelOpt As LabelSymbol
        Public ReadOnly Property ExitLabelOpt As LabelSymbol
            Get
                Return _ExitLabelOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitTryStatement(Me)
        End Function

        Public Function Update(tryBlock As BoundBlock, catchBlocks As ReadOnlyArray(Of BoundCatchBlock), finallyBlockOpt As BoundBlock, exitLabelOpt As LabelSymbol) As BoundTryStatement
            If tryBlock IsNot Me.TryBlock OrElse catchBlocks <> Me.CatchBlocks OrElse finallyBlockOpt IsNot Me.FinallyBlockOpt OrElse exitLabelOpt IsNot Me.ExitLabelOpt Then
                Dim result = New BoundTryStatement(Me.Syntax, tryBlock, catchBlocks, finallyBlockOpt, exitLabelOpt, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundCatchBlock
        Inherits BoundNode

        Public Sub New(syntax As SyntaxNode, localOpt As LocalSymbol, exceptionVariableOpt As BoundExpression, exceptionFilterOpt As BoundExpression, body As BoundBlock, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.CatchBlock, syntax, hasErrors OrElse exceptionVariableOpt.NonNullAndHasErrors() OrElse exceptionFilterOpt.NonNullAndHasErrors() OrElse body.NonNullAndHasErrors())

            Debug.Assert(body IsNot Nothing, "Field 'body' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._LocalOpt = localOpt
            Me._ExceptionVariableOpt = exceptionVariableOpt
            Me._ExceptionFilterOpt = exceptionFilterOpt
            Me._Body = body
        End Sub


        Private ReadOnly _LocalOpt As LocalSymbol
        Public ReadOnly Property LocalOpt As LocalSymbol
            Get
                Return _LocalOpt
            End Get
        End Property

        Private ReadOnly _ExceptionVariableOpt As BoundExpression
        Public ReadOnly Property ExceptionVariableOpt As BoundExpression
            Get
                Return _ExceptionVariableOpt
            End Get
        End Property

        Private ReadOnly _ExceptionFilterOpt As BoundExpression
        Public ReadOnly Property ExceptionFilterOpt As BoundExpression
            Get
                Return _ExceptionFilterOpt
            End Get
        End Property

        Private ReadOnly _Body As BoundBlock
        Public ReadOnly Property Body As BoundBlock
            Get
                Return _Body
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitCatchBlock(Me)
        End Function

        Public Function Update(localOpt As LocalSymbol, exceptionVariableOpt As BoundExpression, exceptionFilterOpt As BoundExpression, body As BoundBlock) As BoundCatchBlock
            If localOpt IsNot Me.LocalOpt OrElse exceptionVariableOpt IsNot Me.ExceptionVariableOpt OrElse exceptionFilterOpt IsNot Me.ExceptionFilterOpt OrElse body IsNot Me.Body Then
                Dim result = New BoundCatchBlock(Me.Syntax, localOpt, exceptionVariableOpt, exceptionFilterOpt, body, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundLiteral
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, value As ConstantValue, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.Literal, syntax, type, hasErrors)

            Debug.Assert(value IsNot Nothing, "Field 'value' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Value = value

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub

        Public Sub New(syntax As SyntaxNode, value As ConstantValue, type As TypeSymbol)
            MyBase.New(BoundKind.Literal, syntax, type)

            Debug.Assert(value IsNot Nothing, "Field 'value' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Value = value

            Validate()
        End Sub


        Private ReadOnly _Value As ConstantValue
        Public ReadOnly Property Value As ConstantValue
            Get
                Return _Value
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitLiteral(Me)
        End Function

        Public Function Update(value As ConstantValue, type As TypeSymbol) As BoundLiteral
            If value IsNot Me.Value OrElse type IsNot Me.Type Then
                Dim result = New BoundLiteral(Me.Syntax, value, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundMeReference
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, meSymbolOpt As ParameterSymbol, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.MeReference, syntax, type, hasErrors)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._MeSymbolOpt = meSymbolOpt
        End Sub

        Public Sub New(syntax As SyntaxNode, meSymbolOpt As ParameterSymbol, type As TypeSymbol)
            MyBase.New(BoundKind.MeReference, syntax, type)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._MeSymbolOpt = meSymbolOpt
        End Sub


        Private ReadOnly _MeSymbolOpt As ParameterSymbol
        Public ReadOnly Property MeSymbolOpt As ParameterSymbol
            Get
                Return _MeSymbolOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitMeReference(Me)
        End Function

        Public Function Update(meSymbolOpt As ParameterSymbol, type As TypeSymbol) As BoundMeReference
            If meSymbolOpt IsNot Me.MeSymbolOpt OrElse type IsNot Me.Type Then
                Dim result = New BoundMeReference(Me.Syntax, meSymbolOpt, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundMyBaseReference
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, meSymbolOpt As ParameterSymbol, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.MyBaseReference, syntax, type, hasErrors)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._MeSymbolOpt = meSymbolOpt
        End Sub

        Public Sub New(syntax As SyntaxNode, meSymbolOpt As ParameterSymbol, type As TypeSymbol)
            MyBase.New(BoundKind.MyBaseReference, syntax, type)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._MeSymbolOpt = meSymbolOpt
        End Sub


        Private ReadOnly _MeSymbolOpt As ParameterSymbol
        Public ReadOnly Property MeSymbolOpt As ParameterSymbol
            Get
                Return _MeSymbolOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitMyBaseReference(Me)
        End Function

        Public Function Update(meSymbolOpt As ParameterSymbol, type As TypeSymbol) As BoundMyBaseReference
            If meSymbolOpt IsNot Me.MeSymbolOpt OrElse type IsNot Me.Type Then
                Dim result = New BoundMyBaseReference(Me.Syntax, meSymbolOpt, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundMyClassReference
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, meSymbolOpt As ParameterSymbol, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.MyClassReference, syntax, type, hasErrors)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._MeSymbolOpt = meSymbolOpt
        End Sub

        Public Sub New(syntax As SyntaxNode, meSymbolOpt As ParameterSymbol, type As TypeSymbol)
            MyBase.New(BoundKind.MyClassReference, syntax, type)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._MeSymbolOpt = meSymbolOpt
        End Sub


        Private ReadOnly _MeSymbolOpt As ParameterSymbol
        Public ReadOnly Property MeSymbolOpt As ParameterSymbol
            Get
                Return _MeSymbolOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitMyClassReference(Me)
        End Function

        Public Function Update(meSymbolOpt As ParameterSymbol, type As TypeSymbol) As BoundMyClassReference
            If meSymbolOpt IsNot Me.MeSymbolOpt OrElse type IsNot Me.Type Then
                Dim result = New BoundMyClassReference(Me.Syntax, meSymbolOpt, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundPreviousSubmissionReference
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, sourceType As NamedTypeSymbol, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.PreviousSubmissionReference, syntax, type, hasErrors)

            Debug.Assert(sourceType IsNot Nothing, "Field 'sourceType' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._SourceType = sourceType
        End Sub

        Public Sub New(syntax As SyntaxNode, sourceType As NamedTypeSymbol, type As TypeSymbol)
            MyBase.New(BoundKind.PreviousSubmissionReference, syntax, type)

            Debug.Assert(sourceType IsNot Nothing, "Field 'sourceType' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._SourceType = sourceType
        End Sub


        Private ReadOnly _SourceType As NamedTypeSymbol
        Public ReadOnly Property SourceType As NamedTypeSymbol
            Get
                Return _SourceType
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitPreviousSubmissionReference(Me)
        End Function

        Public Function Update(sourceType As NamedTypeSymbol, type As TypeSymbol) As BoundPreviousSubmissionReference
            If sourceType IsNot Me.SourceType OrElse type IsNot Me.Type Then
                Dim result = New BoundPreviousSubmissionReference(Me.Syntax, sourceType, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundHostObjectMemberReference
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.HostObjectMemberReference, syntax, type, hasErrors)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

        End Sub

        Public Sub New(syntax As SyntaxNode, type As TypeSymbol)
            MyBase.New(BoundKind.HostObjectMemberReference, syntax, type)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

        End Sub


        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitHostObjectMemberReference(Me)
        End Function

        Public Function Update(type As TypeSymbol) As BoundHostObjectMemberReference
            If type IsNot Me.Type Then
                Dim result = New BoundHostObjectMemberReference(Me.Syntax, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundLocal
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, localSymbol As LocalSymbol, isLValue As Boolean, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.Local, syntax, type, hasErrors)

            Debug.Assert(localSymbol IsNot Nothing, "Field 'localSymbol' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._LocalSymbol = localSymbol
            Me._IsLValue = isLValue

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub

        Public Sub New(syntax As SyntaxNode, localSymbol As LocalSymbol, isLValue As Boolean, type As TypeSymbol)
            MyBase.New(BoundKind.Local, syntax, type)

            Debug.Assert(localSymbol IsNot Nothing, "Field 'localSymbol' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._LocalSymbol = localSymbol
            Me._IsLValue = isLValue

            Validate()
        End Sub


        Private ReadOnly _LocalSymbol As LocalSymbol
        Public ReadOnly Property LocalSymbol As LocalSymbol
            Get
                Return _LocalSymbol
            End Get
        End Property

        Private ReadOnly _IsLValue As Boolean
        Public Overrides ReadOnly Property IsLValue As Boolean
            Get
                Return _IsLValue
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitLocal(Me)
        End Function

        Public Function Update(localSymbol As LocalSymbol, isLValue As Boolean, type As TypeSymbol) As BoundLocal
            If localSymbol IsNot Me.LocalSymbol OrElse isLValue <> Me.IsLValue OrElse type IsNot Me.Type Then
                Dim result = New BoundLocal(Me.Syntax, localSymbol, isLValue, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundParameter
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, parameterSymbol As ParameterSymbol, isLValue As Boolean, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.Parameter, syntax, type, hasErrors)

            Debug.Assert(parameterSymbol IsNot Nothing, "Field 'parameterSymbol' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._ParameterSymbol = parameterSymbol
            Me._IsLValue = isLValue
        End Sub

        Public Sub New(syntax As SyntaxNode, parameterSymbol As ParameterSymbol, isLValue As Boolean, type As TypeSymbol)
            MyBase.New(BoundKind.Parameter, syntax, type)

            Debug.Assert(parameterSymbol IsNot Nothing, "Field 'parameterSymbol' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._ParameterSymbol = parameterSymbol
            Me._IsLValue = isLValue
        End Sub


        Private ReadOnly _ParameterSymbol As ParameterSymbol
        Public ReadOnly Property ParameterSymbol As ParameterSymbol
            Get
                Return _ParameterSymbol
            End Get
        End Property

        Private ReadOnly _IsLValue As Boolean
        Public Overrides ReadOnly Property IsLValue As Boolean
            Get
                Return _IsLValue
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitParameter(Me)
        End Function

        Public Function Update(parameterSymbol As ParameterSymbol, isLValue As Boolean, type As TypeSymbol) As BoundParameter
            If parameterSymbol IsNot Me.ParameterSymbol OrElse isLValue <> Me.IsLValue OrElse type IsNot Me.Type Then
                Dim result = New BoundParameter(Me.Syntax, parameterSymbol, isLValue, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundByRefArgumentPlaceholder
        Inherits BoundValuePlaceholderBase

        Public Sub New(syntax As SyntaxNode, isOut As Boolean, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.ByRefArgumentPlaceholder, syntax, type, hasErrors)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._IsOut = isOut
        End Sub

        Public Sub New(syntax As SyntaxNode, isOut As Boolean, type As TypeSymbol)
            MyBase.New(BoundKind.ByRefArgumentPlaceholder, syntax, type)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._IsOut = isOut
        End Sub


        Private ReadOnly _IsOut As Boolean
        Public ReadOnly Property IsOut As Boolean
            Get
                Return _IsOut
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitByRefArgumentPlaceholder(Me)
        End Function

        Public Function Update(isOut As Boolean, type As TypeSymbol) As BoundByRefArgumentPlaceholder
            If isOut <> Me.IsOut OrElse type IsNot Me.Type Then
                Dim result = New BoundByRefArgumentPlaceholder(Me.Syntax, isOut, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundByRefArgumentWithCopyBack
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, originalArgument As BoundExpression, inConversion As BoundExpression, inPlaceholder As BoundByRefArgumentPlaceholder, outConversion As BoundExpression, outPlaceholder As BoundValuePlaceholder, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.ByRefArgumentWithCopyBack, syntax, type, hasErrors OrElse originalArgument.NonNullAndHasErrors() OrElse inConversion.NonNullAndHasErrors() OrElse inPlaceholder.NonNullAndHasErrors() OrElse outConversion.NonNullAndHasErrors() OrElse outPlaceholder.NonNullAndHasErrors())

            Debug.Assert(originalArgument IsNot Nothing, "Field 'originalArgument' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(inConversion IsNot Nothing, "Field 'inConversion' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(inPlaceholder IsNot Nothing, "Field 'inPlaceholder' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(outConversion IsNot Nothing, "Field 'outConversion' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(outPlaceholder IsNot Nothing, "Field 'outPlaceholder' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._OriginalArgument = originalArgument
            Me._InConversion = inConversion
            Me._InPlaceholder = inPlaceholder
            Me._OutConversion = outConversion
            Me._OutPlaceholder = outPlaceholder

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _OriginalArgument As BoundExpression
        Public ReadOnly Property OriginalArgument As BoundExpression
            Get
                Return _OriginalArgument
            End Get
        End Property

        Private ReadOnly _InConversion As BoundExpression
        Public ReadOnly Property InConversion As BoundExpression
            Get
                Return _InConversion
            End Get
        End Property

        Private ReadOnly _InPlaceholder As BoundByRefArgumentPlaceholder
        Public ReadOnly Property InPlaceholder As BoundByRefArgumentPlaceholder
            Get
                Return _InPlaceholder
            End Get
        End Property

        Private ReadOnly _OutConversion As BoundExpression
        Public ReadOnly Property OutConversion As BoundExpression
            Get
                Return _OutConversion
            End Get
        End Property

        Private ReadOnly _OutPlaceholder As BoundValuePlaceholder
        Public ReadOnly Property OutPlaceholder As BoundValuePlaceholder
            Get
                Return _OutPlaceholder
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitByRefArgumentWithCopyBack(Me)
        End Function

        Public Function Update(originalArgument As BoundExpression, inConversion As BoundExpression, inPlaceholder As BoundByRefArgumentPlaceholder, outConversion As BoundExpression, outPlaceholder As BoundValuePlaceholder, type As TypeSymbol) As BoundByRefArgumentWithCopyBack
            If originalArgument IsNot Me.OriginalArgument OrElse inConversion IsNot Me.InConversion OrElse inPlaceholder IsNot Me.InPlaceholder OrElse outConversion IsNot Me.OutConversion OrElse outPlaceholder IsNot Me.OutPlaceholder OrElse type IsNot Me.Type Then
                Dim result = New BoundByRefArgumentWithCopyBack(Me.Syntax, originalArgument, inConversion, inPlaceholder, outConversion, outPlaceholder, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundLabelStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, label As LabelSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.LabelStatement, syntax, hasErrors)

            Debug.Assert(label IsNot Nothing, "Field 'label' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Label = label
        End Sub

        Public Sub New(syntax As SyntaxNode, label As LabelSymbol)
            MyBase.New(BoundKind.LabelStatement, syntax)

            Debug.Assert(label IsNot Nothing, "Field 'label' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Label = label
        End Sub


        Private ReadOnly _Label As LabelSymbol
        Public ReadOnly Property Label As LabelSymbol
            Get
                Return _Label
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitLabelStatement(Me)
        End Function

        Public Function Update(label As LabelSymbol) As BoundLabelStatement
            If label IsNot Me.Label Then
                Dim result = New BoundLabelStatement(Me.Syntax, label, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundLabel
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, label As LabelSymbol, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.Label, syntax, type, hasErrors)

            Debug.Assert(label IsNot Nothing, "Field 'label' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Label = label
        End Sub

        Public Sub New(syntax As SyntaxNode, label As LabelSymbol, type As TypeSymbol)
            MyBase.New(BoundKind.Label, syntax, type)

            Debug.Assert(label IsNot Nothing, "Field 'label' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Label = label
        End Sub


        Private ReadOnly _Label As LabelSymbol
        Public ReadOnly Property Label As LabelSymbol
            Get
                Return _Label
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitLabel(Me)
        End Function

        Public Function Update(label As LabelSymbol, type As TypeSymbol) As BoundLabel
            If label IsNot Me.Label OrElse type IsNot Me.Type Then
                Dim result = New BoundLabel(Me.Syntax, label, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundGotoStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, label As LabelSymbol, labelExpressionOpt As BoundLabel, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.GotoStatement, syntax, hasErrors OrElse labelExpressionOpt.NonNullAndHasErrors())

            Debug.Assert(label IsNot Nothing, "Field 'label' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Label = label
            Me._LabelExpressionOpt = labelExpressionOpt
        End Sub


        Private ReadOnly _Label As LabelSymbol
        Public ReadOnly Property Label As LabelSymbol
            Get
                Return _Label
            End Get
        End Property

        Private ReadOnly _LabelExpressionOpt As BoundLabel
        Public ReadOnly Property LabelExpressionOpt As BoundLabel
            Get
                Return _LabelExpressionOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitGotoStatement(Me)
        End Function

        Public Function Update(label As LabelSymbol, labelExpressionOpt As BoundLabel) As BoundGotoStatement
            If label IsNot Me.Label OrElse labelExpressionOpt IsNot Me.LabelExpressionOpt Then
                Dim result = New BoundGotoStatement(Me.Syntax, label, labelExpressionOpt, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundStatementList
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, statements As ReadOnlyArray(Of BoundStatement), Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.StatementList, syntax, hasErrors OrElse statements.NonNullAndHasErrors())

            Debug.Assert(Not (statements.IsNull), "Field 'statements' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Statements = statements
        End Sub


        Private ReadOnly _Statements As ReadOnlyArray(Of BoundStatement)
        Public ReadOnly Property Statements As ReadOnlyArray(Of BoundStatement)
            Get
                Return _Statements
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitStatementList(Me)
        End Function

        Public Function Update(statements As ReadOnlyArray(Of BoundStatement)) As BoundStatementList
            If statements <> Me.Statements Then
                Dim result = New BoundStatementList(Me.Syntax, statements, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundConditionalGoto
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, condition As BoundExpression, jumpIfTrue As Boolean, label As LabelSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.ConditionalGoto, syntax, hasErrors OrElse condition.NonNullAndHasErrors())

            Debug.Assert(condition IsNot Nothing, "Field 'condition' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(label IsNot Nothing, "Field 'label' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Condition = condition
            Me._JumpIfTrue = jumpIfTrue
            Me._Label = label
        End Sub


        Private ReadOnly _Condition As BoundExpression
        Public ReadOnly Property Condition As BoundExpression
            Get
                Return _Condition
            End Get
        End Property

        Private ReadOnly _JumpIfTrue As Boolean
        Public ReadOnly Property JumpIfTrue As Boolean
            Get
                Return _JumpIfTrue
            End Get
        End Property

        Private ReadOnly _Label As LabelSymbol
        Public ReadOnly Property Label As LabelSymbol
            Get
                Return _Label
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitConditionalGoto(Me)
        End Function

        Public Function Update(condition As BoundExpression, jumpIfTrue As Boolean, label As LabelSymbol) As BoundConditionalGoto
            If condition IsNot Me.Condition OrElse jumpIfTrue <> Me.JumpIfTrue OrElse label IsNot Me.Label Then
                Dim result = New BoundConditionalGoto(Me.Syntax, condition, jumpIfTrue, label, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundWithStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, originalExpression As BoundExpression, body As BoundBlock, binder As WithBlockBinder, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.WithStatement, syntax, hasErrors OrElse originalExpression.NonNullAndHasErrors() OrElse body.NonNullAndHasErrors())

            Debug.Assert(originalExpression IsNot Nothing, "Field 'originalExpression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(body IsNot Nothing, "Field 'body' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(binder IsNot Nothing, "Field 'binder' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._OriginalExpression = originalExpression
            Me._Body = body
            Me._Binder = binder
        End Sub


        Private ReadOnly _OriginalExpression As BoundExpression
        Public ReadOnly Property OriginalExpression As BoundExpression
            Get
                Return _OriginalExpression
            End Get
        End Property

        Private ReadOnly _Body As BoundBlock
        Public ReadOnly Property Body As BoundBlock
            Get
                Return _Body
            End Get
        End Property

        Private ReadOnly _Binder As WithBlockBinder
        Public ReadOnly Property Binder As WithBlockBinder
            Get
                Return _Binder
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitWithStatement(Me)
        End Function

        Public Function Update(originalExpression As BoundExpression, body As BoundBlock, binder As WithBlockBinder) As BoundWithStatement
            If originalExpression IsNot Me.OriginalExpression OrElse body IsNot Me.Body OrElse binder IsNot Me.Binder Then
                Dim result = New BoundWithStatement(Me.Syntax, originalExpression, body, binder, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class UnboundLambda
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, binder As Binder, parameters As ReadOnlyArray(Of ParameterSymbol), returnType As TypeSymbol, bindingCache As UnboundLambda.UnboundLambdaBindingCache, hasErrors As Boolean)
            MyBase.New(BoundKind.UnboundLambda, syntax, Nothing, hasErrors)

            Debug.Assert(binder IsNot Nothing, "Field 'binder' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (parameters.IsNull), "Field 'parameters' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(bindingCache IsNot Nothing, "Field 'bindingCache' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Binder = binder
            Me._Parameters = parameters
            Me._ReturnType = returnType
            Me._BindingCache = bindingCache
        End Sub

        Public Sub New(syntax As SyntaxNode, binder As Binder, parameters As ReadOnlyArray(Of ParameterSymbol), returnType As TypeSymbol, bindingCache As UnboundLambda.UnboundLambdaBindingCache)
            MyBase.New(BoundKind.UnboundLambda, syntax, Nothing)

            Debug.Assert(binder IsNot Nothing, "Field 'binder' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (parameters.IsNull), "Field 'parameters' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(bindingCache IsNot Nothing, "Field 'bindingCache' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Binder = binder
            Me._Parameters = parameters
            Me._ReturnType = returnType
            Me._BindingCache = bindingCache
        End Sub


        Private ReadOnly _Binder As Binder
        Public ReadOnly Property Binder As Binder
            Get
                Return _Binder
            End Get
        End Property

        Private ReadOnly _Parameters As ReadOnlyArray(Of ParameterSymbol)
        Public ReadOnly Property Parameters As ReadOnlyArray(Of ParameterSymbol)
            Get
                Return _Parameters
            End Get
        End Property

        Private ReadOnly _ReturnType As TypeSymbol
        Public ReadOnly Property ReturnType As TypeSymbol
            Get
                Return _ReturnType
            End Get
        End Property

        Private ReadOnly _BindingCache As UnboundLambda.UnboundLambdaBindingCache
        Public ReadOnly Property BindingCache As UnboundLambda.UnboundLambdaBindingCache
            Get
                Return _BindingCache
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitUnboundLambda(Me)
        End Function

        Public Function Update(binder As Binder, parameters As ReadOnlyArray(Of ParameterSymbol), returnType As TypeSymbol, bindingCache As UnboundLambda.UnboundLambdaBindingCache) As UnboundLambda
            If binder IsNot Me.Binder OrElse parameters <> Me.Parameters OrElse returnType IsNot Me.ReturnType OrElse bindingCache IsNot Me.BindingCache Then
                Dim result = New UnboundLambda(Me.Syntax, binder, parameters, returnType, bindingCache, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundLambda
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, unboundLambdaOpt As UnboundLambda, lambdaSymbol As LambdaSymbol, body As BoundBlock, diagnosticsOpt As DiagnosticBag, lambdaBinderOpt As LambdaBodyBinder, delegateRelaxation As ConversionKind, methodConversionKind As MethodConversionKind, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.Lambda, syntax, Nothing, hasErrors OrElse unboundLambdaOpt.NonNullAndHasErrors() OrElse body.NonNullAndHasErrors())

            Debug.Assert(lambdaSymbol IsNot Nothing, "Field 'lambdaSymbol' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(body IsNot Nothing, "Field 'body' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._UnboundLambdaOpt = unboundLambdaOpt
            Me._LambdaSymbol = lambdaSymbol
            Me._Body = body
            Me._DiagnosticsOpt = diagnosticsOpt
            Me._LambdaBinderOpt = lambdaBinderOpt
            Me._DelegateRelaxation = delegateRelaxation
            Me._MethodConversionKind = methodConversionKind

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _UnboundLambdaOpt As UnboundLambda
        Public ReadOnly Property UnboundLambdaOpt As UnboundLambda
            Get
                Return _UnboundLambdaOpt
            End Get
        End Property

        Private ReadOnly _LambdaSymbol As LambdaSymbol
        Public ReadOnly Property LambdaSymbol As LambdaSymbol
            Get
                Return _LambdaSymbol
            End Get
        End Property

        Private ReadOnly _Body As BoundBlock
        Public ReadOnly Property Body As BoundBlock
            Get
                Return _Body
            End Get
        End Property

        Private ReadOnly _DiagnosticsOpt As DiagnosticBag
        Public ReadOnly Property DiagnosticsOpt As DiagnosticBag
            Get
                Return _DiagnosticsOpt
            End Get
        End Property

        Private ReadOnly _LambdaBinderOpt As LambdaBodyBinder
        Public ReadOnly Property LambdaBinderOpt As LambdaBodyBinder
            Get
                Return _LambdaBinderOpt
            End Get
        End Property

        Private ReadOnly _DelegateRelaxation As ConversionKind
        Public ReadOnly Property DelegateRelaxation As ConversionKind
            Get
                Return _DelegateRelaxation
            End Get
        End Property

        Private ReadOnly _MethodConversionKind As MethodConversionKind
        Public ReadOnly Property MethodConversionKind As MethodConversionKind
            Get
                Return _MethodConversionKind
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitLambda(Me)
        End Function

        Public Function Update(unboundLambdaOpt As UnboundLambda, lambdaSymbol As LambdaSymbol, body As BoundBlock, diagnosticsOpt As DiagnosticBag, lambdaBinderOpt As LambdaBodyBinder, delegateRelaxation As ConversionKind, methodConversionKind As MethodConversionKind) As BoundLambda
            If unboundLambdaOpt IsNot Me.UnboundLambdaOpt OrElse lambdaSymbol IsNot Me.LambdaSymbol OrElse body IsNot Me.Body OrElse diagnosticsOpt IsNot Me.DiagnosticsOpt OrElse lambdaBinderOpt IsNot Me.LambdaBinderOpt OrElse delegateRelaxation <> Me.DelegateRelaxation OrElse methodConversionKind <> Me.MethodConversionKind Then
                Dim result = New BoundLambda(Me.Syntax, unboundLambdaOpt, lambdaSymbol, body, diagnosticsOpt, lambdaBinderOpt, delegateRelaxation, methodConversionKind, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundQueryExpression
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, lastOperator As BoundQueryClauseBase, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.QueryExpression, syntax, type, hasErrors OrElse lastOperator.NonNullAndHasErrors())

            Debug.Assert(lastOperator IsNot Nothing, "Field 'lastOperator' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._LastOperator = lastOperator
        End Sub


        Private ReadOnly _LastOperator As BoundQueryClauseBase
        Public ReadOnly Property LastOperator As BoundQueryClauseBase
            Get
                Return _LastOperator
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitQueryExpression(Me)
        End Function

        Public Function Update(lastOperator As BoundQueryClauseBase, type As TypeSymbol) As BoundQueryExpression
            If lastOperator IsNot Me.LastOperator OrElse type IsNot Me.Type Then
                Dim result = New BoundQueryExpression(Me.Syntax, lastOperator, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend MustInherit Partial Class BoundQueryPart
        Inherits BoundExpression

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(kind, syntax, type, hasErrors)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

        End Sub

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, type As TypeSymbol)
            MyBase.New(kind, syntax, type)

            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

        End Sub

    End Class

    Friend NotInheritable Partial Class BoundQuerySource
        Inherits BoundQueryPart

        Public Sub New(syntax As SyntaxNode, expression As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.QuerySource, syntax, type, hasErrors OrElse expression.NonNullAndHasErrors())

            Debug.Assert(expression IsNot Nothing, "Field 'expression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Expression = expression
        End Sub


        Private ReadOnly _Expression As BoundExpression
        Public ReadOnly Property Expression As BoundExpression
            Get
                Return _Expression
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitQuerySource(Me)
        End Function

        Public Function Update(expression As BoundExpression, type As TypeSymbol) As BoundQuerySource
            If expression IsNot Me.Expression OrElse type IsNot Me.Type Then
                Dim result = New BoundQuerySource(Me.Syntax, expression, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundToQueryableCollectionConversion
        Inherits BoundQueryPart

        Public Sub New(syntax As SyntaxNode, conversionCall As BoundCall, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.ToQueryableCollectionConversion, syntax, type, hasErrors OrElse conversionCall.NonNullAndHasErrors())

            Debug.Assert(conversionCall IsNot Nothing, "Field 'conversionCall' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._ConversionCall = conversionCall
        End Sub


        Private ReadOnly _ConversionCall As BoundCall
        Public ReadOnly Property ConversionCall As BoundCall
            Get
                Return _ConversionCall
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitToQueryableCollectionConversion(Me)
        End Function

        Public Function Update(conversionCall As BoundCall, type As TypeSymbol) As BoundToQueryableCollectionConversion
            If conversionCall IsNot Me.ConversionCall OrElse type IsNot Me.Type Then
                Dim result = New BoundToQueryableCollectionConversion(Me.Syntax, conversionCall, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend MustInherit Partial Class BoundQueryClauseBase
        Inherits BoundQueryPart

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, rangeVariables As ReadOnlyArray(Of RangeVariableSymbol), compoundVariableType As TypeSymbol, binders As ReadOnlyArray(Of Binder), type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(kind, syntax, type, hasErrors)

            Debug.Assert(Not (rangeVariables.IsNull), "Field 'rangeVariables' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(compoundVariableType IsNot Nothing, "Field 'compoundVariableType' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (binders.IsNull), "Field 'binders' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._RangeVariables = rangeVariables
            Me._CompoundVariableType = compoundVariableType
            Me._Binders = binders
        End Sub

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, rangeVariables As ReadOnlyArray(Of RangeVariableSymbol), compoundVariableType As TypeSymbol, binders As ReadOnlyArray(Of Binder), type As TypeSymbol)
            MyBase.New(kind, syntax, type)

            Debug.Assert(Not (rangeVariables.IsNull), "Field 'rangeVariables' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(compoundVariableType IsNot Nothing, "Field 'compoundVariableType' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (binders.IsNull), "Field 'binders' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._RangeVariables = rangeVariables
            Me._CompoundVariableType = compoundVariableType
            Me._Binders = binders
        End Sub


        Private ReadOnly _RangeVariables As ReadOnlyArray(Of RangeVariableSymbol)
        Public ReadOnly Property RangeVariables As ReadOnlyArray(Of RangeVariableSymbol)
            Get
                Return _RangeVariables
            End Get
        End Property

        Private ReadOnly _CompoundVariableType As TypeSymbol
        Public ReadOnly Property CompoundVariableType As TypeSymbol
            Get
                Return _CompoundVariableType
            End Get
        End Property

        Private ReadOnly _Binders As ReadOnlyArray(Of Binder)
        Public ReadOnly Property Binders As ReadOnlyArray(Of Binder)
            Get
                Return _Binders
            End Get
        End Property
    End Class

    Friend NotInheritable Partial Class BoundQueryableSource
        Inherits BoundQueryClauseBase

        Public Sub New(syntax As SyntaxNode, source As BoundQueryPart, rangeVariableOpt As RangeVariableSymbol, rangeVariables As ReadOnlyArray(Of RangeVariableSymbol), compoundVariableType As TypeSymbol, binders As ReadOnlyArray(Of Binder), type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.QueryableSource, syntax, rangeVariables, compoundVariableType, binders, type, hasErrors OrElse source.NonNullAndHasErrors())

            Debug.Assert(source IsNot Nothing, "Field 'source' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (rangeVariables.IsNull), "Field 'rangeVariables' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(compoundVariableType IsNot Nothing, "Field 'compoundVariableType' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (binders.IsNull), "Field 'binders' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Source = source
            Me._RangeVariableOpt = rangeVariableOpt

            Validate()
        End Sub

        Private Partial Sub Validate()
        End Sub


        Private ReadOnly _Source As BoundQueryPart
        Public ReadOnly Property Source As BoundQueryPart
            Get
                Return _Source
            End Get
        End Property

        Private ReadOnly _RangeVariableOpt As RangeVariableSymbol
        Public ReadOnly Property RangeVariableOpt As RangeVariableSymbol
            Get
                Return _RangeVariableOpt
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitQueryableSource(Me)
        End Function

        Public Function Update(source As BoundQueryPart, rangeVariableOpt As RangeVariableSymbol, rangeVariables As ReadOnlyArray(Of RangeVariableSymbol), compoundVariableType As TypeSymbol, binders As ReadOnlyArray(Of Binder), type As TypeSymbol) As BoundQueryableSource
            If source IsNot Me.Source OrElse rangeVariableOpt IsNot Me.RangeVariableOpt OrElse rangeVariables <> Me.RangeVariables OrElse compoundVariableType IsNot Me.CompoundVariableType OrElse binders <> Me.Binders OrElse type IsNot Me.Type Then
                Dim result = New BoundQueryableSource(Me.Syntax, source, rangeVariableOpt, rangeVariables, compoundVariableType, binders, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundQueryClause
        Inherits BoundQueryClauseBase

        Public Sub New(syntax As SyntaxNode, underlyingExpression As BoundExpression, rangeVariables As ReadOnlyArray(Of RangeVariableSymbol), compoundVariableType As TypeSymbol, binders As ReadOnlyArray(Of Binder), type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.QueryClause, syntax, rangeVariables, compoundVariableType, binders, type, hasErrors OrElse underlyingExpression.NonNullAndHasErrors())

            Debug.Assert(underlyingExpression IsNot Nothing, "Field 'underlyingExpression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (rangeVariables.IsNull), "Field 'rangeVariables' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(compoundVariableType IsNot Nothing, "Field 'compoundVariableType' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (binders.IsNull), "Field 'binders' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._UnderlyingExpression = underlyingExpression
        End Sub


        Private ReadOnly _UnderlyingExpression As BoundExpression
        Public ReadOnly Property UnderlyingExpression As BoundExpression
            Get
                Return _UnderlyingExpression
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitQueryClause(Me)
        End Function

        Public Function Update(underlyingExpression As BoundExpression, rangeVariables As ReadOnlyArray(Of RangeVariableSymbol), compoundVariableType As TypeSymbol, binders As ReadOnlyArray(Of Binder), type As TypeSymbol) As BoundQueryClause
            If underlyingExpression IsNot Me.UnderlyingExpression OrElse rangeVariables <> Me.RangeVariables OrElse compoundVariableType IsNot Me.CompoundVariableType OrElse binders <> Me.Binders OrElse type IsNot Me.Type Then
                Dim result = New BoundQueryClause(Me.Syntax, underlyingExpression, rangeVariables, compoundVariableType, binders, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundOrdering
        Inherits BoundQueryPart

        Public Sub New(syntax As SyntaxNode, underlyingExpression As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.Ordering, syntax, type, hasErrors OrElse underlyingExpression.NonNullAndHasErrors())

            Debug.Assert(underlyingExpression IsNot Nothing, "Field 'underlyingExpression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._UnderlyingExpression = underlyingExpression
        End Sub


        Private ReadOnly _UnderlyingExpression As BoundExpression
        Public ReadOnly Property UnderlyingExpression As BoundExpression
            Get
                Return _UnderlyingExpression
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitOrdering(Me)
        End Function

        Public Function Update(underlyingExpression As BoundExpression, type As TypeSymbol) As BoundOrdering
            If underlyingExpression IsNot Me.UnderlyingExpression OrElse type IsNot Me.Type Then
                Dim result = New BoundOrdering(Me.Syntax, underlyingExpression, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundQueryLambda
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, lambdaSymbol As QueryLambdaSymbol, rangeVariables As ReadOnlyArray(Of RangeVariableSymbol), expression As BoundExpression, exprIsOperandOfConditionalBranch As Boolean, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.QueryLambda, syntax, type, hasErrors OrElse expression.NonNullAndHasErrors())

            Debug.Assert(lambdaSymbol IsNot Nothing, "Field 'lambdaSymbol' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (rangeVariables.IsNull), "Field 'rangeVariables' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(expression IsNot Nothing, "Field 'expression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._LambdaSymbol = lambdaSymbol
            Me._RangeVariables = rangeVariables
            Me._Expression = expression
            Me._ExprIsOperandOfConditionalBranch = exprIsOperandOfConditionalBranch
        End Sub


        Private ReadOnly _LambdaSymbol As QueryLambdaSymbol
        Public ReadOnly Property LambdaSymbol As QueryLambdaSymbol
            Get
                Return _LambdaSymbol
            End Get
        End Property

        Private ReadOnly _RangeVariables As ReadOnlyArray(Of RangeVariableSymbol)
        Public ReadOnly Property RangeVariables As ReadOnlyArray(Of RangeVariableSymbol)
            Get
                Return _RangeVariables
            End Get
        End Property

        Private ReadOnly _Expression As BoundExpression
        Public ReadOnly Property Expression As BoundExpression
            Get
                Return _Expression
            End Get
        End Property

        Private ReadOnly _ExprIsOperandOfConditionalBranch As Boolean
        Public ReadOnly Property ExprIsOperandOfConditionalBranch As Boolean
            Get
                Return _ExprIsOperandOfConditionalBranch
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitQueryLambda(Me)
        End Function

        Public Function Update(lambdaSymbol As QueryLambdaSymbol, rangeVariables As ReadOnlyArray(Of RangeVariableSymbol), expression As BoundExpression, exprIsOperandOfConditionalBranch As Boolean, type As TypeSymbol) As BoundQueryLambda
            If lambdaSymbol IsNot Me.LambdaSymbol OrElse rangeVariables <> Me.RangeVariables OrElse expression IsNot Me.Expression OrElse exprIsOperandOfConditionalBranch <> Me.ExprIsOperandOfConditionalBranch OrElse type IsNot Me.Type Then
                Dim result = New BoundQueryLambda(Me.Syntax, lambdaSymbol, rangeVariables, expression, exprIsOperandOfConditionalBranch, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundRangeVariableAssignment
        Inherits BoundQueryPart

        Public Sub New(syntax As SyntaxNode, rangeVariable As RangeVariableSymbol, value As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.RangeVariableAssignment, syntax, type, hasErrors OrElse value.NonNullAndHasErrors())

            Debug.Assert(rangeVariable IsNot Nothing, "Field 'rangeVariable' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(value IsNot Nothing, "Field 'value' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._RangeVariable = rangeVariable
            Me._Value = value
        End Sub


        Private ReadOnly _RangeVariable As RangeVariableSymbol
        Public ReadOnly Property RangeVariable As RangeVariableSymbol
            Get
                Return _RangeVariable
            End Get
        End Property

        Private ReadOnly _Value As BoundExpression
        Public ReadOnly Property Value As BoundExpression
            Get
                Return _Value
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitRangeVariableAssignment(Me)
        End Function

        Public Function Update(rangeVariable As RangeVariableSymbol, value As BoundExpression, type As TypeSymbol) As BoundRangeVariableAssignment
            If rangeVariable IsNot Me.RangeVariable OrElse value IsNot Me.Value OrElse type IsNot Me.Type Then
                Dim result = New BoundRangeVariableAssignment(Me.Syntax, rangeVariable, value, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class GroupTypeInferenceLambda
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, binder As Binder, parameters As ReadOnlyArray(Of ParameterSymbol), compilation As Compilation, hasErrors As Boolean)
            MyBase.New(BoundKind.GroupTypeInferenceLambda, syntax, Nothing, hasErrors)

            Debug.Assert(binder IsNot Nothing, "Field 'binder' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (parameters.IsNull), "Field 'parameters' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(compilation IsNot Nothing, "Field 'compilation' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Binder = binder
            Me._Parameters = parameters
            Me._Compilation = compilation
        End Sub

        Public Sub New(syntax As SyntaxNode, binder As Binder, parameters As ReadOnlyArray(Of ParameterSymbol), compilation As Compilation)
            MyBase.New(BoundKind.GroupTypeInferenceLambda, syntax, Nothing)

            Debug.Assert(binder IsNot Nothing, "Field 'binder' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (parameters.IsNull), "Field 'parameters' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(compilation IsNot Nothing, "Field 'compilation' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Binder = binder
            Me._Parameters = parameters
            Me._Compilation = compilation
        End Sub


        Private ReadOnly _Binder As Binder
        Public ReadOnly Property Binder As Binder
            Get
                Return _Binder
            End Get
        End Property

        Private ReadOnly _Parameters As ReadOnlyArray(Of ParameterSymbol)
        Public ReadOnly Property Parameters As ReadOnlyArray(Of ParameterSymbol)
            Get
                Return _Parameters
            End Get
        End Property

        Private ReadOnly _Compilation As Compilation
        Public ReadOnly Property Compilation As Compilation
            Get
                Return _Compilation
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitGroupTypeInferenceLambda(Me)
        End Function

        Public Function Update(binder As Binder, parameters As ReadOnlyArray(Of ParameterSymbol), compilation As Compilation) As GroupTypeInferenceLambda
            If binder IsNot Me.Binder OrElse parameters <> Me.Parameters OrElse compilation IsNot Me.Compilation Then
                Dim result = New GroupTypeInferenceLambda(Me.Syntax, binder, parameters, compilation, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundAggregateClause
        Inherits BoundQueryClauseBase

        Public Sub New(syntax As SyntaxNode, capturedGroupOpt As BoundQueryClauseBase, groupPlaceholderOpt As BoundValuePlaceholder, underlyingExpression As BoundExpression, rangeVariables As ReadOnlyArray(Of RangeVariableSymbol), compoundVariableType As TypeSymbol, binders As ReadOnlyArray(Of Binder), type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.AggregateClause, syntax, rangeVariables, compoundVariableType, binders, type, hasErrors OrElse capturedGroupOpt.NonNullAndHasErrors() OrElse groupPlaceholderOpt.NonNullAndHasErrors() OrElse underlyingExpression.NonNullAndHasErrors())

            Debug.Assert(underlyingExpression IsNot Nothing, "Field 'underlyingExpression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (rangeVariables.IsNull), "Field 'rangeVariables' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(compoundVariableType IsNot Nothing, "Field 'compoundVariableType' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (binders.IsNull), "Field 'binders' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._CapturedGroupOpt = capturedGroupOpt
            Me._GroupPlaceholderOpt = groupPlaceholderOpt
            Me._UnderlyingExpression = underlyingExpression
        End Sub


        Private ReadOnly _CapturedGroupOpt As BoundQueryClauseBase
        Public ReadOnly Property CapturedGroupOpt As BoundQueryClauseBase
            Get
                Return _CapturedGroupOpt
            End Get
        End Property

        Private ReadOnly _GroupPlaceholderOpt As BoundValuePlaceholder
        Public ReadOnly Property GroupPlaceholderOpt As BoundValuePlaceholder
            Get
                Return _GroupPlaceholderOpt
            End Get
        End Property

        Private ReadOnly _UnderlyingExpression As BoundExpression
        Public ReadOnly Property UnderlyingExpression As BoundExpression
            Get
                Return _UnderlyingExpression
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitAggregateClause(Me)
        End Function

        Public Function Update(capturedGroupOpt As BoundQueryClauseBase, groupPlaceholderOpt As BoundValuePlaceholder, underlyingExpression As BoundExpression, rangeVariables As ReadOnlyArray(Of RangeVariableSymbol), compoundVariableType As TypeSymbol, binders As ReadOnlyArray(Of Binder), type As TypeSymbol) As BoundAggregateClause
            If capturedGroupOpt IsNot Me.CapturedGroupOpt OrElse groupPlaceholderOpt IsNot Me.GroupPlaceholderOpt OrElse underlyingExpression IsNot Me.UnderlyingExpression OrElse rangeVariables <> Me.RangeVariables OrElse compoundVariableType IsNot Me.CompoundVariableType OrElse binders <> Me.Binders OrElse type IsNot Me.Type Then
                Dim result = New BoundAggregateClause(Me.Syntax, capturedGroupOpt, groupPlaceholderOpt, underlyingExpression, rangeVariables, compoundVariableType, binders, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundGroupAggregation
        Inherits BoundQueryPart

        Public Sub New(syntax As SyntaxNode, group As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.GroupAggregation, syntax, type, hasErrors OrElse group.NonNullAndHasErrors())

            Debug.Assert(group IsNot Nothing, "Field 'group' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Group = group
        End Sub


        Private ReadOnly _Group As BoundExpression
        Public ReadOnly Property Group As BoundExpression
            Get
                Return _Group
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitGroupAggregation(Me)
        End Function

        Public Function Update(group As BoundExpression, type As TypeSymbol) As BoundGroupAggregation
            If group IsNot Me.Group OrElse type IsNot Me.Type Then
                Dim result = New BoundGroupAggregation(Me.Syntax, group, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundRangeVariable
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, rangeVariable As RangeVariableSymbol, type As TypeSymbol, hasErrors As Boolean)
            MyBase.New(BoundKind.RangeVariable, syntax, type, hasErrors)

            Debug.Assert(rangeVariable IsNot Nothing, "Field 'rangeVariable' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._RangeVariable = rangeVariable
        End Sub

        Public Sub New(syntax As SyntaxNode, rangeVariable As RangeVariableSymbol, type As TypeSymbol)
            MyBase.New(BoundKind.RangeVariable, syntax, type)

            Debug.Assert(rangeVariable IsNot Nothing, "Field 'rangeVariable' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._RangeVariable = rangeVariable
        End Sub


        Private ReadOnly _RangeVariable As RangeVariableSymbol
        Public ReadOnly Property RangeVariable As RangeVariableSymbol
            Get
                Return _RangeVariable
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitRangeVariable(Me)
        End Function

        Public Function Update(rangeVariable As RangeVariableSymbol, type As TypeSymbol) As BoundRangeVariable
            If rangeVariable IsNot Me.RangeVariable OrElse type IsNot Me.Type Then
                Dim result = New BoundRangeVariable(Me.Syntax, rangeVariable, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend MustInherit Partial Class BoundAddRemoveHandlerStatement
        Inherits BoundStatement

        Protected Sub New(kind As BoundKind, syntax as SyntaxNode, eventAccess As BoundExpression, handler As BoundExpression, Optional hasErrors As Boolean = False)
            MyBase.New(kind, syntax, hasErrors)

            Debug.Assert(eventAccess IsNot Nothing, "Field 'eventAccess' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(handler IsNot Nothing, "Field 'handler' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._EventAccess = eventAccess
            Me._Handler = handler
        End Sub


        Private ReadOnly _EventAccess As BoundExpression
        Public ReadOnly Property EventAccess As BoundExpression
            Get
                Return _EventAccess
            End Get
        End Property

        Private ReadOnly _Handler As BoundExpression
        Public ReadOnly Property Handler As BoundExpression
            Get
                Return _Handler
            End Get
        End Property
    End Class

    Friend NotInheritable Partial Class BoundAddHandlerStatement
        Inherits BoundAddRemoveHandlerStatement

        Public Sub New(syntax As SyntaxNode, eventAccess As BoundExpression, handler As BoundExpression, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.AddHandlerStatement, syntax, eventAccess, handler, hasErrors OrElse eventAccess.NonNullAndHasErrors() OrElse handler.NonNullAndHasErrors())

            Debug.Assert(eventAccess IsNot Nothing, "Field 'eventAccess' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(handler IsNot Nothing, "Field 'handler' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

        End Sub


        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitAddHandlerStatement(Me)
        End Function

        Public Function Update(eventAccess As BoundExpression, handler As BoundExpression) As BoundAddHandlerStatement
            If eventAccess IsNot Me.EventAccess OrElse handler IsNot Me.Handler Then
                Dim result = New BoundAddHandlerStatement(Me.Syntax, eventAccess, handler, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundRemoveHandlerStatement
        Inherits BoundAddRemoveHandlerStatement

        Public Sub New(syntax As SyntaxNode, eventAccess As BoundExpression, handler As BoundExpression, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.RemoveHandlerStatement, syntax, eventAccess, handler, hasErrors OrElse eventAccess.NonNullAndHasErrors() OrElse handler.NonNullAndHasErrors())

            Debug.Assert(eventAccess IsNot Nothing, "Field 'eventAccess' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(handler IsNot Nothing, "Field 'handler' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

        End Sub


        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitRemoveHandlerStatement(Me)
        End Function

        Public Function Update(eventAccess As BoundExpression, handler As BoundExpression) As BoundRemoveHandlerStatement
            If eventAccess IsNot Me.EventAccess OrElse handler IsNot Me.Handler Then
                Dim result = New BoundRemoveHandlerStatement(Me.Syntax, eventAccess, handler, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundRaiseEventStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, eventSymbol As EventSymbol, eventInvocation As BoundExpression, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.RaiseEventStatement, syntax, hasErrors OrElse eventInvocation.NonNullAndHasErrors())

            Debug.Assert(eventSymbol IsNot Nothing, "Field 'eventSymbol' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(eventInvocation IsNot Nothing, "Field 'eventInvocation' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._EventSymbol = eventSymbol
            Me._EventInvocation = eventInvocation
        End Sub


        Private ReadOnly _EventSymbol As EventSymbol
        Public ReadOnly Property EventSymbol As EventSymbol
            Get
                Return _EventSymbol
            End Get
        End Property

        Private ReadOnly _EventInvocation As BoundExpression
        Public ReadOnly Property EventInvocation As BoundExpression
            Get
                Return _EventInvocation
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitRaiseEventStatement(Me)
        End Function

        Public Function Update(eventSymbol As EventSymbol, eventInvocation As BoundExpression) As BoundRaiseEventStatement
            If eventSymbol IsNot Me.EventSymbol OrElse eventInvocation IsNot Me.EventInvocation Then
                Dim result = New BoundRaiseEventStatement(Me.Syntax, eventSymbol, eventInvocation, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundUsingStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, resourceList As ReadOnlyArray(Of BoundLocalDeclarationBase), resourceExpressionOpt As BoundExpression, body As BoundBlock, usingInfo As UsingInfo, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.UsingStatement, syntax, hasErrors OrElse resourceList.NonNullAndHasErrors() OrElse resourceExpressionOpt.NonNullAndHasErrors() OrElse body.NonNullAndHasErrors())

            Debug.Assert(body IsNot Nothing, "Field 'body' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(usingInfo IsNot Nothing, "Field 'usingInfo' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._ResourceList = resourceList
            Me._ResourceExpressionOpt = resourceExpressionOpt
            Me._Body = body
            Me._UsingInfo = usingInfo
        End Sub


        Private ReadOnly _ResourceList As ReadOnlyArray(Of BoundLocalDeclarationBase)
        Public ReadOnly Property ResourceList As ReadOnlyArray(Of BoundLocalDeclarationBase)
            Get
                Return _ResourceList
            End Get
        End Property

        Private ReadOnly _ResourceExpressionOpt As BoundExpression
        Public ReadOnly Property ResourceExpressionOpt As BoundExpression
            Get
                Return _ResourceExpressionOpt
            End Get
        End Property

        Private ReadOnly _Body As BoundBlock
        Public ReadOnly Property Body As BoundBlock
            Get
                Return _Body
            End Get
        End Property

        Private ReadOnly _UsingInfo As UsingInfo
        Public ReadOnly Property UsingInfo As UsingInfo
            Get
                Return _UsingInfo
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitUsingStatement(Me)
        End Function

        Public Function Update(resourceList As ReadOnlyArray(Of BoundLocalDeclarationBase), resourceExpressionOpt As BoundExpression, body As BoundBlock, usingInfo As UsingInfo) As BoundUsingStatement
            If resourceList <> Me.ResourceList OrElse resourceExpressionOpt IsNot Me.ResourceExpressionOpt OrElse body IsNot Me.Body OrElse usingInfo IsNot Me.UsingInfo Then
                Dim result = New BoundUsingStatement(Me.Syntax, resourceList, resourceExpressionOpt, body, usingInfo, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundSyncLockStatement
        Inherits BoundStatement

        Public Sub New(syntax As SyntaxNode, lockExpression As BoundExpression, body As BoundBlock, expressionTypeWasTypeParameter As Boolean, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.SyncLockStatement, syntax, hasErrors OrElse lockExpression.NonNullAndHasErrors() OrElse body.NonNullAndHasErrors())

            Debug.Assert(lockExpression IsNot Nothing, "Field 'lockExpression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(body IsNot Nothing, "Field 'body' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._LockExpression = lockExpression
            Me._Body = body
            Me._ExpressionTypeWasTypeParameter = expressionTypeWasTypeParameter
        End Sub


        Private ReadOnly _LockExpression As BoundExpression
        Public ReadOnly Property LockExpression As BoundExpression
            Get
                Return _LockExpression
            End Get
        End Property

        Private ReadOnly _Body As BoundBlock
        Public ReadOnly Property Body As BoundBlock
            Get
                Return _Body
            End Get
        End Property

        Private ReadOnly _ExpressionTypeWasTypeParameter As Boolean
        Public ReadOnly Property ExpressionTypeWasTypeParameter As Boolean
            Get
                Return _ExpressionTypeWasTypeParameter
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitSyncLockStatement(Me)
        End Function

        Public Function Update(lockExpression As BoundExpression, body As BoundBlock, expressionTypeWasTypeParameter As Boolean) As BoundSyncLockStatement
            If lockExpression IsNot Me.LockExpression OrElse body IsNot Me.Body OrElse expressionTypeWasTypeParameter <> Me.ExpressionTypeWasTypeParameter Then
                Dim result = New BoundSyncLockStatement(Me.Syntax, lockExpression, body, expressionTypeWasTypeParameter, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundXmlName
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, xmlNamespace As BoundExpression, localName As BoundExpression, objectCreation As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.XmlName, syntax, type, hasErrors OrElse xmlNamespace.NonNullAndHasErrors() OrElse localName.NonNullAndHasErrors() OrElse objectCreation.NonNullAndHasErrors())

            Debug.Assert(xmlNamespace IsNot Nothing, "Field 'xmlNamespace' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(localName IsNot Nothing, "Field 'localName' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(objectCreation IsNot Nothing, "Field 'objectCreation' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._XmlNamespace = xmlNamespace
            Me._LocalName = localName
            Me._ObjectCreation = objectCreation
        End Sub


        Private ReadOnly _XmlNamespace As BoundExpression
        Public ReadOnly Property XmlNamespace As BoundExpression
            Get
                Return _XmlNamespace
            End Get
        End Property

        Private ReadOnly _LocalName As BoundExpression
        Public ReadOnly Property LocalName As BoundExpression
            Get
                Return _LocalName
            End Get
        End Property

        Private ReadOnly _ObjectCreation As BoundExpression
        Public ReadOnly Property ObjectCreation As BoundExpression
            Get
                Return _ObjectCreation
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitXmlName(Me)
        End Function

        Public Function Update(xmlNamespace As BoundExpression, localName As BoundExpression, objectCreation As BoundExpression, type As TypeSymbol) As BoundXmlName
            If xmlNamespace IsNot Me.XmlNamespace OrElse localName IsNot Me.LocalName OrElse objectCreation IsNot Me.ObjectCreation OrElse type IsNot Me.Type Then
                Dim result = New BoundXmlName(Me.Syntax, xmlNamespace, localName, objectCreation, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundXmlDocument
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, declaration As BoundExpression, childNodes As ReadOnlyArray(of BoundExpression), rewriterInfo As BoundXmlContainerRewriterInfo, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.XmlDocument, syntax, type, hasErrors OrElse declaration.NonNullAndHasErrors() OrElse childNodes.NonNullAndHasErrors())

            Debug.Assert(declaration IsNot Nothing, "Field 'declaration' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (childNodes.IsNull), "Field 'childNodes' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(rewriterInfo IsNot Nothing, "Field 'rewriterInfo' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Declaration = declaration
            Me._ChildNodes = childNodes
            Me._RewriterInfo = rewriterInfo
        End Sub


        Private ReadOnly _Declaration As BoundExpression
        Public ReadOnly Property Declaration As BoundExpression
            Get
                Return _Declaration
            End Get
        End Property

        Private ReadOnly _ChildNodes As ReadOnlyArray(of BoundExpression)
        Public ReadOnly Property ChildNodes As ReadOnlyArray(of BoundExpression)
            Get
                Return _ChildNodes
            End Get
        End Property

        Private ReadOnly _RewriterInfo As BoundXmlContainerRewriterInfo
        Public ReadOnly Property RewriterInfo As BoundXmlContainerRewriterInfo
            Get
                Return _RewriterInfo
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitXmlDocument(Me)
        End Function

        Public Function Update(declaration As BoundExpression, childNodes As ReadOnlyArray(of BoundExpression), rewriterInfo As BoundXmlContainerRewriterInfo, type As TypeSymbol) As BoundXmlDocument
            If declaration IsNot Me.Declaration OrElse childNodes <> Me.ChildNodes OrElse rewriterInfo IsNot Me.RewriterInfo OrElse type IsNot Me.Type Then
                Dim result = New BoundXmlDocument(Me.Syntax, declaration, childNodes, rewriterInfo, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundXmlDeclaration
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, version As BoundExpression, encoding As BoundExpression, standalone As BoundExpression, objectCreation As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.XmlDeclaration, syntax, type, hasErrors OrElse version.NonNullAndHasErrors() OrElse encoding.NonNullAndHasErrors() OrElse standalone.NonNullAndHasErrors() OrElse objectCreation.NonNullAndHasErrors())

            Debug.Assert(objectCreation IsNot Nothing, "Field 'objectCreation' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Version = version
            Me._Encoding = encoding
            Me._Standalone = standalone
            Me._ObjectCreation = objectCreation
        End Sub


        Private ReadOnly _Version As BoundExpression
        Public ReadOnly Property Version As BoundExpression
            Get
                Return _Version
            End Get
        End Property

        Private ReadOnly _Encoding As BoundExpression
        Public ReadOnly Property Encoding As BoundExpression
            Get
                Return _Encoding
            End Get
        End Property

        Private ReadOnly _Standalone As BoundExpression
        Public ReadOnly Property Standalone As BoundExpression
            Get
                Return _Standalone
            End Get
        End Property

        Private ReadOnly _ObjectCreation As BoundExpression
        Public ReadOnly Property ObjectCreation As BoundExpression
            Get
                Return _ObjectCreation
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitXmlDeclaration(Me)
        End Function

        Public Function Update(version As BoundExpression, encoding As BoundExpression, standalone As BoundExpression, objectCreation As BoundExpression, type As TypeSymbol) As BoundXmlDeclaration
            If version IsNot Me.Version OrElse encoding IsNot Me.Encoding OrElse standalone IsNot Me.Standalone OrElse objectCreation IsNot Me.ObjectCreation OrElse type IsNot Me.Type Then
                Dim result = New BoundXmlDeclaration(Me.Syntax, version, encoding, standalone, objectCreation, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundXmlProcessingInstruction
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, target As BoundExpression, data As BoundExpression, objectCreation As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.XmlProcessingInstruction, syntax, type, hasErrors OrElse target.NonNullAndHasErrors() OrElse data.NonNullAndHasErrors() OrElse objectCreation.NonNullAndHasErrors())

            Debug.Assert(target IsNot Nothing, "Field 'target' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(data IsNot Nothing, "Field 'data' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(objectCreation IsNot Nothing, "Field 'objectCreation' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Target = target
            Me._Data = data
            Me._ObjectCreation = objectCreation
        End Sub


        Private ReadOnly _Target As BoundExpression
        Public ReadOnly Property Target As BoundExpression
            Get
                Return _Target
            End Get
        End Property

        Private ReadOnly _Data As BoundExpression
        Public ReadOnly Property Data As BoundExpression
            Get
                Return _Data
            End Get
        End Property

        Private ReadOnly _ObjectCreation As BoundExpression
        Public ReadOnly Property ObjectCreation As BoundExpression
            Get
                Return _ObjectCreation
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitXmlProcessingInstruction(Me)
        End Function

        Public Function Update(target As BoundExpression, data As BoundExpression, objectCreation As BoundExpression, type As TypeSymbol) As BoundXmlProcessingInstruction
            If target IsNot Me.Target OrElse data IsNot Me.Data OrElse objectCreation IsNot Me.ObjectCreation OrElse type IsNot Me.Type Then
                Dim result = New BoundXmlProcessingInstruction(Me.Syntax, target, data, objectCreation, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundXmlComment
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, value As BoundExpression, objectCreation As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.XmlComment, syntax, type, hasErrors OrElse value.NonNullAndHasErrors() OrElse objectCreation.NonNullAndHasErrors())

            Debug.Assert(value IsNot Nothing, "Field 'value' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(objectCreation IsNot Nothing, "Field 'objectCreation' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Value = value
            Me._ObjectCreation = objectCreation
        End Sub


        Private ReadOnly _Value As BoundExpression
        Public ReadOnly Property Value As BoundExpression
            Get
                Return _Value
            End Get
        End Property

        Private ReadOnly _ObjectCreation As BoundExpression
        Public ReadOnly Property ObjectCreation As BoundExpression
            Get
                Return _ObjectCreation
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitXmlComment(Me)
        End Function

        Public Function Update(value As BoundExpression, objectCreation As BoundExpression, type As TypeSymbol) As BoundXmlComment
            If value IsNot Me.Value OrElse objectCreation IsNot Me.ObjectCreation OrElse type IsNot Me.Type Then
                Dim result = New BoundXmlComment(Me.Syntax, value, objectCreation, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundXmlAttribute
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, name As BoundExpression, value As BoundExpression, objectCreation As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.XmlAttribute, syntax, type, hasErrors OrElse name.NonNullAndHasErrors() OrElse value.NonNullAndHasErrors() OrElse objectCreation.NonNullAndHasErrors())

            Debug.Assert(name IsNot Nothing, "Field 'name' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(value IsNot Nothing, "Field 'value' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(objectCreation IsNot Nothing, "Field 'objectCreation' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Name = name
            Me._Value = value
            Me._ObjectCreation = objectCreation
        End Sub


        Private ReadOnly _Name As BoundExpression
        Public ReadOnly Property Name As BoundExpression
            Get
                Return _Name
            End Get
        End Property

        Private ReadOnly _Value As BoundExpression
        Public ReadOnly Property Value As BoundExpression
            Get
                Return _Value
            End Get
        End Property

        Private ReadOnly _ObjectCreation As BoundExpression
        Public ReadOnly Property ObjectCreation As BoundExpression
            Get
                Return _ObjectCreation
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitXmlAttribute(Me)
        End Function

        Public Function Update(name As BoundExpression, value As BoundExpression, objectCreation As BoundExpression, type As TypeSymbol) As BoundXmlAttribute
            If name IsNot Me.Name OrElse value IsNot Me.Value OrElse objectCreation IsNot Me.ObjectCreation OrElse type IsNot Me.Type Then
                Dim result = New BoundXmlAttribute(Me.Syntax, name, value, objectCreation, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundXmlElement
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, argument As BoundExpression, childNodes As ReadOnlyArray(of BoundExpression), rewriterInfo As BoundXmlContainerRewriterInfo, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.XmlElement, syntax, type, hasErrors OrElse argument.NonNullAndHasErrors() OrElse childNodes.NonNullAndHasErrors())

            Debug.Assert(argument IsNot Nothing, "Field 'argument' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(Not (childNodes.IsNull), "Field 'childNodes' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(rewriterInfo IsNot Nothing, "Field 'rewriterInfo' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Argument = argument
            Me._ChildNodes = childNodes
            Me._RewriterInfo = rewriterInfo
        End Sub


        Private ReadOnly _Argument As BoundExpression
        Public ReadOnly Property Argument As BoundExpression
            Get
                Return _Argument
            End Get
        End Property

        Private ReadOnly _ChildNodes As ReadOnlyArray(of BoundExpression)
        Public ReadOnly Property ChildNodes As ReadOnlyArray(of BoundExpression)
            Get
                Return _ChildNodes
            End Get
        End Property

        Private ReadOnly _RewriterInfo As BoundXmlContainerRewriterInfo
        Public ReadOnly Property RewriterInfo As BoundXmlContainerRewriterInfo
            Get
                Return _RewriterInfo
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitXmlElement(Me)
        End Function

        Public Function Update(argument As BoundExpression, childNodes As ReadOnlyArray(of BoundExpression), rewriterInfo As BoundXmlContainerRewriterInfo, type As TypeSymbol) As BoundXmlElement
            If argument IsNot Me.Argument OrElse childNodes <> Me.ChildNodes OrElse rewriterInfo IsNot Me.RewriterInfo OrElse type IsNot Me.Type Then
                Dim result = New BoundXmlElement(Me.Syntax, argument, childNodes, rewriterInfo, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundXmlMemberAccess
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, receiver As BoundExpression, name As BoundExpression, memberAccess As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.XmlMemberAccess, syntax, type, hasErrors OrElse receiver.NonNullAndHasErrors() OrElse name.NonNullAndHasErrors() OrElse memberAccess.NonNullAndHasErrors())

            Debug.Assert(receiver IsNot Nothing, "Field 'receiver' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(name IsNot Nothing, "Field 'name' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(memberAccess IsNot Nothing, "Field 'memberAccess' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Receiver = receiver
            Me._Name = name
            Me._MemberAccess = memberAccess
        End Sub


        Private ReadOnly _Receiver As BoundExpression
        Public ReadOnly Property Receiver As BoundExpression
            Get
                Return _Receiver
            End Get
        End Property

        Private ReadOnly _Name As BoundExpression
        Public ReadOnly Property Name As BoundExpression
            Get
                Return _Name
            End Get
        End Property

        Private ReadOnly _MemberAccess As BoundExpression
        Public ReadOnly Property MemberAccess As BoundExpression
            Get
                Return _MemberAccess
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitXmlMemberAccess(Me)
        End Function

        Public Function Update(receiver As BoundExpression, name As BoundExpression, memberAccess As BoundExpression, type As TypeSymbol) As BoundXmlMemberAccess
            If receiver IsNot Me.Receiver OrElse name IsNot Me.Name OrElse memberAccess IsNot Me.MemberAccess OrElse type IsNot Me.Type Then
                Dim result = New BoundXmlMemberAccess(Me.Syntax, receiver, name, memberAccess, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend NotInheritable Partial Class BoundXmlEmbeddedExpression
        Inherits BoundExpression

        Public Sub New(syntax As SyntaxNode, expression As BoundExpression, type As TypeSymbol, Optional hasErrors As Boolean = False)
            MyBase.New(BoundKind.XmlEmbeddedExpression, syntax, type, hasErrors OrElse expression.NonNullAndHasErrors())

            Debug.Assert(expression IsNot Nothing, "Field 'expression' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")
            Debug.Assert(type IsNot Nothing, "Field 'type' cannot be null (use Null=""allow"" in BoundNodes.xml to remove this check)")

            Me._Expression = expression
        End Sub


        Private ReadOnly _Expression As BoundExpression
        Public ReadOnly Property Expression As BoundExpression
            Get
                Return _Expression
            End Get
        End Property

        Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode
            Return visitor.VisitXmlEmbeddedExpression(Me)
        End Function

        Public Function Update(expression As BoundExpression, type As TypeSymbol) As BoundXmlEmbeddedExpression
            If expression IsNot Me.Expression OrElse type IsNot Me.Type Then
                Dim result = New BoundXmlEmbeddedExpression(Me.Syntax, expression, type, Me.HasErrors)
                
                If Me.WasCompilerGenerated Then
                    result.SetWasCompilerGenerated()
                End If
                
                Return result
            End If
            Return Me
        End Function
    End Class

    Friend MustInherit Partial Class BoundTreeVisitor(Of A,R)

        <MethodImpl(MethodImplOptions.NoInlining)>
        Friend Function VisitInternal(node As BoundNode, arg As A) As R
            Select Case node.Kind
                Case BoundKind.TypeArguments: 
                    Return VisitTypeArguments(CType(node, BoundTypeArguments), arg)
                Case BoundKind.OmittedArgument: 
                    Return VisitOmittedArgument(CType(node, BoundOmittedArgument), arg)
                Case BoundKind.LValuePlaceholderRValueWrapper: 
                    Return VisitLValuePlaceholderRValueWrapper(CType(node, BoundLValuePlaceholderRValueWrapper), arg)
                Case BoundKind.WithLValueExpressionPlaceholder: 
                    Return VisitWithLValueExpressionPlaceholder(CType(node, BoundWithLValueExpressionPlaceholder), arg)
                Case BoundKind.WithRValueExpressionPlaceholder: 
                    Return VisitWithRValueExpressionPlaceholder(CType(node, BoundWithRValueExpressionPlaceholder), arg)
                Case BoundKind.ValuePlaceholder: 
                    Return VisitValuePlaceholder(CType(node, BoundValuePlaceholder), arg)
                Case BoundKind.BadExpression: 
                    Return VisitBadExpression(CType(node, BoundBadExpression), arg)
                Case BoundKind.BadStatement: 
                    Return VisitBadStatement(CType(node, BoundBadStatement), arg)
                Case BoundKind.Parenthesized: 
                    Return VisitParenthesized(CType(node, BoundParenthesized), arg)
                Case BoundKind.BadVariable: 
                    Return VisitBadVariable(CType(node, BoundBadVariable), arg)
                Case BoundKind.ArrayAccess: 
                    Return VisitArrayAccess(CType(node, BoundArrayAccess), arg)
                Case BoundKind.ArrayLength: 
                    Return VisitArrayLength(CType(node, BoundArrayLength), arg)
                Case BoundKind.[GetType]: 
                    Return VisitGetType(CType(node, BoundGetType), arg)
                Case BoundKind.TypeExpression: 
                    Return VisitTypeExpression(CType(node, BoundTypeExpression), arg)
                Case BoundKind.TypeOrValueExpression: 
                    Return VisitTypeOrValueExpression(CType(node, BoundTypeOrValueExpression), arg)
                Case BoundKind.NamespaceExpression: 
                    Return VisitNamespaceExpression(CType(node, BoundNamespaceExpression), arg)
                Case BoundKind.UnaryOperator: 
                    Return VisitUnaryOperator(CType(node, BoundUnaryOperator), arg)
                Case BoundKind.UserDefinedUnaryOperator: 
                    Return VisitUserDefinedUnaryOperator(CType(node, BoundUserDefinedUnaryOperator), arg)
                Case BoundKind.NullableIsTrueOperator: 
                    Return VisitNullableIsTrueOperator(CType(node, BoundNullableIsTrueOperator), arg)
                Case BoundKind.BinaryOperator: 
                    Return VisitBinaryOperator(CType(node, BoundBinaryOperator), arg)
                Case BoundKind.CompoundAssignmentTargetPlaceholder: 
                    Return VisitCompoundAssignmentTargetPlaceholder(CType(node, BoundCompoundAssignmentTargetPlaceholder), arg)
                Case BoundKind.AssignmentOperator: 
                    Return VisitAssignmentOperator(CType(node, BoundAssignmentOperator), arg)
                Case BoundKind.ReferenceAssignment: 
                    Return VisitReferenceAssignment(CType(node, BoundReferenceAssignment), arg)
                Case BoundKind.AddressOfOperator: 
                    Return VisitAddressOfOperator(CType(node, BoundAddressOfOperator), arg)
                Case BoundKind.TernaryConditionalExpression: 
                    Return VisitTernaryConditionalExpression(CType(node, BoundTernaryConditionalExpression), arg)
                Case BoundKind.BinaryConditionalExpression: 
                    Return VisitBinaryConditionalExpression(CType(node, BoundBinaryConditionalExpression), arg)
                Case BoundKind.Conversion: 
                    Return VisitConversion(CType(node, BoundConversion), arg)
                Case BoundKind.UserDefinedConversion: 
                    Return VisitUserDefinedConversion(CType(node, BoundUserDefinedConversion), arg)
                Case BoundKind.[DirectCast]: 
                    Return VisitDirectCast(CType(node, BoundDirectCast), arg)
                Case BoundKind.[TryCast]: 
                    Return VisitTryCast(CType(node, BoundTryCast), arg)
                Case BoundKind.[TypeOf]: 
                    Return VisitTypeOf(CType(node, BoundTypeOf), arg)
                Case BoundKind.SequencePoint: 
                    Return VisitSequencePoint(CType(node, BoundSequencePoint), arg)
                Case BoundKind.SequencePointExpression: 
                    Return VisitSequencePointExpression(CType(node, BoundSequencePointExpression), arg)
                Case BoundKind.SequencePointWithSpan: 
                    Return VisitSequencePointWithSpan(CType(node, BoundSequencePointWithSpan), arg)
                Case BoundKind.NoOpStatement: 
                    Return VisitNoOpStatement(CType(node, BoundNoOpStatement), arg)
                Case BoundKind.MethodGroup: 
                    Return VisitMethodGroup(CType(node, BoundMethodGroup), arg)
                Case BoundKind.PropertyGroup: 
                    Return VisitPropertyGroup(CType(node, BoundPropertyGroup), arg)
                Case BoundKind.ReturnStatement: 
                    Return VisitReturnStatement(CType(node, BoundReturnStatement), arg)
                Case BoundKind.ThrowStatement: 
                    Return VisitThrowStatement(CType(node, BoundThrowStatement), arg)
                Case BoundKind.RedimStatement: 
                    Return VisitRedimStatement(CType(node, BoundRedimStatement), arg)
                Case BoundKind.RedimClause: 
                    Return VisitRedimClause(CType(node, BoundRedimClause), arg)
                Case BoundKind.[Call]: 
                    Return VisitCall(CType(node, BoundCall), arg)
                Case BoundKind.Attribute: 
                    Return VisitAttribute(CType(node, BoundAttribute), arg)
                Case BoundKind.LateCall: 
                    Return VisitLateCall(CType(node, BoundLateCall), arg)
                Case BoundKind.ObjectCreationExpression: 
                    Return VisitObjectCreationExpression(CType(node, BoundObjectCreationExpression), arg)
                Case BoundKind.AnonymousTypeCreationExpression: 
                    Return VisitAnonymousTypeCreationExpression(CType(node, BoundAnonymousTypeCreationExpression), arg)
                Case BoundKind.AnonymousTypePropertyAccess: 
                    Return VisitAnonymousTypePropertyAccess(CType(node, BoundAnonymousTypePropertyAccess), arg)
                Case BoundKind.AnonymousTypeFieldInitializer: 
                    Return VisitAnonymousTypeFieldInitializer(CType(node, BoundAnonymousTypeFieldInitializer), arg)
                Case BoundKind.NewT: 
                    Return VisitNewT(CType(node, BoundNewT), arg)
                Case BoundKind.DelegateCreationExpression: 
                    Return VisitDelegateCreationExpression(CType(node, BoundDelegateCreationExpression), arg)
                Case BoundKind.ArrayCreation: 
                    Return VisitArrayCreation(CType(node, BoundArrayCreation), arg)
                Case BoundKind.ArrayInitialization: 
                    Return VisitArrayInitialization(CType(node, BoundArrayInitialization), arg)
                Case BoundKind.FieldAccess: 
                    Return VisitFieldAccess(CType(node, BoundFieldAccess), arg)
                Case BoundKind.PropertyAccess: 
                    Return VisitPropertyAccess(CType(node, BoundPropertyAccess), arg)
                Case BoundKind.EventAccess: 
                    Return VisitEventAccess(CType(node, BoundEventAccess), arg)
                Case BoundKind.Block: 
                    Return VisitBlock(CType(node, BoundBlock), arg)
                Case BoundKind.LocalDeclaration: 
                    Return VisitLocalDeclaration(CType(node, BoundLocalDeclaration), arg)
                Case BoundKind.AsNewLocalDeclarations: 
                    Return VisitAsNewLocalDeclarations(CType(node, BoundAsNewLocalDeclarations), arg)
                Case BoundKind.DimStatement: 
                    Return VisitDimStatement(CType(node, BoundDimStatement), arg)
                Case BoundKind.Initializer: 
                    Return VisitInitializer(CType(node, BoundInitializer), arg)
                Case BoundKind.FieldOrPropertyInitializer: 
                    Return VisitFieldOrPropertyInitializer(CType(node, BoundFieldOrPropertyInitializer), arg)
                Case BoundKind.GlobalStatementInitializer: 
                    Return VisitGlobalStatementInitializer(CType(node, BoundGlobalStatementInitializer), arg)
                Case BoundKind.Sequence: 
                    Return VisitSequence(CType(node, BoundSequence), arg)
                Case BoundKind.ExpressionStatement: 
                    Return VisitExpressionStatement(CType(node, BoundExpressionStatement), arg)
                Case BoundKind.IfStatement: 
                    Return VisitIfStatement(CType(node, BoundIfStatement), arg)
                Case BoundKind.SelectStatement: 
                    Return VisitSelectStatement(CType(node, BoundSelectStatement), arg)
                Case BoundKind.CaseBlock: 
                    Return VisitCaseBlock(CType(node, BoundCaseBlock), arg)
                Case BoundKind.CaseStatement: 
                    Return VisitCaseStatement(CType(node, BoundCaseStatement), arg)
                Case BoundKind.CaseValueClause: 
                    Return VisitCaseValueClause(CType(node, BoundCaseValueClause), arg)
                Case BoundKind.CaseRangeClause: 
                    Return VisitCaseRangeClause(CType(node, BoundCaseRangeClause), arg)
                Case BoundKind.CaseRelationalClause: 
                    Return VisitCaseRelationalClause(CType(node, BoundCaseRelationalClause), arg)
                Case BoundKind.DoLoopStatement: 
                    Return VisitDoLoopStatement(CType(node, BoundDoLoopStatement), arg)
                Case BoundKind.WhileStatement: 
                    Return VisitWhileStatement(CType(node, BoundWhileStatement), arg)
                Case BoundKind.ForToStatement: 
                    Return VisitForToStatement(CType(node, BoundForToStatement), arg)
                Case BoundKind.ForEachStatement: 
                    Return VisitForEachStatement(CType(node, BoundForEachStatement), arg)
                Case BoundKind.ExitStatement: 
                    Return VisitExitStatement(CType(node, BoundExitStatement), arg)
                Case BoundKind.ContinueStatement: 
                    Return VisitContinueStatement(CType(node, BoundContinueStatement), arg)
                Case BoundKind.TryStatement: 
                    Return VisitTryStatement(CType(node, BoundTryStatement), arg)
                Case BoundKind.CatchBlock: 
                    Return VisitCatchBlock(CType(node, BoundCatchBlock), arg)
                Case BoundKind.Literal: 
                    Return VisitLiteral(CType(node, BoundLiteral), arg)
                Case BoundKind.MeReference: 
                    Return VisitMeReference(CType(node, BoundMeReference), arg)
                Case BoundKind.MyBaseReference: 
                    Return VisitMyBaseReference(CType(node, BoundMyBaseReference), arg)
                Case BoundKind.MyClassReference: 
                    Return VisitMyClassReference(CType(node, BoundMyClassReference), arg)
                Case BoundKind.PreviousSubmissionReference: 
                    Return VisitPreviousSubmissionReference(CType(node, BoundPreviousSubmissionReference), arg)
                Case BoundKind.HostObjectMemberReference: 
                    Return VisitHostObjectMemberReference(CType(node, BoundHostObjectMemberReference), arg)
                Case BoundKind.Local: 
                    Return VisitLocal(CType(node, BoundLocal), arg)
                Case BoundKind.Parameter: 
                    Return VisitParameter(CType(node, BoundParameter), arg)
                Case BoundKind.ByRefArgumentPlaceholder: 
                    Return VisitByRefArgumentPlaceholder(CType(node, BoundByRefArgumentPlaceholder), arg)
                Case BoundKind.ByRefArgumentWithCopyBack: 
                    Return VisitByRefArgumentWithCopyBack(CType(node, BoundByRefArgumentWithCopyBack), arg)
                Case BoundKind.LabelStatement: 
                    Return VisitLabelStatement(CType(node, BoundLabelStatement), arg)
                Case BoundKind.Label: 
                    Return VisitLabel(CType(node, BoundLabel), arg)
                Case BoundKind.GotoStatement: 
                    Return VisitGotoStatement(CType(node, BoundGotoStatement), arg)
                Case BoundKind.StatementList: 
                    Return VisitStatementList(CType(node, BoundStatementList), arg)
                Case BoundKind.ConditionalGoto: 
                    Return VisitConditionalGoto(CType(node, BoundConditionalGoto), arg)
                Case BoundKind.WithStatement: 
                    Return VisitWithStatement(CType(node, BoundWithStatement), arg)
                Case BoundKind.UnboundLambda: 
                    Return VisitUnboundLambda(CType(node, UnboundLambda), arg)
                Case BoundKind.Lambda: 
                    Return VisitLambda(CType(node, BoundLambda), arg)
                Case BoundKind.QueryExpression: 
                    Return VisitQueryExpression(CType(node, BoundQueryExpression), arg)
                Case BoundKind.QuerySource: 
                    Return VisitQuerySource(CType(node, BoundQuerySource), arg)
                Case BoundKind.ToQueryableCollectionConversion: 
                    Return VisitToQueryableCollectionConversion(CType(node, BoundToQueryableCollectionConversion), arg)
                Case BoundKind.QueryableSource: 
                    Return VisitQueryableSource(CType(node, BoundQueryableSource), arg)
                Case BoundKind.QueryClause: 
                    Return VisitQueryClause(CType(node, BoundQueryClause), arg)
                Case BoundKind.Ordering: 
                    Return VisitOrdering(CType(node, BoundOrdering), arg)
                Case BoundKind.QueryLambda: 
                    Return VisitQueryLambda(CType(node, BoundQueryLambda), arg)
                Case BoundKind.RangeVariableAssignment: 
                    Return VisitRangeVariableAssignment(CType(node, BoundRangeVariableAssignment), arg)
                Case BoundKind.GroupTypeInferenceLambda: 
                    Return VisitGroupTypeInferenceLambda(CType(node, GroupTypeInferenceLambda), arg)
                Case BoundKind.AggregateClause: 
                    Return VisitAggregateClause(CType(node, BoundAggregateClause), arg)
                Case BoundKind.GroupAggregation: 
                    Return VisitGroupAggregation(CType(node, BoundGroupAggregation), arg)
                Case BoundKind.RangeVariable: 
                    Return VisitRangeVariable(CType(node, BoundRangeVariable), arg)
                Case BoundKind.AddHandlerStatement: 
                    Return VisitAddHandlerStatement(CType(node, BoundAddHandlerStatement), arg)
                Case BoundKind.RemoveHandlerStatement: 
                    Return VisitRemoveHandlerStatement(CType(node, BoundRemoveHandlerStatement), arg)
                Case BoundKind.RaiseEventStatement: 
                    Return VisitRaiseEventStatement(CType(node, BoundRaiseEventStatement), arg)
                Case BoundKind.UsingStatement: 
                    Return VisitUsingStatement(CType(node, BoundUsingStatement), arg)
                Case BoundKind.SyncLockStatement: 
                    Return VisitSyncLockStatement(CType(node, BoundSyncLockStatement), arg)
                Case BoundKind.XmlName: 
                    Return VisitXmlName(CType(node, BoundXmlName), arg)
                Case BoundKind.XmlDocument: 
                    Return VisitXmlDocument(CType(node, BoundXmlDocument), arg)
                Case BoundKind.XmlDeclaration: 
                    Return VisitXmlDeclaration(CType(node, BoundXmlDeclaration), arg)
                Case BoundKind.XmlProcessingInstruction: 
                    Return VisitXmlProcessingInstruction(CType(node, BoundXmlProcessingInstruction), arg)
                Case BoundKind.XmlComment: 
                    Return VisitXmlComment(CType(node, BoundXmlComment), arg)
                Case BoundKind.XmlAttribute: 
                    Return VisitXmlAttribute(CType(node, BoundXmlAttribute), arg)
                Case BoundKind.XmlElement: 
                    Return VisitXmlElement(CType(node, BoundXmlElement), arg)
                Case BoundKind.XmlMemberAccess: 
                    Return VisitXmlMemberAccess(CType(node, BoundXmlMemberAccess), arg)
                Case BoundKind.XmlEmbeddedExpression: 
                    Return VisitXmlEmbeddedExpression(CType(node, BoundXmlEmbeddedExpression), arg)
            End Select
            Return DefaultVisit(node, arg)
        End Function

    End Class

    Friend MustInherit Partial Class BoundTreeVisitor(Of A,R)
        Public Overridable Function VisitTypeArguments(node As BoundTypeArguments, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitOmittedArgument(node As BoundOmittedArgument, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitLValuePlaceholderRValueWrapper(node As BoundLValuePlaceholderRValueWrapper, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitWithLValueExpressionPlaceholder(node As BoundWithLValueExpressionPlaceholder, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitWithRValueExpressionPlaceholder(node As BoundWithRValueExpressionPlaceholder, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitValuePlaceholder(node As BoundValuePlaceholder, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitBadExpression(node As BoundBadExpression, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitBadStatement(node As BoundBadStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitParenthesized(node As BoundParenthesized, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitBadVariable(node As BoundBadVariable, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitArrayAccess(node As BoundArrayAccess, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitArrayLength(node As BoundArrayLength, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitGetType(node As BoundGetType, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitTypeExpression(node As BoundTypeExpression, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitTypeOrValueExpression(node As BoundTypeOrValueExpression, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitNamespaceExpression(node As BoundNamespaceExpression, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitUnaryOperator(node As BoundUnaryOperator, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitUserDefinedUnaryOperator(node As BoundUserDefinedUnaryOperator, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitNullableIsTrueOperator(node As BoundNullableIsTrueOperator, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitBinaryOperator(node As BoundBinaryOperator, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitCompoundAssignmentTargetPlaceholder(node As BoundCompoundAssignmentTargetPlaceholder, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitAssignmentOperator(node As BoundAssignmentOperator, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitReferenceAssignment(node As BoundReferenceAssignment, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitAddressOfOperator(node As BoundAddressOfOperator, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitTernaryConditionalExpression(node As BoundTernaryConditionalExpression, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitBinaryConditionalExpression(node As BoundBinaryConditionalExpression, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitConversion(node As BoundConversion, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitUserDefinedConversion(node As BoundUserDefinedConversion, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitDirectCast(node As BoundDirectCast, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitTryCast(node As BoundTryCast, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitTypeOf(node As BoundTypeOf, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitSequencePoint(node As BoundSequencePoint, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitSequencePointExpression(node As BoundSequencePointExpression, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitSequencePointWithSpan(node As BoundSequencePointWithSpan, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitNoOpStatement(node As BoundNoOpStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitMethodGroup(node As BoundMethodGroup, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitPropertyGroup(node As BoundPropertyGroup, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitReturnStatement(node As BoundReturnStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitThrowStatement(node As BoundThrowStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitRedimStatement(node As BoundRedimStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitRedimClause(node As BoundRedimClause, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitCall(node As BoundCall, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitAttribute(node As BoundAttribute, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitLateCall(node As BoundLateCall, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitObjectCreationExpression(node As BoundObjectCreationExpression, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitAnonymousTypeCreationExpression(node As BoundAnonymousTypeCreationExpression, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitAnonymousTypePropertyAccess(node As BoundAnonymousTypePropertyAccess, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitAnonymousTypeFieldInitializer(node As BoundAnonymousTypeFieldInitializer, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitNewT(node As BoundNewT, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitDelegateCreationExpression(node As BoundDelegateCreationExpression, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitArrayCreation(node As BoundArrayCreation, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitArrayInitialization(node As BoundArrayInitialization, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitFieldAccess(node As BoundFieldAccess, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitPropertyAccess(node As BoundPropertyAccess, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitEventAccess(node As BoundEventAccess, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitBlock(node As BoundBlock, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitLocalDeclaration(node As BoundLocalDeclaration, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitAsNewLocalDeclarations(node As BoundAsNewLocalDeclarations, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitDimStatement(node As BoundDimStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitInitializer(node As BoundInitializer, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitFieldOrPropertyInitializer(node As BoundFieldOrPropertyInitializer, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitGlobalStatementInitializer(node As BoundGlobalStatementInitializer, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitSequence(node As BoundSequence, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitExpressionStatement(node As BoundExpressionStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitIfStatement(node As BoundIfStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitSelectStatement(node As BoundSelectStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitCaseBlock(node As BoundCaseBlock, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitCaseStatement(node As BoundCaseStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitCaseValueClause(node As BoundCaseValueClause, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitCaseRangeClause(node As BoundCaseRangeClause, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitCaseRelationalClause(node As BoundCaseRelationalClause, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitDoLoopStatement(node As BoundDoLoopStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitWhileStatement(node As BoundWhileStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitForToStatement(node As BoundForToStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitForEachStatement(node As BoundForEachStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitExitStatement(node As BoundExitStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitContinueStatement(node As BoundContinueStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitTryStatement(node As BoundTryStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitCatchBlock(node As BoundCatchBlock, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitLiteral(node As BoundLiteral, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitMeReference(node As BoundMeReference, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitMyBaseReference(node As BoundMyBaseReference, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitMyClassReference(node As BoundMyClassReference, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitPreviousSubmissionReference(node As BoundPreviousSubmissionReference, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitHostObjectMemberReference(node As BoundHostObjectMemberReference, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitLocal(node As BoundLocal, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitParameter(node As BoundParameter, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitByRefArgumentPlaceholder(node As BoundByRefArgumentPlaceholder, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitByRefArgumentWithCopyBack(node As BoundByRefArgumentWithCopyBack, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitLabelStatement(node As BoundLabelStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitLabel(node As BoundLabel, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitGotoStatement(node As BoundGotoStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitStatementList(node As BoundStatementList, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitConditionalGoto(node As BoundConditionalGoto, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitWithStatement(node As BoundWithStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitUnboundLambda(node As UnboundLambda, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitLambda(node As BoundLambda, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitQueryExpression(node As BoundQueryExpression, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitQuerySource(node As BoundQuerySource, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitToQueryableCollectionConversion(node As BoundToQueryableCollectionConversion, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitQueryableSource(node As BoundQueryableSource, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitQueryClause(node As BoundQueryClause, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitOrdering(node As BoundOrdering, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitQueryLambda(node As BoundQueryLambda, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitRangeVariableAssignment(node As BoundRangeVariableAssignment, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitGroupTypeInferenceLambda(node As GroupTypeInferenceLambda, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitAggregateClause(node As BoundAggregateClause, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitGroupAggregation(node As BoundGroupAggregation, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitRangeVariable(node As BoundRangeVariable, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitAddHandlerStatement(node As BoundAddHandlerStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitRemoveHandlerStatement(node As BoundRemoveHandlerStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitRaiseEventStatement(node As BoundRaiseEventStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitUsingStatement(node As BoundUsingStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitSyncLockStatement(node As BoundSyncLockStatement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitXmlName(node As BoundXmlName, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitXmlDocument(node As BoundXmlDocument, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitXmlDeclaration(node As BoundXmlDeclaration, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitXmlProcessingInstruction(node As BoundXmlProcessingInstruction, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitXmlComment(node As BoundXmlComment, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitXmlAttribute(node As BoundXmlAttribute, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitXmlElement(node As BoundXmlElement, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitXmlMemberAccess(node As BoundXmlMemberAccess, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

        Public Overridable Function VisitXmlEmbeddedExpression(node As BoundXmlEmbeddedExpression, arg As A) As R
            Return Me.DefaultVisit(node, arg)
        End Function

    End Class

    Friend MustInherit Partial Class BoundTreeVisitor
        Public Overridable Function VisitTypeArguments(node As BoundTypeArguments) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitOmittedArgument(node As BoundOmittedArgument) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitLValuePlaceholderRValueWrapper(node As BoundLValuePlaceholderRValueWrapper) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitWithLValueExpressionPlaceholder(node As BoundWithLValueExpressionPlaceholder) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitWithRValueExpressionPlaceholder(node As BoundWithRValueExpressionPlaceholder) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitValuePlaceholder(node As BoundValuePlaceholder) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitBadExpression(node As BoundBadExpression) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitBadStatement(node As BoundBadStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitParenthesized(node As BoundParenthesized) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitBadVariable(node As BoundBadVariable) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitArrayAccess(node As BoundArrayAccess) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitArrayLength(node As BoundArrayLength) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitGetType(node As BoundGetType) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitTypeExpression(node As BoundTypeExpression) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitTypeOrValueExpression(node As BoundTypeOrValueExpression) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitNamespaceExpression(node As BoundNamespaceExpression) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitUnaryOperator(node As BoundUnaryOperator) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitUserDefinedUnaryOperator(node As BoundUserDefinedUnaryOperator) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitNullableIsTrueOperator(node As BoundNullableIsTrueOperator) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitBinaryOperator(node As BoundBinaryOperator) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitCompoundAssignmentTargetPlaceholder(node As BoundCompoundAssignmentTargetPlaceholder) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitAssignmentOperator(node As BoundAssignmentOperator) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitReferenceAssignment(node As BoundReferenceAssignment) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitAddressOfOperator(node As BoundAddressOfOperator) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitTernaryConditionalExpression(node As BoundTernaryConditionalExpression) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitBinaryConditionalExpression(node As BoundBinaryConditionalExpression) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitConversion(node As BoundConversion) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitUserDefinedConversion(node As BoundUserDefinedConversion) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitDirectCast(node As BoundDirectCast) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitTryCast(node As BoundTryCast) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitTypeOf(node As BoundTypeOf) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitSequencePoint(node As BoundSequencePoint) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitSequencePointExpression(node As BoundSequencePointExpression) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitSequencePointWithSpan(node As BoundSequencePointWithSpan) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitNoOpStatement(node As BoundNoOpStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitMethodGroup(node As BoundMethodGroup) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitPropertyGroup(node As BoundPropertyGroup) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitReturnStatement(node As BoundReturnStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitThrowStatement(node As BoundThrowStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitRedimStatement(node As BoundRedimStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitRedimClause(node As BoundRedimClause) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitCall(node As BoundCall) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitAttribute(node As BoundAttribute) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitLateCall(node As BoundLateCall) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitObjectCreationExpression(node As BoundObjectCreationExpression) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitAnonymousTypeCreationExpression(node As BoundAnonymousTypeCreationExpression) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitAnonymousTypePropertyAccess(node As BoundAnonymousTypePropertyAccess) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitAnonymousTypeFieldInitializer(node As BoundAnonymousTypeFieldInitializer) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitNewT(node As BoundNewT) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitDelegateCreationExpression(node As BoundDelegateCreationExpression) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitArrayCreation(node As BoundArrayCreation) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitArrayInitialization(node As BoundArrayInitialization) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitFieldAccess(node As BoundFieldAccess) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitPropertyAccess(node As BoundPropertyAccess) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitEventAccess(node As BoundEventAccess) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitBlock(node As BoundBlock) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitLocalDeclaration(node As BoundLocalDeclaration) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitAsNewLocalDeclarations(node As BoundAsNewLocalDeclarations) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitDimStatement(node As BoundDimStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitInitializer(node As BoundInitializer) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitFieldOrPropertyInitializer(node As BoundFieldOrPropertyInitializer) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitGlobalStatementInitializer(node As BoundGlobalStatementInitializer) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitSequence(node As BoundSequence) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitExpressionStatement(node As BoundExpressionStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitIfStatement(node As BoundIfStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitSelectStatement(node As BoundSelectStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitCaseBlock(node As BoundCaseBlock) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitCaseStatement(node As BoundCaseStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitCaseValueClause(node As BoundCaseValueClause) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitCaseRangeClause(node As BoundCaseRangeClause) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitCaseRelationalClause(node As BoundCaseRelationalClause) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitDoLoopStatement(node As BoundDoLoopStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitWhileStatement(node As BoundWhileStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitForToStatement(node As BoundForToStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitForEachStatement(node As BoundForEachStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitExitStatement(node As BoundExitStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitContinueStatement(node As BoundContinueStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitTryStatement(node As BoundTryStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitCatchBlock(node As BoundCatchBlock) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitLiteral(node As BoundLiteral) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitMeReference(node As BoundMeReference) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitMyBaseReference(node As BoundMyBaseReference) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitMyClassReference(node As BoundMyClassReference) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitPreviousSubmissionReference(node As BoundPreviousSubmissionReference) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitHostObjectMemberReference(node As BoundHostObjectMemberReference) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitLocal(node As BoundLocal) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitParameter(node As BoundParameter) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitByRefArgumentPlaceholder(node As BoundByRefArgumentPlaceholder) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitByRefArgumentWithCopyBack(node As BoundByRefArgumentWithCopyBack) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitLabelStatement(node As BoundLabelStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitLabel(node As BoundLabel) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitGotoStatement(node As BoundGotoStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitStatementList(node As BoundStatementList) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitConditionalGoto(node As BoundConditionalGoto) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitWithStatement(node As BoundWithStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitUnboundLambda(node As UnboundLambda) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitLambda(node As BoundLambda) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitQueryExpression(node As BoundQueryExpression) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitQuerySource(node As BoundQuerySource) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitToQueryableCollectionConversion(node As BoundToQueryableCollectionConversion) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitQueryableSource(node As BoundQueryableSource) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitQueryClause(node As BoundQueryClause) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitOrdering(node As BoundOrdering) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitQueryLambda(node As BoundQueryLambda) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitRangeVariableAssignment(node As BoundRangeVariableAssignment) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitGroupTypeInferenceLambda(node As GroupTypeInferenceLambda) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitAggregateClause(node As BoundAggregateClause) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitGroupAggregation(node As BoundGroupAggregation) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitRangeVariable(node As BoundRangeVariable) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitAddHandlerStatement(node As BoundAddHandlerStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitRemoveHandlerStatement(node As BoundRemoveHandlerStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitRaiseEventStatement(node As BoundRaiseEventStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitUsingStatement(node As BoundUsingStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitSyncLockStatement(node As BoundSyncLockStatement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitXmlName(node As BoundXmlName) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitXmlDocument(node As BoundXmlDocument) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitXmlDeclaration(node As BoundXmlDeclaration) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitXmlProcessingInstruction(node As BoundXmlProcessingInstruction) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitXmlComment(node As BoundXmlComment) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitXmlAttribute(node As BoundXmlAttribute) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitXmlElement(node As BoundXmlElement) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitXmlMemberAccess(node As BoundXmlMemberAccess) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

        Public Overridable Function VisitXmlEmbeddedExpression(node As BoundXmlEmbeddedExpression) As BoundNode
            Return Me.DefaultVisit(node)
        End Function

    End Class

    Friend MustInherit Partial Class BoundTreeWalker(Of A)
        Inherits BoundTreeVisitor(Of A, Object)

        Public Overrides Function VisitTypeArguments(node as BoundTypeArguments, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitOmittedArgument(node as BoundOmittedArgument, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitLValuePlaceholderRValueWrapper(node as BoundLValuePlaceholderRValueWrapper, arg As A) As Object
            Me.Visit(node.Placeholder, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitWithLValueExpressionPlaceholder(node as BoundWithLValueExpressionPlaceholder, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitWithRValueExpressionPlaceholder(node as BoundWithRValueExpressionPlaceholder, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitValuePlaceholder(node as BoundValuePlaceholder, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitBadExpression(node as BoundBadExpression, arg As A) As Object
            Me.VisitList(node.ChildBoundNodes, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitBadStatement(node as BoundBadStatement, arg As A) As Object
            Me.VisitList(node.ChildBoundNodes, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitParenthesized(node as BoundParenthesized, arg As A) As Object
            Me.Visit(node.Expression, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitBadVariable(node as BoundBadVariable, arg As A) As Object
            Me.Visit(node.Expression, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitArrayAccess(node as BoundArrayAccess, arg As A) As Object
            Me.Visit(node.Expression, arg)
            Me.VisitList(node.Indices, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitArrayLength(node as BoundArrayLength, arg As A) As Object
            Me.Visit(node.Expression, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitGetType(node as BoundGetType, arg As A) As Object
            Me.Visit(node.SourceType, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitTypeExpression(node as BoundTypeExpression, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitTypeOrValueExpression(node as BoundTypeOrValueExpression, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitNamespaceExpression(node as BoundNamespaceExpression, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitUnaryOperator(node as BoundUnaryOperator, arg As A) As Object
            Me.Visit(node.Operand, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitUserDefinedUnaryOperator(node as BoundUserDefinedUnaryOperator, arg As A) As Object
            Me.Visit(node.UnderlyingExpression, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitNullableIsTrueOperator(node as BoundNullableIsTrueOperator, arg As A) As Object
            Me.Visit(node.Operand, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitBinaryOperator(node as BoundBinaryOperator, arg As A) As Object
            Me.Visit(node.Left, arg)
            Me.Visit(node.Right, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitCompoundAssignmentTargetPlaceholder(node as BoundCompoundAssignmentTargetPlaceholder, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitAssignmentOperator(node as BoundAssignmentOperator, arg As A) As Object
            Me.Visit(node.Left, arg)
            Me.Visit(node.LeftOnTheRightOpt, arg)
            Me.Visit(node.Right, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitReferenceAssignment(node as BoundReferenceAssignment, arg As A) As Object
            Me.Visit(node.ByRefLocal, arg)
            Me.Visit(node.LValue, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitAddressOfOperator(node as BoundAddressOfOperator, arg As A) As Object
            Me.Visit(node.MethodGroup, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitTernaryConditionalExpression(node as BoundTernaryConditionalExpression, arg As A) As Object
            Me.Visit(node.Condition, arg)
            Me.Visit(node.WhenTrue, arg)
            Me.Visit(node.WhenFalse, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitBinaryConditionalExpression(node as BoundBinaryConditionalExpression, arg As A) As Object
            Me.Visit(node.TestExpression, arg)
            Me.Visit(node.ElseExpression, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitConversion(node as BoundConversion, arg As A) As Object
            Me.Visit(node.Operand, arg)
            Me.Visit(node.RelaxationLambdaOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitUserDefinedConversion(node as BoundUserDefinedConversion, arg As A) As Object
            Me.Visit(node.UnderlyingExpression, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitDirectCast(node as BoundDirectCast, arg As A) As Object
            Me.Visit(node.Operand, arg)
            Me.Visit(node.RelaxationLambdaOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitTryCast(node as BoundTryCast, arg As A) As Object
            Me.Visit(node.Operand, arg)
            Me.Visit(node.RelaxationLambdaOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitTypeOf(node as BoundTypeOf, arg As A) As Object
            Me.Visit(node.Operand, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitSequencePoint(node as BoundSequencePoint, arg As A) As Object
            Me.Visit(node.StatementOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitSequencePointExpression(node as BoundSequencePointExpression, arg As A) As Object
            Me.Visit(node.Expression, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitSequencePointWithSpan(node as BoundSequencePointWithSpan, arg As A) As Object
            Me.Visit(node.StatementOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitNoOpStatement(node as BoundNoOpStatement, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitMethodGroup(node as BoundMethodGroup, arg As A) As Object
            Me.Visit(node.TypeArgumentsOpt, arg)
            Me.Visit(node.ReceiverOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitPropertyGroup(node as BoundPropertyGroup, arg As A) As Object
            Me.Visit(node.ReceiverOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitReturnStatement(node as BoundReturnStatement, arg As A) As Object
            Me.Visit(node.ExpressionOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitThrowStatement(node as BoundThrowStatement, arg As A) As Object
            Me.Visit(node.ExpressionOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitRedimStatement(node as BoundRedimStatement, arg As A) As Object
            Me.VisitList(node.Clauses, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitRedimClause(node as BoundRedimClause, arg As A) As Object
            Me.Visit(node.Operand, arg)
            Me.VisitList(node.Indices, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitCall(node as BoundCall, arg As A) As Object
            Me.Visit(node.ReceiverOpt, arg)
            Me.VisitList(node.Arguments, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitAttribute(node as BoundAttribute, arg As A) As Object
            Me.VisitList(node.ConstructorArguments, arg)
            Me.VisitList(node.NamedArguments, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitLateCall(node as BoundLateCall, arg As A) As Object
            Me.Visit(node.Receiver, arg)
            Me.Visit(node.OriginalMethodGroupOpt, arg)
            Me.VisitList(node.Arguments, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitObjectCreationExpression(node as BoundObjectCreationExpression, arg As A) As Object
            Me.VisitList(node.Arguments, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitAnonymousTypeCreationExpression(node as BoundAnonymousTypeCreationExpression, arg As A) As Object
            Me.VisitList(node.Declarations, arg)
            Me.VisitList(node.Arguments, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitAnonymousTypePropertyAccess(node as BoundAnonymousTypePropertyAccess, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitAnonymousTypeFieldInitializer(node as BoundAnonymousTypeFieldInitializer, arg As A) As Object
            Me.Visit(node.Value, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitNewT(node as BoundNewT, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitDelegateCreationExpression(node as BoundDelegateCreationExpression, arg As A) As Object
            Me.Visit(node.ReceiverOpt, arg)
            Me.Visit(node.RelaxationLambdaOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitArrayCreation(node as BoundArrayCreation, arg As A) As Object
            Me.VisitList(node.Bounds, arg)
            Me.Visit(node.InitializerOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitArrayInitialization(node as BoundArrayInitialization, arg As A) As Object
            Me.VisitList(node.Initializers, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitFieldAccess(node as BoundFieldAccess, arg As A) As Object
            Me.Visit(node.ReceiverOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitPropertyAccess(node as BoundPropertyAccess, arg As A) As Object
            Me.Visit(node.ReceiverOpt, arg)
            Me.VisitList(node.Arguments, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitEventAccess(node as BoundEventAccess, arg As A) As Object
            Me.Visit(node.ReceiverOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitBlock(node as BoundBlock, arg As A) As Object
            Me.VisitList(node.Statements, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitLocalDeclaration(node as BoundLocalDeclaration, arg As A) As Object
            Me.Visit(node.InitializerOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitAsNewLocalDeclarations(node as BoundAsNewLocalDeclarations, arg As A) As Object
            Me.VisitList(node.LocalDeclarations, arg)
            Me.Visit(node.Initializer, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitDimStatement(node as BoundDimStatement, arg As A) As Object
            Me.VisitList(node.LocalDeclarations, arg)
            Me.Visit(node.InitializerOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitInitializer(node as BoundInitializer, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitFieldOrPropertyInitializer(node as BoundFieldOrPropertyInitializer, arg As A) As Object
            Me.Visit(node.FieldOrProperty, arg)
            Me.Visit(node.InitialValue, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitGlobalStatementInitializer(node as BoundGlobalStatementInitializer, arg As A) As Object
            Me.Visit(node.Statement, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitSequence(node as BoundSequence, arg As A) As Object
            Me.VisitList(node.SideEffects, arg)
            Me.Visit(node.ValueOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitExpressionStatement(node as BoundExpressionStatement, arg As A) As Object
            Me.Visit(node.Expression, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitIfStatement(node as BoundIfStatement, arg As A) As Object
            Me.Visit(node.Condition, arg)
            Me.Visit(node.Consequence, arg)
            Me.Visit(node.AlternativeOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitSelectStatement(node as BoundSelectStatement, arg As A) As Object
            Me.Visit(node.ExpressionStatement, arg)
            Me.Visit(node.ExprPlaceholderOpt, arg)
            Me.VisitList(node.CaseBlocks, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitCaseBlock(node as BoundCaseBlock, arg As A) As Object
            Me.Visit(node.CaseStatement, arg)
            Me.Visit(node.Body, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitCaseStatement(node as BoundCaseStatement, arg As A) As Object
            Me.VisitList(node.CaseClauses, arg)
            Me.Visit(node.ConditionOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitCaseValueClause(node as BoundCaseValueClause, arg As A) As Object
            Me.Visit(node.ValueOpt, arg)
            Me.Visit(node.ConditionOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitCaseRangeClause(node as BoundCaseRangeClause, arg As A) As Object
            Me.Visit(node.LowerBoundOpt, arg)
            Me.Visit(node.UpperBoundOpt, arg)
            Me.Visit(node.LowerBoundConditionOpt, arg)
            Me.Visit(node.UpperBoundConditionOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitCaseRelationalClause(node as BoundCaseRelationalClause, arg As A) As Object
            Me.Visit(node.OperandOpt, arg)
            Me.Visit(node.ConditionOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitDoLoopStatement(node as BoundDoLoopStatement, arg As A) As Object
            Me.Visit(node.TopConditionOpt, arg)
            Me.Visit(node.BottomConditionOpt, arg)
            Me.Visit(node.Body, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitWhileStatement(node as BoundWhileStatement, arg As A) As Object
            Me.Visit(node.Condition, arg)
            Me.Visit(node.Body, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitForToStatement(node as BoundForToStatement, arg As A) As Object
            Me.Visit(node.InitialValue, arg)
            Me.Visit(node.LimitValue, arg)
            Me.Visit(node.StepValue, arg)
            Me.Visit(node.ControlVariable, arg)
            Me.Visit(node.Body, arg)
            Me.VisitList(node.NextVariablesOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitForEachStatement(node as BoundForEachStatement, arg As A) As Object
            Me.Visit(node.Collection, arg)
            Me.Visit(node.ControlVariable, arg)
            Me.Visit(node.Body, arg)
            Me.VisitList(node.NextVariablesOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitExitStatement(node as BoundExitStatement, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitContinueStatement(node as BoundContinueStatement, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitTryStatement(node as BoundTryStatement, arg As A) As Object
            Me.Visit(node.TryBlock, arg)
            Me.VisitList(node.CatchBlocks, arg)
            Me.Visit(node.FinallyBlockOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitCatchBlock(node as BoundCatchBlock, arg As A) As Object
            Me.Visit(node.ExceptionVariableOpt, arg)
            Me.Visit(node.ExceptionFilterOpt, arg)
            Me.Visit(node.Body, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitLiteral(node as BoundLiteral, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitMeReference(node as BoundMeReference, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitMyBaseReference(node as BoundMyBaseReference, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitMyClassReference(node as BoundMyClassReference, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitPreviousSubmissionReference(node as BoundPreviousSubmissionReference, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitHostObjectMemberReference(node as BoundHostObjectMemberReference, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitLocal(node as BoundLocal, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitParameter(node as BoundParameter, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitByRefArgumentPlaceholder(node as BoundByRefArgumentPlaceholder, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitByRefArgumentWithCopyBack(node as BoundByRefArgumentWithCopyBack, arg As A) As Object
            Me.Visit(node.OriginalArgument, arg)
            Me.Visit(node.InConversion, arg)
            Me.Visit(node.InPlaceholder, arg)
            Me.Visit(node.OutConversion, arg)
            Me.Visit(node.OutPlaceholder, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitLabelStatement(node as BoundLabelStatement, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitLabel(node as BoundLabel, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitGotoStatement(node as BoundGotoStatement, arg As A) As Object
            Me.Visit(node.LabelExpressionOpt, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitStatementList(node as BoundStatementList, arg As A) As Object
            Me.VisitList(node.Statements, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitConditionalGoto(node as BoundConditionalGoto, arg As A) As Object
            Me.Visit(node.Condition, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitWithStatement(node as BoundWithStatement, arg As A) As Object
            Me.Visit(node.OriginalExpression, arg)
            Me.Visit(node.Body, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitUnboundLambda(node as UnboundLambda, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitLambda(node as BoundLambda, arg As A) As Object
            Me.Visit(node.Body, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitQueryExpression(node as BoundQueryExpression, arg As A) As Object
            Me.Visit(node.LastOperator, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitQuerySource(node as BoundQuerySource, arg As A) As Object
            Me.Visit(node.Expression, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitToQueryableCollectionConversion(node as BoundToQueryableCollectionConversion, arg As A) As Object
            Me.Visit(node.ConversionCall, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitQueryableSource(node as BoundQueryableSource, arg As A) As Object
            Me.Visit(node.Source, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitQueryClause(node as BoundQueryClause, arg As A) As Object
            Me.Visit(node.UnderlyingExpression, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitOrdering(node as BoundOrdering, arg As A) As Object
            Me.Visit(node.UnderlyingExpression, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitQueryLambda(node as BoundQueryLambda, arg As A) As Object
            Me.Visit(node.Expression, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitRangeVariableAssignment(node as BoundRangeVariableAssignment, arg As A) As Object
            Me.Visit(node.Value, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitGroupTypeInferenceLambda(node as GroupTypeInferenceLambda, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitAggregateClause(node as BoundAggregateClause, arg As A) As Object
            Me.Visit(node.CapturedGroupOpt, arg)
            Me.Visit(node.GroupPlaceholderOpt, arg)
            Me.Visit(node.UnderlyingExpression, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitGroupAggregation(node as BoundGroupAggregation, arg As A) As Object
            Me.Visit(node.Group, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitRangeVariable(node as BoundRangeVariable, arg As A) As Object
            Return Nothing
        End Function

        Public Overrides Function VisitAddHandlerStatement(node as BoundAddHandlerStatement, arg As A) As Object
            Me.Visit(node.EventAccess, arg)
            Me.Visit(node.Handler, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitRemoveHandlerStatement(node as BoundRemoveHandlerStatement, arg As A) As Object
            Me.Visit(node.EventAccess, arg)
            Me.Visit(node.Handler, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitRaiseEventStatement(node as BoundRaiseEventStatement, arg As A) As Object
            Me.Visit(node.EventInvocation, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitUsingStatement(node as BoundUsingStatement, arg As A) As Object
            Me.VisitList(node.ResourceList, arg)
            Me.Visit(node.ResourceExpressionOpt, arg)
            Me.Visit(node.Body, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitSyncLockStatement(node as BoundSyncLockStatement, arg As A) As Object
            Me.Visit(node.LockExpression, arg)
            Me.Visit(node.Body, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlName(node as BoundXmlName, arg As A) As Object
            Me.Visit(node.XmlNamespace, arg)
            Me.Visit(node.LocalName, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlDocument(node as BoundXmlDocument, arg As A) As Object
            Me.Visit(node.Declaration, arg)
            Me.VisitList(node.ChildNodes, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlDeclaration(node as BoundXmlDeclaration, arg As A) As Object
            Me.Visit(node.Version, arg)
            Me.Visit(node.Encoding, arg)
            Me.Visit(node.Standalone, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlProcessingInstruction(node as BoundXmlProcessingInstruction, arg As A) As Object
            Me.Visit(node.Target, arg)
            Me.Visit(node.Data, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlComment(node as BoundXmlComment, arg As A) As Object
            Me.Visit(node.Value, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlAttribute(node as BoundXmlAttribute, arg As A) As Object
            Me.Visit(node.Name, arg)
            Me.Visit(node.Value, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlElement(node as BoundXmlElement, arg As A) As Object
            Me.Visit(node.Argument, arg)
            Me.VisitList(node.ChildNodes, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlMemberAccess(node as BoundXmlMemberAccess, arg As A) As Object
            Me.Visit(node.Receiver, arg)
            Me.Visit(node.Name, arg)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlEmbeddedExpression(node as BoundXmlEmbeddedExpression, arg As A) As Object
            Me.Visit(node.Expression, arg)
            Return Nothing
        End Function

    End Class

    Friend MustInherit Partial Class BoundTreeWalker
        Inherits BoundTreeVisitor

        Public Overrides Function VisitTypeArguments(node as BoundTypeArguments) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitOmittedArgument(node as BoundOmittedArgument) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitLValuePlaceholderRValueWrapper(node as BoundLValuePlaceholderRValueWrapper) As BoundNode
            Me.Visit(node.Placeholder)
            Return Nothing
        End Function

        Public Overrides Function VisitWithLValueExpressionPlaceholder(node as BoundWithLValueExpressionPlaceholder) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitWithRValueExpressionPlaceholder(node as BoundWithRValueExpressionPlaceholder) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitValuePlaceholder(node as BoundValuePlaceholder) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitBadExpression(node as BoundBadExpression) As BoundNode
            Me.VisitList(node.ChildBoundNodes)
            Return Nothing
        End Function

        Public Overrides Function VisitBadStatement(node as BoundBadStatement) As BoundNode
            Me.VisitList(node.ChildBoundNodes)
            Return Nothing
        End Function

        Public Overrides Function VisitParenthesized(node as BoundParenthesized) As BoundNode
            Me.Visit(node.Expression)
            Return Nothing
        End Function

        Public Overrides Function VisitBadVariable(node as BoundBadVariable) As BoundNode
            Me.Visit(node.Expression)
            Return Nothing
        End Function

        Public Overrides Function VisitArrayAccess(node as BoundArrayAccess) As BoundNode
            Me.Visit(node.Expression)
            Me.VisitList(node.Indices)
            Return Nothing
        End Function

        Public Overrides Function VisitArrayLength(node as BoundArrayLength) As BoundNode
            Me.Visit(node.Expression)
            Return Nothing
        End Function

        Public Overrides Function VisitGetType(node as BoundGetType) As BoundNode
            Me.Visit(node.SourceType)
            Return Nothing
        End Function

        Public Overrides Function VisitTypeExpression(node as BoundTypeExpression) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitTypeOrValueExpression(node as BoundTypeOrValueExpression) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitNamespaceExpression(node as BoundNamespaceExpression) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitUnaryOperator(node as BoundUnaryOperator) As BoundNode
            Me.Visit(node.Operand)
            Return Nothing
        End Function

        Public Overrides Function VisitUserDefinedUnaryOperator(node as BoundUserDefinedUnaryOperator) As BoundNode
            Me.Visit(node.UnderlyingExpression)
            Return Nothing
        End Function

        Public Overrides Function VisitNullableIsTrueOperator(node as BoundNullableIsTrueOperator) As BoundNode
            Me.Visit(node.Operand)
            Return Nothing
        End Function

        Public Overrides Function VisitBinaryOperator(node as BoundBinaryOperator) As BoundNode
            Me.Visit(node.Left)
            Me.Visit(node.Right)
            Return Nothing
        End Function

        Public Overrides Function VisitCompoundAssignmentTargetPlaceholder(node as BoundCompoundAssignmentTargetPlaceholder) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitAssignmentOperator(node as BoundAssignmentOperator) As BoundNode
            Me.Visit(node.Left)
            Me.Visit(node.LeftOnTheRightOpt)
            Me.Visit(node.Right)
            Return Nothing
        End Function

        Public Overrides Function VisitReferenceAssignment(node as BoundReferenceAssignment) As BoundNode
            Me.Visit(node.ByRefLocal)
            Me.Visit(node.LValue)
            Return Nothing
        End Function

        Public Overrides Function VisitAddressOfOperator(node as BoundAddressOfOperator) As BoundNode
            Me.Visit(node.MethodGroup)
            Return Nothing
        End Function

        Public Overrides Function VisitTernaryConditionalExpression(node as BoundTernaryConditionalExpression) As BoundNode
            Me.Visit(node.Condition)
            Me.Visit(node.WhenTrue)
            Me.Visit(node.WhenFalse)
            Return Nothing
        End Function

        Public Overrides Function VisitBinaryConditionalExpression(node as BoundBinaryConditionalExpression) As BoundNode
            Me.Visit(node.TestExpression)
            Me.Visit(node.ElseExpression)
            Return Nothing
        End Function

        Public Overrides Function VisitConversion(node as BoundConversion) As BoundNode
            Me.Visit(node.Operand)
            Me.Visit(node.RelaxationLambdaOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitUserDefinedConversion(node as BoundUserDefinedConversion) As BoundNode
            Me.Visit(node.UnderlyingExpression)
            Return Nothing
        End Function

        Public Overrides Function VisitDirectCast(node as BoundDirectCast) As BoundNode
            Me.Visit(node.Operand)
            Me.Visit(node.RelaxationLambdaOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitTryCast(node as BoundTryCast) As BoundNode
            Me.Visit(node.Operand)
            Me.Visit(node.RelaxationLambdaOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitTypeOf(node as BoundTypeOf) As BoundNode
            Me.Visit(node.Operand)
            Return Nothing
        End Function

        Public Overrides Function VisitSequencePoint(node as BoundSequencePoint) As BoundNode
            Me.Visit(node.StatementOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitSequencePointExpression(node as BoundSequencePointExpression) As BoundNode
            Me.Visit(node.Expression)
            Return Nothing
        End Function

        Public Overrides Function VisitSequencePointWithSpan(node as BoundSequencePointWithSpan) As BoundNode
            Me.Visit(node.StatementOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitNoOpStatement(node as BoundNoOpStatement) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitMethodGroup(node as BoundMethodGroup) As BoundNode
            Me.Visit(node.TypeArgumentsOpt)
            Me.Visit(node.ReceiverOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitPropertyGroup(node as BoundPropertyGroup) As BoundNode
            Me.Visit(node.ReceiverOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitReturnStatement(node as BoundReturnStatement) As BoundNode
            Me.Visit(node.ExpressionOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitThrowStatement(node as BoundThrowStatement) As BoundNode
            Me.Visit(node.ExpressionOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitRedimStatement(node as BoundRedimStatement) As BoundNode
            Me.VisitList(node.Clauses)
            Return Nothing
        End Function

        Public Overrides Function VisitRedimClause(node as BoundRedimClause) As BoundNode
            Me.Visit(node.Operand)
            Me.VisitList(node.Indices)
            Return Nothing
        End Function

        Public Overrides Function VisitCall(node as BoundCall) As BoundNode
            Me.Visit(node.ReceiverOpt)
            Me.VisitList(node.Arguments)
            Return Nothing
        End Function

        Public Overrides Function VisitAttribute(node as BoundAttribute) As BoundNode
            Me.VisitList(node.ConstructorArguments)
            Me.VisitList(node.NamedArguments)
            Return Nothing
        End Function

        Public Overrides Function VisitLateCall(node as BoundLateCall) As BoundNode
            Me.Visit(node.Receiver)
            Me.Visit(node.OriginalMethodGroupOpt)
            Me.VisitList(node.Arguments)
            Return Nothing
        End Function

        Public Overrides Function VisitObjectCreationExpression(node as BoundObjectCreationExpression) As BoundNode
            Me.VisitList(node.Arguments)
            Return Nothing
        End Function

        Public Overrides Function VisitAnonymousTypeCreationExpression(node as BoundAnonymousTypeCreationExpression) As BoundNode
            Me.VisitList(node.Declarations)
            Me.VisitList(node.Arguments)
            Return Nothing
        End Function

        Public Overrides Function VisitAnonymousTypePropertyAccess(node as BoundAnonymousTypePropertyAccess) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitAnonymousTypeFieldInitializer(node as BoundAnonymousTypeFieldInitializer) As BoundNode
            Me.Visit(node.Value)
            Return Nothing
        End Function

        Public Overrides Function VisitNewT(node as BoundNewT) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitDelegateCreationExpression(node as BoundDelegateCreationExpression) As BoundNode
            Me.Visit(node.ReceiverOpt)
            Me.Visit(node.RelaxationLambdaOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitArrayCreation(node as BoundArrayCreation) As BoundNode
            Me.VisitList(node.Bounds)
            Me.Visit(node.InitializerOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitArrayInitialization(node as BoundArrayInitialization) As BoundNode
            Me.VisitList(node.Initializers)
            Return Nothing
        End Function

        Public Overrides Function VisitFieldAccess(node as BoundFieldAccess) As BoundNode
            Me.Visit(node.ReceiverOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitPropertyAccess(node as BoundPropertyAccess) As BoundNode
            Me.Visit(node.ReceiverOpt)
            Me.VisitList(node.Arguments)
            Return Nothing
        End Function

        Public Overrides Function VisitEventAccess(node as BoundEventAccess) As BoundNode
            Me.Visit(node.ReceiverOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitBlock(node as BoundBlock) As BoundNode
            Me.VisitList(node.Statements)
            Return Nothing
        End Function

        Public Overrides Function VisitLocalDeclaration(node as BoundLocalDeclaration) As BoundNode
            Me.Visit(node.InitializerOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitAsNewLocalDeclarations(node as BoundAsNewLocalDeclarations) As BoundNode
            Me.VisitList(node.LocalDeclarations)
            Me.Visit(node.Initializer)
            Return Nothing
        End Function

        Public Overrides Function VisitDimStatement(node as BoundDimStatement) As BoundNode
            Me.VisitList(node.LocalDeclarations)
            Me.Visit(node.InitializerOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitInitializer(node as BoundInitializer) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitFieldOrPropertyInitializer(node as BoundFieldOrPropertyInitializer) As BoundNode
            Me.Visit(node.FieldOrProperty)
            Me.Visit(node.InitialValue)
            Return Nothing
        End Function

        Public Overrides Function VisitGlobalStatementInitializer(node as BoundGlobalStatementInitializer) As BoundNode
            Me.Visit(node.Statement)
            Return Nothing
        End Function

        Public Overrides Function VisitSequence(node as BoundSequence) As BoundNode
            Me.VisitList(node.SideEffects)
            Me.Visit(node.ValueOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitExpressionStatement(node as BoundExpressionStatement) As BoundNode
            Me.Visit(node.Expression)
            Return Nothing
        End Function

        Public Overrides Function VisitIfStatement(node as BoundIfStatement) As BoundNode
            Me.Visit(node.Condition)
            Me.Visit(node.Consequence)
            Me.Visit(node.AlternativeOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitSelectStatement(node as BoundSelectStatement) As BoundNode
            Me.Visit(node.ExpressionStatement)
            Me.Visit(node.ExprPlaceholderOpt)
            Me.VisitList(node.CaseBlocks)
            Return Nothing
        End Function

        Public Overrides Function VisitCaseBlock(node as BoundCaseBlock) As BoundNode
            Me.Visit(node.CaseStatement)
            Me.Visit(node.Body)
            Return Nothing
        End Function

        Public Overrides Function VisitCaseStatement(node as BoundCaseStatement) As BoundNode
            Me.VisitList(node.CaseClauses)
            Me.Visit(node.ConditionOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitCaseValueClause(node as BoundCaseValueClause) As BoundNode
            Me.Visit(node.ValueOpt)
            Me.Visit(node.ConditionOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitCaseRangeClause(node as BoundCaseRangeClause) As BoundNode
            Me.Visit(node.LowerBoundOpt)
            Me.Visit(node.UpperBoundOpt)
            Me.Visit(node.LowerBoundConditionOpt)
            Me.Visit(node.UpperBoundConditionOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitCaseRelationalClause(node as BoundCaseRelationalClause) As BoundNode
            Me.Visit(node.OperandOpt)
            Me.Visit(node.ConditionOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitDoLoopStatement(node as BoundDoLoopStatement) As BoundNode
            Me.Visit(node.TopConditionOpt)
            Me.Visit(node.BottomConditionOpt)
            Me.Visit(node.Body)
            Return Nothing
        End Function

        Public Overrides Function VisitWhileStatement(node as BoundWhileStatement) As BoundNode
            Me.Visit(node.Condition)
            Me.Visit(node.Body)
            Return Nothing
        End Function

        Public Overrides Function VisitForToStatement(node as BoundForToStatement) As BoundNode
            Me.Visit(node.InitialValue)
            Me.Visit(node.LimitValue)
            Me.Visit(node.StepValue)
            Me.Visit(node.ControlVariable)
            Me.Visit(node.Body)
            Me.VisitList(node.NextVariablesOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitForEachStatement(node as BoundForEachStatement) As BoundNode
            Me.Visit(node.Collection)
            Me.Visit(node.ControlVariable)
            Me.Visit(node.Body)
            Me.VisitList(node.NextVariablesOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitExitStatement(node as BoundExitStatement) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitContinueStatement(node as BoundContinueStatement) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitTryStatement(node as BoundTryStatement) As BoundNode
            Me.Visit(node.TryBlock)
            Me.VisitList(node.CatchBlocks)
            Me.Visit(node.FinallyBlockOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitCatchBlock(node as BoundCatchBlock) As BoundNode
            Me.Visit(node.ExceptionVariableOpt)
            Me.Visit(node.ExceptionFilterOpt)
            Me.Visit(node.Body)
            Return Nothing
        End Function

        Public Overrides Function VisitLiteral(node as BoundLiteral) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitMeReference(node as BoundMeReference) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitMyBaseReference(node as BoundMyBaseReference) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitMyClassReference(node as BoundMyClassReference) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitPreviousSubmissionReference(node as BoundPreviousSubmissionReference) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitHostObjectMemberReference(node as BoundHostObjectMemberReference) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitLocal(node as BoundLocal) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitParameter(node as BoundParameter) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitByRefArgumentPlaceholder(node as BoundByRefArgumentPlaceholder) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitByRefArgumentWithCopyBack(node as BoundByRefArgumentWithCopyBack) As BoundNode
            Me.Visit(node.OriginalArgument)
            Me.Visit(node.InConversion)
            Me.Visit(node.InPlaceholder)
            Me.Visit(node.OutConversion)
            Me.Visit(node.OutPlaceholder)
            Return Nothing
        End Function

        Public Overrides Function VisitLabelStatement(node as BoundLabelStatement) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitLabel(node as BoundLabel) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitGotoStatement(node as BoundGotoStatement) As BoundNode
            Me.Visit(node.LabelExpressionOpt)
            Return Nothing
        End Function

        Public Overrides Function VisitStatementList(node as BoundStatementList) As BoundNode
            Me.VisitList(node.Statements)
            Return Nothing
        End Function

        Public Overrides Function VisitConditionalGoto(node as BoundConditionalGoto) As BoundNode
            Me.Visit(node.Condition)
            Return Nothing
        End Function

        Public Overrides Function VisitWithStatement(node as BoundWithStatement) As BoundNode
            Me.Visit(node.OriginalExpression)
            Me.Visit(node.Body)
            Return Nothing
        End Function

        Public Overrides Function VisitUnboundLambda(node as UnboundLambda) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitLambda(node as BoundLambda) As BoundNode
            Me.Visit(node.Body)
            Return Nothing
        End Function

        Public Overrides Function VisitQueryExpression(node as BoundQueryExpression) As BoundNode
            Me.Visit(node.LastOperator)
            Return Nothing
        End Function

        Public Overrides Function VisitQuerySource(node as BoundQuerySource) As BoundNode
            Me.Visit(node.Expression)
            Return Nothing
        End Function

        Public Overrides Function VisitToQueryableCollectionConversion(node as BoundToQueryableCollectionConversion) As BoundNode
            Me.Visit(node.ConversionCall)
            Return Nothing
        End Function

        Public Overrides Function VisitQueryableSource(node as BoundQueryableSource) As BoundNode
            Me.Visit(node.Source)
            Return Nothing
        End Function

        Public Overrides Function VisitQueryClause(node as BoundQueryClause) As BoundNode
            Me.Visit(node.UnderlyingExpression)
            Return Nothing
        End Function

        Public Overrides Function VisitOrdering(node as BoundOrdering) As BoundNode
            Me.Visit(node.UnderlyingExpression)
            Return Nothing
        End Function

        Public Overrides Function VisitQueryLambda(node as BoundQueryLambda) As BoundNode
            Me.Visit(node.Expression)
            Return Nothing
        End Function

        Public Overrides Function VisitRangeVariableAssignment(node as BoundRangeVariableAssignment) As BoundNode
            Me.Visit(node.Value)
            Return Nothing
        End Function

        Public Overrides Function VisitGroupTypeInferenceLambda(node as GroupTypeInferenceLambda) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitAggregateClause(node as BoundAggregateClause) As BoundNode
            Me.Visit(node.CapturedGroupOpt)
            Me.Visit(node.GroupPlaceholderOpt)
            Me.Visit(node.UnderlyingExpression)
            Return Nothing
        End Function

        Public Overrides Function VisitGroupAggregation(node as BoundGroupAggregation) As BoundNode
            Me.Visit(node.Group)
            Return Nothing
        End Function

        Public Overrides Function VisitRangeVariable(node as BoundRangeVariable) As BoundNode
            Return Nothing
        End Function

        Public Overrides Function VisitAddHandlerStatement(node as BoundAddHandlerStatement) As BoundNode
            Me.Visit(node.EventAccess)
            Me.Visit(node.Handler)
            Return Nothing
        End Function

        Public Overrides Function VisitRemoveHandlerStatement(node as BoundRemoveHandlerStatement) As BoundNode
            Me.Visit(node.EventAccess)
            Me.Visit(node.Handler)
            Return Nothing
        End Function

        Public Overrides Function VisitRaiseEventStatement(node as BoundRaiseEventStatement) As BoundNode
            Me.Visit(node.EventInvocation)
            Return Nothing
        End Function

        Public Overrides Function VisitUsingStatement(node as BoundUsingStatement) As BoundNode
            Me.VisitList(node.ResourceList)
            Me.Visit(node.ResourceExpressionOpt)
            Me.Visit(node.Body)
            Return Nothing
        End Function

        Public Overrides Function VisitSyncLockStatement(node as BoundSyncLockStatement) As BoundNode
            Me.Visit(node.LockExpression)
            Me.Visit(node.Body)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlName(node as BoundXmlName) As BoundNode
            Me.Visit(node.XmlNamespace)
            Me.Visit(node.LocalName)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlDocument(node as BoundXmlDocument) As BoundNode
            Me.Visit(node.Declaration)
            Me.VisitList(node.ChildNodes)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlDeclaration(node as BoundXmlDeclaration) As BoundNode
            Me.Visit(node.Version)
            Me.Visit(node.Encoding)
            Me.Visit(node.Standalone)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlProcessingInstruction(node as BoundXmlProcessingInstruction) As BoundNode
            Me.Visit(node.Target)
            Me.Visit(node.Data)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlComment(node as BoundXmlComment) As BoundNode
            Me.Visit(node.Value)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlAttribute(node as BoundXmlAttribute) As BoundNode
            Me.Visit(node.Name)
            Me.Visit(node.Value)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlElement(node as BoundXmlElement) As BoundNode
            Me.Visit(node.Argument)
            Me.VisitList(node.ChildNodes)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlMemberAccess(node as BoundXmlMemberAccess) As BoundNode
            Me.Visit(node.Receiver)
            Me.Visit(node.Name)
            Return Nothing
        End Function

        Public Overrides Function VisitXmlEmbeddedExpression(node as BoundXmlEmbeddedExpression) As BoundNode
            Me.Visit(node.Expression)
            Return Nothing
        End Function

    End Class

    Friend MustInherit Partial Class BoundTreeRewriter
        Inherits BoundTreeVisitor

        Public Overrides Function VisitTypeArguments(node As BoundTypeArguments) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.Arguments)
        End Function

        Public Overrides Function VisitOmittedArgument(node As BoundOmittedArgument) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update()
        End Function

        Public Overrides Function VisitLValuePlaceholderRValueWrapper(node As BoundLValuePlaceholderRValueWrapper) As BoundNode
            Dim placeholder As BoundValuePlaceholderBase = DirectCast(Me.Visit(node.Placeholder), BoundValuePlaceholderBase)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(placeholder, type)
        End Function

        Public Overrides Function VisitWithLValueExpressionPlaceholder(node As BoundWithLValueExpressionPlaceholder) As BoundNode
            Dim draftSubstitutor As BoundExpression = node.DraftSubstitutor
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(draftSubstitutor, type)
        End Function

        Public Overrides Function VisitWithRValueExpressionPlaceholder(node As BoundWithRValueExpressionPlaceholder) As BoundNode
            Dim draftSubstitutor As BoundExpression = node.DraftSubstitutor
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(draftSubstitutor, type)
        End Function

        Public Overrides Function VisitValuePlaceholder(node As BoundValuePlaceholder) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(type)
        End Function

        Public Overrides Function VisitBadExpression(node As BoundBadExpression) As BoundNode
            Dim childBoundNodes As ReadOnlyArray(Of BoundNode) = Me.VisitList(node.ChildBoundNodes)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.ResultKind, node.Symbols, childBoundNodes, type)
        End Function

        Public Overrides Function VisitBadStatement(node As BoundBadStatement) As BoundNode
            Dim childBoundNodes As ReadOnlyArray(Of BoundNode) = Me.VisitList(node.ChildBoundNodes)
            Return node.Update(childBoundNodes)
        End Function

        Public Overrides Function VisitParenthesized(node As BoundParenthesized) As BoundNode
            Dim expression As BoundExpression = DirectCast(Me.Visit(node.Expression), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(expression, type)
        End Function

        Public Overrides Function VisitBadVariable(node As BoundBadVariable) As BoundNode
            Dim expression As BoundExpression = DirectCast(Me.Visit(node.Expression), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(expression, node.IsLValue, type)
        End Function

        Public Overrides Function VisitArrayAccess(node As BoundArrayAccess) As BoundNode
            Dim expression As BoundExpression = DirectCast(Me.Visit(node.Expression), BoundExpression)
            Dim indices As ReadOnlyArray(Of BoundExpression) = Me.VisitList(node.Indices)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(expression, indices, node.IsLValue, type)
        End Function

        Public Overrides Function VisitArrayLength(node As BoundArrayLength) As BoundNode
            Dim expression As BoundExpression = DirectCast(Me.Visit(node.Expression), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(expression, type)
        End Function

        Public Overrides Function VisitGetType(node As BoundGetType) As BoundNode
            Dim sourceType As BoundTypeExpression = DirectCast(Me.Visit(node.SourceType), BoundTypeExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(sourceType, type)
        End Function

        Public Overrides Function VisitTypeExpression(node As BoundTypeExpression) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.AliasOpt, type)
        End Function

        Public Overrides Function VisitTypeOrValueExpression(node As BoundTypeOrValueExpression) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(type)
        End Function

        Public Overrides Function VisitNamespaceExpression(node As BoundNamespaceExpression) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.AliasOpt, node.NamespaceSymbol)
        End Function

        Public Overrides Function VisitUnaryOperator(node As BoundUnaryOperator) As BoundNode
            Dim operand As BoundExpression = DirectCast(Me.Visit(node.Operand), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.OperatorKind, operand, node.Checked, node.ConstantValueOpt, type)
        End Function

        Public Overrides Function VisitUserDefinedUnaryOperator(node As BoundUserDefinedUnaryOperator) As BoundNode
            Dim underlyingExpression As BoundExpression = DirectCast(Me.Visit(node.UnderlyingExpression), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.OperatorKind, underlyingExpression, type)
        End Function

        Public Overrides Function VisitNullableIsTrueOperator(node As BoundNullableIsTrueOperator) As BoundNode
            Dim operand As BoundExpression = DirectCast(Me.Visit(node.Operand), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(operand, type)
        End Function

        Public Overrides Function VisitBinaryOperator(node As BoundBinaryOperator) As BoundNode
            Dim left As BoundExpression = DirectCast(Me.Visit(node.Left), BoundExpression)
            Dim right As BoundExpression = DirectCast(Me.Visit(node.Right), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.OperatorKind, left, right, node.Checked, node.ConstantValueOpt, type)
        End Function

        Public Overrides Function VisitCompoundAssignmentTargetPlaceholder(node As BoundCompoundAssignmentTargetPlaceholder) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(type)
        End Function

        Public Overrides Function VisitAssignmentOperator(node As BoundAssignmentOperator) As BoundNode
            Dim left As BoundExpression = DirectCast(Me.Visit(node.Left), BoundExpression)
            Dim leftOnTheRightOpt As BoundCompoundAssignmentTargetPlaceholder = DirectCast(Me.Visit(node.LeftOnTheRightOpt), BoundCompoundAssignmentTargetPlaceholder)
            Dim right As BoundExpression = DirectCast(Me.Visit(node.Right), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(left, leftOnTheRightOpt, right, node.SuppressObjectClone, type)
        End Function

        Public Overrides Function VisitReferenceAssignment(node As BoundReferenceAssignment) As BoundNode
            Dim byRefLocal As BoundLocal = DirectCast(Me.Visit(node.ByRefLocal), BoundLocal)
            Dim lValue As BoundExpression = DirectCast(Me.Visit(node.LValue), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(byRefLocal, lValue, node.IsLValue, type)
        End Function

        Public Overrides Function VisitAddressOfOperator(node As BoundAddressOfOperator) As BoundNode
            Dim methodGroup As BoundMethodGroup = DirectCast(Me.Visit(node.MethodGroup), BoundMethodGroup)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.Binder, methodGroup)
        End Function

        Public Overrides Function VisitTernaryConditionalExpression(node As BoundTernaryConditionalExpression) As BoundNode
            Dim condition As BoundExpression = DirectCast(Me.Visit(node.Condition), BoundExpression)
            Dim whenTrue As BoundExpression = DirectCast(Me.Visit(node.WhenTrue), BoundExpression)
            Dim whenFalse As BoundExpression = DirectCast(Me.Visit(node.WhenFalse), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(condition, whenTrue, whenFalse, node.ConstantValueOpt, type)
        End Function

        Public Overrides Function VisitBinaryConditionalExpression(node As BoundBinaryConditionalExpression) As BoundNode
            Dim testExpression As BoundExpression = DirectCast(Me.Visit(node.TestExpression), BoundExpression)
            Dim convertedTestExpression As BoundExpression = node.ConvertedTestExpression
            Dim testExpressionPlaceholder As BoundValuePlaceholder = node.TestExpressionPlaceholder
            Dim elseExpression As BoundExpression = DirectCast(Me.Visit(node.ElseExpression), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(testExpression, convertedTestExpression, testExpressionPlaceholder, elseExpression, node.ConstantValueOpt, type)
        End Function

        Public Overrides Function VisitConversion(node As BoundConversion) As BoundNode
            Dim operand As BoundExpression = DirectCast(Me.Visit(node.Operand), BoundExpression)
            Dim relaxationLambdaOpt As BoundLambda = DirectCast(Me.Visit(node.RelaxationLambdaOpt), BoundLambda)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(operand, node.ConversionKind, node.Checked, node.ExplicitCastInCode, node.ConstantValueOpt, node.ConstructorOpt, relaxationLambdaOpt, node.RelaxationReceiverTempOpt, type)
        End Function

        Public Overrides Function VisitUserDefinedConversion(node As BoundUserDefinedConversion) As BoundNode
            Dim underlyingExpression As BoundExpression = DirectCast(Me.Visit(node.UnderlyingExpression), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(underlyingExpression, type)
        End Function

        Public Overrides Function VisitDirectCast(node As BoundDirectCast) As BoundNode
            Dim operand As BoundExpression = DirectCast(Me.Visit(node.Operand), BoundExpression)
            Dim relaxationLambdaOpt As BoundLambda = DirectCast(Me.Visit(node.RelaxationLambdaOpt), BoundLambda)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(operand, node.ConversionKind, node.ConstantValueOpt, relaxationLambdaOpt, type)
        End Function

        Public Overrides Function VisitTryCast(node As BoundTryCast) As BoundNode
            Dim operand As BoundExpression = DirectCast(Me.Visit(node.Operand), BoundExpression)
            Dim relaxationLambdaOpt As BoundLambda = DirectCast(Me.Visit(node.RelaxationLambdaOpt), BoundLambda)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(operand, node.ConversionKind, node.ConstantValueOpt, relaxationLambdaOpt, type)
        End Function

        Public Overrides Function VisitTypeOf(node As BoundTypeOf) As BoundNode
            Dim operand As BoundExpression = DirectCast(Me.Visit(node.Operand), BoundExpression)
            Dim targetType as TypeSymbol = Me.VisitType(node.TargetType)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(operand, node.IsTypeOfIsNotExpression, targetType, type)
        End Function

        Public Overrides Function VisitSequencePoint(node As BoundSequencePoint) As BoundNode
            Dim statementOpt As BoundStatement = DirectCast(Me.Visit(node.StatementOpt), BoundStatement)
            Return node.Update(statementOpt)
        End Function

        Public Overrides Function VisitSequencePointExpression(node As BoundSequencePointExpression) As BoundNode
            Dim expression As BoundExpression = DirectCast(Me.Visit(node.Expression), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(expression, type)
        End Function

        Public Overrides Function VisitSequencePointWithSpan(node As BoundSequencePointWithSpan) As BoundNode
            Dim statementOpt As BoundStatement = DirectCast(Me.Visit(node.StatementOpt), BoundStatement)
            Return node.Update(statementOpt, node.SequenceSpan)
        End Function

        Public Overrides Function VisitNoOpStatement(node As BoundNoOpStatement) As BoundNode
            Return node
        End Function

        Public Overrides Function VisitMethodGroup(node As BoundMethodGroup) As BoundNode
            Dim typeArgumentsOpt As BoundTypeArguments = DirectCast(Me.Visit(node.TypeArgumentsOpt), BoundTypeArguments)
            Dim receiverOpt As BoundExpression = DirectCast(Me.Visit(node.ReceiverOpt), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(typeArgumentsOpt, node.Methods, node.PendingExtensionMethodsOpt, node.ResultKind, receiverOpt, node.QualificationKind)
        End Function

        Public Overrides Function VisitPropertyGroup(node As BoundPropertyGroup) As BoundNode
            Dim receiverOpt As BoundExpression = DirectCast(Me.Visit(node.ReceiverOpt), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.Properties, node.ResultKind, receiverOpt, node.QualificationKind)
        End Function

        Public Overrides Function VisitReturnStatement(node As BoundReturnStatement) As BoundNode
            Dim expressionOpt As BoundExpression = DirectCast(Me.Visit(node.ExpressionOpt), BoundExpression)
            Return node.Update(expressionOpt, node.FunctionLocalOpt, node.ExitLabelOpt)
        End Function

        Public Overrides Function VisitThrowStatement(node As BoundThrowStatement) As BoundNode
            Dim expressionOpt As BoundExpression = DirectCast(Me.Visit(node.ExpressionOpt), BoundExpression)
            Return node.Update(expressionOpt)
        End Function

        Public Overrides Function VisitRedimStatement(node As BoundRedimStatement) As BoundNode
            Dim clauses As ReadOnlyArray(Of BoundRedimClause) = Me.VisitList(node.Clauses)
            Return node.Update(clauses)
        End Function

        Public Overrides Function VisitRedimClause(node As BoundRedimClause) As BoundNode
            Dim operand As BoundExpression = DirectCast(Me.Visit(node.Operand), BoundExpression)
            Dim indices As ReadOnlyArray(Of BoundExpression) = Me.VisitList(node.Indices)
            Return node.Update(operand, indices, node.ArrayTypeOpt, node.CopyArrayUtilityMethodOpt)
        End Function

        Public Overrides Function VisitCall(node As BoundCall) As BoundNode
            Dim methodGroupOpt As BoundMethodGroup = node.MethodGroupOpt
            Dim receiverOpt As BoundExpression = DirectCast(Me.Visit(node.ReceiverOpt), BoundExpression)
            Dim arguments As ReadOnlyArray(of BoundExpression) = Me.VisitList(node.Arguments)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.Method, methodGroupOpt, receiverOpt, arguments, node.ConstantValueOpt, node.SuppressObjectClone, type)
        End Function

        Public Overrides Function VisitAttribute(node As BoundAttribute) As BoundNode
            Dim constructorArguments As ReadOnlyArray(of BoundExpression) = Me.VisitList(node.ConstructorArguments)
            Dim namedArguments As ReadOnlyArray(Of BoundExpression) = Me.VisitList(node.NamedArguments)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.Constructor, constructorArguments, namedArguments, node.ResultKind, type)
        End Function

        Public Overrides Function VisitLateCall(node As BoundLateCall) As BoundNode
            Dim receiver As BoundExpression = DirectCast(Me.Visit(node.Receiver), BoundExpression)
            Dim originalMethodGroupOpt As BoundMethodGroup = DirectCast(Me.Visit(node.OriginalMethodGroupOpt), BoundMethodGroup)
            Dim arguments As ReadOnlyArray(of BoundExpression) = Me.VisitList(node.Arguments)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(receiver, node.MethodName, originalMethodGroupOpt, arguments, node.ArgumentNames, type)
        End Function

        Public Overrides Function VisitObjectCreationExpression(node As BoundObjectCreationExpression) As BoundNode
            Dim arguments As ReadOnlyArray(of BoundExpression) = Me.VisitList(node.Arguments)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.ConstructorOpt, arguments, type)
        End Function

        Public Overrides Function VisitAnonymousTypeCreationExpression(node As BoundAnonymousTypeCreationExpression) As BoundNode
            Dim declarations As ReadOnlyArray(of BoundAnonymousTypePropertyAccess) = Me.VisitList(node.Declarations)
            Dim arguments As ReadOnlyArray(of BoundExpression) = Me.VisitList(node.Arguments)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.BinderOpt, declarations, arguments, type)
        End Function

        Public Overrides Function VisitAnonymousTypePropertyAccess(node As BoundAnonymousTypePropertyAccess) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.Binder, node.PropertyIndex, type)
        End Function

        Public Overrides Function VisitAnonymousTypeFieldInitializer(node As BoundAnonymousTypeFieldInitializer) As BoundNode
            Dim value As BoundExpression = DirectCast(Me.Visit(node.Value), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.Binder, value, type)
        End Function

        Public Overrides Function VisitNewT(node As BoundNewT) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(type)
        End Function

        Public Overrides Function VisitDelegateCreationExpression(node As BoundDelegateCreationExpression) As BoundNode
            Dim receiverOpt As BoundExpression = DirectCast(Me.Visit(node.ReceiverOpt), BoundExpression)
            Dim relaxationLambdaOpt As BoundLambda = DirectCast(Me.Visit(node.RelaxationLambdaOpt), BoundLambda)
            Dim methodGroupOpt As BoundMethodGroup = node.MethodGroupOpt
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(receiverOpt, node.Method, relaxationLambdaOpt, node.RelaxationReceiverTempOpt, methodGroupOpt, type)
        End Function

        Public Overrides Function VisitArrayCreation(node As BoundArrayCreation) As BoundNode
            Dim bounds As ReadOnlyArray(Of BoundExpression) = Me.VisitList(node.Bounds)
            Dim initializerOpt As BoundArrayInitialization = DirectCast(Me.Visit(node.InitializerOpt), BoundArrayInitialization)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.IsParamArrayArgument, bounds, initializerOpt, type)
        End Function

        Public Overrides Function VisitArrayInitialization(node As BoundArrayInitialization) As BoundNode
            Dim initializers As ReadOnlyArray(Of BoundExpression) = Me.VisitList(node.Initializers)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(initializers, type)
        End Function

        Public Overrides Function VisitFieldAccess(node As BoundFieldAccess) As BoundNode
            Dim receiverOpt As BoundExpression = DirectCast(Me.Visit(node.ReceiverOpt), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(receiverOpt, node.FieldSymbol, node.IsLValue, node.ConstantsInProgressOpt, type)
        End Function

        Public Overrides Function VisitPropertyAccess(node As BoundPropertyAccess) As BoundNode
            Dim propertyGroupOpt As BoundPropertyGroup = node.PropertyGroupOpt
            Dim receiverOpt As BoundExpression = DirectCast(Me.Visit(node.ReceiverOpt), BoundExpression)
            Dim arguments As ReadOnlyArray(of BoundExpression) = Me.VisitList(node.Arguments)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.PropertySymbol, propertyGroupOpt, node.AccessKind, receiverOpt, arguments, type)
        End Function

        Public Overrides Function VisitEventAccess(node As BoundEventAccess) As BoundNode
            Dim receiverOpt As BoundExpression = DirectCast(Me.Visit(node.ReceiverOpt), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(receiverOpt, node.EventSymbol, type)
        End Function

        Public Overrides Function VisitBlock(node As BoundBlock) As BoundNode
            Dim statements As ReadOnlyArray(Of BoundStatement) = Me.VisitList(node.Statements)
            Return node.Update(node.StatementListSyntax, node.LocalsOpt, statements)
        End Function

        Public Overrides Function VisitLocalDeclaration(node As BoundLocalDeclaration) As BoundNode
            Dim initializerOpt As BoundExpression = DirectCast(Me.Visit(node.InitializerOpt), BoundExpression)
            Return node.Update(node.LocalSymbol, initializerOpt, node.InitializedByAsNew)
        End Function

        Public Overrides Function VisitAsNewLocalDeclarations(node As BoundAsNewLocalDeclarations) As BoundNode
            Dim localDeclarations As ReadOnlyArray(of BoundLocalDeclaration) = Me.VisitList(node.LocalDeclarations)
            Dim initializer As BoundExpression = DirectCast(Me.Visit(node.Initializer), BoundExpression)
            Return node.Update(localDeclarations, initializer)
        End Function

        Public Overrides Function VisitDimStatement(node As BoundDimStatement) As BoundNode
            Dim localDeclarations As ReadOnlyArray(of BoundLocalDeclarationBase) = Me.VisitList(node.LocalDeclarations)
            Dim initializerOpt As BoundExpression = DirectCast(Me.Visit(node.InitializerOpt), BoundExpression)
            Return node.Update(localDeclarations, initializerOpt)
        End Function

        Public Overrides Function VisitInitializer(node As BoundInitializer) As BoundNode
            Return node
        End Function

        Public Overrides Function VisitFieldOrPropertyInitializer(node As BoundFieldOrPropertyInitializer) As BoundNode
            Dim fieldOrProperty As BoundExpression = DirectCast(Me.Visit(node.FieldOrProperty), BoundExpression)
            Dim initialValue As BoundExpression = DirectCast(Me.Visit(node.InitialValue), BoundExpression)
            Return node.Update(fieldOrProperty, initialValue)
        End Function

        Public Overrides Function VisitGlobalStatementInitializer(node As BoundGlobalStatementInitializer) As BoundNode
            Dim statement As BoundStatement = DirectCast(Me.Visit(node.Statement), BoundStatement)
            Return node.Update(statement)
        End Function

        Public Overrides Function VisitSequence(node As BoundSequence) As BoundNode
            Dim sideEffects As ReadOnlyArray(Of BoundExpression) = Me.VisitList(node.SideEffects)
            Dim valueOpt As BoundExpression = DirectCast(Me.Visit(node.ValueOpt), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.LocalsOpt, sideEffects, valueOpt, type)
        End Function

        Public Overrides Function VisitExpressionStatement(node As BoundExpressionStatement) As BoundNode
            Dim expression As BoundExpression = DirectCast(Me.Visit(node.Expression), BoundExpression)
            Return node.Update(expression)
        End Function

        Public Overrides Function VisitIfStatement(node As BoundIfStatement) As BoundNode
            Dim condition As BoundExpression = DirectCast(Me.Visit(node.Condition), BoundExpression)
            Dim consequence As BoundStatement = DirectCast(Me.Visit(node.Consequence), BoundStatement)
            Dim alternativeOpt As BoundStatement = DirectCast(Me.Visit(node.AlternativeOpt), BoundStatement)
            Return node.Update(condition, consequence, alternativeOpt)
        End Function

        Public Overrides Function VisitSelectStatement(node As BoundSelectStatement) As BoundNode
            Dim expressionStatement As BoundExpressionStatement = DirectCast(Me.Visit(node.ExpressionStatement), BoundExpressionStatement)
            Dim exprPlaceholderOpt As BoundValuePlaceholder = DirectCast(Me.Visit(node.ExprPlaceholderOpt), BoundValuePlaceholder)
            Dim caseBlocks As ReadOnlyArray(Of BoundCaseBlock) = Me.VisitList(node.CaseBlocks)
            Return node.Update(expressionStatement, exprPlaceholderOpt, caseBlocks, node.RecommendSwitchTable, node.ExitLabel)
        End Function

        Public Overrides Function VisitCaseBlock(node As BoundCaseBlock) As BoundNode
            Dim caseStatement As BoundCaseStatement = DirectCast(Me.Visit(node.CaseStatement), BoundCaseStatement)
            Dim body As BoundBlock = DirectCast(Me.Visit(node.Body), BoundBlock)
            Return node.Update(caseStatement, body)
        End Function

        Public Overrides Function VisitCaseStatement(node As BoundCaseStatement) As BoundNode
            Dim caseClauses As ReadOnlyArray(Of BoundCaseClause) = Me.VisitList(node.CaseClauses)
            Dim conditionOpt As BoundExpression = DirectCast(Me.Visit(node.ConditionOpt), BoundExpression)
            Return node.Update(caseClauses, conditionOpt)
        End Function

        Public Overrides Function VisitCaseValueClause(node As BoundCaseValueClause) As BoundNode
            Dim valueOpt As BoundExpression = DirectCast(Me.Visit(node.ValueOpt), BoundExpression)
            Dim conditionOpt As BoundExpression = DirectCast(Me.Visit(node.ConditionOpt), BoundExpression)
            Return node.Update(valueOpt, conditionOpt)
        End Function

        Public Overrides Function VisitCaseRangeClause(node As BoundCaseRangeClause) As BoundNode
            Dim lowerBoundOpt As BoundExpression = DirectCast(Me.Visit(node.LowerBoundOpt), BoundExpression)
            Dim upperBoundOpt As BoundExpression = DirectCast(Me.Visit(node.UpperBoundOpt), BoundExpression)
            Dim lowerBoundConditionOpt As BoundExpression = DirectCast(Me.Visit(node.LowerBoundConditionOpt), BoundExpression)
            Dim upperBoundConditionOpt As BoundExpression = DirectCast(Me.Visit(node.UpperBoundConditionOpt), BoundExpression)
            Return node.Update(lowerBoundOpt, upperBoundOpt, lowerBoundConditionOpt, upperBoundConditionOpt)
        End Function

        Public Overrides Function VisitCaseRelationalClause(node As BoundCaseRelationalClause) As BoundNode
            Dim operandOpt As BoundExpression = DirectCast(Me.Visit(node.OperandOpt), BoundExpression)
            Dim conditionOpt As BoundExpression = DirectCast(Me.Visit(node.ConditionOpt), BoundExpression)
            Return node.Update(node.OperatorKind, operandOpt, conditionOpt)
        End Function

        Public Overrides Function VisitDoLoopStatement(node As BoundDoLoopStatement) As BoundNode
            Dim topConditionOpt As BoundExpression = DirectCast(Me.Visit(node.TopConditionOpt), BoundExpression)
            Dim bottomConditionOpt As BoundExpression = DirectCast(Me.Visit(node.BottomConditionOpt), BoundExpression)
            Dim body As BoundStatement = DirectCast(Me.Visit(node.Body), BoundStatement)
            Return node.Update(topConditionOpt, bottomConditionOpt, node.TopConditionIsUntil, node.BottomConditionIsUntil, body, node.ContinueLabel, node.ExitLabel)
        End Function

        Public Overrides Function VisitWhileStatement(node As BoundWhileStatement) As BoundNode
            Dim condition As BoundExpression = DirectCast(Me.Visit(node.Condition), BoundExpression)
            Dim body As BoundStatement = DirectCast(Me.Visit(node.Body), BoundStatement)
            Return node.Update(condition, body, node.ContinueLabel, node.ExitLabel)
        End Function

        Public Overrides Function VisitForToStatement(node As BoundForToStatement) As BoundNode
            Dim initialValue As BoundExpression = DirectCast(Me.Visit(node.InitialValue), BoundExpression)
            Dim limitValue As BoundExpression = DirectCast(Me.Visit(node.LimitValue), BoundExpression)
            Dim stepValue As BoundExpression = DirectCast(Me.Visit(node.StepValue), BoundExpression)
            Dim controlVariable As BoundExpression = DirectCast(Me.Visit(node.ControlVariable), BoundExpression)
            Dim body As BoundStatement = DirectCast(Me.Visit(node.Body), BoundStatement)
            Dim nextVariablesOpt As ReadOnlyArray(Of BoundExpression) = Me.VisitList(node.NextVariablesOpt)
            Return node.Update(initialValue, limitValue, stepValue, node.Checked, node.DeclaredOrInferredLocalOpt, controlVariable, body, nextVariablesOpt, node.ContinueLabel, node.ExitLabel)
        End Function

        Public Overrides Function VisitForEachStatement(node As BoundForEachStatement) As BoundNode
            Dim collection As BoundExpression = DirectCast(Me.Visit(node.Collection), BoundExpression)
            Dim controlVariable As BoundExpression = DirectCast(Me.Visit(node.ControlVariable), BoundExpression)
            Dim body As BoundStatement = DirectCast(Me.Visit(node.Body), BoundStatement)
            Dim nextVariablesOpt As ReadOnlyArray(Of BoundExpression) = Me.VisitList(node.NextVariablesOpt)
            Return node.Update(collection, node.EnumeratorInfo, node.DeclaredOrInferredLocalOpt, controlVariable, body, nextVariablesOpt, node.ContinueLabel, node.ExitLabel)
        End Function

        Public Overrides Function VisitExitStatement(node As BoundExitStatement) As BoundNode
            Return node
        End Function

        Public Overrides Function VisitContinueStatement(node As BoundContinueStatement) As BoundNode
            Return node
        End Function

        Public Overrides Function VisitTryStatement(node As BoundTryStatement) As BoundNode
            Dim tryBlock As BoundBlock = DirectCast(Me.Visit(node.TryBlock), BoundBlock)
            Dim catchBlocks As ReadOnlyArray(Of BoundCatchBlock) = Me.VisitList(node.CatchBlocks)
            Dim finallyBlockOpt As BoundBlock = DirectCast(Me.Visit(node.FinallyBlockOpt), BoundBlock)
            Return node.Update(tryBlock, catchBlocks, finallyBlockOpt, node.ExitLabelOpt)
        End Function

        Public Overrides Function VisitCatchBlock(node As BoundCatchBlock) As BoundNode
            Dim exceptionVariableOpt As BoundExpression = DirectCast(Me.Visit(node.ExceptionVariableOpt), BoundExpression)
            Dim exceptionFilterOpt As BoundExpression = DirectCast(Me.Visit(node.ExceptionFilterOpt), BoundExpression)
            Dim body As BoundBlock = DirectCast(Me.Visit(node.Body), BoundBlock)
            Return node.Update(node.LocalOpt, exceptionVariableOpt, exceptionFilterOpt, body)
        End Function

        Public Overrides Function VisitLiteral(node As BoundLiteral) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.Value, type)
        End Function

        Public Overrides Function VisitMeReference(node As BoundMeReference) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.MeSymbolOpt, type)
        End Function

        Public Overrides Function VisitMyBaseReference(node As BoundMyBaseReference) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.MeSymbolOpt, type)
        End Function

        Public Overrides Function VisitMyClassReference(node As BoundMyClassReference) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.MeSymbolOpt, type)
        End Function

        Public Overrides Function VisitPreviousSubmissionReference(node As BoundPreviousSubmissionReference) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.SourceType, type)
        End Function

        Public Overrides Function VisitHostObjectMemberReference(node As BoundHostObjectMemberReference) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(type)
        End Function

        Public Overrides Function VisitLocal(node As BoundLocal) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.LocalSymbol, node.IsLValue, type)
        End Function

        Public Overrides Function VisitParameter(node As BoundParameter) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.ParameterSymbol, node.IsLValue, type)
        End Function

        Public Overrides Function VisitByRefArgumentPlaceholder(node As BoundByRefArgumentPlaceholder) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.IsOut, type)
        End Function

        Public Overrides Function VisitByRefArgumentWithCopyBack(node As BoundByRefArgumentWithCopyBack) As BoundNode
            Dim originalArgument As BoundExpression = DirectCast(Me.Visit(node.OriginalArgument), BoundExpression)
            Dim inConversion As BoundExpression = DirectCast(Me.Visit(node.InConversion), BoundExpression)
            Dim inPlaceholder As BoundByRefArgumentPlaceholder = DirectCast(Me.Visit(node.InPlaceholder), BoundByRefArgumentPlaceholder)
            Dim outConversion As BoundExpression = DirectCast(Me.Visit(node.OutConversion), BoundExpression)
            Dim outPlaceholder As BoundValuePlaceholder = DirectCast(Me.Visit(node.OutPlaceholder), BoundValuePlaceholder)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(originalArgument, inConversion, inPlaceholder, outConversion, outPlaceholder, type)
        End Function

        Public Overrides Function VisitLabelStatement(node As BoundLabelStatement) As BoundNode
            Return node
        End Function

        Public Overrides Function VisitLabel(node As BoundLabel) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.Label, type)
        End Function

        Public Overrides Function VisitGotoStatement(node As BoundGotoStatement) As BoundNode
            Dim labelExpressionOpt As BoundLabel = DirectCast(Me.Visit(node.LabelExpressionOpt), BoundLabel)
            Return node.Update(node.Label, labelExpressionOpt)
        End Function

        Public Overrides Function VisitStatementList(node As BoundStatementList) As BoundNode
            Dim statements As ReadOnlyArray(Of BoundStatement) = Me.VisitList(node.Statements)
            Return node.Update(statements)
        End Function

        Public Overrides Function VisitConditionalGoto(node As BoundConditionalGoto) As BoundNode
            Dim condition As BoundExpression = DirectCast(Me.Visit(node.Condition), BoundExpression)
            Return node.Update(condition, node.JumpIfTrue, node.Label)
        End Function

        Public Overrides Function VisitWithStatement(node As BoundWithStatement) As BoundNode
            Dim originalExpression As BoundExpression = DirectCast(Me.Visit(node.OriginalExpression), BoundExpression)
            Dim body As BoundBlock = DirectCast(Me.Visit(node.Body), BoundBlock)
            Return node.Update(originalExpression, body, node.Binder)
        End Function

        Public Overrides Function VisitUnboundLambda(node As UnboundLambda) As BoundNode
            Dim returnType as TypeSymbol = Me.VisitType(node.ReturnType)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.Binder, node.Parameters, returnType, node.BindingCache)
        End Function

        Public Overrides Function VisitLambda(node As BoundLambda) As BoundNode
            Dim unboundLambdaOpt As UnboundLambda = node.UnboundLambdaOpt
            Dim body As BoundBlock = DirectCast(Me.Visit(node.Body), BoundBlock)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(unboundLambdaOpt, node.LambdaSymbol, body, node.DiagnosticsOpt, node.LambdaBinderOpt, node.DelegateRelaxation, node.MethodConversionKind)
        End Function

        Public Overrides Function VisitQueryExpression(node As BoundQueryExpression) As BoundNode
            Dim lastOperator As BoundQueryClauseBase = DirectCast(Me.Visit(node.LastOperator), BoundQueryClauseBase)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(lastOperator, type)
        End Function

        Public Overrides Function VisitQuerySource(node As BoundQuerySource) As BoundNode
            Dim expression As BoundExpression = DirectCast(Me.Visit(node.Expression), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(expression, type)
        End Function

        Public Overrides Function VisitToQueryableCollectionConversion(node As BoundToQueryableCollectionConversion) As BoundNode
            Dim conversionCall As BoundCall = DirectCast(Me.Visit(node.ConversionCall), BoundCall)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(conversionCall, type)
        End Function

        Public Overrides Function VisitQueryableSource(node As BoundQueryableSource) As BoundNode
            Dim source As BoundQueryPart = DirectCast(Me.Visit(node.Source), BoundQueryPart)
            Dim compoundVariableType as TypeSymbol = Me.VisitType(node.CompoundVariableType)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(source, node.RangeVariableOpt, node.RangeVariables, compoundVariableType, node.Binders, type)
        End Function

        Public Overrides Function VisitQueryClause(node As BoundQueryClause) As BoundNode
            Dim underlyingExpression As BoundExpression = DirectCast(Me.Visit(node.UnderlyingExpression), BoundExpression)
            Dim compoundVariableType as TypeSymbol = Me.VisitType(node.CompoundVariableType)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(underlyingExpression, node.RangeVariables, compoundVariableType, node.Binders, type)
        End Function

        Public Overrides Function VisitOrdering(node As BoundOrdering) As BoundNode
            Dim underlyingExpression As BoundExpression = DirectCast(Me.Visit(node.UnderlyingExpression), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(underlyingExpression, type)
        End Function

        Public Overrides Function VisitQueryLambda(node As BoundQueryLambda) As BoundNode
            Dim expression As BoundExpression = DirectCast(Me.Visit(node.Expression), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.LambdaSymbol, node.RangeVariables, expression, node.ExprIsOperandOfConditionalBranch, type)
        End Function

        Public Overrides Function VisitRangeVariableAssignment(node As BoundRangeVariableAssignment) As BoundNode
            Dim value As BoundExpression = DirectCast(Me.Visit(node.Value), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.RangeVariable, value, type)
        End Function

        Public Overrides Function VisitGroupTypeInferenceLambda(node As GroupTypeInferenceLambda) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.Binder, node.Parameters, node.Compilation)
        End Function

        Public Overrides Function VisitAggregateClause(node As BoundAggregateClause) As BoundNode
            Dim capturedGroupOpt As BoundQueryClauseBase = DirectCast(Me.Visit(node.CapturedGroupOpt), BoundQueryClauseBase)
            Dim groupPlaceholderOpt As BoundValuePlaceholder = DirectCast(Me.Visit(node.GroupPlaceholderOpt), BoundValuePlaceholder)
            Dim underlyingExpression As BoundExpression = DirectCast(Me.Visit(node.UnderlyingExpression), BoundExpression)
            Dim compoundVariableType as TypeSymbol = Me.VisitType(node.CompoundVariableType)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(capturedGroupOpt, groupPlaceholderOpt, underlyingExpression, node.RangeVariables, compoundVariableType, node.Binders, type)
        End Function

        Public Overrides Function VisitGroupAggregation(node As BoundGroupAggregation) As BoundNode
            Dim group As BoundExpression = DirectCast(Me.Visit(node.Group), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(group, type)
        End Function

        Public Overrides Function VisitRangeVariable(node As BoundRangeVariable) As BoundNode
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(node.RangeVariable, type)
        End Function

        Public Overrides Function VisitAddHandlerStatement(node As BoundAddHandlerStatement) As BoundNode
            Dim eventAccess As BoundExpression = DirectCast(Me.Visit(node.EventAccess), BoundExpression)
            Dim handler As BoundExpression = DirectCast(Me.Visit(node.Handler), BoundExpression)
            Return node.Update(eventAccess, handler)
        End Function

        Public Overrides Function VisitRemoveHandlerStatement(node As BoundRemoveHandlerStatement) As BoundNode
            Dim eventAccess As BoundExpression = DirectCast(Me.Visit(node.EventAccess), BoundExpression)
            Dim handler As BoundExpression = DirectCast(Me.Visit(node.Handler), BoundExpression)
            Return node.Update(eventAccess, handler)
        End Function

        Public Overrides Function VisitRaiseEventStatement(node As BoundRaiseEventStatement) As BoundNode
            Dim eventInvocation As BoundExpression = DirectCast(Me.Visit(node.EventInvocation), BoundExpression)
            Return node.Update(node.EventSymbol, eventInvocation)
        End Function

        Public Overrides Function VisitUsingStatement(node As BoundUsingStatement) As BoundNode
            Dim resourceList As ReadOnlyArray(Of BoundLocalDeclarationBase) = Me.VisitList(node.ResourceList)
            Dim resourceExpressionOpt As BoundExpression = DirectCast(Me.Visit(node.ResourceExpressionOpt), BoundExpression)
            Dim body As BoundBlock = DirectCast(Me.Visit(node.Body), BoundBlock)
            Return node.Update(resourceList, resourceExpressionOpt, body, node.UsingInfo)
        End Function

        Public Overrides Function VisitSyncLockStatement(node As BoundSyncLockStatement) As BoundNode
            Dim lockExpression As BoundExpression = DirectCast(Me.Visit(node.LockExpression), BoundExpression)
            Dim body As BoundBlock = DirectCast(Me.Visit(node.Body), BoundBlock)
            Return node.Update(lockExpression, body, node.ExpressionTypeWasTypeParameter)
        End Function

        Public Overrides Function VisitXmlName(node As BoundXmlName) As BoundNode
            Dim xmlNamespace As BoundExpression = DirectCast(Me.Visit(node.XmlNamespace), BoundExpression)
            Dim localName As BoundExpression = DirectCast(Me.Visit(node.LocalName), BoundExpression)
            Dim objectCreation As BoundExpression = node.ObjectCreation
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(xmlNamespace, localName, objectCreation, type)
        End Function

        Public Overrides Function VisitXmlDocument(node As BoundXmlDocument) As BoundNode
            Dim declaration As BoundExpression = DirectCast(Me.Visit(node.Declaration), BoundExpression)
            Dim childNodes As ReadOnlyArray(of BoundExpression) = Me.VisitList(node.ChildNodes)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(declaration, childNodes, node.RewriterInfo, type)
        End Function

        Public Overrides Function VisitXmlDeclaration(node As BoundXmlDeclaration) As BoundNode
            Dim version As BoundExpression = DirectCast(Me.Visit(node.Version), BoundExpression)
            Dim encoding As BoundExpression = DirectCast(Me.Visit(node.Encoding), BoundExpression)
            Dim standalone As BoundExpression = DirectCast(Me.Visit(node.Standalone), BoundExpression)
            Dim objectCreation As BoundExpression = node.ObjectCreation
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(version, encoding, standalone, objectCreation, type)
        End Function

        Public Overrides Function VisitXmlProcessingInstruction(node As BoundXmlProcessingInstruction) As BoundNode
            Dim target As BoundExpression = DirectCast(Me.Visit(node.Target), BoundExpression)
            Dim data As BoundExpression = DirectCast(Me.Visit(node.Data), BoundExpression)
            Dim objectCreation As BoundExpression = node.ObjectCreation
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(target, data, objectCreation, type)
        End Function

        Public Overrides Function VisitXmlComment(node As BoundXmlComment) As BoundNode
            Dim value As BoundExpression = DirectCast(Me.Visit(node.Value), BoundExpression)
            Dim objectCreation As BoundExpression = node.ObjectCreation
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(value, objectCreation, type)
        End Function

        Public Overrides Function VisitXmlAttribute(node As BoundXmlAttribute) As BoundNode
            Dim name As BoundExpression = DirectCast(Me.Visit(node.Name), BoundExpression)
            Dim value As BoundExpression = DirectCast(Me.Visit(node.Value), BoundExpression)
            Dim objectCreation As BoundExpression = node.ObjectCreation
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(name, value, objectCreation, type)
        End Function

        Public Overrides Function VisitXmlElement(node As BoundXmlElement) As BoundNode
            Dim argument As BoundExpression = DirectCast(Me.Visit(node.Argument), BoundExpression)
            Dim childNodes As ReadOnlyArray(of BoundExpression) = Me.VisitList(node.ChildNodes)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(argument, childNodes, node.RewriterInfo, type)
        End Function

        Public Overrides Function VisitXmlMemberAccess(node As BoundXmlMemberAccess) As BoundNode
            Dim receiver As BoundExpression = DirectCast(Me.Visit(node.Receiver), BoundExpression)
            Dim name As BoundExpression = DirectCast(Me.Visit(node.Name), BoundExpression)
            Dim memberAccess As BoundExpression = node.MemberAccess
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(receiver, name, memberAccess, type)
        End Function

        Public Overrides Function VisitXmlEmbeddedExpression(node As BoundXmlEmbeddedExpression) As BoundNode
            Dim expression As BoundExpression = DirectCast(Me.Visit(node.Expression), BoundExpression)
            Dim type as TypeSymbol = Me.VisitType(node.Type)
            Return node.Update(expression, type)
        End Function

    End Class

    <System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage()>
    Friend NotInheritable Class BoundTreeDumperNodeProducer
        Inherits BoundTreeVisitor(Of Object, TreeDumperNode)

        Private Sub New()
        End Sub

        Public Shared Function MakeTree(node As BoundNode) As TreeDumperNode
            Return (New BoundTreeDumperNodeProducer()).Visit(node, Nothing)
        End Function

        Public Overrides Function VisitTypeArguments(node As BoundTypeArguments, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("typeArguments", Nothing, New TreeDumperNode() {
                New TreeDumperNode("arguments", node.Arguments, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitOmittedArgument(node As BoundOmittedArgument, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("omittedArgument", Nothing, New TreeDumperNode() {
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitLValuePlaceholderRValueWrapper(node As BoundLValuePlaceholderRValueWrapper, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("lValuePlaceholderRValueWrapper", Nothing, New TreeDumperNode() {
                New TreeDumperNode("placeholder", Nothing, new TreeDumperNode() { Visit(node.Placeholder, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitWithLValueExpressionPlaceholder(node As BoundWithLValueExpressionPlaceholder, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("withLValueExpressionPlaceholder", Nothing, New TreeDumperNode() {
                New TreeDumperNode("draftSubstitutor", Nothing, new TreeDumperNode() { Visit(node.DraftSubstitutor, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitWithRValueExpressionPlaceholder(node As BoundWithRValueExpressionPlaceholder, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("withRValueExpressionPlaceholder", Nothing, New TreeDumperNode() {
                New TreeDumperNode("draftSubstitutor", Nothing, new TreeDumperNode() { Visit(node.DraftSubstitutor, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitValuePlaceholder(node As BoundValuePlaceholder, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("valuePlaceholder", Nothing, New TreeDumperNode() {
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitBadExpression(node As BoundBadExpression, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("badExpression", Nothing, New TreeDumperNode() {
                New TreeDumperNode("resultKind", node.ResultKind, Nothing),
                New TreeDumperNode("symbols", node.Symbols, Nothing),
                New TreeDumperNode("childBoundNodes", Nothing, From x In node.ChildBoundNodes Select Visit(x, Nothing)),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitBadStatement(node As BoundBadStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("badStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("childBoundNodes", Nothing, From x In node.ChildBoundNodes Select Visit(x, Nothing))
            })
        End Function

        Public Overrides Function VisitParenthesized(node As BoundParenthesized, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("parenthesized", Nothing, New TreeDumperNode() {
                New TreeDumperNode("expression", Nothing, new TreeDumperNode() { Visit(node.Expression, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitBadVariable(node As BoundBadVariable, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("badVariable", Nothing, New TreeDumperNode() {
                New TreeDumperNode("expression", Nothing, new TreeDumperNode() { Visit(node.Expression, Nothing) }),
                New TreeDumperNode("isLValue", node.IsLValue, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitArrayAccess(node As BoundArrayAccess, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("arrayAccess", Nothing, New TreeDumperNode() {
                New TreeDumperNode("expression", Nothing, new TreeDumperNode() { Visit(node.Expression, Nothing) }),
                New TreeDumperNode("indices", Nothing, From x In node.Indices Select Visit(x, Nothing)),
                New TreeDumperNode("isLValue", node.IsLValue, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitArrayLength(node As BoundArrayLength, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("arrayLength", Nothing, New TreeDumperNode() {
                New TreeDumperNode("expression", Nothing, new TreeDumperNode() { Visit(node.Expression, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitGetType(node As BoundGetType, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("[getType]", Nothing, New TreeDumperNode() {
                New TreeDumperNode("sourceType", Nothing, new TreeDumperNode() { Visit(node.SourceType, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitTypeExpression(node As BoundTypeExpression, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("typeExpression", Nothing, New TreeDumperNode() {
                New TreeDumperNode("aliasOpt", node.AliasOpt, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitTypeOrValueExpression(node As BoundTypeOrValueExpression, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("typeOrValueExpression", Nothing, New TreeDumperNode() {
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitNamespaceExpression(node As BoundNamespaceExpression, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("namespaceExpression", Nothing, New TreeDumperNode() {
                New TreeDumperNode("aliasOpt", node.AliasOpt, Nothing),
                New TreeDumperNode("namespaceSymbol", node.NamespaceSymbol, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitUnaryOperator(node As BoundUnaryOperator, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("unaryOperator", Nothing, New TreeDumperNode() {
                New TreeDumperNode("operatorKind", node.OperatorKind, Nothing),
                New TreeDumperNode("operand", Nothing, new TreeDumperNode() { Visit(node.Operand, Nothing) }),
                New TreeDumperNode("checked", node.Checked, Nothing),
                New TreeDumperNode("constantValueOpt", node.ConstantValueOpt, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitUserDefinedUnaryOperator(node As BoundUserDefinedUnaryOperator, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("userDefinedUnaryOperator", Nothing, New TreeDumperNode() {
                New TreeDumperNode("operatorKind", node.OperatorKind, Nothing),
                New TreeDumperNode("underlyingExpression", Nothing, new TreeDumperNode() { Visit(node.UnderlyingExpression, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitNullableIsTrueOperator(node As BoundNullableIsTrueOperator, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("nullableIsTrueOperator", Nothing, New TreeDumperNode() {
                New TreeDumperNode("operand", Nothing, new TreeDumperNode() { Visit(node.Operand, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitBinaryOperator(node As BoundBinaryOperator, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("binaryOperator", Nothing, New TreeDumperNode() {
                New TreeDumperNode("operatorKind", node.OperatorKind, Nothing),
                New TreeDumperNode("left", Nothing, new TreeDumperNode() { Visit(node.Left, Nothing) }),
                New TreeDumperNode("right", Nothing, new TreeDumperNode() { Visit(node.Right, Nothing) }),
                New TreeDumperNode("checked", node.Checked, Nothing),
                New TreeDumperNode("constantValueOpt", node.ConstantValueOpt, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitCompoundAssignmentTargetPlaceholder(node As BoundCompoundAssignmentTargetPlaceholder, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("compoundAssignmentTargetPlaceholder", Nothing, New TreeDumperNode() {
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitAssignmentOperator(node As BoundAssignmentOperator, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("assignmentOperator", Nothing, New TreeDumperNode() {
                New TreeDumperNode("left", Nothing, new TreeDumperNode() { Visit(node.Left, Nothing) }),
                New TreeDumperNode("leftOnTheRightOpt", Nothing, new TreeDumperNode() { Visit(node.LeftOnTheRightOpt, Nothing) }),
                New TreeDumperNode("right", Nothing, new TreeDumperNode() { Visit(node.Right, Nothing) }),
                New TreeDumperNode("suppressObjectClone", node.SuppressObjectClone, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitReferenceAssignment(node As BoundReferenceAssignment, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("referenceAssignment", Nothing, New TreeDumperNode() {
                New TreeDumperNode("byRefLocal", Nothing, new TreeDumperNode() { Visit(node.ByRefLocal, Nothing) }),
                New TreeDumperNode("lValue", Nothing, new TreeDumperNode() { Visit(node.LValue, Nothing) }),
                New TreeDumperNode("isLValue", node.IsLValue, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitAddressOfOperator(node As BoundAddressOfOperator, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("addressOfOperator", Nothing, New TreeDumperNode() {
                New TreeDumperNode("binder", node.Binder, Nothing),
                New TreeDumperNode("methodGroup", Nothing, new TreeDumperNode() { Visit(node.MethodGroup, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitTernaryConditionalExpression(node As BoundTernaryConditionalExpression, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("ternaryConditionalExpression", Nothing, New TreeDumperNode() {
                New TreeDumperNode("condition", Nothing, new TreeDumperNode() { Visit(node.Condition, Nothing) }),
                New TreeDumperNode("whenTrue", Nothing, new TreeDumperNode() { Visit(node.WhenTrue, Nothing) }),
                New TreeDumperNode("whenFalse", Nothing, new TreeDumperNode() { Visit(node.WhenFalse, Nothing) }),
                New TreeDumperNode("constantValueOpt", node.ConstantValueOpt, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitBinaryConditionalExpression(node As BoundBinaryConditionalExpression, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("binaryConditionalExpression", Nothing, New TreeDumperNode() {
                New TreeDumperNode("testExpression", Nothing, new TreeDumperNode() { Visit(node.TestExpression, Nothing) }),
                New TreeDumperNode("convertedTestExpression", Nothing, new TreeDumperNode() { Visit(node.ConvertedTestExpression, Nothing) }),
                New TreeDumperNode("testExpressionPlaceholder", Nothing, new TreeDumperNode() { Visit(node.TestExpressionPlaceholder, Nothing) }),
                New TreeDumperNode("elseExpression", Nothing, new TreeDumperNode() { Visit(node.ElseExpression, Nothing) }),
                New TreeDumperNode("constantValueOpt", node.ConstantValueOpt, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitConversion(node As BoundConversion, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("conversion", Nothing, New TreeDumperNode() {
                New TreeDumperNode("operand", Nothing, new TreeDumperNode() { Visit(node.Operand, Nothing) }),
                New TreeDumperNode("conversionKind", node.ConversionKind, Nothing),
                New TreeDumperNode("checked", node.Checked, Nothing),
                New TreeDumperNode("explicitCastInCode", node.ExplicitCastInCode, Nothing),
                New TreeDumperNode("constantValueOpt", node.ConstantValueOpt, Nothing),
                New TreeDumperNode("constructorOpt", node.ConstructorOpt, Nothing),
                New TreeDumperNode("relaxationLambdaOpt", Nothing, new TreeDumperNode() { Visit(node.RelaxationLambdaOpt, Nothing) }),
                New TreeDumperNode("relaxationReceiverTempOpt", node.RelaxationReceiverTempOpt, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitUserDefinedConversion(node As BoundUserDefinedConversion, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("userDefinedConversion", Nothing, New TreeDumperNode() {
                New TreeDumperNode("underlyingExpression", Nothing, new TreeDumperNode() { Visit(node.UnderlyingExpression, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitDirectCast(node As BoundDirectCast, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("[directCast]", Nothing, New TreeDumperNode() {
                New TreeDumperNode("operand", Nothing, new TreeDumperNode() { Visit(node.Operand, Nothing) }),
                New TreeDumperNode("conversionKind", node.ConversionKind, Nothing),
                New TreeDumperNode("constantValueOpt", node.ConstantValueOpt, Nothing),
                New TreeDumperNode("relaxationLambdaOpt", Nothing, new TreeDumperNode() { Visit(node.RelaxationLambdaOpt, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitTryCast(node As BoundTryCast, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("[tryCast]", Nothing, New TreeDumperNode() {
                New TreeDumperNode("operand", Nothing, new TreeDumperNode() { Visit(node.Operand, Nothing) }),
                New TreeDumperNode("conversionKind", node.ConversionKind, Nothing),
                New TreeDumperNode("constantValueOpt", node.ConstantValueOpt, Nothing),
                New TreeDumperNode("relaxationLambdaOpt", Nothing, new TreeDumperNode() { Visit(node.RelaxationLambdaOpt, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitTypeOf(node As BoundTypeOf, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("[typeOf]", Nothing, New TreeDumperNode() {
                New TreeDumperNode("operand", Nothing, new TreeDumperNode() { Visit(node.Operand, Nothing) }),
                New TreeDumperNode("isTypeOfIsNotExpression", node.IsTypeOfIsNotExpression, Nothing),
                New TreeDumperNode("targetType", node.TargetType, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitSequencePoint(node As BoundSequencePoint, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("sequencePoint", Nothing, New TreeDumperNode() {
                New TreeDumperNode("statementOpt", Nothing, new TreeDumperNode() { Visit(node.StatementOpt, Nothing) })
            })
        End Function

        Public Overrides Function VisitSequencePointExpression(node As BoundSequencePointExpression, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("sequencePointExpression", Nothing, New TreeDumperNode() {
                New TreeDumperNode("expression", Nothing, new TreeDumperNode() { Visit(node.Expression, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitSequencePointWithSpan(node As BoundSequencePointWithSpan, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("sequencePointWithSpan", Nothing, New TreeDumperNode() {
                New TreeDumperNode("statementOpt", Nothing, new TreeDumperNode() { Visit(node.StatementOpt, Nothing) }),
                New TreeDumperNode("sequenceSpan", node.SequenceSpan, Nothing)
            })
        End Function

        Public Overrides Function VisitNoOpStatement(node As BoundNoOpStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("noOpStatement", Nothing, New TreeDumperNode() {
            })
        End Function

        Public Overrides Function VisitMethodGroup(node As BoundMethodGroup, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("methodGroup", Nothing, New TreeDumperNode() {
                New TreeDumperNode("typeArgumentsOpt", Nothing, new TreeDumperNode() { Visit(node.TypeArgumentsOpt, Nothing) }),
                New TreeDumperNode("methods", node.Methods, Nothing),
                New TreeDumperNode("pendingExtensionMethodsOpt", node.PendingExtensionMethodsOpt, Nothing),
                New TreeDumperNode("resultKind", node.ResultKind, Nothing),
                New TreeDumperNode("receiverOpt", Nothing, new TreeDumperNode() { Visit(node.ReceiverOpt, Nothing) }),
                New TreeDumperNode("qualificationKind", node.QualificationKind, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitPropertyGroup(node As BoundPropertyGroup, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("propertyGroup", Nothing, New TreeDumperNode() {
                New TreeDumperNode("properties", node.Properties, Nothing),
                New TreeDumperNode("resultKind", node.ResultKind, Nothing),
                New TreeDumperNode("receiverOpt", Nothing, new TreeDumperNode() { Visit(node.ReceiverOpt, Nothing) }),
                New TreeDumperNode("qualificationKind", node.QualificationKind, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitReturnStatement(node As BoundReturnStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("returnStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("expressionOpt", Nothing, new TreeDumperNode() { Visit(node.ExpressionOpt, Nothing) }),
                New TreeDumperNode("functionLocalOpt", node.FunctionLocalOpt, Nothing),
                New TreeDumperNode("exitLabelOpt", node.ExitLabelOpt, Nothing)
            })
        End Function

        Public Overrides Function VisitThrowStatement(node As BoundThrowStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("throwStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("expressionOpt", Nothing, new TreeDumperNode() { Visit(node.ExpressionOpt, Nothing) })
            })
        End Function

        Public Overrides Function VisitRedimStatement(node As BoundRedimStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("redimStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("clauses", Nothing, From x In node.Clauses Select Visit(x, Nothing))
            })
        End Function

        Public Overrides Function VisitRedimClause(node As BoundRedimClause, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("redimClause", Nothing, New TreeDumperNode() {
                New TreeDumperNode("operand", Nothing, new TreeDumperNode() { Visit(node.Operand, Nothing) }),
                New TreeDumperNode("indices", Nothing, From x In node.Indices Select Visit(x, Nothing)),
                New TreeDumperNode("arrayTypeOpt", node.ArrayTypeOpt, Nothing),
                New TreeDumperNode("copyArrayUtilityMethodOpt", node.CopyArrayUtilityMethodOpt, Nothing)
            })
        End Function

        Public Overrides Function VisitCall(node As BoundCall, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("[call]", Nothing, New TreeDumperNode() {
                New TreeDumperNode("method", node.Method, Nothing),
                New TreeDumperNode("methodGroupOpt", Nothing, new TreeDumperNode() { Visit(node.MethodGroupOpt, Nothing) }),
                New TreeDumperNode("receiverOpt", Nothing, new TreeDumperNode() { Visit(node.ReceiverOpt, Nothing) }),
                New TreeDumperNode("arguments", Nothing, From x In node.Arguments Select Visit(x, Nothing)),
                New TreeDumperNode("constantValueOpt", node.ConstantValueOpt, Nothing),
                New TreeDumperNode("suppressObjectClone", node.SuppressObjectClone, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitAttribute(node As BoundAttribute, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("attribute", Nothing, New TreeDumperNode() {
                New TreeDumperNode("constructor", node.Constructor, Nothing),
                New TreeDumperNode("constructorArguments", Nothing, From x In node.ConstructorArguments Select Visit(x, Nothing)),
                New TreeDumperNode("namedArguments", Nothing, From x In node.NamedArguments Select Visit(x, Nothing)),
                New TreeDumperNode("resultKind", node.ResultKind, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitLateCall(node As BoundLateCall, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("lateCall", Nothing, New TreeDumperNode() {
                New TreeDumperNode("receiver", Nothing, new TreeDumperNode() { Visit(node.Receiver, Nothing) }),
                New TreeDumperNode("methodName", node.MethodName, Nothing),
                New TreeDumperNode("originalMethodGroupOpt", Nothing, new TreeDumperNode() { Visit(node.OriginalMethodGroupOpt, Nothing) }),
                New TreeDumperNode("arguments", Nothing, From x In node.Arguments Select Visit(x, Nothing)),
                New TreeDumperNode("argumentNames", node.ArgumentNames, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitObjectCreationExpression(node As BoundObjectCreationExpression, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("objectCreationExpression", Nothing, New TreeDumperNode() {
                New TreeDumperNode("constructorOpt", node.ConstructorOpt, Nothing),
                New TreeDumperNode("arguments", Nothing, From x In node.Arguments Select Visit(x, Nothing)),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitAnonymousTypeCreationExpression(node As BoundAnonymousTypeCreationExpression, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("anonymousTypeCreationExpression", Nothing, New TreeDumperNode() {
                New TreeDumperNode("binderOpt", node.BinderOpt, Nothing),
                New TreeDumperNode("declarations", Nothing, From x In node.Declarations Select Visit(x, Nothing)),
                New TreeDumperNode("arguments", Nothing, From x In node.Arguments Select Visit(x, Nothing)),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitAnonymousTypePropertyAccess(node As BoundAnonymousTypePropertyAccess, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("anonymousTypePropertyAccess", Nothing, New TreeDumperNode() {
                New TreeDumperNode("binder", node.Binder, Nothing),
                New TreeDumperNode("propertyIndex", node.PropertyIndex, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitAnonymousTypeFieldInitializer(node As BoundAnonymousTypeFieldInitializer, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("anonymousTypeFieldInitializer", Nothing, New TreeDumperNode() {
                New TreeDumperNode("binder", node.Binder, Nothing),
                New TreeDumperNode("value", Nothing, new TreeDumperNode() { Visit(node.Value, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitNewT(node As BoundNewT, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("newT", Nothing, New TreeDumperNode() {
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitDelegateCreationExpression(node As BoundDelegateCreationExpression, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("delegateCreationExpression", Nothing, New TreeDumperNode() {
                New TreeDumperNode("receiverOpt", Nothing, new TreeDumperNode() { Visit(node.ReceiverOpt, Nothing) }),
                New TreeDumperNode("method", node.Method, Nothing),
                New TreeDumperNode("relaxationLambdaOpt", Nothing, new TreeDumperNode() { Visit(node.RelaxationLambdaOpt, Nothing) }),
                New TreeDumperNode("relaxationReceiverTempOpt", node.RelaxationReceiverTempOpt, Nothing),
                New TreeDumperNode("methodGroupOpt", Nothing, new TreeDumperNode() { Visit(node.MethodGroupOpt, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitArrayCreation(node As BoundArrayCreation, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("arrayCreation", Nothing, New TreeDumperNode() {
                New TreeDumperNode("isParamArrayArgument", node.IsParamArrayArgument, Nothing),
                New TreeDumperNode("bounds", Nothing, From x In node.Bounds Select Visit(x, Nothing)),
                New TreeDumperNode("initializerOpt", Nothing, new TreeDumperNode() { Visit(node.InitializerOpt, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitArrayInitialization(node As BoundArrayInitialization, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("arrayInitialization", Nothing, New TreeDumperNode() {
                New TreeDumperNode("initializers", Nothing, From x In node.Initializers Select Visit(x, Nothing)),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitFieldAccess(node As BoundFieldAccess, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("fieldAccess", Nothing, New TreeDumperNode() {
                New TreeDumperNode("receiverOpt", Nothing, new TreeDumperNode() { Visit(node.ReceiverOpt, Nothing) }),
                New TreeDumperNode("fieldSymbol", node.FieldSymbol, Nothing),
                New TreeDumperNode("isLValue", node.IsLValue, Nothing),
                New TreeDumperNode("constantsInProgressOpt", node.ConstantsInProgressOpt, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitPropertyAccess(node As BoundPropertyAccess, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("propertyAccess", Nothing, New TreeDumperNode() {
                New TreeDumperNode("propertySymbol", node.PropertySymbol, Nothing),
                New TreeDumperNode("propertyGroupOpt", Nothing, new TreeDumperNode() { Visit(node.PropertyGroupOpt, Nothing) }),
                New TreeDumperNode("accessKind", node.AccessKind, Nothing),
                New TreeDumperNode("receiverOpt", Nothing, new TreeDumperNode() { Visit(node.ReceiverOpt, Nothing) }),
                New TreeDumperNode("arguments", Nothing, From x In node.Arguments Select Visit(x, Nothing)),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitEventAccess(node As BoundEventAccess, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("eventAccess", Nothing, New TreeDumperNode() {
                New TreeDumperNode("receiverOpt", Nothing, new TreeDumperNode() { Visit(node.ReceiverOpt, Nothing) }),
                New TreeDumperNode("eventSymbol", node.EventSymbol, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitBlock(node As BoundBlock, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("block", Nothing, New TreeDumperNode() {
                New TreeDumperNode("statementListSyntax", node.StatementListSyntax, Nothing),
                New TreeDumperNode("localsOpt", node.LocalsOpt, Nothing),
                New TreeDumperNode("statements", Nothing, From x In node.Statements Select Visit(x, Nothing))
            })
        End Function

        Public Overrides Function VisitLocalDeclaration(node As BoundLocalDeclaration, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("localDeclaration", Nothing, New TreeDumperNode() {
                New TreeDumperNode("localSymbol", node.LocalSymbol, Nothing),
                New TreeDumperNode("initializerOpt", Nothing, new TreeDumperNode() { Visit(node.InitializerOpt, Nothing) }),
                New TreeDumperNode("initializedByAsNew", node.InitializedByAsNew, Nothing)
            })
        End Function

        Public Overrides Function VisitAsNewLocalDeclarations(node As BoundAsNewLocalDeclarations, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("asNewLocalDeclarations", Nothing, New TreeDumperNode() {
                New TreeDumperNode("localDeclarations", Nothing, From x In node.LocalDeclarations Select Visit(x, Nothing)),
                New TreeDumperNode("initializer", Nothing, new TreeDumperNode() { Visit(node.Initializer, Nothing) })
            })
        End Function

        Public Overrides Function VisitDimStatement(node As BoundDimStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("dimStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("localDeclarations", Nothing, From x In node.LocalDeclarations Select Visit(x, Nothing)),
                New TreeDumperNode("initializerOpt", Nothing, new TreeDumperNode() { Visit(node.InitializerOpt, Nothing) })
            })
        End Function

        Public Overrides Function VisitInitializer(node As BoundInitializer, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("initializer", Nothing, New TreeDumperNode() {
            })
        End Function

        Public Overrides Function VisitFieldOrPropertyInitializer(node As BoundFieldOrPropertyInitializer, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("fieldOrPropertyInitializer", Nothing, New TreeDumperNode() {
                New TreeDumperNode("fieldOrProperty", Nothing, new TreeDumperNode() { Visit(node.FieldOrProperty, Nothing) }),
                New TreeDumperNode("initialValue", Nothing, new TreeDumperNode() { Visit(node.InitialValue, Nothing) })
            })
        End Function

        Public Overrides Function VisitGlobalStatementInitializer(node As BoundGlobalStatementInitializer, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("globalStatementInitializer", Nothing, New TreeDumperNode() {
                New TreeDumperNode("statement", Nothing, new TreeDumperNode() { Visit(node.Statement, Nothing) })
            })
        End Function

        Public Overrides Function VisitSequence(node As BoundSequence, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("sequence", Nothing, New TreeDumperNode() {
                New TreeDumperNode("localsOpt", node.LocalsOpt, Nothing),
                New TreeDumperNode("sideEffects", Nothing, From x In node.SideEffects Select Visit(x, Nothing)),
                New TreeDumperNode("valueOpt", Nothing, new TreeDumperNode() { Visit(node.ValueOpt, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitExpressionStatement(node As BoundExpressionStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("expressionStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("expression", Nothing, new TreeDumperNode() { Visit(node.Expression, Nothing) })
            })
        End Function

        Public Overrides Function VisitIfStatement(node As BoundIfStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("ifStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("condition", Nothing, new TreeDumperNode() { Visit(node.Condition, Nothing) }),
                New TreeDumperNode("consequence", Nothing, new TreeDumperNode() { Visit(node.Consequence, Nothing) }),
                New TreeDumperNode("alternativeOpt", Nothing, new TreeDumperNode() { Visit(node.AlternativeOpt, Nothing) })
            })
        End Function

        Public Overrides Function VisitSelectStatement(node As BoundSelectStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("selectStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("expressionStatement", Nothing, new TreeDumperNode() { Visit(node.ExpressionStatement, Nothing) }),
                New TreeDumperNode("exprPlaceholderOpt", Nothing, new TreeDumperNode() { Visit(node.ExprPlaceholderOpt, Nothing) }),
                New TreeDumperNode("caseBlocks", Nothing, From x In node.CaseBlocks Select Visit(x, Nothing)),
                New TreeDumperNode("recommendSwitchTable", node.RecommendSwitchTable, Nothing),
                New TreeDumperNode("exitLabel", node.ExitLabel, Nothing)
            })
        End Function

        Public Overrides Function VisitCaseBlock(node As BoundCaseBlock, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("caseBlock", Nothing, New TreeDumperNode() {
                New TreeDumperNode("caseStatement", Nothing, new TreeDumperNode() { Visit(node.CaseStatement, Nothing) }),
                New TreeDumperNode("body", Nothing, new TreeDumperNode() { Visit(node.Body, Nothing) })
            })
        End Function

        Public Overrides Function VisitCaseStatement(node As BoundCaseStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("caseStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("caseClauses", Nothing, From x In node.CaseClauses Select Visit(x, Nothing)),
                New TreeDumperNode("conditionOpt", Nothing, new TreeDumperNode() { Visit(node.ConditionOpt, Nothing) })
            })
        End Function

        Public Overrides Function VisitCaseValueClause(node As BoundCaseValueClause, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("caseValueClause", Nothing, New TreeDumperNode() {
                New TreeDumperNode("valueOpt", Nothing, new TreeDumperNode() { Visit(node.ValueOpt, Nothing) }),
                New TreeDumperNode("conditionOpt", Nothing, new TreeDumperNode() { Visit(node.ConditionOpt, Nothing) })
            })
        End Function

        Public Overrides Function VisitCaseRangeClause(node As BoundCaseRangeClause, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("caseRangeClause", Nothing, New TreeDumperNode() {
                New TreeDumperNode("lowerBoundOpt", Nothing, new TreeDumperNode() { Visit(node.LowerBoundOpt, Nothing) }),
                New TreeDumperNode("upperBoundOpt", Nothing, new TreeDumperNode() { Visit(node.UpperBoundOpt, Nothing) }),
                New TreeDumperNode("lowerBoundConditionOpt", Nothing, new TreeDumperNode() { Visit(node.LowerBoundConditionOpt, Nothing) }),
                New TreeDumperNode("upperBoundConditionOpt", Nothing, new TreeDumperNode() { Visit(node.UpperBoundConditionOpt, Nothing) })
            })
        End Function

        Public Overrides Function VisitCaseRelationalClause(node As BoundCaseRelationalClause, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("caseRelationalClause", Nothing, New TreeDumperNode() {
                New TreeDumperNode("operatorKind", node.OperatorKind, Nothing),
                New TreeDumperNode("operandOpt", Nothing, new TreeDumperNode() { Visit(node.OperandOpt, Nothing) }),
                New TreeDumperNode("conditionOpt", Nothing, new TreeDumperNode() { Visit(node.ConditionOpt, Nothing) })
            })
        End Function

        Public Overrides Function VisitDoLoopStatement(node As BoundDoLoopStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("doLoopStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("topConditionOpt", Nothing, new TreeDumperNode() { Visit(node.TopConditionOpt, Nothing) }),
                New TreeDumperNode("bottomConditionOpt", Nothing, new TreeDumperNode() { Visit(node.BottomConditionOpt, Nothing) }),
                New TreeDumperNode("topConditionIsUntil", node.TopConditionIsUntil, Nothing),
                New TreeDumperNode("bottomConditionIsUntil", node.BottomConditionIsUntil, Nothing),
                New TreeDumperNode("body", Nothing, new TreeDumperNode() { Visit(node.Body, Nothing) }),
                New TreeDumperNode("continueLabel", node.ContinueLabel, Nothing),
                New TreeDumperNode("exitLabel", node.ExitLabel, Nothing)
            })
        End Function

        Public Overrides Function VisitWhileStatement(node As BoundWhileStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("whileStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("condition", Nothing, new TreeDumperNode() { Visit(node.Condition, Nothing) }),
                New TreeDumperNode("body", Nothing, new TreeDumperNode() { Visit(node.Body, Nothing) }),
                New TreeDumperNode("continueLabel", node.ContinueLabel, Nothing),
                New TreeDumperNode("exitLabel", node.ExitLabel, Nothing)
            })
        End Function

        Public Overrides Function VisitForToStatement(node As BoundForToStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("forToStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("initialValue", Nothing, new TreeDumperNode() { Visit(node.InitialValue, Nothing) }),
                New TreeDumperNode("limitValue", Nothing, new TreeDumperNode() { Visit(node.LimitValue, Nothing) }),
                New TreeDumperNode("stepValue", Nothing, new TreeDumperNode() { Visit(node.StepValue, Nothing) }),
                New TreeDumperNode("checked", node.Checked, Nothing),
                New TreeDumperNode("declaredOrInferredLocalOpt", node.DeclaredOrInferredLocalOpt, Nothing),
                New TreeDumperNode("controlVariable", Nothing, new TreeDumperNode() { Visit(node.ControlVariable, Nothing) }),
                New TreeDumperNode("body", Nothing, new TreeDumperNode() { Visit(node.Body, Nothing) }),
                New TreeDumperNode("nextVariablesOpt", Nothing, From x In node.NextVariablesOpt Select Visit(x, Nothing)),
                New TreeDumperNode("continueLabel", node.ContinueLabel, Nothing),
                New TreeDumperNode("exitLabel", node.ExitLabel, Nothing)
            })
        End Function

        Public Overrides Function VisitForEachStatement(node As BoundForEachStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("forEachStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("collection", Nothing, new TreeDumperNode() { Visit(node.Collection, Nothing) }),
                New TreeDumperNode("enumeratorInfo", node.EnumeratorInfo, Nothing),
                New TreeDumperNode("declaredOrInferredLocalOpt", node.DeclaredOrInferredLocalOpt, Nothing),
                New TreeDumperNode("controlVariable", Nothing, new TreeDumperNode() { Visit(node.ControlVariable, Nothing) }),
                New TreeDumperNode("body", Nothing, new TreeDumperNode() { Visit(node.Body, Nothing) }),
                New TreeDumperNode("nextVariablesOpt", Nothing, From x In node.NextVariablesOpt Select Visit(x, Nothing)),
                New TreeDumperNode("continueLabel", node.ContinueLabel, Nothing),
                New TreeDumperNode("exitLabel", node.ExitLabel, Nothing)
            })
        End Function

        Public Overrides Function VisitExitStatement(node As BoundExitStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("exitStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("label", node.Label, Nothing)
            })
        End Function

        Public Overrides Function VisitContinueStatement(node As BoundContinueStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("continueStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("label", node.Label, Nothing)
            })
        End Function

        Public Overrides Function VisitTryStatement(node As BoundTryStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("tryStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("tryBlock", Nothing, new TreeDumperNode() { Visit(node.TryBlock, Nothing) }),
                New TreeDumperNode("catchBlocks", Nothing, From x In node.CatchBlocks Select Visit(x, Nothing)),
                New TreeDumperNode("finallyBlockOpt", Nothing, new TreeDumperNode() { Visit(node.FinallyBlockOpt, Nothing) }),
                New TreeDumperNode("exitLabelOpt", node.ExitLabelOpt, Nothing)
            })
        End Function

        Public Overrides Function VisitCatchBlock(node As BoundCatchBlock, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("catchBlock", Nothing, New TreeDumperNode() {
                New TreeDumperNode("localOpt", node.LocalOpt, Nothing),
                New TreeDumperNode("exceptionVariableOpt", Nothing, new TreeDumperNode() { Visit(node.ExceptionVariableOpt, Nothing) }),
                New TreeDumperNode("exceptionFilterOpt", Nothing, new TreeDumperNode() { Visit(node.ExceptionFilterOpt, Nothing) }),
                New TreeDumperNode("body", Nothing, new TreeDumperNode() { Visit(node.Body, Nothing) })
            })
        End Function

        Public Overrides Function VisitLiteral(node As BoundLiteral, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("literal", Nothing, New TreeDumperNode() {
                New TreeDumperNode("value", node.Value, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitMeReference(node As BoundMeReference, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("meReference", Nothing, New TreeDumperNode() {
                New TreeDumperNode("meSymbolOpt", node.MeSymbolOpt, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitMyBaseReference(node As BoundMyBaseReference, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("myBaseReference", Nothing, New TreeDumperNode() {
                New TreeDumperNode("meSymbolOpt", node.MeSymbolOpt, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitMyClassReference(node As BoundMyClassReference, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("myClassReference", Nothing, New TreeDumperNode() {
                New TreeDumperNode("meSymbolOpt", node.MeSymbolOpt, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitPreviousSubmissionReference(node As BoundPreviousSubmissionReference, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("previousSubmissionReference", Nothing, New TreeDumperNode() {
                New TreeDumperNode("sourceType", node.SourceType, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitHostObjectMemberReference(node As BoundHostObjectMemberReference, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("hostObjectMemberReference", Nothing, New TreeDumperNode() {
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitLocal(node As BoundLocal, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("local", Nothing, New TreeDumperNode() {
                New TreeDumperNode("localSymbol", node.LocalSymbol, Nothing),
                New TreeDumperNode("isLValue", node.IsLValue, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitParameter(node As BoundParameter, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("parameter", Nothing, New TreeDumperNode() {
                New TreeDumperNode("parameterSymbol", node.ParameterSymbol, Nothing),
                New TreeDumperNode("isLValue", node.IsLValue, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitByRefArgumentPlaceholder(node As BoundByRefArgumentPlaceholder, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("byRefArgumentPlaceholder", Nothing, New TreeDumperNode() {
                New TreeDumperNode("isOut", node.IsOut, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitByRefArgumentWithCopyBack(node As BoundByRefArgumentWithCopyBack, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("byRefArgumentWithCopyBack", Nothing, New TreeDumperNode() {
                New TreeDumperNode("originalArgument", Nothing, new TreeDumperNode() { Visit(node.OriginalArgument, Nothing) }),
                New TreeDumperNode("inConversion", Nothing, new TreeDumperNode() { Visit(node.InConversion, Nothing) }),
                New TreeDumperNode("inPlaceholder", Nothing, new TreeDumperNode() { Visit(node.InPlaceholder, Nothing) }),
                New TreeDumperNode("outConversion", Nothing, new TreeDumperNode() { Visit(node.OutConversion, Nothing) }),
                New TreeDumperNode("outPlaceholder", Nothing, new TreeDumperNode() { Visit(node.OutPlaceholder, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitLabelStatement(node As BoundLabelStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("labelStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("label", node.Label, Nothing)
            })
        End Function

        Public Overrides Function VisitLabel(node As BoundLabel, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("label", Nothing, New TreeDumperNode() {
                New TreeDumperNode("label", node.Label, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitGotoStatement(node As BoundGotoStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("gotoStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("label", node.Label, Nothing),
                New TreeDumperNode("labelExpressionOpt", Nothing, new TreeDumperNode() { Visit(node.LabelExpressionOpt, Nothing) })
            })
        End Function

        Public Overrides Function VisitStatementList(node As BoundStatementList, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("statementList", Nothing, New TreeDumperNode() {
                New TreeDumperNode("statements", Nothing, From x In node.Statements Select Visit(x, Nothing))
            })
        End Function

        Public Overrides Function VisitConditionalGoto(node As BoundConditionalGoto, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("conditionalGoto", Nothing, New TreeDumperNode() {
                New TreeDumperNode("condition", Nothing, new TreeDumperNode() { Visit(node.Condition, Nothing) }),
                New TreeDumperNode("jumpIfTrue", node.JumpIfTrue, Nothing),
                New TreeDumperNode("label", node.Label, Nothing)
            })
        End Function

        Public Overrides Function VisitWithStatement(node As BoundWithStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("withStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("originalExpression", Nothing, new TreeDumperNode() { Visit(node.OriginalExpression, Nothing) }),
                New TreeDumperNode("body", Nothing, new TreeDumperNode() { Visit(node.Body, Nothing) }),
                New TreeDumperNode("binder", node.Binder, Nothing)
            })
        End Function

        Public Overrides Function VisitUnboundLambda(node As UnboundLambda, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("unboundLambda", Nothing, New TreeDumperNode() {
                New TreeDumperNode("binder", node.Binder, Nothing),
                New TreeDumperNode("parameters", node.Parameters, Nothing),
                New TreeDumperNode("returnType", node.ReturnType, Nothing),
                New TreeDumperNode("bindingCache", node.BindingCache, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitLambda(node As BoundLambda, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("lambda", Nothing, New TreeDumperNode() {
                New TreeDumperNode("unboundLambdaOpt", Nothing, new TreeDumperNode() { Visit(node.UnboundLambdaOpt, Nothing) }),
                New TreeDumperNode("lambdaSymbol", node.LambdaSymbol, Nothing),
                New TreeDumperNode("body", Nothing, new TreeDumperNode() { Visit(node.Body, Nothing) }),
                New TreeDumperNode("diagnosticsOpt", node.DiagnosticsOpt, Nothing),
                New TreeDumperNode("lambdaBinderOpt", node.LambdaBinderOpt, Nothing),
                New TreeDumperNode("delegateRelaxation", node.DelegateRelaxation, Nothing),
                New TreeDumperNode("methodConversionKind", node.MethodConversionKind, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitQueryExpression(node As BoundQueryExpression, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("queryExpression", Nothing, New TreeDumperNode() {
                New TreeDumperNode("lastOperator", Nothing, new TreeDumperNode() { Visit(node.LastOperator, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitQuerySource(node As BoundQuerySource, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("querySource", Nothing, New TreeDumperNode() {
                New TreeDumperNode("expression", Nothing, new TreeDumperNode() { Visit(node.Expression, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitToQueryableCollectionConversion(node As BoundToQueryableCollectionConversion, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("toQueryableCollectionConversion", Nothing, New TreeDumperNode() {
                New TreeDumperNode("conversionCall", Nothing, new TreeDumperNode() { Visit(node.ConversionCall, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitQueryableSource(node As BoundQueryableSource, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("queryableSource", Nothing, New TreeDumperNode() {
                New TreeDumperNode("source", Nothing, new TreeDumperNode() { Visit(node.Source, Nothing) }),
                New TreeDumperNode("rangeVariableOpt", node.RangeVariableOpt, Nothing),
                New TreeDumperNode("rangeVariables", node.RangeVariables, Nothing),
                New TreeDumperNode("compoundVariableType", node.CompoundVariableType, Nothing),
                New TreeDumperNode("binders", node.Binders, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitQueryClause(node As BoundQueryClause, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("queryClause", Nothing, New TreeDumperNode() {
                New TreeDumperNode("underlyingExpression", Nothing, new TreeDumperNode() { Visit(node.UnderlyingExpression, Nothing) }),
                New TreeDumperNode("rangeVariables", node.RangeVariables, Nothing),
                New TreeDumperNode("compoundVariableType", node.CompoundVariableType, Nothing),
                New TreeDumperNode("binders", node.Binders, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitOrdering(node As BoundOrdering, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("ordering", Nothing, New TreeDumperNode() {
                New TreeDumperNode("underlyingExpression", Nothing, new TreeDumperNode() { Visit(node.UnderlyingExpression, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitQueryLambda(node As BoundQueryLambda, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("queryLambda", Nothing, New TreeDumperNode() {
                New TreeDumperNode("lambdaSymbol", node.LambdaSymbol, Nothing),
                New TreeDumperNode("rangeVariables", node.RangeVariables, Nothing),
                New TreeDumperNode("expression", Nothing, new TreeDumperNode() { Visit(node.Expression, Nothing) }),
                New TreeDumperNode("exprIsOperandOfConditionalBranch", node.ExprIsOperandOfConditionalBranch, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitRangeVariableAssignment(node As BoundRangeVariableAssignment, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("rangeVariableAssignment", Nothing, New TreeDumperNode() {
                New TreeDumperNode("rangeVariable", node.RangeVariable, Nothing),
                New TreeDumperNode("value", Nothing, new TreeDumperNode() { Visit(node.Value, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitGroupTypeInferenceLambda(node As GroupTypeInferenceLambda, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("groupTypeInferenceLambda", Nothing, New TreeDumperNode() {
                New TreeDumperNode("binder", node.Binder, Nothing),
                New TreeDumperNode("parameters", node.Parameters, Nothing),
                New TreeDumperNode("compilation", node.Compilation, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitAggregateClause(node As BoundAggregateClause, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("aggregateClause", Nothing, New TreeDumperNode() {
                New TreeDumperNode("capturedGroupOpt", Nothing, new TreeDumperNode() { Visit(node.CapturedGroupOpt, Nothing) }),
                New TreeDumperNode("groupPlaceholderOpt", Nothing, new TreeDumperNode() { Visit(node.GroupPlaceholderOpt, Nothing) }),
                New TreeDumperNode("underlyingExpression", Nothing, new TreeDumperNode() { Visit(node.UnderlyingExpression, Nothing) }),
                New TreeDumperNode("rangeVariables", node.RangeVariables, Nothing),
                New TreeDumperNode("compoundVariableType", node.CompoundVariableType, Nothing),
                New TreeDumperNode("binders", node.Binders, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitGroupAggregation(node As BoundGroupAggregation, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("groupAggregation", Nothing, New TreeDumperNode() {
                New TreeDumperNode("group", Nothing, new TreeDumperNode() { Visit(node.Group, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitRangeVariable(node As BoundRangeVariable, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("rangeVariable", Nothing, New TreeDumperNode() {
                New TreeDumperNode("rangeVariable", node.RangeVariable, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitAddHandlerStatement(node As BoundAddHandlerStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("addHandlerStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("eventAccess", Nothing, new TreeDumperNode() { Visit(node.EventAccess, Nothing) }),
                New TreeDumperNode("handler", Nothing, new TreeDumperNode() { Visit(node.Handler, Nothing) })
            })
        End Function

        Public Overrides Function VisitRemoveHandlerStatement(node As BoundRemoveHandlerStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("removeHandlerStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("eventAccess", Nothing, new TreeDumperNode() { Visit(node.EventAccess, Nothing) }),
                New TreeDumperNode("handler", Nothing, new TreeDumperNode() { Visit(node.Handler, Nothing) })
            })
        End Function

        Public Overrides Function VisitRaiseEventStatement(node As BoundRaiseEventStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("raiseEventStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("eventSymbol", node.EventSymbol, Nothing),
                New TreeDumperNode("eventInvocation", Nothing, new TreeDumperNode() { Visit(node.EventInvocation, Nothing) })
            })
        End Function

        Public Overrides Function VisitUsingStatement(node As BoundUsingStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("usingStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("resourceList", Nothing, From x In node.ResourceList Select Visit(x, Nothing)),
                New TreeDumperNode("resourceExpressionOpt", Nothing, new TreeDumperNode() { Visit(node.ResourceExpressionOpt, Nothing) }),
                New TreeDumperNode("body", Nothing, new TreeDumperNode() { Visit(node.Body, Nothing) }),
                New TreeDumperNode("usingInfo", node.UsingInfo, Nothing)
            })
        End Function

        Public Overrides Function VisitSyncLockStatement(node As BoundSyncLockStatement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("syncLockStatement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("lockExpression", Nothing, new TreeDumperNode() { Visit(node.LockExpression, Nothing) }),
                New TreeDumperNode("body", Nothing, new TreeDumperNode() { Visit(node.Body, Nothing) }),
                New TreeDumperNode("expressionTypeWasTypeParameter", node.ExpressionTypeWasTypeParameter, Nothing)
            })
        End Function

        Public Overrides Function VisitXmlName(node As BoundXmlName, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("xmlName", Nothing, New TreeDumperNode() {
                New TreeDumperNode("xmlNamespace", Nothing, new TreeDumperNode() { Visit(node.XmlNamespace, Nothing) }),
                New TreeDumperNode("localName", Nothing, new TreeDumperNode() { Visit(node.LocalName, Nothing) }),
                New TreeDumperNode("objectCreation", Nothing, new TreeDumperNode() { Visit(node.ObjectCreation, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitXmlDocument(node As BoundXmlDocument, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("xmlDocument", Nothing, New TreeDumperNode() {
                New TreeDumperNode("declaration", Nothing, new TreeDumperNode() { Visit(node.Declaration, Nothing) }),
                New TreeDumperNode("childNodes", Nothing, From x In node.ChildNodes Select Visit(x, Nothing)),
                New TreeDumperNode("rewriterInfo", node.RewriterInfo, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitXmlDeclaration(node As BoundXmlDeclaration, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("xmlDeclaration", Nothing, New TreeDumperNode() {
                New TreeDumperNode("version", Nothing, new TreeDumperNode() { Visit(node.Version, Nothing) }),
                New TreeDumperNode("encoding", Nothing, new TreeDumperNode() { Visit(node.Encoding, Nothing) }),
                New TreeDumperNode("standalone", Nothing, new TreeDumperNode() { Visit(node.Standalone, Nothing) }),
                New TreeDumperNode("objectCreation", Nothing, new TreeDumperNode() { Visit(node.ObjectCreation, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitXmlProcessingInstruction(node As BoundXmlProcessingInstruction, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("xmlProcessingInstruction", Nothing, New TreeDumperNode() {
                New TreeDumperNode("target", Nothing, new TreeDumperNode() { Visit(node.Target, Nothing) }),
                New TreeDumperNode("data", Nothing, new TreeDumperNode() { Visit(node.Data, Nothing) }),
                New TreeDumperNode("objectCreation", Nothing, new TreeDumperNode() { Visit(node.ObjectCreation, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitXmlComment(node As BoundXmlComment, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("xmlComment", Nothing, New TreeDumperNode() {
                New TreeDumperNode("value", Nothing, new TreeDumperNode() { Visit(node.Value, Nothing) }),
                New TreeDumperNode("objectCreation", Nothing, new TreeDumperNode() { Visit(node.ObjectCreation, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitXmlAttribute(node As BoundXmlAttribute, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("xmlAttribute", Nothing, New TreeDumperNode() {
                New TreeDumperNode("name", Nothing, new TreeDumperNode() { Visit(node.Name, Nothing) }),
                New TreeDumperNode("value", Nothing, new TreeDumperNode() { Visit(node.Value, Nothing) }),
                New TreeDumperNode("objectCreation", Nothing, new TreeDumperNode() { Visit(node.ObjectCreation, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitXmlElement(node As BoundXmlElement, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("xmlElement", Nothing, New TreeDumperNode() {
                New TreeDumperNode("argument", Nothing, new TreeDumperNode() { Visit(node.Argument, Nothing) }),
                New TreeDumperNode("childNodes", Nothing, From x In node.ChildNodes Select Visit(x, Nothing)),
                New TreeDumperNode("rewriterInfo", node.RewriterInfo, Nothing),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitXmlMemberAccess(node As BoundXmlMemberAccess, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("xmlMemberAccess", Nothing, New TreeDumperNode() {
                New TreeDumperNode("receiver", Nothing, new TreeDumperNode() { Visit(node.Receiver, Nothing) }),
                New TreeDumperNode("name", Nothing, new TreeDumperNode() { Visit(node.Name, Nothing) }),
                New TreeDumperNode("memberAccess", Nothing, new TreeDumperNode() { Visit(node.MemberAccess, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

        Public Overrides Function VisitXmlEmbeddedExpression(node As BoundXmlEmbeddedExpression, arg As Object) As TreeDumperNode
            Return New TreeDumperNode("xmlEmbeddedExpression", Nothing, New TreeDumperNode() {
                New TreeDumperNode("expression", Nothing, new TreeDumperNode() { Visit(node.Expression, Nothing) }),
                New TreeDumperNode("type", node.Type, Nothing)
            })
        End Function

    End Class
End Namespace
