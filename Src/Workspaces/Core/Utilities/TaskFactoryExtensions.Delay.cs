// <auto-generated/> 

// This code comes from the TPL in .Net 5.  Because we want to keep it as close to the original as
// possible, we turn off stylecop so it doesn't complain about things like naming conventions.

using System;
using System.Threading;
using System.Threading.Tasks;

namespace Roslyn.Utilities
{
    internal static partial class TaskFactoryExtensions
    {
        // Code graciously provided by Stephen Toub (and copied from the 5.0 BCL).
        /// <summary>
        /// Creates a Task that will complete after a time delay.
        /// </summary>
        /// <param name="factory">Extension parameter</param>
        /// <param name="delay">The time span to wait before completing the returned Task</param>
        /// <returns>A Task that represents the time delay</returns>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// The <paramref name="delay"/> is less than -1 or greater than Int32.MaxValue.
        /// </exception>
        /// <remarks>
        /// After the specified time delay, the Task is completed in RanToCompletion state.
        /// </remarks>
        public static Task Delay(this TaskFactory factory, TimeSpan delay)
        {
            return factory.Delay(delay, CancellationToken.None);
        }

        /// <summary>
        /// Creates a Task that will complete after a time delay.
        /// </summary>
        /// <param name="factory">Extension parameter</param>
        /// <param name="delay">The time span to wait before completing the returned Task</param>
        /// <param name="cancellationToken">The cancellation token that will be checked prior to completing the returned Task</param>
        /// <returns>A Task that represents the time delay</returns>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// The <paramref name="delay"/> is less than -1 or greater than Int32.MaxValue.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        /// The provided <paramref name="cancellationToken"/> has already been disposed.
        /// </exception>        
        /// <remarks>
        /// If the cancellation token is signaled before the specified time delay, then the Task is completed in
        /// Canceled state.  Otherwise, the Task is completed in RanToCompletion state once the specified time
        /// delay has expired.
        /// </remarks>        
        public static Task Delay(this TaskFactory factory, TimeSpan delay, CancellationToken cancellationToken)
        {
            var totalMilliseconds = (long)delay.TotalMilliseconds;
            if (totalMilliseconds < -1 || totalMilliseconds > Int32.MaxValue)
            {
                throw new ArgumentOutOfRangeException("delay");
            }

            return factory.Delay((int)totalMilliseconds, cancellationToken);
        }

        /// <summary>
        /// Creates a Task that will complete after a time delay.
        /// </summary>
        /// <param name="factory">Extension parameter</param>
        /// <param name="millisecondsDelay">The number of milliseconds to wait before completing the returned Task</param>
        /// <returns>A Task that represents the time delay</returns>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// The <paramref name="millisecondsDelay"/> is less than -1.
        /// </exception>
        /// <remarks>
        /// After the specified time delay, the Task is completed in RanToCompletion state.
        /// </remarks>
        public static Task Delay(this TaskFactory factory, int millisecondsDelay)
        {
            return factory.Delay(millisecondsDelay, CancellationToken.None);
        }

        /// <summary>
        /// Creates a Task that will complete after a time delay.
        /// </summary>
        /// <param name="factory">Extension parameter</param>
        /// <param name="millisecondsDelay">The number of milliseconds to wait before completing the returned Task</param>
        /// <param name="cancellationToken">The cancellation token that will be checked prior to completing the returned Task</param>
        /// <returns>A Task that represents the time delay</returns>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// The <paramref name="millisecondsDelay"/> is less than -1.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        /// The provided <paramref name="cancellationToken"/> has already been disposed.
        /// </exception>        
        /// <remarks>
        /// If the cancellation token is signaled before the specified time delay, then the Task is completed in
        /// Canceled state.  Otherwise, the Task is completed in RanToCompletion state once the specified time
        /// delay has expired.
        /// </remarks>        
        public static Task Delay(this TaskFactory factory, int millisecondsDelay, CancellationToken cancellationToken)
        {
            // NOTE(cyrusn): I have modified this code to run without internal access to the TPL.  My
            // changes are indicated where appropriate.

            // Throw on non-sensical time
            if (millisecondsDelay < -1)
            {
                throw new ArgumentOutOfRangeException("millisecondsDelay");
            }

#if false
            // ORIGINAL CODE

            // some short-cuts in case quick completion is in order
            if (cancellationToken.IsCancellationRequested)
            {
                // return a Task created as already-Canceled
                return new Task(true, TaskCreationOptions.None, cancellationToken);
            }
            else if (millisecondsDelay == 0)
            {
                // return a Task created as already-RanToCompletion
                return new Task(false, TaskCreationOptions.None, cancellationToken);
            }

            // Construct a TCS to encapsulate our return value
            TaskCompletionSource<bool> tcs = new TaskCompletionSource<bool>();
#else
            // NOTE: the type param of 'bool' is just a dummy placeholder since there is no
            // nongeneric TaskCompletionSource.  We never actually use this type for anything.
            var tcs = new TaskCompletionSource<bool>();

            // some short-cuts in case quick completion is in order
            if (cancellationToken.IsCancellationRequested)
            {
                // return a Task created as already-Canceled
                tcs.TrySetCanceled();
                return tcs.Task;
            }
            else if (millisecondsDelay == 0)
            {
                // return a Task created as already-RanToCompletion
                tcs.TrySetResult(result: true);
                return tcs.Task;
            }
#endif

            var ctr = default(CancellationTokenRegistration);
            Timer timer = null;

            // The common logic to run when completion is desired
            // Note that there are a couple of potential races here, both benign:
            //      (1) The cancellation token may get signaled at the same time that
            //          the timer expires.  All of the logic herein should be thread-safe.
            //      (2) The cancellation token may get signaled before the timer is
            //          created.  This will result in the timer not being disposed/canceled,
            //          which will result in the delegate below running (harmlessly) one more time
            //          than it needs to run.  This is a corner case that was deemed acceptible.
            Action completionLogic = () =>
            {
                if (cancellationToken.IsCancellationRequested)
                {
#if false
                    // ORIGINAL CODE
                    tcs.TrySetCanceled(cancellationToken);
#else
                    // TrySetCanceled(CancellationToken) is internal in the tpl.  Call the slightly
                    // less efficient version.
                    tcs.TrySetCanceled();
#endif
                }
                else
                {
                    tcs.TrySetResult(true);
                }

                if (timer != null) timer.Dispose();
                ctr.Dispose();
            };

            // Register our cancellation token, if necessary.
            if (cancellationToken.CanBeCanceled)
            {
                ctr = cancellationToken.Register(completionLogic);
            }

            // ... and create our timer.
            timer = new Timer(state => ((Action)state)(), completionLogic, millisecondsDelay, -1);

#if true
            // The original code has a bug on .Net 4.0.  According to Stephen Toub, there is nothing
            // rooting the timer, so it can be GC'ed. In order to deal with this, we ensure the
            // timer stays alive as long as the task is alive.

            // NOTE: the GC.KeepAlive part isn't important.  All it is used for is so that we capture
            // the timer.  Any code that would capture the timer and making a path from the task to
            // it would suffice here.
            tcs.Task.SafeContinueWith(_ => GC.KeepAlive(timer), TaskScheduler.Default);
#endif

            // Return the timer proxy task
            return tcs.Task;
        }
    }
}
