using System;
using System.Collections.Generic;
using Roslyn.Compilers;
using Roslyn.Compilers.Common;
using Roslyn.Compilers.CSharp;
using Roslyn.Services;
using Roslyn.Services.Formatting;
using Roslyn.Utilities;

namespace Roslyn.Services.CSharp.Formatting
{
    internal class AutoGeneratedCodeOperationProvider : IFormattingOperationProvider
    {
        private readonly IFormattingOperationsFactory factory;
        private readonly IFormattingOperationProvider provider;

        public AutoGeneratedCodeOperationProvider(IFormattingOperationsFactory factory, IFormattingOperationProvider provider)
        {
            Contract.ThrowIfNull(factory);
            Contract.ThrowIfNull(provider);

            this.factory = factory;
            this.provider = provider;
        }

        public void AddSuppressOperations(List<ISuppressOperation> list, CommonSyntaxNode node)
        {
            // anchor operation is to preserve user code style. don't do anything
        }

        public void AddAnchorIndentationOperations(List<IAnchorIndentationOperation> list, CommonSyntaxNode node)
        {
            // anchor operation is to preserve user code style. don't do anything
        }

        public void AddIndentBlockOperations(List<IIndentBlockOperation> list, CommonSyntaxNode node)
        {
            // anchor operation is to preserve user code style. don't do anything
        }

        public void AddAlignTokensOperations(List<IAlignTokensOperation> list, CommonSyntaxNode node)
        {
            // anchor operation is to preserve user code style. don't do anything
        }

        public IAdjustNewLinesOperation GetAdjustNewLinesOperation(CommonSyntaxToken previousToken, CommonSyntaxToken currentToken)
        {
            return GetAdjustNewLinesOperation((SyntaxToken)previousToken, (SyntaxToken)currentToken);
        }

        private IAdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken previousToken, SyntaxToken currentToken)
        {
            var operation = this.provider.GetAdjustNewLinesOperation(previousToken, currentToken);
            if (operation == null)
            {
                return null;
            }

            // if operation is already forced, return as it is.
            if (operation.Option == AdjustNewLinesOption.ForceLines)
            {
                return operation;
            }

            var line = Math.Max(LineBreaksAfter(previousToken, currentToken), operation.Line);
            if (line == 0)
            {
                return this.factory.CreateAdjustNewLinesOperation(0, AdjustNewLinesOption.PreserveLines);
            }

            return this.factory.CreateAdjustNewLinesOperation(line, AdjustNewLinesOption.ForceLines);
        }

        public IAdjustSpacesOperation GetAdjustSpacesOperation(CommonSyntaxToken previousToken, CommonSyntaxToken currentToken)
        {
            var operation = this.provider.GetAdjustSpacesOperation(previousToken, currentToken);
            if (operation == null)
            {
                return null;
            }

            // if operation is already forced, return as it is.
            if (operation.Option == AdjustSpacesOption.ForceSpaces)
            {
                return operation;
            }

            // current implementation of engine gives higher priority on new line operations over space operations if
            // two are conflicting.
            // ex) new line operation says add 1 line between tokens, and 
            //     space operation says give 1 space between two tokens (basically means remove new lines)
            //     then, engine will pick new line operation and ignore space operation

            // make every operation forced
            return this.factory.CreateAdjustSpacesOperation(Math.Max(0, operation.Space), AdjustSpacesOption.ForceSpaces);
        }

        // copied from compiler formatter to have same base forced format
        private int LineBreaksAfter(SyntaxToken previousToken, SyntaxToken currentToken)
        {
            if (currentToken.Kind == SyntaxKind.None)
            {
                return 0;
            }

            switch (previousToken.Kind)
            {
                case SyntaxKind.None:
                    return 0;

                case SyntaxKind.OpenBraceToken:
                case SyntaxKind.FinallyKeyword:
                    return 1;

                case SyntaxKind.CloseBraceToken:
                    return LineBreaksAfterCloseBrace(currentToken);

                case SyntaxKind.CloseParenToken:
                    return (((previousToken.Parent is StatementSyntax) && currentToken.Parent != previousToken.Parent)
                        || currentToken.Kind == SyntaxKind.OpenBraceToken) ? 1 : 0;

                case SyntaxKind.CloseBracketToken:
                    if (previousToken.Parent is AttributeDeclarationSyntax)
                    {
                        return 1;
                    }

                    break;

                case SyntaxKind.SemicolonToken:
                    return LineBreaksAfterSemicolon(previousToken, currentToken);

                case SyntaxKind.CommaToken:
                    return previousToken.Parent is EnumDeclarationSyntax ? 1 : 0;

                case SyntaxKind.ElseKeyword:
                    return currentToken.Kind != SyntaxKind.IfKeyword ? 1 : 0;

                case SyntaxKind.ColonToken:
                    if (previousToken.Parent is LabeledStatementSyntax || previousToken.Parent is SwitchLabelSyntax)
                    {
                        return 1;
                    }

                    break;
            }

            if ((currentToken.Kind == SyntaxKind.FromKeyword && currentToken.Parent.Kind == SyntaxKind.FromClause) ||
                (currentToken.Kind == SyntaxKind.LetKeyword && currentToken.Parent.Kind == SyntaxKind.LetClause) ||
                (currentToken.Kind == SyntaxKind.WhereKeyword && currentToken.Parent.Kind == SyntaxKind.WhereClause) ||
                (currentToken.Kind == SyntaxKind.JoinKeyword && currentToken.Parent.Kind == SyntaxKind.JoinClause) ||
                (currentToken.Kind == SyntaxKind.JoinKeyword && currentToken.Parent.Kind == SyntaxKind.JoinIntoClause) ||
                (currentToken.Kind == SyntaxKind.OrderByKeyword && currentToken.Parent.Kind == SyntaxKind.OrderByClause) ||
                (currentToken.Kind == SyntaxKind.SelectKeyword && currentToken.Parent.Kind == SyntaxKind.SelectClause) ||
                (currentToken.Kind == SyntaxKind.GroupKeyword && currentToken.Parent.Kind == SyntaxKind.GroupClause))
            {
                return 1;
            }

            switch (currentToken.Kind)
            {
                case SyntaxKind.OpenBraceToken:
                case SyntaxKind.CloseBraceToken:
                case SyntaxKind.ElseKeyword:
                case SyntaxKind.FinallyKeyword:
                    return 1;

                case SyntaxKind.OpenBracketToken:
                    return currentToken.Parent is AttributeDeclarationSyntax ? 1 : 0;

                case SyntaxKind.WhereKeyword:
                    return previousToken.Parent is TypeParameterListSyntax ? 1 : 0;
            }

            return 0;
        }

        private static int LineBreaksAfterCloseBrace(SyntaxToken nextToken)
        {
            if (nextToken.Kind == SyntaxKind.CloseBraceToken)
            {
                return 1;
            }
            else if (
                nextToken.Kind == SyntaxKind.CatchKeyword ||
                nextToken.Kind == SyntaxKind.FinallyKeyword ||
                nextToken.Kind == SyntaxKind.ElseKeyword)
            {
                return 1;
            }
            else if (
                nextToken.Kind == SyntaxKind.WhileKeyword &&
                nextToken.Parent.Kind == SyntaxKind.DoStatement)
            {
                return 1;
            }
            else if (nextToken.Kind == SyntaxKind.EndOfFileToken)
            {
                return 0;
            }
            else
            {
                return 2;
            }
        }

        private static int LineBreaksAfterSemicolon(SyntaxToken previousToken, SyntaxToken currentToken)
        {
            if (previousToken.Parent is ForStatementSyntax)
            {
                return 0;
            }
            else if (currentToken.Kind == SyntaxKind.CloseBraceToken)
            {
                return 1;
            }
            else if (previousToken.Parent is UsingDirectiveSyntax)
            {
                return currentToken.Parent is UsingDirectiveSyntax ? 1 : 2;
            }
            else if (previousToken.Parent is ExternAliasDirectiveSyntax)
            {
                return currentToken.Parent is ExternAliasDirectiveSyntax ? 1 : 2;
            }
            else
            {
                return 1;
            }
        }
    }
}
