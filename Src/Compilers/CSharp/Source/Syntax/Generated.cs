// <auto-generated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace Roslyn.Compilers.CSharp.InternalSyntax
{
  /// <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class NameSyntax : TypeSyntax
  {
    internal NameSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal NameSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected NameSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class SimpleNameSyntax : NameSyntax
  {
    internal SimpleNameSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal SimpleNameSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected SimpleNameSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>SyntaxToken representing the identifier of the simple name.</summary>
    public abstract SyntaxToken Identifier { get; }
  }

  /// <summary>Class which represents the syntax node for identifier name.</summary>
  internal sealed partial class IdentifierNameSyntax : SimpleNameSyntax
  {
    private readonly SyntaxToken identifier;

    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 1;
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
    }


    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier)
        : base(kind)
    {
        this.slotCount = 1;
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
    }

    /// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
    public override SyntaxToken Identifier { get { return this.identifier; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.IdentifierNameSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIdentifierName(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitIdentifierName(this);
    }

    public IdentifierNameSyntax Update(SyntaxToken identifier)
    {
        if (identifier != this.Identifier)
        {
            var newNode = Syntax.IdentifierName(identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IdentifierNameSyntax(this.Kind, this.identifier, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IdentifierNameSyntax(this.Kind, this.identifier, GetDiagnostics(), annotations);
    }

    internal IdentifierNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 1;
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new IdentifierNameSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
    }
  }

  /// <summary>Class which represents the syntax node for qualified name.</summary>
  internal sealed partial class QualifiedNameSyntax : NameSyntax
  {
    private readonly NameSyntax left;
    private readonly SyntaxToken dotToken;
    private readonly SimpleNameSyntax right;

    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.left = left;
        this.AdjustFlagsAndWidth(left);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(dotToken);
        this.right = right;
        this.AdjustFlagsAndWidth(right);
    }


    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
        : base(kind)
    {
        this.slotCount = 3;
        this.left = left;
        this.AdjustFlagsAndWidth(left);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(dotToken);
        this.right = right;
        this.AdjustFlagsAndWidth(right);
    }

    /// <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
    public NameSyntax Left { get { return this.left; } }
    /// <summary>SyntaxToken representing the dot.</summary>
    public SyntaxToken DotToken { get { return this.dotToken; } }
    /// <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
    public SimpleNameSyntax Right { get { return this.right; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 1: return this.dotToken;
            case 2: return this.right;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.QualifiedNameSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQualifiedName(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitQualifiedName(this);
    }

    public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
        if (left != this.Left || dotToken != this.DotToken || right != this.Right)
        {
            var newNode = Syntax.QualifiedName(left, dotToken, right);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new QualifiedNameSyntax(this.Kind, this.left, this.dotToken, this.right, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new QualifiedNameSyntax(this.Kind, this.left, this.dotToken, this.right, GetDiagnostics(), annotations);
    }

    internal QualifiedNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.left = (NameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.left);
      this.dotToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.dotToken);
      this.right = (SimpleNameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.right);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new QualifiedNameSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.left);
      writer.WriteValue(this.dotToken);
      writer.WriteValue(this.right);
    }
  }

  /// <summary>Class which represents the syntax node for generic name.</summary>
  internal sealed partial class GenericNameSyntax : SimpleNameSyntax
  {
    private readonly SyntaxToken identifier;
    private readonly TypeArgumentListSyntax typeArgumentList;

    internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.typeArgumentList = typeArgumentList;
        this.AdjustFlagsAndWidth(typeArgumentList);
    }


    internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
        : base(kind)
    {
        this.slotCount = 2;
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.typeArgumentList = typeArgumentList;
        this.AdjustFlagsAndWidth(typeArgumentList);
    }

    /// <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
    public override SyntaxToken Identifier { get { return this.identifier; } }
    /// <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
    public TypeArgumentListSyntax TypeArgumentList { get { return this.typeArgumentList; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.typeArgumentList;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.GenericNameSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGenericName(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitGenericName(this);
    }

    public GenericNameSyntax Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
        if (identifier != this.Identifier || typeArgumentList != this.TypeArgumentList)
        {
            var newNode = Syntax.GenericName(identifier, typeArgumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new GenericNameSyntax(this.Kind, this.identifier, this.typeArgumentList, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new GenericNameSyntax(this.Kind, this.identifier, this.typeArgumentList, GetDiagnostics(), annotations);
    }

    internal GenericNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.typeArgumentList = (TypeArgumentListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.typeArgumentList);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new GenericNameSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeArgumentList);
    }
  }

  /// <summary>Class which represents the syntax node for type argument list.</summary>
  internal sealed partial class TypeArgumentListSyntax : SyntaxNode
  {
    private readonly SyntaxToken lessThanToken;
    private readonly SyntaxNode arguments;
    private readonly SyntaxToken greaterThanToken;

    internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, SyntaxNode arguments, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(lessThanToken);
        if (arguments != null)
        {
            this.arguments = arguments;
            this.AdjustFlagsAndWidth(arguments);
        }
        this.greaterThanToken = greaterThanToken;
        this.AdjustFlagsAndWidth(greaterThanToken);
    }


    internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, SyntaxNode arguments, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(lessThanToken);
        if (arguments != null)
        {
            this.arguments = arguments;
            this.AdjustFlagsAndWidth(arguments);
        }
        this.greaterThanToken = greaterThanToken;
        this.AdjustFlagsAndWidth(greaterThanToken);
    }

    /// <summary>SyntaxToken representing less than.</summary>
    public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
    /// <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
    public SeparatedSyntaxList<TypeSyntax> Arguments { get { return new SeparatedSyntaxList<TypeSyntax>(new SyntaxList<SyntaxNode>(this.arguments)); } }
    /// <summary>SyntaxToken representing greater than.</summary>
    public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.arguments;
            case 2: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.TypeArgumentListSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeArgumentList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitTypeArgumentList(this);
    }

    public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || arguments != this.Arguments || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = Syntax.TypeArgumentList(lessThanToken, arguments, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, GetDiagnostics(), annotations);
    }

    internal TypeArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.lessThanToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.lessThanToken);
      this.arguments = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.arguments);
      this.greaterThanToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.greaterThanToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new TypeArgumentListSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.greaterThanToken);
    }
  }

  /// <summary>Class which represents the syntax node for alias qualified name.</summary>
  internal sealed partial class AliasQualifiedNameSyntax : NameSyntax
  {
    private readonly IdentifierNameSyntax alias;
    private readonly SyntaxToken colonColonToken;
    private readonly SimpleNameSyntax name;

    internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.alias = alias;
        this.AdjustFlagsAndWidth(alias);
        this.colonColonToken = colonColonToken;
        this.AdjustFlagsAndWidth(colonColonToken);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
    }


    internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
        : base(kind)
    {
        this.slotCount = 3;
        this.alias = alias;
        this.AdjustFlagsAndWidth(alias);
        this.colonColonToken = colonColonToken;
        this.AdjustFlagsAndWidth(colonColonToken);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
    }

    /// <summary>IdentifierNameSyntax node representing the name of the alias</summary>
    public IdentifierNameSyntax Alias { get { return this.alias; } }
    /// <summary>SyntaxToken representing colon colon.</summary>
    public SyntaxToken ColonColonToken { get { return this.colonColonToken; } }
    /// <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
    public SimpleNameSyntax Name { get { return this.name; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.alias;
            case 1: return this.colonColonToken;
            case 2: return this.name;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.AliasQualifiedNameSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAliasQualifiedName(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAliasQualifiedName(this);
    }

    public AliasQualifiedNameSyntax Update(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
        if (alias != this.Alias || colonColonToken != this.ColonColonToken || name != this.Name)
        {
            var newNode = Syntax.AliasQualifiedName(alias, colonColonToken, name);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AliasQualifiedNameSyntax(this.Kind, this.alias, this.colonColonToken, this.name, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AliasQualifiedNameSyntax(this.Kind, this.alias, this.colonColonToken, this.name, GetDiagnostics(), annotations);
    }

    internal AliasQualifiedNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.alias = (IdentifierNameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.alias);
      this.colonColonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.colonColonToken);
      this.name = (SimpleNameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.name);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new AliasQualifiedNameSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.alias);
      writer.WriteValue(this.colonColonToken);
      writer.WriteValue(this.name);
    }
  }

  /// <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class TypeSyntax : ExpressionSyntax
  {
    internal TypeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal TypeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected TypeSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Class which represents the syntax node for predefined types.</summary>
  internal sealed partial class PredefinedTypeSyntax : TypeSyntax
  {
    private readonly SyntaxToken keyword;

    internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 1;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
    }


    internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword)
        : base(kind)
    {
        this.slotCount = 1;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
    }

    /// <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.PredefinedTypeSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPredefinedType(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitPredefinedType(this);
    }

    public PredefinedTypeSyntax Update(SyntaxToken keyword)
    {
        if (keyword != this.Keyword)
        {
            var newNode = Syntax.PredefinedType(keyword);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PredefinedTypeSyntax(this.Kind, this.keyword, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PredefinedTypeSyntax(this.Kind, this.keyword, GetDiagnostics(), annotations);
    }

    internal PredefinedTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 1;
      this.keyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.keyword);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new PredefinedTypeSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
    }
  }

  /// <summary>Class which represents the syntax node for the array type.</summary>
  internal sealed partial class ArrayTypeSyntax : TypeSyntax
  {
    private readonly TypeSyntax elementType;
    private readonly SyntaxNode rankSpecifiers;

    internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxNode rankSpecifiers, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(elementType);
        if (rankSpecifiers != null)
        {
            this.rankSpecifiers = rankSpecifiers;
            this.AdjustFlagsAndWidth(rankSpecifiers);
        }
    }


    internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxNode rankSpecifiers)
        : base(kind)
    {
        this.slotCount = 2;
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(elementType);
        if (rankSpecifiers != null)
        {
            this.rankSpecifiers = rankSpecifiers;
            this.AdjustFlagsAndWidth(rankSpecifiers);
        }
    }

    /// <summary>TypeSyntax node representing the type of the element of the array.</summary>
    public TypeSyntax ElementType { get { return this.elementType; } }
    /// <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
    public SyntaxList<ArrayRankSpecifierSyntax> RankSpecifiers { get { return new SyntaxList<ArrayRankSpecifierSyntax>(this.rankSpecifiers); } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            case 1: return this.rankSpecifiers;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ArrayTypeSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayType(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitArrayType(this);
    }

    public ArrayTypeSyntax Update(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
        if (elementType != this.ElementType || rankSpecifiers != this.RankSpecifiers)
        {
            var newNode = Syntax.ArrayType(elementType, rankSpecifiers);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArrayTypeSyntax(this.Kind, this.elementType, this.rankSpecifiers, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArrayTypeSyntax(this.Kind, this.elementType, this.rankSpecifiers, GetDiagnostics(), annotations);
    }

    internal ArrayTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.elementType = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.elementType);
      this.rankSpecifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.rankSpecifiers);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ArrayTypeSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elementType);
      writer.WriteValue(this.rankSpecifiers);
    }
  }

  internal sealed partial class ArrayRankSpecifierSyntax : SyntaxNode
  {
    private readonly SyntaxToken openBracketToken;
    private readonly SyntaxNode sizes;
    private readonly SyntaxToken closeBracketToken;

    internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, SyntaxNode sizes, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.openBracketToken = openBracketToken;
        this.AdjustFlagsAndWidth(openBracketToken);
        if (sizes != null)
        {
            this.sizes = sizes;
            this.AdjustFlagsAndWidth(sizes);
        }
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(closeBracketToken);
    }


    internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, SyntaxNode sizes, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.openBracketToken = openBracketToken;
        this.AdjustFlagsAndWidth(openBracketToken);
        if (sizes != null)
        {
            this.sizes = sizes;
            this.AdjustFlagsAndWidth(sizes);
        }
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(closeBracketToken);
    }

    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    public SeparatedSyntaxList<ExpressionSyntax> Sizes { get { return new SeparatedSyntaxList<ExpressionSyntax>(new SyntaxList<SyntaxNode>(this.sizes)); } }
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.sizes;
            case 2: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ArrayRankSpecifierSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayRankSpecifier(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitArrayRankSpecifier(this);
    }

    public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || sizes != this.Sizes || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = Syntax.ArrayRankSpecifier(openBracketToken, sizes, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArrayRankSpecifierSyntax(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArrayRankSpecifierSyntax(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, GetDiagnostics(), annotations);
    }

    internal ArrayRankSpecifierSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.openBracketToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openBracketToken);
      this.sizes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.sizes);
      this.closeBracketToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeBracketToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ArrayRankSpecifierSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.sizes);
      writer.WriteValue(this.closeBracketToken);
    }
  }

  /// <summary>Class which represents the syntax node for pointer type.</summary>
  internal sealed partial class PointerTypeSyntax : TypeSyntax
  {
    private readonly TypeSyntax elementType;
    private readonly SyntaxToken asteriskToken;

    internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(elementType);
        this.asteriskToken = asteriskToken;
        this.AdjustFlagsAndWidth(asteriskToken);
    }


    internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken)
        : base(kind)
    {
        this.slotCount = 2;
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(elementType);
        this.asteriskToken = asteriskToken;
        this.AdjustFlagsAndWidth(asteriskToken);
    }

    /// <summary>TypeSyntax node that represents the element type of the pointer.</summary>
    public TypeSyntax ElementType { get { return this.elementType; } }
    /// <summary>SyntaxToken representing the asterisk.</summary>
    public SyntaxToken AsteriskToken { get { return this.asteriskToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            case 1: return this.asteriskToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.PointerTypeSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPointerType(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitPointerType(this);
    }

    public PointerTypeSyntax Update(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
        if (elementType != this.ElementType || asteriskToken != this.AsteriskToken)
        {
            var newNode = Syntax.PointerType(elementType, asteriskToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PointerTypeSyntax(this.Kind, this.elementType, this.asteriskToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PointerTypeSyntax(this.Kind, this.elementType, this.asteriskToken, GetDiagnostics(), annotations);
    }

    internal PointerTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.elementType = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.elementType);
      this.asteriskToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.asteriskToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new PointerTypeSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elementType);
      writer.WriteValue(this.asteriskToken);
    }
  }

  /// <summary>Class which represents the syntax node for a nullable type.</summary>
  internal sealed partial class NullableTypeSyntax : TypeSyntax
  {
    private readonly TypeSyntax elementType;
    private readonly SyntaxToken questionToken;

    internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(elementType);
        this.questionToken = questionToken;
        this.AdjustFlagsAndWidth(questionToken);
    }


    internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken)
        : base(kind)
    {
        this.slotCount = 2;
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(elementType);
        this.questionToken = questionToken;
        this.AdjustFlagsAndWidth(questionToken);
    }

    /// <summary>TypeSyntax node representing the type of the element.</summary>
    public TypeSyntax ElementType { get { return this.elementType; } }
    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken QuestionToken { get { return this.questionToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            case 1: return this.questionToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.NullableTypeSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNullableType(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitNullableType(this);
    }

    public NullableTypeSyntax Update(TypeSyntax elementType, SyntaxToken questionToken)
    {
        if (elementType != this.ElementType || questionToken != this.QuestionToken)
        {
            var newNode = Syntax.NullableType(elementType, questionToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new NullableTypeSyntax(this.Kind, this.elementType, this.questionToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new NullableTypeSyntax(this.Kind, this.elementType, this.questionToken, GetDiagnostics(), annotations);
    }

    internal NullableTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.elementType = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.elementType);
      this.questionToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.questionToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new NullableTypeSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elementType);
      writer.WriteValue(this.questionToken);
    }
  }

  /// <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
  internal sealed partial class OmittedTypeArgumentSyntax : TypeSyntax
  {
    private readonly SyntaxToken omittedTypeArgumentToken;

    internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 1;
        this.omittedTypeArgumentToken = omittedTypeArgumentToken;
        this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
    }


    internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken)
        : base(kind)
    {
        this.slotCount = 1;
        this.omittedTypeArgumentToken = omittedTypeArgumentToken;
        this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
    }

    /// <summary>SyntaxToken representing the omitted type argument.</summary>
    public SyntaxToken OmittedTypeArgumentToken { get { return this.omittedTypeArgumentToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.omittedTypeArgumentToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.OmittedTypeArgumentSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOmittedTypeArgument(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitOmittedTypeArgument(this);
    }

    public OmittedTypeArgumentSyntax Update(SyntaxToken omittedTypeArgumentToken)
    {
        if (omittedTypeArgumentToken != this.OmittedTypeArgumentToken)
        {
            var newNode = Syntax.OmittedTypeArgument(omittedTypeArgumentToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OmittedTypeArgumentSyntax(this.Kind, this.omittedTypeArgumentToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OmittedTypeArgumentSyntax(this.Kind, this.omittedTypeArgumentToken, GetDiagnostics(), annotations);
    }

    internal OmittedTypeArgumentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 1;
      this.omittedTypeArgumentToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.omittedTypeArgumentToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new OmittedTypeArgumentSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.omittedTypeArgumentToken);
    }
  }

  /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class ExpressionSyntax : SyntaxNode
  {
    internal ExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal ExpressionSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected ExpressionSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
  internal sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken openParenToken;
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken closeParenToken;

    internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }


    internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.expression;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ParenthesizedExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParenthesizedExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitParenthesizedExpression(this);
    }

    public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.ParenthesizedExpression(openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal ParenthesizedExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ParenthesizedExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for prefix unary expression.</summary>
  internal sealed partial class PrefixUnaryExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken operatorToken;
    private readonly ExpressionSyntax operand;

    internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operand = operand;
        this.AdjustFlagsAndWidth(operand);
    }


    internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
        : base(kind)
    {
        this.slotCount = 2;
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operand = operand;
        this.AdjustFlagsAndWidth(operand);
    }

    /// <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    /// <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
    public ExpressionSyntax Operand { get { return this.operand; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operatorToken;
            case 1: return this.operand;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.PrefixUnaryExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPrefixUnaryExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitPrefixUnaryExpression(this);
    }

    public PrefixUnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand)
    {
        if (operatorToken != this.OperatorToken || operand != this.Operand)
        {
            var newNode = Syntax.PrefixUnaryExpression(this.Kind, operatorToken, operand);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PrefixUnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PrefixUnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, GetDiagnostics(), annotations);
    }

    internal PrefixUnaryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.operatorToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.operatorToken);
      this.operand = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.operand);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new PrefixUnaryExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.operand);
    }
  }

  /// <summary>Class which represents the syntax node for postfix unary expression.</summary>
  internal sealed partial class PostfixUnaryExpressionSyntax : ExpressionSyntax
  {
    private readonly ExpressionSyntax operand;
    private readonly SyntaxToken operatorToken;

    internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.operand = operand;
        this.AdjustFlagsAndWidth(operand);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operatorToken);
    }


    internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
        : base(kind)
    {
        this.slotCount = 2;
        this.operand = operand;
        this.AdjustFlagsAndWidth(operand);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operatorToken);
    }

    /// <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
    public ExpressionSyntax Operand { get { return this.operand; } }
    /// <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operand;
            case 1: return this.operatorToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.PostfixUnaryExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPostfixUnaryExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitPostfixUnaryExpression(this);
    }

    public PostfixUnaryExpressionSyntax Update(ExpressionSyntax operand, SyntaxToken operatorToken)
    {
        if (operand != this.Operand || operatorToken != this.OperatorToken)
        {
            var newNode = Syntax.PostfixUnaryExpression(this.Kind, operand, operatorToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PostfixUnaryExpressionSyntax(this.Kind, this.operand, this.operatorToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PostfixUnaryExpressionSyntax(this.Kind, this.operand, this.operatorToken, GetDiagnostics(), annotations);
    }

    internal PostfixUnaryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.operand = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.operand);
      this.operatorToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.operatorToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new PostfixUnaryExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.operand);
      writer.WriteValue(this.operatorToken);
    }
  }

  /// <summary>Class which represents the syntax node for member access expression.</summary>
  internal sealed partial class MemberAccessExpressionSyntax : ExpressionSyntax
  {
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken operatorToken;
    private readonly SimpleNameSyntax name;

    internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operatorToken);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
    }


    internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
        : base(kind)
    {
        this.slotCount = 3;
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operatorToken);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
    }

    /// <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    /// <summary>SimpleNameSyntax node representing the member being accessed.</summary>
    public SimpleNameSyntax Name { get { return this.name; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.operatorToken;
            case 2: return this.name;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.MemberAccessExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMemberAccessExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitMemberAccessExpression(this);
    }

    public MemberAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
        if (expression != this.Expression || operatorToken != this.OperatorToken || name != this.Name)
        {
            var newNode = Syntax.MemberAccessExpression(this.Kind, expression, operatorToken, name);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new MemberAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.name, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new MemberAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.name, GetDiagnostics(), annotations);
    }

    internal MemberAccessExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.operatorToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.operatorToken);
      this.name = (SimpleNameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.name);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new MemberAccessExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.name);
    }
  }

  /// <summary>Class which represents an expression that has a binary operator.</summary>
  internal sealed partial class BinaryExpressionSyntax : ExpressionSyntax
  {
    private readonly ExpressionSyntax left;
    private readonly SyntaxToken operatorToken;
    private readonly ExpressionSyntax right;

    internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.left = left;
        this.AdjustFlagsAndWidth(left);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operatorToken);
        this.right = right;
        this.AdjustFlagsAndWidth(right);
    }


    internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        : base(kind)
    {
        this.slotCount = 3;
        this.left = left;
        this.AdjustFlagsAndWidth(left);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operatorToken);
        this.right = right;
        this.AdjustFlagsAndWidth(right);
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
    public ExpressionSyntax Left { get { return this.left; } }
    /// <summary>SyntaxToken representing the operator of the binary expression.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    /// <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
    public ExpressionSyntax Right { get { return this.right; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 1: return this.operatorToken;
            case 2: return this.right;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.BinaryExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBinaryExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBinaryExpression(this);
    }

    public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
        if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
        {
            var newNode = Syntax.BinaryExpression(this.Kind, left, operatorToken, right);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);
    }

    internal BinaryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.left = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.left);
      this.operatorToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.operatorToken);
      this.right = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.right);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new BinaryExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.left);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.right);
    }
  }

  /// <summary>Class which represents the syntax node for conditional expression.</summary>
  internal sealed partial class ConditionalExpressionSyntax : ExpressionSyntax
  {
    private readonly ExpressionSyntax condition;
    private readonly SyntaxToken questionToken;
    private readonly ExpressionSyntax whenTrue;
    private readonly SyntaxToken colonToken;
    private readonly ExpressionSyntax whenFalse;

    internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 5;
        this.condition = condition;
        this.AdjustFlagsAndWidth(condition);
        this.questionToken = questionToken;
        this.AdjustFlagsAndWidth(questionToken);
        this.whenTrue = whenTrue;
        this.AdjustFlagsAndWidth(whenTrue);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
        this.whenFalse = whenFalse;
        this.AdjustFlagsAndWidth(whenFalse);
    }


    internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
        : base(kind)
    {
        this.slotCount = 5;
        this.condition = condition;
        this.AdjustFlagsAndWidth(condition);
        this.questionToken = questionToken;
        this.AdjustFlagsAndWidth(questionToken);
        this.whenTrue = whenTrue;
        this.AdjustFlagsAndWidth(whenTrue);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
        this.whenFalse = whenFalse;
        this.AdjustFlagsAndWidth(whenFalse);
    }

    /// <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
    public ExpressionSyntax Condition { get { return this.condition; } }
    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken QuestionToken { get { return this.questionToken; } }
    /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
    public ExpressionSyntax WhenTrue { get { return this.whenTrue; } }
    public SyntaxToken ColonToken { get { return this.colonToken; } }
    /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
    public ExpressionSyntax WhenFalse { get { return this.whenFalse; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.condition;
            case 1: return this.questionToken;
            case 2: return this.whenTrue;
            case 3: return this.colonToken;
            case 4: return this.whenFalse;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ConditionalExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConditionalExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitConditionalExpression(this);
    }

    public ConditionalExpressionSyntax Update(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
        if (condition != this.Condition || questionToken != this.QuestionToken || whenTrue != this.WhenTrue || colonToken != this.ColonToken || whenFalse != this.WhenFalse)
        {
            var newNode = Syntax.ConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConditionalExpressionSyntax(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConditionalExpressionSyntax(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, GetDiagnostics(), annotations);
    }

    internal ConditionalExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 5;
      this.condition = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.condition);
      this.questionToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.questionToken);
      this.whenTrue = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.whenTrue);
      this.colonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.colonToken);
      this.whenFalse = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.whenFalse);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ConditionalExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.questionToken);
      writer.WriteValue(this.whenTrue);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.whenFalse);
    }
  }

  /// <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class InstanceExpressionSyntax : ExpressionSyntax
  {
    internal InstanceExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal InstanceExpressionSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected InstanceExpressionSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Class which represents the syntax node for a this expression.</summary>
  internal sealed partial class ThisExpressionSyntax : InstanceExpressionSyntax
  {
    private readonly SyntaxToken token;

    internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 1;
        this.token = token;
        this.AdjustFlagsAndWidth(token);
    }


    internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token)
        : base(kind)
    {
        this.slotCount = 1;
        this.token = token;
        this.AdjustFlagsAndWidth(token);
    }

    /// <summary>SyntaxToken representing the this keyword.</summary>
    public SyntaxToken Token { get { return this.token; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.token;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ThisExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitThisExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitThisExpression(this);
    }

    public ThisExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = Syntax.ThisExpression(token);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ThisExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ThisExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);
    }

    internal ThisExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 1;
      this.token = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.token);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ThisExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.token);
    }
  }

  /// <summary>Class which represents the syntax node for a base expression.</summary>
  internal sealed partial class BaseExpressionSyntax : InstanceExpressionSyntax
  {
    private readonly SyntaxToken token;

    internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 1;
        this.token = token;
        this.AdjustFlagsAndWidth(token);
    }


    internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token)
        : base(kind)
    {
        this.slotCount = 1;
        this.token = token;
        this.AdjustFlagsAndWidth(token);
    }

    /// <summary>SyntaxToken representing the base keyword.</summary>
    public SyntaxToken Token { get { return this.token; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.token;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.BaseExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBaseExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBaseExpression(this);
    }

    public BaseExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = Syntax.BaseExpression(token);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BaseExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BaseExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);
    }

    internal BaseExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 1;
      this.token = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.token);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new BaseExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.token);
    }
  }

  /// <summary>Class which represents the syntax node for a literal expression.</summary>
  internal sealed partial class LiteralExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken token;

    internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 1;
        this.token = token;
        this.AdjustFlagsAndWidth(token);
    }


    internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token)
        : base(kind)
    {
        this.slotCount = 1;
        this.token = token;
        this.AdjustFlagsAndWidth(token);
    }

    /// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
    public SyntaxToken Token { get { return this.token; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.token;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.LiteralExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLiteralExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitLiteralExpression(this);
    }

    public LiteralExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = Syntax.LiteralExpression(this.Kind, token);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LiteralExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LiteralExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);
    }

    internal LiteralExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 1;
      this.token = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.token);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new LiteralExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.token);
    }
  }

  /// <summary>Class which represents the syntax node for MakeRef expression.</summary>
  internal sealed partial class MakeRefExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken keyword;
    private readonly SyntaxToken openParenToken;
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken closeParenToken;

    internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }


    internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }

    /// <summary>SyntaxToken representing the MakeRefKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.MakeRefExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMakeRefExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitMakeRefExpression(this);
    }

    public MakeRefExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.MakeRefExpression(keyword, openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new MakeRefExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new MakeRefExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal MakeRefExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.keyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.keyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new MakeRefExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for RefType expression.</summary>
  internal sealed partial class RefTypeExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken keyword;
    private readonly SyntaxToken openParenToken;
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken closeParenToken;

    internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }


    internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }

    /// <summary>SyntaxToken representing the RefTypeKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.RefTypeExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefTypeExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitRefTypeExpression(this);
    }

    public RefTypeExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.RefTypeExpression(keyword, openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new RefTypeExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new RefTypeExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal RefTypeExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.keyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.keyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new RefTypeExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for RefValue expression.</summary>
  internal sealed partial class RefValueExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken keyword;
    private readonly SyntaxToken openParenToken;
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken comma;
    private readonly TypeSyntax type;
    private readonly SyntaxToken closeParenToken;

    internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 6;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.comma = comma;
        this.AdjustFlagsAndWidth(comma);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }


    internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.slotCount = 6;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.comma = comma;
        this.AdjustFlagsAndWidth(comma);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }

    /// <summary>SyntaxToken representing the RefValueKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Typed reference expression.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>Comma separating the arguments.</summary>
    public SyntaxToken Comma { get { return this.comma; } }
    /// <summary>The type of the value.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.comma;
            case 4: return this.type;
            case 5: return this.closeParenToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.RefValueExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefValueExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitRefValueExpression(this);
    }

    public RefValueExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || comma != this.Comma || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.RefValueExpression(keyword, openParenToken, expression, comma, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new RefValueExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.comma, this.type, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new RefValueExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.comma, this.type, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal RefValueExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 6;
      this.keyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.keyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.comma = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.comma);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new RefValueExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.comma);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
  internal sealed partial class CheckedExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken keyword;
    private readonly SyntaxToken openParenToken;
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken closeParenToken;

    internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }


    internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }

    /// <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.CheckedExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCheckedExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCheckedExpression(this);
    }

    public CheckedExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.CheckedExpression(this.Kind, keyword, openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CheckedExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CheckedExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal CheckedExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.keyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.keyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new CheckedExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for Default expression.</summary>
  internal sealed partial class DefaultExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken keyword;
    private readonly SyntaxToken openParenToken;
    private readonly TypeSyntax type;
    private readonly SyntaxToken closeParenToken;

    internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }


    internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }

    /// <summary>SyntaxToken representing the DefaultKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Argument of the primary function.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.type;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.DefaultExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefaultExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitDefaultExpression(this);
    }

    public DefaultExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.DefaultExpression(keyword, openParenToken, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DefaultExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DefaultExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal DefaultExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.keyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.keyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new DefaultExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for TypeOf expression.</summary>
  internal sealed partial class TypeOfExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken keyword;
    private readonly SyntaxToken openParenToken;
    private readonly TypeSyntax type;
    private readonly SyntaxToken closeParenToken;

    internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }


    internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }

    /// <summary>SyntaxToken representing the TypeOfKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>The expression to return type of.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.type;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.TypeOfExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeOfExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitTypeOfExpression(this);
    }

    public TypeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.TypeOfExpression(keyword, openParenToken, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal TypeOfExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.keyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.keyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new TypeOfExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for SizeOf expression.</summary>
  internal sealed partial class SizeOfExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken keyword;
    private readonly SyntaxToken openParenToken;
    private readonly TypeSyntax type;
    private readonly SyntaxToken closeParenToken;

    internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }


    internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }

    /// <summary>SyntaxToken representing the SizeOfKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Argument of the primary function.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.type;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.SizeOfExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSizeOfExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitSizeOfExpression(this);
    }

    public SizeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.SizeOfExpression(keyword, openParenToken, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SizeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SizeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal SizeOfExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.keyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.keyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new SizeOfExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for invocation expression.</summary>
  internal sealed partial class InvocationExpressionSyntax : ExpressionSyntax
  {
    private readonly ExpressionSyntax expression;
    private readonly ArgumentListSyntax argumentList;

    internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.argumentList = argumentList;
        this.AdjustFlagsAndWidth(argumentList);
    }


    internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList)
        : base(kind)
    {
        this.slotCount = 2;
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.argumentList = argumentList;
        this.AdjustFlagsAndWidth(argumentList);
    }

    /// <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
    public ArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.InvocationExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInvocationExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitInvocationExpression(this);
    }

    public InvocationExpressionSyntax Update(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
        if (expression != this.Expression || argumentList != this.ArgumentList)
        {
            var newNode = Syntax.InvocationExpression(expression, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InvocationExpressionSyntax(this.Kind, this.expression, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InvocationExpressionSyntax(this.Kind, this.expression, this.argumentList, GetDiagnostics(), annotations);
    }

    internal InvocationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.argumentList = (ArgumentListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.argumentList);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new InvocationExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.argumentList);
    }
  }

  /// <summary>Class which represents the syntax node for element access expression.</summary>
  internal sealed partial class ElementAccessExpressionSyntax : ExpressionSyntax
  {
    private readonly ExpressionSyntax expression;
    private readonly BracketedArgumentListSyntax argumentList;

    internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.argumentList = argumentList;
        this.AdjustFlagsAndWidth(argumentList);
    }


    internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
        : base(kind)
    {
        this.slotCount = 2;
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.argumentList = argumentList;
        this.AdjustFlagsAndWidth(argumentList);
    }

    /// <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
    public BracketedArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ElementAccessExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElementAccessExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitElementAccessExpression(this);
    }

    public ElementAccessExpressionSyntax Update(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
        if (expression != this.Expression || argumentList != this.ArgumentList)
        {
            var newNode = Syntax.ElementAccessExpression(expression, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ElementAccessExpressionSyntax(this.Kind, this.expression, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ElementAccessExpressionSyntax(this.Kind, this.expression, this.argumentList, GetDiagnostics(), annotations);
    }

    internal ElementAccessExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.argumentList);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ElementAccessExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.argumentList);
    }
  }

  /// <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class BaseArgumentListSyntax : SyntaxNode
  {
    internal BaseArgumentListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseArgumentListSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseArgumentListSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
    public abstract SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
  }

  /// <summary>Class which represents the syntax node for the list of arguments.</summary>
  internal sealed partial class ArgumentListSyntax : BaseArgumentListSyntax
  {
    private readonly SyntaxToken openParenToken;
    private readonly SyntaxNode arguments;
    private readonly SyntaxToken closeParenToken;

    internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, SyntaxNode arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        if (arguments != null)
        {
            this.arguments = arguments;
            this.AdjustFlagsAndWidth(arguments);
        }
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }


    internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, SyntaxNode arguments, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        if (arguments != null)
        {
            this.arguments = arguments;
            this.AdjustFlagsAndWidth(arguments);
        }
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public override SeparatedSyntaxList<ArgumentSyntax> Arguments { get { return new SeparatedSyntaxList<ArgumentSyntax>(new SyntaxList<SyntaxNode>(this.arguments)); } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.arguments;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ArgumentListSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArgumentList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitArgumentList(this);
    }

    public ArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.ArgumentList(openParenToken, arguments, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal ArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.arguments = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.arguments);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ArgumentListSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for bracketed argument list.</summary>
  internal sealed partial class BracketedArgumentListSyntax : BaseArgumentListSyntax
  {
    private readonly SyntaxToken openBracketToken;
    private readonly SyntaxNode arguments;
    private readonly SyntaxToken closeBracketToken;

    internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, SyntaxNode arguments, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.openBracketToken = openBracketToken;
        this.AdjustFlagsAndWidth(openBracketToken);
        if (arguments != null)
        {
            this.arguments = arguments;
            this.AdjustFlagsAndWidth(arguments);
        }
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(closeBracketToken);
    }


    internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, SyntaxNode arguments, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.openBracketToken = openBracketToken;
        this.AdjustFlagsAndWidth(openBracketToken);
        if (arguments != null)
        {
            this.arguments = arguments;
            this.AdjustFlagsAndWidth(arguments);
        }
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(closeBracketToken);
    }

    /// <summary>SyntaxToken representing open bracket.</summary>
    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public override SeparatedSyntaxList<ArgumentSyntax> Arguments { get { return new SeparatedSyntaxList<ArgumentSyntax>(new SyntaxList<SyntaxNode>(this.arguments)); } }
    /// <summary>SyntaxToken representing close bracket.</summary>
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.arguments;
            case 2: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.BracketedArgumentListSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBracketedArgumentList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBracketedArgumentList(this);
    }

    public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || arguments != this.Arguments || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = Syntax.BracketedArgumentList(openBracketToken, arguments, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BracketedArgumentListSyntax(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BracketedArgumentListSyntax(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, GetDiagnostics(), annotations);
    }

    internal BracketedArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.openBracketToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openBracketToken);
      this.arguments = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.arguments);
      this.closeBracketToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeBracketToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new BracketedArgumentListSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.closeBracketToken);
    }
  }

  /// <summary>Class which represents the syntax node for argument.</summary>
  internal sealed partial class ArgumentSyntax : SyntaxNode
  {
    private readonly NameColonSyntax nameColon;
    private readonly SyntaxToken refOrOutKeyword;
    private readonly ExpressionSyntax expression;

    internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        if (nameColon != null)
        {
            this.nameColon = nameColon;
            this.AdjustFlagsAndWidth(nameColon);
        }
        if (refOrOutKeyword != null)
        {
            this.refOrOutKeyword = refOrOutKeyword;
            this.AdjustFlagsAndWidth(refOrOutKeyword);
        }
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
    }


    internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.slotCount = 3;
        if (nameColon != null)
        {
            this.nameColon = nameColon;
            this.AdjustFlagsAndWidth(nameColon);
        }
        if (refOrOutKeyword != null)
        {
            this.refOrOutKeyword = refOrOutKeyword;
            this.AdjustFlagsAndWidth(refOrOutKeyword);
        }
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
    }

    /// <summary>NameColonSyntax node representing the optional name arguments.</summary>
    public NameColonSyntax NameColon { get { return this.nameColon; } }
    /// <summary>SyntaxToken representing the optional ref or out keyword.</summary>
    public SyntaxToken RefOrOutKeyword { get { return this.refOrOutKeyword; } }
    /// <summary>ExpressionSyntax node representing the argument.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameColon;
            case 1: return this.refOrOutKeyword;
            case 2: return this.expression;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ArgumentSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArgument(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitArgument(this);
    }

    public ArgumentSyntax Update(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)
    {
        if (nameColon != this.NameColon || refOrOutKeyword != this.RefOrOutKeyword || expression != this.Expression)
        {
            var newNode = Syntax.Argument(nameColon, refOrOutKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArgumentSyntax(this.Kind, this.nameColon, this.refOrOutKeyword, this.expression, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArgumentSyntax(this.Kind, this.nameColon, this.refOrOutKeyword, this.expression, GetDiagnostics(), annotations);
    }

    internal ArgumentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.nameColon = (NameColonSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.nameColon);
      this.refOrOutKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.refOrOutKeyword);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ArgumentSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.nameColon);
      writer.WriteValue(this.refOrOutKeyword);
      writer.WriteValue(this.expression);
    }
  }

  /// <summary>Class which represents the syntax node for name colon syntax.</summary>
  internal sealed partial class NameColonSyntax : SyntaxNode
  {
    private readonly IdentifierNameSyntax identifier;
    private readonly SyntaxToken colonToken;

    internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax identifier, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
    }


    internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax identifier, SyntaxToken colonToken)
        : base(kind)
    {
        this.slotCount = 2;
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
    }

    /// <summary>SyntaxToken representing the identifer name.</summary>
    public IdentifierNameSyntax Identifier { get { return this.identifier; } }
    /// <summary>SyntaxToken representing colon.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.NameColonSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameColon(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitNameColon(this);
    }

    public NameColonSyntax Update(IdentifierNameSyntax identifier, SyntaxToken colonToken)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken)
        {
            var newNode = Syntax.NameColon(identifier, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new NameColonSyntax(this.Kind, this.identifier, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new NameColonSyntax(this.Kind, this.identifier, this.colonToken, GetDiagnostics(), annotations);
    }

    internal NameColonSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.identifier = (IdentifierNameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.colonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.colonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new NameColonSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.colonToken);
    }
  }

  /// <summary>Class which represents the syntax node for cast expression.</summary>
  internal sealed partial class CastExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken openParenToken;
    private readonly TypeSyntax type;
    private readonly SyntaxToken closeParenToken;
    private readonly ExpressionSyntax expression;

    internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
    }


    internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
        : base(kind)
    {
        this.slotCount = 4;
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>TypeSyntax node representing the type the expression is being casted to.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    /// <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.type;
            case 2: return this.closeParenToken;
            case 3: return this.expression;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.CastExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCastExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCastExpression(this);
    }

    public CastExpressionSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
        if (openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken || expression != this.Expression)
        {
            var newNode = Syntax.CastExpression(openParenToken, type, closeParenToken, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CastExpressionSyntax(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CastExpressionSyntax(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, GetDiagnostics(), annotations);
    }

    internal CastExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new CastExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.expression);
    }
  }

  /// <summary>Class which represents the syntax node for anonymous method expression.</summary>
  internal sealed partial class AnonymousMethodExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken delegateKeyword;
    private readonly ParameterListSyntax parameterList;
    private readonly BlockSyntax block;

    internal AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.delegateKeyword = delegateKeyword;
        this.AdjustFlagsAndWidth(delegateKeyword);
        if (parameterList != null)
        {
            this.parameterList = parameterList;
            this.AdjustFlagsAndWidth(parameterList);
        }
        this.block = block;
        this.AdjustFlagsAndWidth(block);
    }


    internal AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, BlockSyntax block)
        : base(kind)
    {
        this.slotCount = 3;
        this.delegateKeyword = delegateKeyword;
        this.AdjustFlagsAndWidth(delegateKeyword);
        if (parameterList != null)
        {
            this.parameterList = parameterList;
            this.AdjustFlagsAndWidth(parameterList);
        }
        this.block = block;
        this.AdjustFlagsAndWidth(block);
    }

    /// <summary>SyntaxToken representing the delegate keyword.</summary>
    public SyntaxToken DelegateKeyword { get { return this.delegateKeyword; } }
    /// <summary>List of parameters of the anonymous method expression.</summary>
    public ParameterListSyntax ParameterList { get { return this.parameterList; } }
    /// <summary>BlockSyntax node representing the body of the anonymous method.</summary>
    public BlockSyntax Block { get { return this.block; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.delegateKeyword;
            case 1: return this.parameterList;
            case 2: return this.block;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.AnonymousMethodExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousMethodExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAnonymousMethodExpression(this);
    }

    public AnonymousMethodExpressionSyntax Update(SyntaxToken delegateKeyword, ParameterListSyntax parameterList, BlockSyntax block)
    {
        if (delegateKeyword != this.DelegateKeyword || parameterList != this.ParameterList || block != this.Block)
        {
            var newNode = Syntax.AnonymousMethodExpression(delegateKeyword, parameterList, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AnonymousMethodExpressionSyntax(this.Kind, this.delegateKeyword, this.parameterList, this.block, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AnonymousMethodExpressionSyntax(this.Kind, this.delegateKeyword, this.parameterList, this.block, GetDiagnostics(), annotations);
    }

    internal AnonymousMethodExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.delegateKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.delegateKeyword);
      this.parameterList = (ParameterListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.parameterList);
      this.block = (BlockSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.block);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new AnonymousMethodExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.delegateKeyword);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.block);
    }
  }

  /// <summary>Class which represents the syntax node for a simple lambda expression.</summary>
  internal sealed partial class SimpleLambdaExpressionSyntax : ExpressionSyntax
  {
    private readonly ParameterSyntax parameter;
    private readonly SyntaxToken arrowToken;
    private readonly SyntaxNode body;

    internal SimpleLambdaExpressionSyntax(SyntaxKind kind, ParameterSyntax parameter, SyntaxToken arrowToken, SyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.parameter = parameter;
        this.AdjustFlagsAndWidth(parameter);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(arrowToken);
        this.body = body;
        this.AdjustFlagsAndWidth(body);
    }


    internal SimpleLambdaExpressionSyntax(SyntaxKind kind, ParameterSyntax parameter, SyntaxToken arrowToken, SyntaxNode body)
        : base(kind)
    {
        this.slotCount = 3;
        this.parameter = parameter;
        this.AdjustFlagsAndWidth(parameter);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(arrowToken);
        this.body = body;
        this.AdjustFlagsAndWidth(body);
    }

    /// <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
    public ParameterSyntax Parameter { get { return this.parameter; } }
    /// <summary>SyntaxToken representing equals greater than.</summary>
    public SyntaxToken ArrowToken { get { return this.arrowToken; } }
    /// <summary>SyntaxNode representing the body of the lambda expression.</summary>
    public SyntaxNode Body { get { return this.body; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.parameter;
            case 1: return this.arrowToken;
            case 2: return this.body;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.SimpleLambdaExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSimpleLambdaExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitSimpleLambdaExpression(this);
    }

    public SimpleLambdaExpressionSyntax Update(ParameterSyntax parameter, SyntaxToken arrowToken, SyntaxNode body)
    {
        if (parameter != this.Parameter || arrowToken != this.ArrowToken || body != this.Body)
        {
            var newNode = Syntax.SimpleLambdaExpression(parameter, arrowToken, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SimpleLambdaExpressionSyntax(this.Kind, this.parameter, this.arrowToken, this.body, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SimpleLambdaExpressionSyntax(this.Kind, this.parameter, this.arrowToken, this.body, GetDiagnostics(), annotations);
    }

    internal SimpleLambdaExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.parameter = (ParameterSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.parameter);
      this.arrowToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.arrowToken);
      this.body = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.body);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new SimpleLambdaExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.parameter);
      writer.WriteValue(this.arrowToken);
      writer.WriteValue(this.body);
    }
  }

  /// <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
  internal sealed partial class ParenthesizedLambdaExpressionSyntax : ExpressionSyntax
  {
    private readonly ParameterListSyntax parameterList;
    private readonly SyntaxToken arrowToken;
    private readonly SyntaxNode body;

    internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, ParameterListSyntax parameterList, SyntaxToken arrowToken, SyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(arrowToken);
        this.body = body;
        this.AdjustFlagsAndWidth(body);
    }


    internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, ParameterListSyntax parameterList, SyntaxToken arrowToken, SyntaxNode body)
        : base(kind)
    {
        this.slotCount = 3;
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(arrowToken);
        this.body = body;
        this.AdjustFlagsAndWidth(body);
    }

    /// <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
    public ParameterListSyntax ParameterList { get { return this.parameterList; } }
    /// <summary>SyntaxToken representing equals greater than.</summary>
    public SyntaxToken ArrowToken { get { return this.arrowToken; } }
    /// <summary>SyntaxNode representing the body of the lambda expression.</summary>
    public SyntaxNode Body { get { return this.body; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.parameterList;
            case 1: return this.arrowToken;
            case 2: return this.body;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ParenthesizedLambdaExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParenthesizedLambdaExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitParenthesizedLambdaExpression(this);
    }

    public ParenthesizedLambdaExpressionSyntax Update(ParameterListSyntax parameterList, SyntaxToken arrowToken, SyntaxNode body)
    {
        if (parameterList != this.ParameterList || arrowToken != this.ArrowToken || body != this.Body)
        {
            var newNode = Syntax.ParenthesizedLambdaExpression(parameterList, arrowToken, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ParenthesizedLambdaExpressionSyntax(this.Kind, this.parameterList, this.arrowToken, this.body, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ParenthesizedLambdaExpressionSyntax(this.Kind, this.parameterList, this.arrowToken, this.body, GetDiagnostics(), annotations);
    }

    internal ParenthesizedLambdaExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.parameterList = (ParameterListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.parameterList);
      this.arrowToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.arrowToken);
      this.body = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.body);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ParenthesizedLambdaExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.arrowToken);
      writer.WriteValue(this.body);
    }
  }

  /// <summary>Class which represents the syntax node for initializer expression.</summary>
  internal sealed partial class InitializerExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken openBraceToken;
    private readonly SyntaxNode expressions;
    private readonly SyntaxToken closeBraceToken;

    internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, SyntaxNode expressions, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (expressions != null)
        {
            this.expressions = expressions;
            this.AdjustFlagsAndWidth(expressions);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
    }


    internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, SyntaxNode expressions, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (expressions != null)
        {
            this.expressions = expressions;
            this.AdjustFlagsAndWidth(expressions);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
    }

    /// <summary>SyntaxToken representing the open brace.</summary>
    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    /// <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
    public SeparatedSyntaxList<ExpressionSyntax> Expressions { get { return new SeparatedSyntaxList<ExpressionSyntax>(new SyntaxList<SyntaxNode>(this.expressions)); } }
    /// <summary>SyntaxToken representing the close brace.</summary>
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.expressions;
            case 2: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.InitializerExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInitializerExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitInitializerExpression(this);
    }

    public InitializerExpressionSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || expressions != this.Expressions || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = Syntax.InitializerExpression(this.Kind, openBraceToken, expressions, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InitializerExpressionSyntax(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InitializerExpressionSyntax(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal InitializerExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.openBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openBraceToken);
      this.expressions = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.expressions);
      this.closeBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeBraceToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new InitializerExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.expressions);
      writer.WriteValue(this.closeBraceToken);
    }
  }

  /// <summary>Class which represents the syntax node for object creation expression.</summary>
  internal sealed partial class ObjectCreationExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken newKeyword;
    private readonly TypeSyntax type;
    private readonly ArgumentListSyntax argumentList;
    private readonly InitializerExpressionSyntax initializer;

    internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(newKeyword);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        if (argumentList != null)
        {
            this.argumentList = argumentList;
            this.AdjustFlagsAndWidth(argumentList);
        }
        if (initializer != null)
        {
            this.initializer = initializer;
            this.AdjustFlagsAndWidth(initializer);
        }
    }


    internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
        : base(kind)
    {
        this.slotCount = 4;
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(newKeyword);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        if (argumentList != null)
        {
            this.argumentList = argumentList;
            this.AdjustFlagsAndWidth(argumentList);
        }
        if (initializer != null)
        {
            this.initializer = initializer;
            this.AdjustFlagsAndWidth(initializer);
        }
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword { get { return this.newKeyword; } }
    /// <summary>TypeSyntax representing the type of the object being created.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
    public ArgumentListSyntax ArgumentList { get { return this.argumentList; } }
    /// <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
    public InitializerExpressionSyntax Initializer { get { return this.initializer; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.type;
            case 2: return this.argumentList;
            case 3: return this.initializer;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ObjectCreationExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitObjectCreationExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitObjectCreationExpression(this);
    }

    public ObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || type != this.Type || argumentList != this.ArgumentList || initializer != this.Initializer)
        {
            var newNode = Syntax.ObjectCreationExpression(newKeyword, type, argumentList, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.argumentList, this.initializer, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.argumentList, this.initializer, GetDiagnostics(), annotations);
    }

    internal ObjectCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.newKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.newKeyword);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.argumentList = (ArgumentListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.argumentList);
      this.initializer = (InitializerExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.initializer);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ObjectCreationExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.argumentList);
      writer.WriteValue(this.initializer);
    }
  }

  internal sealed partial class AnonymousObjectMemberDeclaratorSyntax : SyntaxNode
  {
    private readonly NameEqualsSyntax nameEquals;
    private readonly ExpressionSyntax expression;

    internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        if (nameEquals != null)
        {
            this.nameEquals = nameEquals;
            this.AdjustFlagsAndWidth(nameEquals);
        }
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
    }


    internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, ExpressionSyntax expression)
        : base(kind)
    {
        this.slotCount = 2;
        if (nameEquals != null)
        {
            this.nameEquals = nameEquals;
            this.AdjustFlagsAndWidth(nameEquals);
        }
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
    }

    /// <summary>NameEqualsSyntax representing the optional name of the property being initialized.</summary>
    public NameEqualsSyntax NameEquals { get { return this.nameEquals; } }
    /// <summary>ExpressionSyntax representing the value the property is initialized with.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameEquals;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.AnonymousObjectMemberDeclaratorSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousObjectMemberDeclarator(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAnonymousObjectMemberDeclarator(this);
    }

    public AnonymousObjectMemberDeclaratorSyntax Update(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
        if (nameEquals != this.NameEquals || expression != this.Expression)
        {
            var newNode = Syntax.AnonymousObjectMemberDeclarator(nameEquals, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AnonymousObjectMemberDeclaratorSyntax(this.Kind, this.nameEquals, this.expression, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AnonymousObjectMemberDeclaratorSyntax(this.Kind, this.nameEquals, this.expression, GetDiagnostics(), annotations);
    }

    internal AnonymousObjectMemberDeclaratorSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.nameEquals = (NameEqualsSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.nameEquals);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new AnonymousObjectMemberDeclaratorSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.nameEquals);
      writer.WriteValue(this.expression);
    }
  }

  /// <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
  internal sealed partial class AnonymousObjectCreationExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken newKeyword;
    private readonly SyntaxToken openBraceToken;
    private readonly SyntaxNode initializers;
    private readonly SyntaxToken closeBraceToken;

    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, SyntaxNode initializers, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(newKeyword);
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (initializers != null)
        {
            this.initializers = initializers;
            this.AdjustFlagsAndWidth(initializers);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
    }


    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, SyntaxNode initializers, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(newKeyword);
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (initializers != null)
        {
            this.initializers = initializers;
            this.AdjustFlagsAndWidth(initializers);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword { get { return this.newKeyword; } }
    /// <summary>SyntaxToken representing the open brace.</summary>
    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    /// <summary>SeparatedSyntaxList of AnonymousObjectPropertyInitializerSyntax representing the list of object property initializers.</summary>
    public SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> Initializers { get { return new SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>(new SyntaxList<SyntaxNode>(this.initializers)); } }
    /// <summary>SyntaxToken representing the close brace.</summary>
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.openBraceToken;
            case 2: return this.initializers;
            case 3: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.AnonymousObjectCreationExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousObjectCreationExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAnonymousObjectCreationExpression(this);
    }

    public AnonymousObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
        if (newKeyword != this.NewKeyword || openBraceToken != this.OpenBraceToken || initializers != this.Initializers || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = Syntax.AnonymousObjectCreationExpression(newKeyword, openBraceToken, initializers, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AnonymousObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBraceToken, this.initializers, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AnonymousObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBraceToken, this.initializers, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal AnonymousObjectCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.newKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.newKeyword);
      this.openBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openBraceToken);
      this.initializers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.initializers);
      this.closeBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeBraceToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new AnonymousObjectCreationExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.initializers);
      writer.WriteValue(this.closeBraceToken);
    }
  }

  /// <summary>Class which represents the syntax node for array creation expression.</summary>
  internal sealed partial class ArrayCreationExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken newKeyword;
    private readonly ArrayTypeSyntax type;
    private readonly InitializerExpressionSyntax initializer;

    internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(newKeyword);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        if (initializer != null)
        {
            this.initializer = initializer;
            this.AdjustFlagsAndWidth(initializer);
        }
    }


    internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
        : base(kind)
    {
        this.slotCount = 3;
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(newKeyword);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        if (initializer != null)
        {
            this.initializer = initializer;
            this.AdjustFlagsAndWidth(initializer);
        }
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword { get { return this.newKeyword; } }
    /// <summary>ArrayTypeSyntax node representing the type of the array.</summary>
    public ArrayTypeSyntax Type { get { return this.type; } }
    /// <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
    public InitializerExpressionSyntax Initializer { get { return this.initializer; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.type;
            case 2: return this.initializer;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ArrayCreationExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayCreationExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitArrayCreationExpression(this);
    }

    public ArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || type != this.Type || initializer != this.Initializer)
        {
            var newNode = Syntax.ArrayCreationExpression(newKeyword, type, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.initializer, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.initializer, GetDiagnostics(), annotations);
    }

    internal ArrayCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.newKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.newKeyword);
      this.type = (ArrayTypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.initializer = (InitializerExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.initializer);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ArrayCreationExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.initializer);
    }
  }

  /// <summary>Class which represents the syntax node for implicit array creation expression.</summary>
  internal sealed partial class ImplicitArrayCreationExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken newKeyword;
    private readonly SyntaxToken openBracketToken;
    private readonly SyntaxNode commas;
    private readonly SyntaxToken closeBracketToken;
    private readonly InitializerExpressionSyntax initializer;

    internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxNode commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 5;
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(newKeyword);
        this.openBracketToken = openBracketToken;
        this.AdjustFlagsAndWidth(openBracketToken);
        if (commas != null)
        {
            this.commas = commas;
            this.AdjustFlagsAndWidth(commas);
        }
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.initializer = initializer;
        this.AdjustFlagsAndWidth(initializer);
    }


    internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxNode commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
        : base(kind)
    {
        this.slotCount = 5;
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(newKeyword);
        this.openBracketToken = openBracketToken;
        this.AdjustFlagsAndWidth(openBracketToken);
        if (commas != null)
        {
            this.commas = commas;
            this.AdjustFlagsAndWidth(commas);
        }
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.initializer = initializer;
        this.AdjustFlagsAndWidth(initializer);
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword { get { return this.newKeyword; } }
    /// <summary>SyntaxToken representing the open bracket.</summary>
    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    /// <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
    public SyntaxList<SyntaxToken> Commas { get { return new SyntaxList<SyntaxToken>(this.commas); } }
    /// <summary>SyntaxToken representing the close bracket.</summary>
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }
    /// <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
    public InitializerExpressionSyntax Initializer { get { return this.initializer; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.openBracketToken;
            case 2: return this.commas;
            case 3: return this.closeBracketToken;
            case 4: return this.initializer;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ImplicitArrayCreationExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitImplicitArrayCreationExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitImplicitArrayCreationExpression(this);
    }

    public ImplicitArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || openBracketToken != this.OpenBracketToken || commas != this.Commas || closeBracketToken != this.CloseBracketToken || initializer != this.Initializer)
        {
            var newNode = Syntax.ImplicitArrayCreationExpression(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ImplicitArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBracketToken, this.commas, this.closeBracketToken, this.initializer, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ImplicitArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBracketToken, this.commas, this.closeBracketToken, this.initializer, GetDiagnostics(), annotations);
    }

    internal ImplicitArrayCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 5;
      this.newKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.newKeyword);
      this.openBracketToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openBracketToken);
      this.commas = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.commas);
      this.closeBracketToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeBracketToken);
      this.initializer = (InitializerExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.initializer);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ImplicitArrayCreationExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.commas);
      writer.WriteValue(this.closeBracketToken);
      writer.WriteValue(this.initializer);
    }
  }

  /// <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
  internal sealed partial class StackAllocArrayCreationExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken stackAllocKeyword;
    private readonly TypeSyntax type;

    internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.stackAllocKeyword = stackAllocKeyword;
        this.AdjustFlagsAndWidth(stackAllocKeyword);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
    }


    internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type)
        : base(kind)
    {
        this.slotCount = 2;
        this.stackAllocKeyword = stackAllocKeyword;
        this.AdjustFlagsAndWidth(stackAllocKeyword);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
    }

    /// <summary>SyntaxToken representing the stackalloc keyword.</summary>
    public SyntaxToken StackAllocKeyword { get { return this.stackAllocKeyword; } }
    /// <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
    public TypeSyntax Type { get { return this.type; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.stackAllocKeyword;
            case 1: return this.type;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.StackAllocArrayCreationExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitStackAllocArrayCreationExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitStackAllocArrayCreationExpression(this);
    }

    public StackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, TypeSyntax type)
    {
        if (stackAllocKeyword != this.StackAllocKeyword || type != this.Type)
        {
            var newNode = Syntax.StackAllocArrayCreationExpression(stackAllocKeyword, type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new StackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.type, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new StackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.type, GetDiagnostics(), annotations);
    }

    internal StackAllocArrayCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.stackAllocKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.stackAllocKeyword);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new StackAllocArrayCreationExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.stackAllocKeyword);
      writer.WriteValue(this.type);
    }
  }

  internal abstract partial class QueryClauseSyntax : SyntaxNode
  {
    internal QueryClauseSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal QueryClauseSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected QueryClauseSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal abstract partial class SelectOrGroupClauseSyntax : SyntaxNode
  {
    internal SelectOrGroupClauseSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal SelectOrGroupClauseSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected SelectOrGroupClauseSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class QueryExpressionSyntax : ExpressionSyntax
  {
    private readonly FromClauseSyntax fromClause;
    private readonly QueryBodySyntax body;

    internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.fromClause = fromClause;
        this.AdjustFlagsAndWidth(fromClause);
        this.body = body;
        this.AdjustFlagsAndWidth(body);
    }


    internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body)
        : base(kind)
    {
        this.slotCount = 2;
        this.fromClause = fromClause;
        this.AdjustFlagsAndWidth(fromClause);
        this.body = body;
        this.AdjustFlagsAndWidth(body);
    }

    public FromClauseSyntax FromClause { get { return this.fromClause; } }
    public QueryBodySyntax Body { get { return this.body; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.fromClause;
            case 1: return this.body;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.QueryExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitQueryExpression(this);
    }

    public QueryExpressionSyntax Update(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
        if (fromClause != this.FromClause || body != this.Body)
        {
            var newNode = Syntax.QueryExpression(fromClause, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new QueryExpressionSyntax(this.Kind, this.fromClause, this.body, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new QueryExpressionSyntax(this.Kind, this.fromClause, this.body, GetDiagnostics(), annotations);
    }

    internal QueryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.fromClause = (FromClauseSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.fromClause);
      this.body = (QueryBodySyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.body);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new QueryExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.fromClause);
      writer.WriteValue(this.body);
    }
  }

  internal sealed partial class QueryBodySyntax : SyntaxNode
  {
    private readonly SyntaxNode clauses;
    private readonly SelectOrGroupClauseSyntax selectOrGroup;
    private readonly QueryContinuationSyntax continuation;

    internal QueryBodySyntax(SyntaxKind kind, SyntaxNode clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        if (clauses != null)
        {
            this.clauses = clauses;
            this.AdjustFlagsAndWidth(clauses);
        }
        this.selectOrGroup = selectOrGroup;
        this.AdjustFlagsAndWidth(selectOrGroup);
        if (continuation != null)
        {
            this.continuation = continuation;
            this.AdjustFlagsAndWidth(continuation);
        }
    }


    internal QueryBodySyntax(SyntaxKind kind, SyntaxNode clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
        : base(kind)
    {
        this.slotCount = 3;
        if (clauses != null)
        {
            this.clauses = clauses;
            this.AdjustFlagsAndWidth(clauses);
        }
        this.selectOrGroup = selectOrGroup;
        this.AdjustFlagsAndWidth(selectOrGroup);
        if (continuation != null)
        {
            this.continuation = continuation;
            this.AdjustFlagsAndWidth(continuation);
        }
    }

    public SyntaxList<QueryClauseSyntax> Clauses { get { return new SyntaxList<QueryClauseSyntax>(this.clauses); } }
    public SelectOrGroupClauseSyntax SelectOrGroup { get { return this.selectOrGroup; } }
    public QueryContinuationSyntax Continuation { get { return this.continuation; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.clauses;
            case 1: return this.selectOrGroup;
            case 2: return this.continuation;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.QueryBodySyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryBody(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitQueryBody(this);
    }

    public QueryBodySyntax Update(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
        if (clauses != this.Clauses || selectOrGroup != this.SelectOrGroup || continuation != this.Continuation)
        {
            var newNode = Syntax.QueryBody(clauses, selectOrGroup, continuation);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new QueryBodySyntax(this.Kind, this.clauses, this.selectOrGroup, this.continuation, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new QueryBodySyntax(this.Kind, this.clauses, this.selectOrGroup, this.continuation, GetDiagnostics(), annotations);
    }

    internal QueryBodySyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.clauses = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.clauses);
      this.selectOrGroup = (SelectOrGroupClauseSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.selectOrGroup);
      this.continuation = (QueryContinuationSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.continuation);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new QueryBodySyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.clauses);
      writer.WriteValue(this.selectOrGroup);
      writer.WriteValue(this.continuation);
    }
  }

  internal sealed partial class FromClauseSyntax : QueryClauseSyntax
  {
    private readonly SyntaxToken fromKeyword;
    private readonly TypeSyntax type;
    private readonly SyntaxToken identifier;
    private readonly SyntaxToken inKeyword;
    private readonly ExpressionSyntax expression;

    internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 5;
        this.fromKeyword = fromKeyword;
        this.AdjustFlagsAndWidth(fromKeyword);
        if (type != null)
        {
            this.type = type;
            this.AdjustFlagsAndWidth(type);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(inKeyword);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
    }


    internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.slotCount = 5;
        this.fromKeyword = fromKeyword;
        this.AdjustFlagsAndWidth(fromKeyword);
        if (type != null)
        {
            this.type = type;
            this.AdjustFlagsAndWidth(type);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(inKeyword);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
    }

    public SyntaxToken FromKeyword { get { return this.fromKeyword; } }
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public SyntaxToken InKeyword { get { return this.inKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.fromKeyword;
            case 1: return this.type;
            case 2: return this.identifier;
            case 3: return this.inKeyword;
            case 4: return this.expression;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.FromClauseSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFromClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitFromClause(this);
    }

    public FromClauseSyntax Update(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
        if (fromKeyword != this.FromKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression)
        {
            var newNode = Syntax.FromClause(fromKeyword, type, identifier, inKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new FromClauseSyntax(this.Kind, this.fromKeyword, this.type, this.identifier, this.inKeyword, this.expression, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new FromClauseSyntax(this.Kind, this.fromKeyword, this.type, this.identifier, this.inKeyword, this.expression, GetDiagnostics(), annotations);
    }

    internal FromClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 5;
      this.fromKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.fromKeyword);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.inKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.inKeyword);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new FromClauseSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.fromKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.inKeyword);
      writer.WriteValue(this.expression);
    }
  }

  internal sealed partial class LetClauseSyntax : QueryClauseSyntax
  {
    private readonly SyntaxToken letKeyword;
    private readonly SyntaxToken identifier;
    private readonly SyntaxToken equalsToken;
    private readonly ExpressionSyntax expression;

    internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.letKeyword = letKeyword;
        this.AdjustFlagsAndWidth(letKeyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(equalsToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
    }


    internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
        : base(kind)
    {
        this.slotCount = 4;
        this.letKeyword = letKeyword;
        this.AdjustFlagsAndWidth(letKeyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(equalsToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
    }

    public SyntaxToken LetKeyword { get { return this.letKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.letKeyword;
            case 1: return this.identifier;
            case 2: return this.equalsToken;
            case 3: return this.expression;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.LetClauseSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLetClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitLetClause(this);
    }

    public LetClauseSyntax Update(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
        if (letKeyword != this.LetKeyword || identifier != this.Identifier || equalsToken != this.EqualsToken || expression != this.Expression)
        {
            var newNode = Syntax.LetClause(letKeyword, identifier, equalsToken, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LetClauseSyntax(this.Kind, this.letKeyword, this.identifier, this.equalsToken, this.expression, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LetClauseSyntax(this.Kind, this.letKeyword, this.identifier, this.equalsToken, this.expression, GetDiagnostics(), annotations);
    }

    internal LetClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.letKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.letKeyword);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.equalsToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.equalsToken);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new LetClauseSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.letKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.expression);
    }
  }

  internal sealed partial class JoinClauseSyntax : QueryClauseSyntax
  {
    private readonly SyntaxToken joinKeyword;
    private readonly TypeSyntax type;
    private readonly SyntaxToken identifier;
    private readonly SyntaxToken inKeyword;
    private readonly ExpressionSyntax inExpression;
    private readonly SyntaxToken onKeyword;
    private readonly ExpressionSyntax leftExpression;
    private readonly SyntaxToken equalsKeyword;
    private readonly ExpressionSyntax rightExpression;
    private readonly JoinIntoClauseSyntax into;

    internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 10;
        this.joinKeyword = joinKeyword;
        this.AdjustFlagsAndWidth(joinKeyword);
        if (type != null)
        {
            this.type = type;
            this.AdjustFlagsAndWidth(type);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inExpression = inExpression;
        this.AdjustFlagsAndWidth(inExpression);
        this.onKeyword = onKeyword;
        this.AdjustFlagsAndWidth(onKeyword);
        this.leftExpression = leftExpression;
        this.AdjustFlagsAndWidth(leftExpression);
        this.equalsKeyword = equalsKeyword;
        this.AdjustFlagsAndWidth(equalsKeyword);
        this.rightExpression = rightExpression;
        this.AdjustFlagsAndWidth(rightExpression);
        if (into != null)
        {
            this.into = into;
            this.AdjustFlagsAndWidth(into);
        }
    }


    internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
        : base(kind)
    {
        this.slotCount = 10;
        this.joinKeyword = joinKeyword;
        this.AdjustFlagsAndWidth(joinKeyword);
        if (type != null)
        {
            this.type = type;
            this.AdjustFlagsAndWidth(type);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inExpression = inExpression;
        this.AdjustFlagsAndWidth(inExpression);
        this.onKeyword = onKeyword;
        this.AdjustFlagsAndWidth(onKeyword);
        this.leftExpression = leftExpression;
        this.AdjustFlagsAndWidth(leftExpression);
        this.equalsKeyword = equalsKeyword;
        this.AdjustFlagsAndWidth(equalsKeyword);
        this.rightExpression = rightExpression;
        this.AdjustFlagsAndWidth(rightExpression);
        if (into != null)
        {
            this.into = into;
            this.AdjustFlagsAndWidth(into);
        }
    }

    public SyntaxToken JoinKeyword { get { return this.joinKeyword; } }
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public SyntaxToken InKeyword { get { return this.inKeyword; } }
    public ExpressionSyntax InExpression { get { return this.inExpression; } }
    public SyntaxToken OnKeyword { get { return this.onKeyword; } }
    public ExpressionSyntax LeftExpression { get { return this.leftExpression; } }
    public SyntaxToken EqualsKeyword { get { return this.equalsKeyword; } }
    public ExpressionSyntax RightExpression { get { return this.rightExpression; } }
    public JoinIntoClauseSyntax Into { get { return this.into; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.joinKeyword;
            case 1: return this.type;
            case 2: return this.identifier;
            case 3: return this.inKeyword;
            case 4: return this.inExpression;
            case 5: return this.onKeyword;
            case 6: return this.leftExpression;
            case 7: return this.equalsKeyword;
            case 8: return this.rightExpression;
            case 9: return this.into;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.JoinClauseSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitJoinClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitJoinClause(this);
    }

    public JoinClauseSyntax Update(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
        if (joinKeyword != this.JoinKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || inExpression != this.InExpression || onKeyword != this.OnKeyword || leftExpression != this.LeftExpression || equalsKeyword != this.EqualsKeyword || rightExpression != this.RightExpression || into != this.Into)
        {
            var newNode = Syntax.JoinClause(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new JoinClauseSyntax(this.Kind, this.joinKeyword, this.type, this.identifier, this.inKeyword, this.inExpression, this.onKeyword, this.leftExpression, this.equalsKeyword, this.rightExpression, this.into, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new JoinClauseSyntax(this.Kind, this.joinKeyword, this.type, this.identifier, this.inKeyword, this.inExpression, this.onKeyword, this.leftExpression, this.equalsKeyword, this.rightExpression, this.into, GetDiagnostics(), annotations);
    }

    internal JoinClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 10;
      this.joinKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.joinKeyword);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.inKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.inKeyword);
      this.inExpression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.inExpression);
      this.onKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.onKeyword);
      this.leftExpression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.leftExpression);
      this.equalsKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.equalsKeyword);
      this.rightExpression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.rightExpression);
      this.into = (JoinIntoClauseSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.into);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new JoinClauseSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.joinKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.inKeyword);
      writer.WriteValue(this.inExpression);
      writer.WriteValue(this.onKeyword);
      writer.WriteValue(this.leftExpression);
      writer.WriteValue(this.equalsKeyword);
      writer.WriteValue(this.rightExpression);
      writer.WriteValue(this.into);
    }
  }

  internal sealed partial class JoinIntoClauseSyntax : SyntaxNode
  {
    private readonly SyntaxToken intoKeyword;
    private readonly SyntaxToken identifier;

    internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
    }


    internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier)
        : base(kind)
    {
        this.slotCount = 2;
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
    }

    public SyntaxToken IntoKeyword { get { return this.intoKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.intoKeyword;
            case 1: return this.identifier;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.JoinIntoClauseSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitJoinIntoClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitJoinIntoClause(this);
    }

    public JoinIntoClauseSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
        if (intoKeyword != this.IntoKeyword || identifier != this.Identifier)
        {
            var newNode = Syntax.JoinIntoClause(intoKeyword, identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new JoinIntoClauseSyntax(this.Kind, this.intoKeyword, this.identifier, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new JoinIntoClauseSyntax(this.Kind, this.intoKeyword, this.identifier, GetDiagnostics(), annotations);
    }

    internal JoinIntoClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.intoKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.intoKeyword);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new JoinIntoClauseSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.intoKeyword);
      writer.WriteValue(this.identifier);
    }
  }

  internal sealed partial class WhereClauseSyntax : QueryClauseSyntax
  {
    private readonly SyntaxToken whereKeyword;
    private readonly ExpressionSyntax condition;

    internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.condition = condition;
        this.AdjustFlagsAndWidth(condition);
    }


    internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition)
        : base(kind)
    {
        this.slotCount = 2;
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.condition = condition;
        this.AdjustFlagsAndWidth(condition);
    }

    public SyntaxToken WhereKeyword { get { return this.whereKeyword; } }
    public ExpressionSyntax Condition { get { return this.condition; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whereKeyword;
            case 1: return this.condition;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.WhereClauseSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhereClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitWhereClause(this);
    }

    public WhereClauseSyntax Update(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
        if (whereKeyword != this.WhereKeyword || condition != this.Condition)
        {
            var newNode = Syntax.WhereClause(whereKeyword, condition);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new WhereClauseSyntax(this.Kind, this.whereKeyword, this.condition, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new WhereClauseSyntax(this.Kind, this.whereKeyword, this.condition, GetDiagnostics(), annotations);
    }

    internal WhereClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.whereKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.whereKeyword);
      this.condition = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.condition);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new WhereClauseSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whereKeyword);
      writer.WriteValue(this.condition);
    }
  }

  internal sealed partial class OrderByClauseSyntax : QueryClauseSyntax
  {
    private readonly SyntaxToken orderByKeyword;
    private readonly SyntaxNode orderings;

    internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, SyntaxNode orderings, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.orderByKeyword = orderByKeyword;
        this.AdjustFlagsAndWidth(orderByKeyword);
        if (orderings != null)
        {
            this.orderings = orderings;
            this.AdjustFlagsAndWidth(orderings);
        }
    }


    internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, SyntaxNode orderings)
        : base(kind)
    {
        this.slotCount = 2;
        this.orderByKeyword = orderByKeyword;
        this.AdjustFlagsAndWidth(orderByKeyword);
        if (orderings != null)
        {
            this.orderings = orderings;
            this.AdjustFlagsAndWidth(orderings);
        }
    }

    public SyntaxToken OrderByKeyword { get { return this.orderByKeyword; } }
    public SeparatedSyntaxList<OrderingSyntax> Orderings { get { return new SeparatedSyntaxList<OrderingSyntax>(new SyntaxList<SyntaxNode>(this.orderings)); } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.orderByKeyword;
            case 1: return this.orderings;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.OrderByClauseSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOrderByClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitOrderByClause(this);
    }

    public OrderByClauseSyntax Update(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings)
    {
        if (orderByKeyword != this.OrderByKeyword || orderings != this.Orderings)
        {
            var newNode = Syntax.OrderByClause(orderByKeyword, orderings);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OrderByClauseSyntax(this.Kind, this.orderByKeyword, this.orderings, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OrderByClauseSyntax(this.Kind, this.orderByKeyword, this.orderings, GetDiagnostics(), annotations);
    }

    internal OrderByClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.orderByKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.orderByKeyword);
      this.orderings = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.orderings);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new OrderByClauseSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.orderByKeyword);
      writer.WriteValue(this.orderings);
    }
  }

  internal sealed partial class OrderingSyntax : SyntaxNode
  {
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken ascendingOrDescendingKeyword;

    internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        if (ascendingOrDescendingKeyword != null)
        {
            this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
            this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
        }
    }


    internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
        : base(kind)
    {
        this.slotCount = 2;
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        if (ascendingOrDescendingKeyword != null)
        {
            this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
            this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
        }
    }

    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken AscendingOrDescendingKeyword { get { return this.ascendingOrDescendingKeyword; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.ascendingOrDescendingKeyword;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.OrderingSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOrdering(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitOrdering(this);
    }

    public OrderingSyntax Update(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
        if (expression != this.Expression || ascendingOrDescendingKeyword != this.AscendingOrDescendingKeyword)
        {
            var newNode = Syntax.Ordering(this.Kind, expression, ascendingOrDescendingKeyword);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OrderingSyntax(this.Kind, this.expression, this.ascendingOrDescendingKeyword, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OrderingSyntax(this.Kind, this.expression, this.ascendingOrDescendingKeyword, GetDiagnostics(), annotations);
    }

    internal OrderingSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.ascendingOrDescendingKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.ascendingOrDescendingKeyword);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new OrderingSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.ascendingOrDescendingKeyword);
    }
  }

  internal sealed partial class SelectClauseSyntax : SelectOrGroupClauseSyntax
  {
    private readonly SyntaxToken selectKeyword;
    private readonly ExpressionSyntax expression;

    internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.selectKeyword = selectKeyword;
        this.AdjustFlagsAndWidth(selectKeyword);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
    }


    internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.slotCount = 2;
        this.selectKeyword = selectKeyword;
        this.AdjustFlagsAndWidth(selectKeyword);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
    }

    public SyntaxToken SelectKeyword { get { return this.selectKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.selectKeyword;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.SelectClauseSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSelectClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitSelectClause(this);
    }

    public SelectClauseSyntax Update(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
        if (selectKeyword != this.SelectKeyword || expression != this.Expression)
        {
            var newNode = Syntax.SelectClause(selectKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SelectClauseSyntax(this.Kind, this.selectKeyword, this.expression, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SelectClauseSyntax(this.Kind, this.selectKeyword, this.expression, GetDiagnostics(), annotations);
    }

    internal SelectClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.selectKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.selectKeyword);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new SelectClauseSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.selectKeyword);
      writer.WriteValue(this.expression);
    }
  }

  internal sealed partial class GroupClauseSyntax : SelectOrGroupClauseSyntax
  {
    private readonly SyntaxToken groupKeyword;
    private readonly ExpressionSyntax groupExpression;
    private readonly SyntaxToken byKeyword;
    private readonly ExpressionSyntax byExpression;

    internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.groupKeyword = groupKeyword;
        this.AdjustFlagsAndWidth(groupKeyword);
        this.groupExpression = groupExpression;
        this.AdjustFlagsAndWidth(groupExpression);
        this.byKeyword = byKeyword;
        this.AdjustFlagsAndWidth(byKeyword);
        this.byExpression = byExpression;
        this.AdjustFlagsAndWidth(byExpression);
    }


    internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
        : base(kind)
    {
        this.slotCount = 4;
        this.groupKeyword = groupKeyword;
        this.AdjustFlagsAndWidth(groupKeyword);
        this.groupExpression = groupExpression;
        this.AdjustFlagsAndWidth(groupExpression);
        this.byKeyword = byKeyword;
        this.AdjustFlagsAndWidth(byKeyword);
        this.byExpression = byExpression;
        this.AdjustFlagsAndWidth(byExpression);
    }

    public SyntaxToken GroupKeyword { get { return this.groupKeyword; } }
    public ExpressionSyntax GroupExpression { get { return this.groupExpression; } }
    public SyntaxToken ByKeyword { get { return this.byKeyword; } }
    public ExpressionSyntax ByExpression { get { return this.byExpression; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.groupKeyword;
            case 1: return this.groupExpression;
            case 2: return this.byKeyword;
            case 3: return this.byExpression;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.GroupClauseSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGroupClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitGroupClause(this);
    }

    public GroupClauseSyntax Update(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
        if (groupKeyword != this.GroupKeyword || groupExpression != this.GroupExpression || byKeyword != this.ByKeyword || byExpression != this.ByExpression)
        {
            var newNode = Syntax.GroupClause(groupKeyword, groupExpression, byKeyword, byExpression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new GroupClauseSyntax(this.Kind, this.groupKeyword, this.groupExpression, this.byKeyword, this.byExpression, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new GroupClauseSyntax(this.Kind, this.groupKeyword, this.groupExpression, this.byKeyword, this.byExpression, GetDiagnostics(), annotations);
    }

    internal GroupClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.groupKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.groupKeyword);
      this.groupExpression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.groupExpression);
      this.byKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.byKeyword);
      this.byExpression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.byExpression);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new GroupClauseSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.groupKeyword);
      writer.WriteValue(this.groupExpression);
      writer.WriteValue(this.byKeyword);
      writer.WriteValue(this.byExpression);
    }
  }

  internal sealed partial class QueryContinuationSyntax : SyntaxNode
  {
    private readonly SyntaxToken intoKeyword;
    private readonly SyntaxToken identifier;
    private readonly QueryBodySyntax body;

    internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.body = body;
        this.AdjustFlagsAndWidth(body);
    }


    internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
        : base(kind)
    {
        this.slotCount = 3;
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.body = body;
        this.AdjustFlagsAndWidth(body);
    }

    public SyntaxToken IntoKeyword { get { return this.intoKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public QueryBodySyntax Body { get { return this.body; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.intoKeyword;
            case 1: return this.identifier;
            case 2: return this.body;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.QueryContinuationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryContinuation(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitQueryContinuation(this);
    }

    public QueryContinuationSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
        if (intoKeyword != this.IntoKeyword || identifier != this.Identifier || body != this.Body)
        {
            var newNode = Syntax.QueryContinuation(intoKeyword, identifier, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new QueryContinuationSyntax(this.Kind, this.intoKeyword, this.identifier, this.body, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new QueryContinuationSyntax(this.Kind, this.intoKeyword, this.identifier, this.body, GetDiagnostics(), annotations);
    }

    internal QueryContinuationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.intoKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.intoKeyword);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.body = (QueryBodySyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.body);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new QueryContinuationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.intoKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.body);
    }
  }

  /// <summary>Class which represents a placeholder in an array size list.</summary>
  internal sealed partial class OmittedArraySizeExpressionSyntax : ExpressionSyntax
  {
    private readonly SyntaxToken omittedArraySizeExpressionToken;

    internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 1;
        this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
        this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
    }


    internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken)
        : base(kind)
    {
        this.slotCount = 1;
        this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
        this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
    }

    /// <summary>SyntaxToken representing the omitted array size expression.</summary>
    public SyntaxToken OmittedArraySizeExpressionToken { get { return this.omittedArraySizeExpressionToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.omittedArraySizeExpressionToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.OmittedArraySizeExpressionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOmittedArraySizeExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitOmittedArraySizeExpression(this);
    }

    public OmittedArraySizeExpressionSyntax Update(SyntaxToken omittedArraySizeExpressionToken)
    {
        if (omittedArraySizeExpressionToken != this.OmittedArraySizeExpressionToken)
        {
            var newNode = Syntax.OmittedArraySizeExpression(omittedArraySizeExpressionToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OmittedArraySizeExpressionSyntax(this.Kind, this.omittedArraySizeExpressionToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OmittedArraySizeExpressionSyntax(this.Kind, this.omittedArraySizeExpressionToken, GetDiagnostics(), annotations);
    }

    internal OmittedArraySizeExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 1;
      this.omittedArraySizeExpressionToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.omittedArraySizeExpressionToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new OmittedArraySizeExpressionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.omittedArraySizeExpressionToken);
    }
  }

  internal sealed partial class GlobalStatementSyntax : MemberDeclarationSyntax
  {
    private readonly StatementSyntax statement;

    internal GlobalStatementSyntax(SyntaxKind kind, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 1;
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }


    internal GlobalStatementSyntax(SyntaxKind kind, StatementSyntax statement)
        : base(kind)
    {
        this.slotCount = 1;
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }

    public StatementSyntax Statement { get { return this.statement; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.statement;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.GlobalStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGlobalStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitGlobalStatement(this);
    }

    public GlobalStatementSyntax Update(StatementSyntax statement)
    {
        if (statement != this.Statement)
        {
            var newNode = Syntax.GlobalStatement(statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new GlobalStatementSyntax(this.Kind, this.statement, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new GlobalStatementSyntax(this.Kind, this.statement, GetDiagnostics(), annotations);
    }

    internal GlobalStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 1;
      this.statement = (StatementSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.statement);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new GlobalStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.statement);
    }
  }

  /// <summary>Represents the base class for all statements syntax classes.</summary>
  internal abstract partial class StatementSyntax : SyntaxNode
  {
    internal StatementSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal StatementSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected StatementSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class BlockSyntax : StatementSyntax
  {
    private readonly SyntaxToken openBraceToken;
    private readonly SyntaxNode statements;
    private readonly SyntaxToken closeBraceToken;

    internal BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, SyntaxNode statements, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (statements != null)
        {
            this.statements = statements;
            this.AdjustFlagsAndWidth(statements);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
    }


    internal BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, SyntaxNode statements, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (statements != null)
        {
            this.statements = statements;
            this.AdjustFlagsAndWidth(statements);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
    }

    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public SyntaxList<StatementSyntax> Statements { get { return new SyntaxList<StatementSyntax>(this.statements); } }
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.statements;
            case 2: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.BlockSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBlock(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBlock(this);
    }

    public BlockSyntax Update(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || statements != this.Statements || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = Syntax.Block(openBraceToken, statements, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BlockSyntax(this.Kind, this.openBraceToken, this.statements, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BlockSyntax(this.Kind, this.openBraceToken, this.statements, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal BlockSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.openBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openBraceToken);
      this.statements = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.statements);
      this.closeBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeBraceToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new BlockSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.statements);
      writer.WriteValue(this.closeBraceToken);
    }
  }

  internal sealed partial class LocalDeclarationStatementSyntax : StatementSyntax
  {
    private readonly SyntaxNode modifiers;
    private readonly VariableDeclarationSyntax declaration;
    private readonly SyntaxToken semicolonToken;

    internal LocalDeclarationStatementSyntax(SyntaxKind kind, SyntaxNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(declaration);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }


    internal LocalDeclarationStatementSyntax(SyntaxKind kind, SyntaxNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 3;
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(declaration);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }

    /// <summary>Gets the modifier list.</summary>
    public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.modifiers;
            case 1: return this.declaration;
            case 2: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.LocalDeclarationStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLocalDeclarationStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitLocalDeclarationStatement(this);
    }

    public LocalDeclarationStatementSyntax Update(SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.LocalDeclarationStatement(modifiers, declaration, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LocalDeclarationStatementSyntax(this.Kind, this.modifiers, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LocalDeclarationStatementSyntax(this.Kind, this.modifiers, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal LocalDeclarationStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.declaration = (VariableDeclarationSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.declaration);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new LocalDeclarationStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.semicolonToken);
    }
  }

  internal sealed partial class VariableDeclarationSyntax : SyntaxNode
  {
    private readonly TypeSyntax type;
    private readonly SyntaxNode variables;

    internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, SyntaxNode variables, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        if (variables != null)
        {
            this.variables = variables;
            this.AdjustFlagsAndWidth(variables);
        }
    }


    internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, SyntaxNode variables)
        : base(kind)
    {
        this.slotCount = 2;
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        if (variables != null)
        {
            this.variables = variables;
            this.AdjustFlagsAndWidth(variables);
        }
    }

    public TypeSyntax Type { get { return this.type; } }
    public SeparatedSyntaxList<VariableDeclaratorSyntax> Variables { get { return new SeparatedSyntaxList<VariableDeclaratorSyntax>(new SyntaxList<SyntaxNode>(this.variables)); } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.variables;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.VariableDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitVariableDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitVariableDeclaration(this);
    }

    public VariableDeclarationSyntax Update(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
    {
        if (type != this.Type || variables != this.Variables)
        {
            var newNode = Syntax.VariableDeclaration(type, variables);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new VariableDeclarationSyntax(this.Kind, this.type, this.variables, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new VariableDeclarationSyntax(this.Kind, this.type, this.variables, GetDiagnostics(), annotations);
    }

    internal VariableDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.variables = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.variables);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new VariableDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
      writer.WriteValue(this.variables);
    }
  }

  internal sealed partial class VariableDeclaratorSyntax : SyntaxNode
  {
    private readonly SyntaxToken identifier;
    private readonly BracketedArgumentListSyntax argumentList;
    private readonly EqualsValueClauseSyntax initializer;

    internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (argumentList != null)
        {
            this.argumentList = argumentList;
            this.AdjustFlagsAndWidth(argumentList);
        }
        if (initializer != null)
        {
            this.initializer = initializer;
            this.AdjustFlagsAndWidth(initializer);
        }
    }


    internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
        : base(kind)
    {
        this.slotCount = 3;
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (argumentList != null)
        {
            this.argumentList = argumentList;
            this.AdjustFlagsAndWidth(argumentList);
        }
        if (initializer != null)
        {
            this.initializer = initializer;
            this.AdjustFlagsAndWidth(initializer);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public BracketedArgumentListSyntax ArgumentList { get { return this.argumentList; } }
    public EqualsValueClauseSyntax Initializer { get { return this.initializer; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.argumentList;
            case 2: return this.initializer;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.VariableDeclaratorSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitVariableDeclarator(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitVariableDeclarator(this);
    }

    public VariableDeclaratorSyntax Update(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
        if (identifier != this.Identifier || argumentList != this.ArgumentList || initializer != this.Initializer)
        {
            var newNode = Syntax.VariableDeclarator(identifier, argumentList, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new VariableDeclaratorSyntax(this.Kind, this.identifier, this.argumentList, this.initializer, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new VariableDeclaratorSyntax(this.Kind, this.identifier, this.argumentList, this.initializer, GetDiagnostics(), annotations);
    }

    internal VariableDeclaratorSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.argumentList);
      this.initializer = (EqualsValueClauseSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.initializer);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new VariableDeclaratorSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.argumentList);
      writer.WriteValue(this.initializer);
    }
  }

  internal sealed partial class EqualsValueClauseSyntax : SyntaxNode
  {
    private readonly SyntaxToken equalsToken;
    private readonly ExpressionSyntax value;

    internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(equalsToken);
        this.value = value;
        this.AdjustFlagsAndWidth(value);
    }


    internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value)
        : base(kind)
    {
        this.slotCount = 2;
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(equalsToken);
        this.value = value;
        this.AdjustFlagsAndWidth(value);
    }

    public SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public ExpressionSyntax Value { get { return this.value; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.equalsToken;
            case 1: return this.value;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.EqualsValueClauseSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEqualsValueClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEqualsValueClause(this);
    }

    public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, ExpressionSyntax value)
    {
        if (equalsToken != this.EqualsToken || value != this.Value)
        {
            var newNode = Syntax.EqualsValueClause(equalsToken, value);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EqualsValueClauseSyntax(this.Kind, this.equalsToken, this.value, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EqualsValueClauseSyntax(this.Kind, this.equalsToken, this.value, GetDiagnostics(), annotations);
    }

    internal EqualsValueClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.equalsToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.equalsToken);
      this.value = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.value);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new EqualsValueClauseSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.value);
    }
  }

  internal sealed partial class ExpressionStatementSyntax : StatementSyntax
  {
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken semicolonToken;

    internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }


    internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 2;
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }

    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ExpressionStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExpressionStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitExpressionStatement(this);
    }

    public ExpressionStatementSyntax Update(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ExpressionStatement(expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ExpressionStatementSyntax(this.Kind, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ExpressionStatementSyntax(this.Kind, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ExpressionStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ExpressionStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }
  }

  internal sealed partial class EmptyStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken semicolonToken;

    internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 1;
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }


    internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 1;
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }

    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.EmptyStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEmptyStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEmptyStatement(this);
    }

    public EmptyStatementSyntax Update(SyntaxToken semicolonToken)
    {
        if (semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.EmptyStatement(semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EmptyStatementSyntax(this.Kind, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EmptyStatementSyntax(this.Kind, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal EmptyStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 1;
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new EmptyStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.semicolonToken);
    }
  }

  /// <summary>Represents a labeled statement syntax.</summary>
  internal sealed partial class LabeledStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken identifier;
    private readonly SyntaxToken colonToken;
    private readonly StatementSyntax statement;

    internal LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }


    internal LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
        : base(kind)
    {
        this.slotCount = 3;
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    /// <summary>Gets a SyntaxToken that represents the colon succeeding the statement's label.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.colonToken;
            case 2: return this.statement;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.LabeledStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLabeledStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitLabeledStatement(this);
    }

    public LabeledStatementSyntax Update(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken || statement != this.Statement)
        {
            var newNode = Syntax.LabeledStatement(identifier, colonToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LabeledStatementSyntax(this.Kind, this.identifier, this.colonToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LabeledStatementSyntax(this.Kind, this.identifier, this.colonToken, this.statement, GetDiagnostics(), annotations);
    }

    internal LabeledStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.colonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.colonToken);
      this.statement = (StatementSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.statement);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new LabeledStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.statement);
    }
  }

  /// <summary>
  /// Represents a goto statement syntax
  /// </summary>
  internal sealed partial class GotoStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken gotoKeyword;
    private readonly SyntaxToken caseOrDefaultKeyword;
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken semicolonToken;

    internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.gotoKeyword = gotoKeyword;
        this.AdjustFlagsAndWidth(gotoKeyword);
        if (caseOrDefaultKeyword != null)
        {
            this.caseOrDefaultKeyword = caseOrDefaultKeyword;
            this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
        }
        if (expression != null)
        {
            this.expression = expression;
            this.AdjustFlagsAndWidth(expression);
        }
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }


    internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.gotoKeyword = gotoKeyword;
        this.AdjustFlagsAndWidth(gotoKeyword);
        if (caseOrDefaultKeyword != null)
        {
            this.caseOrDefaultKeyword = caseOrDefaultKeyword;
            this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
        }
        if (expression != null)
        {
            this.expression = expression;
            this.AdjustFlagsAndWidth(expression);
        }
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the goto keyword.
    /// </summary>
    public SyntaxToken GotoKeyword { get { return this.gotoKeyword; } }
    public SyntaxToken CaseOrDefaultKeyword { get { return this.caseOrDefaultKeyword; } }
    /// <summary>
    /// Gets a constant expression for a goto case statement.
    /// </summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the semi-colon at the end of the statement.
    /// </summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.gotoKeyword;
            case 1: return this.caseOrDefaultKeyword;
            case 2: return this.expression;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.GotoStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGotoStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitGotoStatement(this);
    }

    public GotoStatementSyntax Update(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (gotoKeyword != this.GotoKeyword || caseOrDefaultKeyword != this.CaseOrDefaultKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.GotoStatement(this.Kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new GotoStatementSyntax(this.Kind, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new GotoStatementSyntax(this.Kind, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal GotoStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.gotoKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.gotoKeyword);
      this.caseOrDefaultKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.caseOrDefaultKeyword);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new GotoStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.gotoKeyword);
      writer.WriteValue(this.caseOrDefaultKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }
  }

  internal sealed partial class BreakStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken breakKeyword;
    private readonly SyntaxToken semicolonToken;

    internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.breakKeyword = breakKeyword;
        this.AdjustFlagsAndWidth(breakKeyword);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }


    internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 2;
        this.breakKeyword = breakKeyword;
        this.AdjustFlagsAndWidth(breakKeyword);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }

    public SyntaxToken BreakKeyword { get { return this.breakKeyword; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.breakKeyword;
            case 1: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.BreakStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBreakStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBreakStatement(this);
    }

    public BreakStatementSyntax Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
        if (breakKeyword != this.BreakKeyword || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.BreakStatement(breakKeyword, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BreakStatementSyntax(this.Kind, this.breakKeyword, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BreakStatementSyntax(this.Kind, this.breakKeyword, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal BreakStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.breakKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.breakKeyword);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new BreakStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.breakKeyword);
      writer.WriteValue(this.semicolonToken);
    }
  }

  internal sealed partial class ContinueStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken continueKeyword;
    private readonly SyntaxToken semicolonToken;

    internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.continueKeyword = continueKeyword;
        this.AdjustFlagsAndWidth(continueKeyword);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }


    internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 2;
        this.continueKeyword = continueKeyword;
        this.AdjustFlagsAndWidth(continueKeyword);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }

    public SyntaxToken ContinueKeyword { get { return this.continueKeyword; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.continueKeyword;
            case 1: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ContinueStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitContinueStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitContinueStatement(this);
    }

    public ContinueStatementSyntax Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
        if (continueKeyword != this.ContinueKeyword || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ContinueStatement(continueKeyword, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ContinueStatementSyntax(this.Kind, this.continueKeyword, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ContinueStatementSyntax(this.Kind, this.continueKeyword, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ContinueStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.continueKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.continueKeyword);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ContinueStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.continueKeyword);
      writer.WriteValue(this.semicolonToken);
    }
  }

  internal sealed partial class ReturnStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken returnKeyword;
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken semicolonToken;

    internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.returnKeyword = returnKeyword;
        this.AdjustFlagsAndWidth(returnKeyword);
        if (expression != null)
        {
            this.expression = expression;
            this.AdjustFlagsAndWidth(expression);
        }
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }


    internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.returnKeyword = returnKeyword;
        this.AdjustFlagsAndWidth(returnKeyword);
        if (expression != null)
        {
            this.expression = expression;
            this.AdjustFlagsAndWidth(expression);
        }
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }

    public SyntaxToken ReturnKeyword { get { return this.returnKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.returnKeyword;
            case 1: return this.expression;
            case 2: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ReturnStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitReturnStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitReturnStatement(this);
    }

    public ReturnStatementSyntax Update(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (returnKeyword != this.ReturnKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ReturnStatement(returnKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ReturnStatementSyntax(this.Kind, this.returnKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ReturnStatementSyntax(this.Kind, this.returnKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ReturnStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.returnKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.returnKeyword);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ReturnStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.returnKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }
  }

  internal sealed partial class ThrowStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken throwKeyword;
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken semicolonToken;

    internal ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.throwKeyword = throwKeyword;
        this.AdjustFlagsAndWidth(throwKeyword);
        if (expression != null)
        {
            this.expression = expression;
            this.AdjustFlagsAndWidth(expression);
        }
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }


    internal ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.throwKeyword = throwKeyword;
        this.AdjustFlagsAndWidth(throwKeyword);
        if (expression != null)
        {
            this.expression = expression;
            this.AdjustFlagsAndWidth(expression);
        }
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }

    public SyntaxToken ThrowKeyword { get { return this.throwKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.throwKeyword;
            case 1: return this.expression;
            case 2: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ThrowStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitThrowStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitThrowStatement(this);
    }

    public ThrowStatementSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (throwKeyword != this.ThrowKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ThrowStatement(throwKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ThrowStatementSyntax(this.Kind, this.throwKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ThrowStatementSyntax(this.Kind, this.throwKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ThrowStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.throwKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.throwKeyword);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ThrowStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.throwKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }
  }

  internal sealed partial class YieldStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken yieldKeyword;
    private readonly SyntaxToken returnOrBreakKeyword;
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken semicolonToken;

    internal YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.yieldKeyword = yieldKeyword;
        this.AdjustFlagsAndWidth(yieldKeyword);
        this.returnOrBreakKeyword = returnOrBreakKeyword;
        this.AdjustFlagsAndWidth(returnOrBreakKeyword);
        if (expression != null)
        {
            this.expression = expression;
            this.AdjustFlagsAndWidth(expression);
        }
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }


    internal YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.yieldKeyword = yieldKeyword;
        this.AdjustFlagsAndWidth(yieldKeyword);
        this.returnOrBreakKeyword = returnOrBreakKeyword;
        this.AdjustFlagsAndWidth(returnOrBreakKeyword);
        if (expression != null)
        {
            this.expression = expression;
            this.AdjustFlagsAndWidth(expression);
        }
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }

    public SyntaxToken YieldKeyword { get { return this.yieldKeyword; } }
    public SyntaxToken ReturnOrBreakKeyword { get { return this.returnOrBreakKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.yieldKeyword;
            case 1: return this.returnOrBreakKeyword;
            case 2: return this.expression;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.YieldStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitYieldStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitYieldStatement(this);
    }

    public YieldStatementSyntax Update(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (yieldKeyword != this.YieldKeyword || returnOrBreakKeyword != this.ReturnOrBreakKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.YieldStatement(this.Kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new YieldStatementSyntax(this.Kind, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new YieldStatementSyntax(this.Kind, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal YieldStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.yieldKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.yieldKeyword);
      this.returnOrBreakKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.returnOrBreakKeyword);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new YieldStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.yieldKeyword);
      writer.WriteValue(this.returnOrBreakKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }
  }

  internal sealed partial class WhileStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken whileKeyword;
    private readonly SyntaxToken openParenToken;
    private readonly ExpressionSyntax condition;
    private readonly SyntaxToken closeParenToken;
    private readonly StatementSyntax statement;

    internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 5;
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.condition = condition;
        this.AdjustFlagsAndWidth(condition);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }


    internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.slotCount = 5;
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.condition = condition;
        this.AdjustFlagsAndWidth(condition);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }

    public SyntaxToken WhileKeyword { get { return this.whileKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public ExpressionSyntax Condition { get { return this.condition; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whileKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.WhileStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhileStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitWhileStatement(this);
    }

    public WhileStatementSyntax Update(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = Syntax.WhileStatement(whileKeyword, openParenToken, condition, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new WhileStatementSyntax(this.Kind, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new WhileStatementSyntax(this.Kind, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal WhileStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 5;
      this.whileKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.whileKeyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.condition = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.condition);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
      this.statement = (StatementSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.statement);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new WhileStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whileKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }
  }

  internal sealed partial class DoStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken doKeyword;
    private readonly StatementSyntax statement;
    private readonly SyntaxToken whileKeyword;
    private readonly SyntaxToken openParenToken;
    private readonly ExpressionSyntax condition;
    private readonly SyntaxToken closeParenToken;
    private readonly SyntaxToken semicolonToken;

    internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 7;
        this.doKeyword = doKeyword;
        this.AdjustFlagsAndWidth(doKeyword);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.condition = condition;
        this.AdjustFlagsAndWidth(condition);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }


    internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 7;
        this.doKeyword = doKeyword;
        this.AdjustFlagsAndWidth(doKeyword);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.condition = condition;
        this.AdjustFlagsAndWidth(condition);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }

    public SyntaxToken DoKeyword { get { return this.doKeyword; } }
    public StatementSyntax Statement { get { return this.statement; } }
    public SyntaxToken WhileKeyword { get { return this.whileKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public ExpressionSyntax Condition { get { return this.condition; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.doKeyword;
            case 1: return this.statement;
            case 2: return this.whileKeyword;
            case 3: return this.openParenToken;
            case 4: return this.condition;
            case 5: return this.closeParenToken;
            case 6: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.DoStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDoStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitDoStatement(this);
    }

    public DoStatementSyntax Update(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
        if (doKeyword != this.DoKeyword || statement != this.Statement || whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.DoStatement(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DoStatementSyntax(this.Kind, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DoStatementSyntax(this.Kind, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal DoStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 7;
      this.doKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.doKeyword);
      this.statement = (StatementSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.statement);
      this.whileKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.whileKeyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.condition = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.condition);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new DoStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.doKeyword);
      writer.WriteValue(this.statement);
      writer.WriteValue(this.whileKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.semicolonToken);
    }
  }

  internal sealed partial class ForStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken forKeyword;
    private readonly SyntaxToken openParenToken;
    private readonly VariableDeclarationSyntax declaration;
    private readonly SyntaxNode initializers;
    private readonly SyntaxToken firstSemicolonToken;
    private readonly ExpressionSyntax condition;
    private readonly SyntaxToken secondSemicolonToken;
    private readonly SyntaxNode incrementors;
    private readonly SyntaxToken closeParenToken;
    private readonly StatementSyntax statement;

    internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxNode initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SyntaxNode incrementors, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 10;
        this.forKeyword = forKeyword;
        this.AdjustFlagsAndWidth(forKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        if (declaration != null)
        {
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(declaration);
        }
        if (initializers != null)
        {
            this.initializers = initializers;
            this.AdjustFlagsAndWidth(initializers);
        }
        this.firstSemicolonToken = firstSemicolonToken;
        this.AdjustFlagsAndWidth(firstSemicolonToken);
        if (condition != null)
        {
            this.condition = condition;
            this.AdjustFlagsAndWidth(condition);
        }
        this.secondSemicolonToken = secondSemicolonToken;
        this.AdjustFlagsAndWidth(secondSemicolonToken);
        if (incrementors != null)
        {
            this.incrementors = incrementors;
            this.AdjustFlagsAndWidth(incrementors);
        }
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }


    internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxNode initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SyntaxNode incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.slotCount = 10;
        this.forKeyword = forKeyword;
        this.AdjustFlagsAndWidth(forKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        if (declaration != null)
        {
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(declaration);
        }
        if (initializers != null)
        {
            this.initializers = initializers;
            this.AdjustFlagsAndWidth(initializers);
        }
        this.firstSemicolonToken = firstSemicolonToken;
        this.AdjustFlagsAndWidth(firstSemicolonToken);
        if (condition != null)
        {
            this.condition = condition;
            this.AdjustFlagsAndWidth(condition);
        }
        this.secondSemicolonToken = secondSemicolonToken;
        this.AdjustFlagsAndWidth(secondSemicolonToken);
        if (incrementors != null)
        {
            this.incrementors = incrementors;
            this.AdjustFlagsAndWidth(incrementors);
        }
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }

    public SyntaxToken ForKeyword { get { return this.forKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public SeparatedSyntaxList<ExpressionSyntax> Initializers { get { return new SeparatedSyntaxList<ExpressionSyntax>(new SyntaxList<SyntaxNode>(this.initializers)); } }
    public SyntaxToken FirstSemicolonToken { get { return this.firstSemicolonToken; } }
    public ExpressionSyntax Condition { get { return this.condition; } }
    public SyntaxToken SecondSemicolonToken { get { return this.secondSemicolonToken; } }
    public SeparatedSyntaxList<ExpressionSyntax> Incrementors { get { return new SeparatedSyntaxList<ExpressionSyntax>(new SyntaxList<SyntaxNode>(this.incrementors)); } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.forKeyword;
            case 1: return this.openParenToken;
            case 2: return this.declaration;
            case 3: return this.initializers;
            case 4: return this.firstSemicolonToken;
            case 5: return this.condition;
            case 6: return this.secondSemicolonToken;
            case 7: return this.incrementors;
            case 8: return this.closeParenToken;
            case 9: return this.statement;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ForStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitForStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitForStatement(this);
    }

    public ForStatementSyntax Update(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (forKeyword != this.ForKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || initializers != this.Initializers || firstSemicolonToken != this.FirstSemicolonToken || condition != this.Condition || secondSemicolonToken != this.SecondSemicolonToken || incrementors != this.Incrementors || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = Syntax.ForStatement(forKeyword, openParenToken, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ForStatementSyntax(this.Kind, this.forKeyword, this.openParenToken, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ForStatementSyntax(this.Kind, this.forKeyword, this.openParenToken, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal ForStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 10;
      this.forKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.forKeyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.declaration = (VariableDeclarationSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.declaration);
      this.initializers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.initializers);
      this.firstSemicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.firstSemicolonToken);
      this.condition = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.condition);
      this.secondSemicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.secondSemicolonToken);
      this.incrementors = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.incrementors);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
      this.statement = (StatementSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.statement);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ForStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.forKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.initializers);
      writer.WriteValue(this.firstSemicolonToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.secondSemicolonToken);
      writer.WriteValue(this.incrementors);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }
  }

  internal sealed partial class ForEachStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken forEachKeyword;
    private readonly SyntaxToken openParenToken;
    private readonly TypeSyntax type;
    private readonly SyntaxToken identifier;
    private readonly SyntaxToken inKeyword;
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken closeParenToken;
    private readonly StatementSyntax statement;

    internal ForEachStatementSyntax(SyntaxKind kind, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 8;
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(inKeyword);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }


    internal ForEachStatementSyntax(SyntaxKind kind, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.slotCount = 8;
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(inKeyword);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }

    public SyntaxToken ForEachKeyword { get { return this.forEachKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public SyntaxToken InKeyword { get { return this.inKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.forEachKeyword;
            case 1: return this.openParenToken;
            case 2: return this.type;
            case 3: return this.identifier;
            case 4: return this.inKeyword;
            case 5: return this.expression;
            case 6: return this.closeParenToken;
            case 7: return this.statement;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ForEachStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitForEachStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitForEachStatement(this);
    }

    public ForEachStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (forEachKeyword != this.ForEachKeyword || openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = Syntax.ForEachStatement(forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ForEachStatementSyntax(this.Kind, this.forEachKeyword, this.openParenToken, this.type, this.identifier, this.inKeyword, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ForEachStatementSyntax(this.Kind, this.forEachKeyword, this.openParenToken, this.type, this.identifier, this.inKeyword, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal ForEachStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 8;
      this.forEachKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.forEachKeyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.inKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.inKeyword);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
      this.statement = (StatementSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.statement);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ForEachStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.forEachKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.inKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }
  }

  internal sealed partial class UsingStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken usingKeyword;
    private readonly SyntaxToken openParenToken;
    private readonly VariableDeclarationSyntax declaration;
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken closeParenToken;
    private readonly StatementSyntax statement;

    internal UsingStatementSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 6;
        this.usingKeyword = usingKeyword;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        if (declaration != null)
        {
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(declaration);
        }
        if (expression != null)
        {
            this.expression = expression;
            this.AdjustFlagsAndWidth(expression);
        }
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }


    internal UsingStatementSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.slotCount = 6;
        this.usingKeyword = usingKeyword;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        if (declaration != null)
        {
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(declaration);
        }
        if (expression != null)
        {
            this.expression = expression;
            this.AdjustFlagsAndWidth(expression);
        }
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }

    public SyntaxToken UsingKeyword { get { return this.usingKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.usingKeyword;
            case 1: return this.openParenToken;
            case 2: return this.declaration;
            case 3: return this.expression;
            case 4: return this.closeParenToken;
            case 5: return this.statement;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.UsingStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUsingStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitUsingStatement(this);
    }

    public UsingStatementSyntax Update(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (usingKeyword != this.UsingKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = Syntax.UsingStatement(usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new UsingStatementSyntax(this.Kind, this.usingKeyword, this.openParenToken, this.declaration, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new UsingStatementSyntax(this.Kind, this.usingKeyword, this.openParenToken, this.declaration, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal UsingStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 6;
      this.usingKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.usingKeyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.declaration = (VariableDeclarationSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.declaration);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
      this.statement = (StatementSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.statement);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new UsingStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.usingKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }
  }

  internal sealed partial class FixedStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken fixedKeyword;
    private readonly SyntaxToken openParenToken;
    private readonly VariableDeclarationSyntax declaration;
    private readonly SyntaxToken closeParenToken;
    private readonly StatementSyntax statement;

    internal FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 5;
        this.fixedKeyword = fixedKeyword;
        this.AdjustFlagsAndWidth(fixedKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(declaration);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }


    internal FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.slotCount = 5;
        this.fixedKeyword = fixedKeyword;
        this.AdjustFlagsAndWidth(fixedKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(declaration);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }

    public SyntaxToken FixedKeyword { get { return this.fixedKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.fixedKeyword;
            case 1: return this.openParenToken;
            case 2: return this.declaration;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.FixedStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFixedStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitFixedStatement(this);
    }

    public FixedStatementSyntax Update(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (fixedKeyword != this.FixedKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = Syntax.FixedStatement(fixedKeyword, openParenToken, declaration, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new FixedStatementSyntax(this.Kind, this.fixedKeyword, this.openParenToken, this.declaration, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new FixedStatementSyntax(this.Kind, this.fixedKeyword, this.openParenToken, this.declaration, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal FixedStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 5;
      this.fixedKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.fixedKeyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.declaration = (VariableDeclarationSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.declaration);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
      this.statement = (StatementSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.statement);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new FixedStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.fixedKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }
  }

  internal sealed partial class CheckedStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken keyword;
    private readonly BlockSyntax block;

    internal CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.block = block;
        this.AdjustFlagsAndWidth(block);
    }


    internal CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
        : base(kind)
    {
        this.slotCount = 2;
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.block = block;
        this.AdjustFlagsAndWidth(block);
    }

    public SyntaxToken Keyword { get { return this.keyword; } }
    public BlockSyntax Block { get { return this.block; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.block;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.CheckedStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCheckedStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCheckedStatement(this);
    }

    public CheckedStatementSyntax Update(SyntaxToken keyword, BlockSyntax block)
    {
        if (keyword != this.Keyword || block != this.Block)
        {
            var newNode = Syntax.CheckedStatement(this.Kind, keyword, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CheckedStatementSyntax(this.Kind, this.keyword, this.block, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CheckedStatementSyntax(this.Kind, this.keyword, this.block, GetDiagnostics(), annotations);
    }

    internal CheckedStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.keyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.keyword);
      this.block = (BlockSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.block);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new CheckedStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.block);
    }
  }

  internal sealed partial class UnsafeStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken unsafeKeyword;
    private readonly BlockSyntax block;

    internal UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.unsafeKeyword = unsafeKeyword;
        this.AdjustFlagsAndWidth(unsafeKeyword);
        this.block = block;
        this.AdjustFlagsAndWidth(block);
    }


    internal UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block)
        : base(kind)
    {
        this.slotCount = 2;
        this.unsafeKeyword = unsafeKeyword;
        this.AdjustFlagsAndWidth(unsafeKeyword);
        this.block = block;
        this.AdjustFlagsAndWidth(block);
    }

    public SyntaxToken UnsafeKeyword { get { return this.unsafeKeyword; } }
    public BlockSyntax Block { get { return this.block; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.unsafeKeyword;
            case 1: return this.block;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.UnsafeStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUnsafeStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitUnsafeStatement(this);
    }

    public UnsafeStatementSyntax Update(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
        if (unsafeKeyword != this.UnsafeKeyword || block != this.Block)
        {
            var newNode = Syntax.UnsafeStatement(unsafeKeyword, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new UnsafeStatementSyntax(this.Kind, this.unsafeKeyword, this.block, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new UnsafeStatementSyntax(this.Kind, this.unsafeKeyword, this.block, GetDiagnostics(), annotations);
    }

    internal UnsafeStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.unsafeKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.unsafeKeyword);
      this.block = (BlockSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.block);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new UnsafeStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.unsafeKeyword);
      writer.WriteValue(this.block);
    }
  }

  internal sealed partial class LockStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken lockKeyword;
    private readonly SyntaxToken openParenToken;
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken closeParenToken;
    private readonly StatementSyntax statement;

    internal LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 5;
        this.lockKeyword = lockKeyword;
        this.AdjustFlagsAndWidth(lockKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }


    internal LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.slotCount = 5;
        this.lockKeyword = lockKeyword;
        this.AdjustFlagsAndWidth(lockKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }

    public SyntaxToken LockKeyword { get { return this.lockKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lockKeyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.LockStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLockStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitLockStatement(this);
    }

    public LockStatementSyntax Update(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (lockKeyword != this.LockKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = Syntax.LockStatement(lockKeyword, openParenToken, expression, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LockStatementSyntax(this.Kind, this.lockKeyword, this.openParenToken, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LockStatementSyntax(this.Kind, this.lockKeyword, this.openParenToken, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal LockStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 5;
      this.lockKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.lockKeyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
      this.statement = (StatementSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.statement);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new LockStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lockKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }
  }

  /// <summary>
  /// Represents an if statement syntax.
  /// </summary>
  internal sealed partial class IfStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken ifKeyword;
    private readonly SyntaxToken openParenToken;
    private readonly ExpressionSyntax condition;
    private readonly SyntaxToken closeParenToken;
    private readonly StatementSyntax statement;
    private readonly ElseClauseSyntax @else;

    internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 6;
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.condition = condition;
        this.AdjustFlagsAndWidth(condition);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
        if (@else != null)
        {
            this.@else = @else;
            this.AdjustFlagsAndWidth(@else);
        }
    }


    internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
        : base(kind)
    {
        this.slotCount = 6;
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.condition = condition;
        this.AdjustFlagsAndWidth(condition);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
        if (@else != null)
        {
            this.@else = @else;
            this.AdjustFlagsAndWidth(@else);
        }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the if keyword.
    /// </summary>
    public SyntaxToken IfKeyword { get { return this.ifKeyword; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
    /// </summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>
    /// Gets an ExpressionSyntax that represents the condition of the if statement.
    /// </summary>
    public ExpressionSyntax Condition { get { return this.condition; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
    /// </summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    /// <summary>
    /// Gets a StatementSyntax the represents the statement to be executed when the condition is true.
    /// </summary>
    public StatementSyntax Statement { get { return this.statement; } }
    /// <summary>
    /// Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
    /// </summary>
    public ElseClauseSyntax Else { get { return this.@else; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.ifKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            case 5: return this.@else;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.IfStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIfStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitIfStatement(this);
    }

    public IfStatementSyntax Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
        if (ifKeyword != this.IfKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement || @else != this.Else)
        {
            var newNode = Syntax.IfStatement(ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IfStatementSyntax(this.Kind, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.@else, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IfStatementSyntax(this.Kind, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.@else, GetDiagnostics(), annotations);
    }

    internal IfStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 6;
      this.ifKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.ifKeyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.condition = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.condition);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
      this.statement = (StatementSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.statement);
      this.@else = (ElseClauseSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.@else);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new IfStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.ifKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
      writer.WriteValue(this.@else);
    }
  }

  /// <summary>Represents an else statement syntax.</summary>
  internal sealed partial class ElseClauseSyntax : SyntaxNode
  {
    private readonly SyntaxToken elseKeyword;
    private readonly StatementSyntax statement;

    internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }


    internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement)
        : base(kind)
    {
        this.slotCount = 2;
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.statement = statement;
        this.AdjustFlagsAndWidth(statement);
    }

    /// <summary>
    /// Gets a syntax token
    /// </summary>
    public SyntaxToken ElseKeyword { get { return this.elseKeyword; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elseKeyword;
            case 1: return this.statement;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ElseClauseSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElseClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitElseClause(this);
    }

    public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementSyntax statement)
    {
        if (elseKeyword != this.ElseKeyword || statement != this.Statement)
        {
            var newNode = Syntax.ElseClause(elseKeyword, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ElseClauseSyntax(this.Kind, this.elseKeyword, this.statement, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ElseClauseSyntax(this.Kind, this.elseKeyword, this.statement, GetDiagnostics(), annotations);
    }

    internal ElseClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.elseKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.elseKeyword);
      this.statement = (StatementSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.statement);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ElseClauseSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elseKeyword);
      writer.WriteValue(this.statement);
    }
  }

  /// <summary>Represents a switch statement syntax.</summary>
  internal sealed partial class SwitchStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken switchKeyword;
    private readonly SyntaxToken openParenToken;
    private readonly ExpressionSyntax expression;
    private readonly SyntaxToken closeParenToken;
    private readonly SyntaxToken openBraceToken;
    private readonly SyntaxNode sections;
    private readonly SyntaxToken closeBraceToken;

    internal SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxNode sections, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 7;
        this.switchKeyword = switchKeyword;
        this.AdjustFlagsAndWidth(switchKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (sections != null)
        {
            this.sections = sections;
            this.AdjustFlagsAndWidth(sections);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
    }


    internal SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxNode sections, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.slotCount = 7;
        this.switchKeyword = switchKeyword;
        this.AdjustFlagsAndWidth(switchKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (sections != null)
        {
            this.sections = sections;
            this.AdjustFlagsAndWidth(sections);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the switch keyword.
    /// </summary>
    public SyntaxToken SwitchKeyword { get { return this.switchKeyword; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the open parenthesis preceding the switch expression.
    /// </summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>
    /// Gets an ExpressionSyntax representing the expression of the switch statement.
    /// </summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the close parenthesis succeeding the switch expression.
    /// </summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the open braces preceding the switch sections.
    /// </summary>
    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    /// <summary>
    /// Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
    /// </summary>
    public SyntaxList<SwitchSectionSyntax> Sections { get { return new SyntaxList<SwitchSectionSyntax>(this.sections); } }
    /// <summary>
    /// Gets a SyntaxToken that represents the open braces succeeding the switch sections.
    /// </summary>
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.switchKeyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            case 4: return this.openBraceToken;
            case 5: return this.sections;
            case 6: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.SwitchStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitSwitchStatement(this);
    }

    public SwitchStatementSyntax Update(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
        if (switchKeyword != this.SwitchKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || openBraceToken != this.OpenBraceToken || sections != this.Sections || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = Syntax.SwitchStatement(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SwitchStatementSyntax(this.Kind, this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.sections, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SwitchStatementSyntax(this.Kind, this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.sections, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal SwitchStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 7;
      this.switchKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.switchKeyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
      this.openBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openBraceToken);
      this.sections = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.sections);
      this.closeBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeBraceToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new SwitchStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.switchKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.sections);
      writer.WriteValue(this.closeBraceToken);
    }
  }

  /// <summary>Represents a switch section syntax of a switch statement.</summary>
  internal sealed partial class SwitchSectionSyntax : SyntaxNode
  {
    private readonly SyntaxNode labels;
    private readonly SyntaxNode statements;

    internal SwitchSectionSyntax(SyntaxKind kind, SyntaxNode labels, SyntaxNode statements, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        if (labels != null)
        {
            this.labels = labels;
            this.AdjustFlagsAndWidth(labels);
        }
        if (statements != null)
        {
            this.statements = statements;
            this.AdjustFlagsAndWidth(statements);
        }
    }


    internal SwitchSectionSyntax(SyntaxKind kind, SyntaxNode labels, SyntaxNode statements)
        : base(kind)
    {
        this.slotCount = 2;
        if (labels != null)
        {
            this.labels = labels;
            this.AdjustFlagsAndWidth(labels);
        }
        if (statements != null)
        {
            this.statements = statements;
            this.AdjustFlagsAndWidth(statements);
        }
    }

    /// <summary>
    /// Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
    /// </summary>
    public SyntaxList<SwitchLabelSyntax> Labels { get { return new SyntaxList<SwitchLabelSyntax>(this.labels); } }
    /// <summary>
    /// Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
    /// </summary>
    public SyntaxList<StatementSyntax> Statements { get { return new SyntaxList<StatementSyntax>(this.statements); } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.labels;
            case 1: return this.statements;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.SwitchSectionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchSection(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitSwitchSection(this);
    }

    public SwitchSectionSyntax Update(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements)
    {
        if (labels != this.Labels || statements != this.Statements)
        {
            var newNode = Syntax.SwitchSection(labels, statements);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SwitchSectionSyntax(this.Kind, this.labels, this.statements, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SwitchSectionSyntax(this.Kind, this.labels, this.statements, GetDiagnostics(), annotations);
    }

    internal SwitchSectionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.labels = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.labels);
      this.statements = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.statements);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new SwitchSectionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.labels);
      writer.WriteValue(this.statements);
    }
  }

  /// <summary>Represents a switch label within a switch statement.</summary>
  internal sealed partial class SwitchLabelSyntax : SyntaxNode
  {
    private readonly SyntaxToken caseOrDefaultKeyword;
    private readonly ExpressionSyntax value;
    private readonly SyntaxToken colonToken;

    internal SwitchLabelSyntax(SyntaxKind kind, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax value, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.caseOrDefaultKeyword = caseOrDefaultKeyword;
        this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
        if (value != null)
        {
            this.value = value;
            this.AdjustFlagsAndWidth(value);
        }
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
    }


    internal SwitchLabelSyntax(SyntaxKind kind, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax value, SyntaxToken colonToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.caseOrDefaultKeyword = caseOrDefaultKeyword;
        this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
        if (value != null)
        {
            this.value = value;
            this.AdjustFlagsAndWidth(value);
        }
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
    }

    /// <summary>
    /// Gets a SyntaxToken that represents a case or default keywords that belongs to a switch label.
    /// </summary>
    public SyntaxToken CaseOrDefaultKeyword { get { return this.caseOrDefaultKeyword; } }
    /// <summary>
    /// Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label. For default label the property returns null.
    /// </summary>
    public ExpressionSyntax Value { get { return this.value; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the colon that terminates the switch label.
    /// </summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.caseOrDefaultKeyword;
            case 1: return this.value;
            case 2: return this.colonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.SwitchLabelSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchLabel(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitSwitchLabel(this);
    }

    public SwitchLabelSyntax Update(SyntaxToken caseOrDefaultKeyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
        if (caseOrDefaultKeyword != this.CaseOrDefaultKeyword || value != this.Value || colonToken != this.ColonToken)
        {
            var newNode = Syntax.SwitchLabel(this.Kind, caseOrDefaultKeyword, value, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SwitchLabelSyntax(this.Kind, this.caseOrDefaultKeyword, this.value, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SwitchLabelSyntax(this.Kind, this.caseOrDefaultKeyword, this.value, this.colonToken, GetDiagnostics(), annotations);
    }

    internal SwitchLabelSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.caseOrDefaultKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.caseOrDefaultKeyword);
      this.value = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.value);
      this.colonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.colonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new SwitchLabelSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.caseOrDefaultKeyword);
      writer.WriteValue(this.value);
      writer.WriteValue(this.colonToken);
    }
  }

  internal sealed partial class TryStatementSyntax : StatementSyntax
  {
    private readonly SyntaxToken tryKeyword;
    private readonly BlockSyntax block;
    private readonly SyntaxNode catches;
    private readonly FinallyClauseSyntax @finally;

    internal TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, SyntaxNode catches, FinallyClauseSyntax @finally, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.tryKeyword = tryKeyword;
        this.AdjustFlagsAndWidth(tryKeyword);
        this.block = block;
        this.AdjustFlagsAndWidth(block);
        if (catches != null)
        {
            this.catches = catches;
            this.AdjustFlagsAndWidth(catches);
        }
        if (@finally != null)
        {
            this.@finally = @finally;
            this.AdjustFlagsAndWidth(@finally);
        }
    }


    internal TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, SyntaxNode catches, FinallyClauseSyntax @finally)
        : base(kind)
    {
        this.slotCount = 4;
        this.tryKeyword = tryKeyword;
        this.AdjustFlagsAndWidth(tryKeyword);
        this.block = block;
        this.AdjustFlagsAndWidth(block);
        if (catches != null)
        {
            this.catches = catches;
            this.AdjustFlagsAndWidth(catches);
        }
        if (@finally != null)
        {
            this.@finally = @finally;
            this.AdjustFlagsAndWidth(@finally);
        }
    }

    public SyntaxToken TryKeyword { get { return this.tryKeyword; } }
    public BlockSyntax Block { get { return this.block; } }
    public SyntaxList<CatchClauseSyntax> Catches { get { return new SyntaxList<CatchClauseSyntax>(this.catches); } }
    public FinallyClauseSyntax Finally { get { return this.@finally; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.tryKeyword;
            case 1: return this.block;
            case 2: return this.catches;
            case 3: return this.@finally;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.TryStatementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTryStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitTryStatement(this);
    }

    public TryStatementSyntax Update(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
        if (tryKeyword != this.TryKeyword || block != this.Block || catches != this.Catches || @finally != this.Finally)
        {
            var newNode = Syntax.TryStatement(tryKeyword, block, catches, @finally);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TryStatementSyntax(this.Kind, this.tryKeyword, this.block, this.catches, this.@finally, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TryStatementSyntax(this.Kind, this.tryKeyword, this.block, this.catches, this.@finally, GetDiagnostics(), annotations);
    }

    internal TryStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.tryKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.tryKeyword);
      this.block = (BlockSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.block);
      this.catches = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.catches);
      this.@finally = (FinallyClauseSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.@finally);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new TryStatementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.tryKeyword);
      writer.WriteValue(this.block);
      writer.WriteValue(this.catches);
      writer.WriteValue(this.@finally);
    }
  }

  internal sealed partial class CatchClauseSyntax : SyntaxNode
  {
    private readonly SyntaxToken catchKeyword;
    private readonly CatchDeclarationSyntax declaration;
    private readonly BlockSyntax block;

    internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.catchKeyword = catchKeyword;
        this.AdjustFlagsAndWidth(catchKeyword);
        if (declaration != null)
        {
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(declaration);
        }
        this.block = block;
        this.AdjustFlagsAndWidth(block);
    }


    internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, BlockSyntax block)
        : base(kind)
    {
        this.slotCount = 3;
        this.catchKeyword = catchKeyword;
        this.AdjustFlagsAndWidth(catchKeyword);
        if (declaration != null)
        {
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(declaration);
        }
        this.block = block;
        this.AdjustFlagsAndWidth(block);
    }

    public SyntaxToken CatchKeyword { get { return this.catchKeyword; } }
    public CatchDeclarationSyntax Declaration { get { return this.declaration; } }
    public BlockSyntax Block { get { return this.block; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.catchKeyword;
            case 1: return this.declaration;
            case 2: return this.block;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.CatchClauseSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCatchClause(this);
    }

    public CatchClauseSyntax Update(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, BlockSyntax block)
    {
        if (catchKeyword != this.CatchKeyword || declaration != this.Declaration || block != this.Block)
        {
            var newNode = Syntax.CatchClause(catchKeyword, declaration, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CatchClauseSyntax(this.Kind, this.catchKeyword, this.declaration, this.block, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CatchClauseSyntax(this.Kind, this.catchKeyword, this.declaration, this.block, GetDiagnostics(), annotations);
    }

    internal CatchClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.catchKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.catchKeyword);
      this.declaration = (CatchDeclarationSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.declaration);
      this.block = (BlockSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.block);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new CatchClauseSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.catchKeyword);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.block);
    }
  }

  internal sealed partial class CatchDeclarationSyntax : SyntaxNode
  {
    private readonly SyntaxToken openParenToken;
    private readonly TypeSyntax type;
    private readonly SyntaxToken identifier;
    private readonly SyntaxToken closeParenToken;

    internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        if (identifier != null)
        {
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(identifier);
        }
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }


    internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        if (identifier != null)
        {
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(identifier);
        }
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }

    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public TypeSyntax Type { get { return this.type; } }
    public SyntaxToken Identifier { get { return this.identifier; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.type;
            case 2: return this.identifier;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.CatchDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCatchDeclaration(this);
    }

    public CatchDeclarationSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.CatchDeclaration(openParenToken, type, identifier, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CatchDeclarationSyntax(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CatchDeclarationSyntax(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal CatchDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new CatchDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.closeParenToken);
    }
  }

  internal sealed partial class FinallyClauseSyntax : SyntaxNode
  {
    private readonly SyntaxToken finallyKeyword;
    private readonly BlockSyntax block;

    internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.finallyKeyword = finallyKeyword;
        this.AdjustFlagsAndWidth(finallyKeyword);
        this.block = block;
        this.AdjustFlagsAndWidth(block);
    }


    internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block)
        : base(kind)
    {
        this.slotCount = 2;
        this.finallyKeyword = finallyKeyword;
        this.AdjustFlagsAndWidth(finallyKeyword);
        this.block = block;
        this.AdjustFlagsAndWidth(block);
    }

    public SyntaxToken FinallyKeyword { get { return this.finallyKeyword; } }
    public BlockSyntax Block { get { return this.block; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.finallyKeyword;
            case 1: return this.block;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.FinallyClauseSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFinallyClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitFinallyClause(this);
    }

    public FinallyClauseSyntax Update(SyntaxToken finallyKeyword, BlockSyntax block)
    {
        if (finallyKeyword != this.FinallyKeyword || block != this.Block)
        {
            var newNode = Syntax.FinallyClause(finallyKeyword, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new FinallyClauseSyntax(this.Kind, this.finallyKeyword, this.block, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new FinallyClauseSyntax(this.Kind, this.finallyKeyword, this.block, GetDiagnostics(), annotations);
    }

    internal FinallyClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.finallyKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.finallyKeyword);
      this.block = (BlockSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.block);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new FinallyClauseSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.finallyKeyword);
      writer.WriteValue(this.block);
    }
  }

  internal sealed partial class CompilationUnitSyntax : SyntaxNode
  {
    private readonly SyntaxNode externs;
    private readonly SyntaxNode usings;
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode members;
    private readonly SyntaxToken endOfFileToken;

    internal CompilationUnitSyntax(SyntaxKind kind, SyntaxNode externs, SyntaxNode usings, SyntaxNode attributes, SyntaxNode members, SyntaxToken endOfFileToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 5;
        if (externs != null)
        {
            this.externs = externs;
            this.AdjustFlagsAndWidth(externs);
        }
        if (usings != null)
        {
            this.usings = usings;
            this.AdjustFlagsAndWidth(usings);
        }
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (members != null)
        {
            this.members = members;
            this.AdjustFlagsAndWidth(members);
        }
        this.endOfFileToken = endOfFileToken;
        this.AdjustFlagsAndWidth(endOfFileToken);
    }


    internal CompilationUnitSyntax(SyntaxKind kind, SyntaxNode externs, SyntaxNode usings, SyntaxNode attributes, SyntaxNode members, SyntaxToken endOfFileToken)
        : base(kind)
    {
        this.slotCount = 5;
        if (externs != null)
        {
            this.externs = externs;
            this.AdjustFlagsAndWidth(externs);
        }
        if (usings != null)
        {
            this.usings = usings;
            this.AdjustFlagsAndWidth(usings);
        }
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (members != null)
        {
            this.members = members;
            this.AdjustFlagsAndWidth(members);
        }
        this.endOfFileToken = endOfFileToken;
        this.AdjustFlagsAndWidth(endOfFileToken);
    }

    public SyntaxList<ExternAliasDirectiveSyntax> Externs { get { return new SyntaxList<ExternAliasDirectiveSyntax>(this.externs); } }
    public SyntaxList<UsingDirectiveSyntax> Usings { get { return new SyntaxList<UsingDirectiveSyntax>(this.usings); } }
    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    public SyntaxList<MemberDeclarationSyntax> Members { get { return new SyntaxList<MemberDeclarationSyntax>(this.members); } }
    public SyntaxToken EndOfFileToken { get { return this.endOfFileToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.externs;
            case 1: return this.usings;
            case 2: return this.attributes;
            case 3: return this.members;
            case 4: return this.endOfFileToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.CompilationUnitSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCompilationUnit(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCompilationUnit(this);
    }

    public CompilationUnitSyntax Update(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
        if (externs != this.Externs || usings != this.Usings || attributes != this.Attributes || members != this.Members || endOfFileToken != this.EndOfFileToken)
        {
            var newNode = Syntax.CompilationUnit(externs, usings, attributes, members, endOfFileToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CompilationUnitSyntax(this.Kind, this.externs, this.usings, this.attributes, this.members, this.endOfFileToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CompilationUnitSyntax(this.Kind, this.externs, this.usings, this.attributes, this.members, this.endOfFileToken, GetDiagnostics(), annotations);
    }

    internal CompilationUnitSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 5;
      this.externs = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.externs);
      this.usings = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.usings);
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.members = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.members);
      this.endOfFileToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfFileToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new CompilationUnitSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.externs);
      writer.WriteValue(this.usings);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.members);
      writer.WriteValue(this.endOfFileToken);
    }
  }

  /// <summary>
  /// Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
  /// </summary>
  internal sealed partial class ExternAliasDirectiveSyntax : SyntaxNode
  {
    private readonly SyntaxToken externKeyword;
    private readonly SyntaxToken aliasKeyword;
    private readonly SyntaxToken identifier;
    private readonly SyntaxToken semicolonToken;

    internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.externKeyword = externKeyword;
        this.AdjustFlagsAndWidth(externKeyword);
        this.aliasKeyword = aliasKeyword;
        this.AdjustFlagsAndWidth(aliasKeyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }


    internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.externKeyword = externKeyword;
        this.AdjustFlagsAndWidth(externKeyword);
        this.aliasKeyword = aliasKeyword;
        this.AdjustFlagsAndWidth(aliasKeyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }

    /// <summary>SyntaxToken representing the extern keyword.</summary>
    public SyntaxToken ExternKeyword { get { return this.externKeyword; } }
    /// <summary>SyntaxToken representing the alias keyword.</summary>
    public SyntaxToken AliasKeyword { get { return this.aliasKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    /// <summary>SyntaxToken representing the semicolon token.</summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.externKeyword;
            case 1: return this.aliasKeyword;
            case 2: return this.identifier;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ExternAliasDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExternAliasDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitExternAliasDirective(this);
    }

    public ExternAliasDirectiveSyntax Update(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
        if (externKeyword != this.ExternKeyword || aliasKeyword != this.AliasKeyword || identifier != this.Identifier || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ExternAliasDirective(externKeyword, aliasKeyword, identifier, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ExternAliasDirectiveSyntax(this.Kind, this.externKeyword, this.aliasKeyword, this.identifier, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ExternAliasDirectiveSyntax(this.Kind, this.externKeyword, this.aliasKeyword, this.identifier, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ExternAliasDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.externKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.externKeyword);
      this.aliasKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.aliasKeyword);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ExternAliasDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.externKeyword);
      writer.WriteValue(this.aliasKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.semicolonToken);
    }
  }

  internal sealed partial class UsingDirectiveSyntax : SyntaxNode
  {
    private readonly SyntaxToken usingKeyword;
    private readonly NameEqualsSyntax alias;
    private readonly NameSyntax name;
    private readonly SyntaxToken semicolonToken;

    internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.usingKeyword = usingKeyword;
        this.AdjustFlagsAndWidth(usingKeyword);
        if (alias != null)
        {
            this.alias = alias;
            this.AdjustFlagsAndWidth(alias);
        }
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }


    internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.usingKeyword = usingKeyword;
        this.AdjustFlagsAndWidth(usingKeyword);
        if (alias != null)
        {
            this.alias = alias;
            this.AdjustFlagsAndWidth(alias);
        }
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }

    public SyntaxToken UsingKeyword { get { return this.usingKeyword; } }
    public NameEqualsSyntax Alias { get { return this.alias; } }
    public NameSyntax Name { get { return this.name; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.usingKeyword;
            case 1: return this.alias;
            case 2: return this.name;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.UsingDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUsingDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitUsingDirective(this);
    }

    public UsingDirectiveSyntax Update(SyntaxToken usingKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
        if (usingKeyword != this.UsingKeyword || alias != this.Alias || name != this.Name || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.UsingDirective(usingKeyword, alias, name, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new UsingDirectiveSyntax(this.Kind, this.usingKeyword, this.alias, this.name, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new UsingDirectiveSyntax(this.Kind, this.usingKeyword, this.alias, this.name, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal UsingDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.usingKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.usingKeyword);
      this.alias = (NameEqualsSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.alias);
      this.name = (NameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.name);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new UsingDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.usingKeyword);
      writer.WriteValue(this.alias);
      writer.WriteValue(this.name);
      writer.WriteValue(this.semicolonToken);
    }
  }

  /// <summary>Member declaration syntax.</summary>
  internal abstract partial class MemberDeclarationSyntax : SyntaxNode
  {
    internal MemberDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal MemberDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected MemberDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class NamespaceDeclarationSyntax : MemberDeclarationSyntax
  {
    private readonly SyntaxToken namespaceKeyword;
    private readonly NameSyntax name;
    private readonly SyntaxToken openBraceToken;
    private readonly SyntaxNode externs;
    private readonly SyntaxNode usings;
    private readonly SyntaxNode members;
    private readonly SyntaxToken closeBraceToken;
    private readonly SyntaxToken semicolonToken;

    internal NamespaceDeclarationSyntax(SyntaxKind kind, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxNode externs, SyntaxNode usings, SyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 8;
        this.namespaceKeyword = namespaceKeyword;
        this.AdjustFlagsAndWidth(namespaceKeyword);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (externs != null)
        {
            this.externs = externs;
            this.AdjustFlagsAndWidth(externs);
        }
        if (usings != null)
        {
            this.usings = usings;
            this.AdjustFlagsAndWidth(usings);
        }
        if (members != null)
        {
            this.members = members;
            this.AdjustFlagsAndWidth(members);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }


    internal NamespaceDeclarationSyntax(SyntaxKind kind, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxNode externs, SyntaxNode usings, SyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 8;
        this.namespaceKeyword = namespaceKeyword;
        this.AdjustFlagsAndWidth(namespaceKeyword);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (externs != null)
        {
            this.externs = externs;
            this.AdjustFlagsAndWidth(externs);
        }
        if (usings != null)
        {
            this.usings = usings;
            this.AdjustFlagsAndWidth(usings);
        }
        if (members != null)
        {
            this.members = members;
            this.AdjustFlagsAndWidth(members);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }

    public SyntaxToken NamespaceKeyword { get { return this.namespaceKeyword; } }
    public NameSyntax Name { get { return this.name; } }
    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public SyntaxList<ExternAliasDirectiveSyntax> Externs { get { return new SyntaxList<ExternAliasDirectiveSyntax>(this.externs); } }
    public SyntaxList<UsingDirectiveSyntax> Usings { get { return new SyntaxList<UsingDirectiveSyntax>(this.usings); } }
    public SyntaxList<MemberDeclarationSyntax> Members { get { return new SyntaxList<MemberDeclarationSyntax>(this.members); } }
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.namespaceKeyword;
            case 1: return this.name;
            case 2: return this.openBraceToken;
            case 3: return this.externs;
            case 4: return this.usings;
            case 5: return this.members;
            case 6: return this.closeBraceToken;
            case 7: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.NamespaceDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNamespaceDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitNamespaceDeclaration(this);
    }

    public NamespaceDeclarationSyntax Update(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (namespaceKeyword != this.NamespaceKeyword || name != this.Name || openBraceToken != this.OpenBraceToken || externs != this.Externs || usings != this.Usings || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.NamespaceDeclaration(namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new NamespaceDeclarationSyntax(this.Kind, this.namespaceKeyword, this.name, this.openBraceToken, this.externs, this.usings, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new NamespaceDeclarationSyntax(this.Kind, this.namespaceKeyword, this.name, this.openBraceToken, this.externs, this.usings, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal NamespaceDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 8;
      this.namespaceKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.namespaceKeyword);
      this.name = (NameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.name);
      this.openBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openBraceToken);
      this.externs = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.externs);
      this.usings = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.usings);
      this.members = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.members);
      this.closeBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeBraceToken);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new NamespaceDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.namespaceKeyword);
      writer.WriteValue(this.name);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.externs);
      writer.WriteValue(this.usings);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }
  }

  /// <summary>Class representing one or more attributes applied to a language construct.</summary>
  internal sealed partial class AttributeDeclarationSyntax : SyntaxNode
  {
    private readonly SyntaxToken openBracketToken;
    private readonly AttributeTargetSpecifierSyntax target;
    private readonly SyntaxNode attributes;
    private readonly SyntaxToken closeBracketToken;

    internal AttributeDeclarationSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SyntaxNode attributes, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.openBracketToken = openBracketToken;
        this.AdjustFlagsAndWidth(openBracketToken);
        if (target != null)
        {
            this.target = target;
            this.AdjustFlagsAndWidth(target);
        }
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(closeBracketToken);
    }


    internal AttributeDeclarationSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SyntaxNode attributes, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.openBracketToken = openBracketToken;
        this.AdjustFlagsAndWidth(openBracketToken);
        if (target != null)
        {
            this.target = target;
            this.AdjustFlagsAndWidth(target);
        }
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(closeBracketToken);
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    public AttributeTargetSpecifierSyntax Target { get { return this.target; } }
    /// <summary>Gets the attribute declaration list.</summary>
    public SeparatedSyntaxList<AttributeSyntax> Attributes { get { return new SeparatedSyntaxList<AttributeSyntax>(new SyntaxList<SyntaxNode>(this.attributes)); } }
    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.target;
            case 2: return this.attributes;
            case 3: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.AttributeDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAttributeDeclaration(this);
    }

    public AttributeDeclarationSyntax Update(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || target != this.Target || attributes != this.Attributes || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = Syntax.AttributeDeclaration(openBracketToken, target, attributes, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AttributeDeclarationSyntax(this.Kind, this.openBracketToken, this.target, this.attributes, this.closeBracketToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AttributeDeclarationSyntax(this.Kind, this.openBracketToken, this.target, this.attributes, this.closeBracketToken, GetDiagnostics(), annotations);
    }

    internal AttributeDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.openBracketToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openBracketToken);
      this.target = (AttributeTargetSpecifierSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.target);
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.closeBracketToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeBracketToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new AttributeDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.target);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.closeBracketToken);
    }
  }

  /// <summary>Class representing what language construct an attribute targets.</summary>
  internal sealed partial class AttributeTargetSpecifierSyntax : SyntaxNode
  {
    private readonly SyntaxToken identifier;
    private readonly SyntaxToken colonToken;

    internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
    }


    internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken)
        : base(kind)
    {
        this.slotCount = 2;
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.AttributeTargetSpecifierSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeTargetSpecifier(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAttributeTargetSpecifier(this);
    }

    public AttributeTargetSpecifierSyntax Update(SyntaxToken identifier, SyntaxToken colonToken)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken)
        {
            var newNode = Syntax.AttributeTargetSpecifier(identifier, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AttributeTargetSpecifierSyntax(this.Kind, this.identifier, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AttributeTargetSpecifierSyntax(this.Kind, this.identifier, this.colonToken, GetDiagnostics(), annotations);
    }

    internal AttributeTargetSpecifierSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.colonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.colonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new AttributeTargetSpecifierSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.colonToken);
    }
  }

  /// <summary>Attribute syntax.</summary>
  internal sealed partial class AttributeSyntax : SyntaxNode
  {
    private readonly NameSyntax name;
    private readonly AttributeArgumentListSyntax argumentList;

    internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        if (argumentList != null)
        {
            this.argumentList = argumentList;
            this.AdjustFlagsAndWidth(argumentList);
        }
    }


    internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax argumentList)
        : base(kind)
    {
        this.slotCount = 2;
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        if (argumentList != null)
        {
            this.argumentList = argumentList;
            this.AdjustFlagsAndWidth(argumentList);
        }
    }

    /// <summary>Gets the name.</summary>
    public NameSyntax Name { get { return this.name; } }
    public AttributeArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.AttributeSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttribute(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAttribute(this);
    }

    public AttributeSyntax Update(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
        if (name != this.Name || argumentList != this.ArgumentList)
        {
            var newNode = Syntax.Attribute(name, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AttributeSyntax(this.Kind, this.name, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AttributeSyntax(this.Kind, this.name, this.argumentList, GetDiagnostics(), annotations);
    }

    internal AttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.name = (NameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.name);
      this.argumentList = (AttributeArgumentListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.argumentList);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new AttributeSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.argumentList);
    }
  }

  /// <summary>Attribute argument list syntax.</summary>
  internal sealed partial class AttributeArgumentListSyntax : SyntaxNode
  {
    private readonly SyntaxToken openParenToken;
    private readonly SyntaxNode arguments;
    private readonly SyntaxToken closeParenToken;

    internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, SyntaxNode arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        if (arguments != null)
        {
            this.arguments = arguments;
            this.AdjustFlagsAndWidth(arguments);
        }
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }


    internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, SyntaxNode arguments, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        if (arguments != null)
        {
            this.arguments = arguments;
            this.AdjustFlagsAndWidth(arguments);
        }
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Gets the arguments syntax list.</summary>
    public SeparatedSyntaxList<AttributeArgumentSyntax> Arguments { get { return new SeparatedSyntaxList<AttributeArgumentSyntax>(new SyntaxList<SyntaxNode>(this.arguments)); } }
    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.arguments;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.AttributeArgumentListSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeArgumentList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAttributeArgumentList(this);
    }

    public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.AttributeArgumentList(openParenToken, arguments, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AttributeArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AttributeArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal AttributeArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.arguments = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.arguments);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new AttributeArgumentListSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.closeParenToken);
    }
  }

  /// <summary>Attribute argument syntax.</summary>
  internal sealed partial class AttributeArgumentSyntax : SyntaxNode
  {
    private readonly NameEqualsSyntax nameEquals;
    private readonly NameColonSyntax nameColon;
    private readonly ExpressionSyntax expression;

    internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        if (nameEquals != null)
        {
            this.nameEquals = nameEquals;
            this.AdjustFlagsAndWidth(nameEquals);
        }
        if (nameColon != null)
        {
            this.nameColon = nameColon;
            this.AdjustFlagsAndWidth(nameColon);
        }
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
    }


    internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
        : base(kind)
    {
        this.slotCount = 3;
        if (nameEquals != null)
        {
            this.nameEquals = nameEquals;
            this.AdjustFlagsAndWidth(nameEquals);
        }
        if (nameColon != null)
        {
            this.nameColon = nameColon;
            this.AdjustFlagsAndWidth(nameColon);
        }
        this.expression = expression;
        this.AdjustFlagsAndWidth(expression);
    }

    public NameEqualsSyntax NameEquals { get { return this.nameEquals; } }
    public NameColonSyntax NameColon { get { return this.nameColon; } }
    /// <summary>Gets the expression.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameEquals;
            case 1: return this.nameColon;
            case 2: return this.expression;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.AttributeArgumentSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeArgument(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAttributeArgument(this);
    }

    public AttributeArgumentSyntax Update(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
        if (nameEquals != this.NameEquals || nameColon != this.NameColon || expression != this.Expression)
        {
            var newNode = Syntax.AttributeArgument(nameEquals, nameColon, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AttributeArgumentSyntax(this.Kind, this.nameEquals, this.nameColon, this.expression, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AttributeArgumentSyntax(this.Kind, this.nameEquals, this.nameColon, this.expression, GetDiagnostics(), annotations);
    }

    internal AttributeArgumentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.nameEquals = (NameEqualsSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.nameEquals);
      this.nameColon = (NameColonSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.nameColon);
      this.expression = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.expression);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new AttributeArgumentSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.nameEquals);
      writer.WriteValue(this.nameColon);
      writer.WriteValue(this.expression);
    }
  }

  /// <summary>Class representing an identifier followed by an equals token.</summary>
  internal sealed partial class NameEqualsSyntax : SyntaxNode
  {
    private readonly IdentifierNameSyntax identifier;
    private readonly SyntaxToken equalsToken;

    internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax identifier, SyntaxToken equalsToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(equalsToken);
    }


    internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax identifier, SyntaxToken equalsToken)
        : base(kind)
    {
        this.slotCount = 2;
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(equalsToken);
    }

    /// <summary>Gets the identifier.</summary>
    public IdentifierNameSyntax Identifier { get { return this.identifier; } }
    public SyntaxToken EqualsToken { get { return this.equalsToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.equalsToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.NameEqualsSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameEquals(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitNameEquals(this);
    }

    public NameEqualsSyntax Update(IdentifierNameSyntax identifier, SyntaxToken equalsToken)
    {
        if (identifier != this.Identifier || equalsToken != this.EqualsToken)
        {
            var newNode = Syntax.NameEquals(identifier, equalsToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new NameEqualsSyntax(this.Kind, this.identifier, this.equalsToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new NameEqualsSyntax(this.Kind, this.identifier, this.equalsToken, GetDiagnostics(), annotations);
    }

    internal NameEqualsSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.identifier = (IdentifierNameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.equalsToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.equalsToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new NameEqualsSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.equalsToken);
    }
  }

  /// <summary>Type parameter list syntax.</summary>
  internal sealed partial class TypeParameterListSyntax : SyntaxNode
  {
    private readonly SyntaxToken lessThanToken;
    private readonly SyntaxNode parameters;
    private readonly SyntaxToken greaterThanToken;

    internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, SyntaxNode parameters, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(lessThanToken);
        if (parameters != null)
        {
            this.parameters = parameters;
            this.AdjustFlagsAndWidth(parameters);
        }
        this.greaterThanToken = greaterThanToken;
        this.AdjustFlagsAndWidth(greaterThanToken);
    }


    internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, SyntaxNode parameters, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(lessThanToken);
        if (parameters != null)
        {
            this.parameters = parameters;
            this.AdjustFlagsAndWidth(parameters);
        }
        this.greaterThanToken = greaterThanToken;
        this.AdjustFlagsAndWidth(greaterThanToken);
    }

    /// <summary>Gets the &lt; token.</summary>
    public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
    /// <summary>Gets the parameter list.</summary>
    public SeparatedSyntaxList<TypeParameterSyntax> Parameters { get { return new SeparatedSyntaxList<TypeParameterSyntax>(new SyntaxList<SyntaxNode>(this.parameters)); } }
    /// <summary>Gets the &gt; token.</summary>
    public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.parameters;
            case 2: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.TypeParameterListSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameterList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitTypeParameterList(this);
    }

    public TypeParameterListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || parameters != this.Parameters || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = Syntax.TypeParameterList(lessThanToken, parameters, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, GetDiagnostics(), annotations);
    }

    internal TypeParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.lessThanToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.lessThanToken);
      this.parameters = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.parameters);
      this.greaterThanToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.greaterThanToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new TypeParameterListSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.greaterThanToken);
    }
  }

  /// <summary>Type parameter syntax.</summary>
  internal sealed partial class TypeParameterSyntax : SyntaxNode
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxToken varianceKeyword;
    private readonly SyntaxToken identifier;

    internal TypeParameterSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxToken varianceKeyword, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (varianceKeyword != null)
        {
            this.varianceKeyword = varianceKeyword;
            this.AdjustFlagsAndWidth(varianceKeyword);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
    }


    internal TypeParameterSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxToken varianceKeyword, SyntaxToken identifier)
        : base(kind)
    {
        this.slotCount = 3;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (varianceKeyword != null)
        {
            this.varianceKeyword = varianceKeyword;
            this.AdjustFlagsAndWidth(varianceKeyword);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    public SyntaxToken VarianceKeyword { get { return this.varianceKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.varianceKeyword;
            case 2: return this.identifier;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.TypeParameterSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameter(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitTypeParameter(this);
    }

    public TypeParameterSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
        if (attributes != this.Attributes || varianceKeyword != this.VarianceKeyword || identifier != this.Identifier)
        {
            var newNode = Syntax.TypeParameter(attributes, varianceKeyword, identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeParameterSyntax(this.Kind, this.attributes, this.varianceKeyword, this.identifier, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeParameterSyntax(this.Kind, this.attributes, this.varianceKeyword, this.identifier, GetDiagnostics(), annotations);
    }

    internal TypeParameterSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.varianceKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.varianceKeyword);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new TypeParameterSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.varianceKeyword);
      writer.WriteValue(this.identifier);
    }
  }

  /// <summary>Base class for type declaration syntax.</summary>
  internal abstract partial class BaseTypeDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseTypeDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseTypeDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseTypeDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeDeclarationSyntax> Attributes { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxList<SyntaxToken> Modifiers { get; }

    /// <summary>Gets the identifier.</summary>
    public abstract SyntaxToken Identifier { get; }

    /// <summary>Gets the base type list.</summary>
    public abstract BaseListSyntax BaseList { get; }

    /// <summary>Gets the open brace token.</summary>
    public abstract SyntaxToken OpenBraceToken { get; }

    /// <summary>Gets the close brace token.</summary>
    public abstract SyntaxToken CloseBraceToken { get; }

    /// <summary>Gets the optional semicolon token.</summary>
    public abstract SyntaxToken SemicolonToken { get; }
  }

  /// <summary>Base class for type declaration syntax (class, struct, interface).</summary>
  internal abstract partial class TypeDeclarationSyntax : BaseTypeDeclarationSyntax
  {
    internal TypeDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal TypeDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected TypeDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the type keyword token ("class", "struct", "interface").</summary>
    public abstract SyntaxToken Keyword { get; }

    public abstract TypeParameterListSyntax TypeParameterList { get; }

    /// <summary>Gets the type constraint list.</summary>
    public abstract SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }

    /// <summary>Gets the member declarations.</summary>
    public abstract SyntaxList<MemberDeclarationSyntax> Members { get; }
  }

  /// <summary>Class type declaration syntax.</summary>
  internal sealed partial class ClassDeclarationSyntax : TypeDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly SyntaxToken keyword;
    private readonly SyntaxToken identifier;
    private readonly TypeParameterListSyntax typeParameterList;
    private readonly BaseListSyntax baseList;
    private readonly SyntaxNode constraintClauses;
    private readonly SyntaxToken openBraceToken;
    private readonly SyntaxNode members;
    private readonly SyntaxToken closeBraceToken;
    private readonly SyntaxToken semicolonToken;

    internal ClassDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxNode constraintClauses, SyntaxToken openBraceToken, SyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 11;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (typeParameterList != null)
        {
            this.typeParameterList = typeParameterList;
            this.AdjustFlagsAndWidth(typeParameterList);
        }
        if (baseList != null)
        {
            this.baseList = baseList;
            this.AdjustFlagsAndWidth(baseList);
        }
        if (constraintClauses != null)
        {
            this.constraintClauses = constraintClauses;
            this.AdjustFlagsAndWidth(constraintClauses);
        }
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (members != null)
        {
            this.members = members;
            this.AdjustFlagsAndWidth(members);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }


    internal ClassDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxNode constraintClauses, SyntaxToken openBraceToken, SyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 11;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (typeParameterList != null)
        {
            this.typeParameterList = typeParameterList;
            this.AdjustFlagsAndWidth(typeParameterList);
        }
        if (baseList != null)
        {
            this.baseList = baseList;
            this.AdjustFlagsAndWidth(baseList);
        }
        if (constraintClauses != null)
        {
            this.constraintClauses = constraintClauses;
            this.AdjustFlagsAndWidth(constraintClauses);
        }
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (members != null)
        {
            this.members = members;
            this.AdjustFlagsAndWidth(members);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the class keyword token.</summary>
    public override SyntaxToken Keyword { get { return this.keyword; } }
    public override SyntaxToken Identifier { get { return this.identifier; } }
    public override TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    public override BaseListSyntax BaseList { get { return this.baseList; } }
    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public override SyntaxList<MemberDeclarationSyntax> Members { get { return new SyntaxList<MemberDeclarationSyntax>(this.members); } }
    public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.identifier;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 7: return this.openBraceToken;
            case 8: return this.members;
            case 9: return this.closeBraceToken;
            case 10: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ClassDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitClassDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitClassDeclaration(this);
    }

    public ClassDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ClassDeclaration(attributes, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ClassDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ClassDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ClassDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 11;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.keyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.keyword);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.typeParameterList);
      this.baseList = (BaseListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.baseList);
      this.constraintClauses = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.constraintClauses);
      this.openBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openBraceToken);
      this.members = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.members);
      this.closeBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeBraceToken);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ClassDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }
  }

  /// <summary>Struct type declaration syntax.</summary>
  internal sealed partial class StructDeclarationSyntax : TypeDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly SyntaxToken keyword;
    private readonly SyntaxToken identifier;
    private readonly TypeParameterListSyntax typeParameterList;
    private readonly BaseListSyntax baseList;
    private readonly SyntaxNode constraintClauses;
    private readonly SyntaxToken openBraceToken;
    private readonly SyntaxNode members;
    private readonly SyntaxToken closeBraceToken;
    private readonly SyntaxToken semicolonToken;

    internal StructDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxNode constraintClauses, SyntaxToken openBraceToken, SyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 11;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (typeParameterList != null)
        {
            this.typeParameterList = typeParameterList;
            this.AdjustFlagsAndWidth(typeParameterList);
        }
        if (baseList != null)
        {
            this.baseList = baseList;
            this.AdjustFlagsAndWidth(baseList);
        }
        if (constraintClauses != null)
        {
            this.constraintClauses = constraintClauses;
            this.AdjustFlagsAndWidth(constraintClauses);
        }
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (members != null)
        {
            this.members = members;
            this.AdjustFlagsAndWidth(members);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }


    internal StructDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxNode constraintClauses, SyntaxToken openBraceToken, SyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 11;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (typeParameterList != null)
        {
            this.typeParameterList = typeParameterList;
            this.AdjustFlagsAndWidth(typeParameterList);
        }
        if (baseList != null)
        {
            this.baseList = baseList;
            this.AdjustFlagsAndWidth(baseList);
        }
        if (constraintClauses != null)
        {
            this.constraintClauses = constraintClauses;
            this.AdjustFlagsAndWidth(constraintClauses);
        }
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (members != null)
        {
            this.members = members;
            this.AdjustFlagsAndWidth(members);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the struct keyword token.</summary>
    public override SyntaxToken Keyword { get { return this.keyword; } }
    public override SyntaxToken Identifier { get { return this.identifier; } }
    public override TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    public override BaseListSyntax BaseList { get { return this.baseList; } }
    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public override SyntaxList<MemberDeclarationSyntax> Members { get { return new SyntaxList<MemberDeclarationSyntax>(this.members); } }
    public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.identifier;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 7: return this.openBraceToken;
            case 8: return this.members;
            case 9: return this.closeBraceToken;
            case 10: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.StructDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitStructDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitStructDeclaration(this);
    }

    public StructDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.StructDeclaration(attributes, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new StructDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new StructDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal StructDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 11;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.keyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.keyword);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.typeParameterList);
      this.baseList = (BaseListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.baseList);
      this.constraintClauses = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.constraintClauses);
      this.openBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openBraceToken);
      this.members = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.members);
      this.closeBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeBraceToken);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new StructDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }
  }

  /// <summary>Interface type declaration syntax.</summary>
  internal sealed partial class InterfaceDeclarationSyntax : TypeDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly SyntaxToken keyword;
    private readonly SyntaxToken identifier;
    private readonly TypeParameterListSyntax typeParameterList;
    private readonly BaseListSyntax baseList;
    private readonly SyntaxNode constraintClauses;
    private readonly SyntaxToken openBraceToken;
    private readonly SyntaxNode members;
    private readonly SyntaxToken closeBraceToken;
    private readonly SyntaxToken semicolonToken;

    internal InterfaceDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxNode constraintClauses, SyntaxToken openBraceToken, SyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 11;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (typeParameterList != null)
        {
            this.typeParameterList = typeParameterList;
            this.AdjustFlagsAndWidth(typeParameterList);
        }
        if (baseList != null)
        {
            this.baseList = baseList;
            this.AdjustFlagsAndWidth(baseList);
        }
        if (constraintClauses != null)
        {
            this.constraintClauses = constraintClauses;
            this.AdjustFlagsAndWidth(constraintClauses);
        }
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (members != null)
        {
            this.members = members;
            this.AdjustFlagsAndWidth(members);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }


    internal InterfaceDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxNode constraintClauses, SyntaxToken openBraceToken, SyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 11;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (typeParameterList != null)
        {
            this.typeParameterList = typeParameterList;
            this.AdjustFlagsAndWidth(typeParameterList);
        }
        if (baseList != null)
        {
            this.baseList = baseList;
            this.AdjustFlagsAndWidth(baseList);
        }
        if (constraintClauses != null)
        {
            this.constraintClauses = constraintClauses;
            this.AdjustFlagsAndWidth(constraintClauses);
        }
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (members != null)
        {
            this.members = members;
            this.AdjustFlagsAndWidth(members);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the interface keyword token.</summary>
    public override SyntaxToken Keyword { get { return this.keyword; } }
    public override SyntaxToken Identifier { get { return this.identifier; } }
    public override TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    public override BaseListSyntax BaseList { get { return this.baseList; } }
    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public override SyntaxList<MemberDeclarationSyntax> Members { get { return new SyntaxList<MemberDeclarationSyntax>(this.members); } }
    public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.identifier;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 7: return this.openBraceToken;
            case 8: return this.members;
            case 9: return this.closeBraceToken;
            case 10: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.InterfaceDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterfaceDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitInterfaceDeclaration(this);
    }

    public InterfaceDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.InterfaceDeclaration(attributes, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InterfaceDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InterfaceDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal InterfaceDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 11;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.keyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.keyword);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.typeParameterList);
      this.baseList = (BaseListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.baseList);
      this.constraintClauses = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.constraintClauses);
      this.openBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openBraceToken);
      this.members = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.members);
      this.closeBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeBraceToken);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new InterfaceDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }
  }

  /// <summary>Enum type declaration syntax.</summary>
  internal sealed partial class EnumDeclarationSyntax : BaseTypeDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly SyntaxToken enumKeyword;
    private readonly SyntaxToken identifier;
    private readonly BaseListSyntax baseList;
    private readonly SyntaxToken openBraceToken;
    private readonly SyntaxNode members;
    private readonly SyntaxToken closeBraceToken;
    private readonly SyntaxToken semicolonToken;

    internal EnumDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 9;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.enumKeyword = enumKeyword;
        this.AdjustFlagsAndWidth(enumKeyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (baseList != null)
        {
            this.baseList = baseList;
            this.AdjustFlagsAndWidth(baseList);
        }
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (members != null)
        {
            this.members = members;
            this.AdjustFlagsAndWidth(members);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }


    internal EnumDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 9;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.enumKeyword = enumKeyword;
        this.AdjustFlagsAndWidth(enumKeyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (baseList != null)
        {
            this.baseList = baseList;
            this.AdjustFlagsAndWidth(baseList);
        }
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (members != null)
        {
            this.members = members;
            this.AdjustFlagsAndWidth(members);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the enum keyword token.</summary>
    public SyntaxToken EnumKeyword { get { return this.enumKeyword; } }
    public override SyntaxToken Identifier { get { return this.identifier; } }
    public override BaseListSyntax BaseList { get { return this.baseList; } }
    public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    /// <summary>Gets the members declaration list.</summary>
    public SeparatedSyntaxList<EnumMemberDeclarationSyntax> Members { get { return new SeparatedSyntaxList<EnumMemberDeclarationSyntax>(new SyntaxList<SyntaxNode>(this.members)); } }
    public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.enumKeyword;
            case 3: return this.identifier;
            case 4: return this.baseList;
            case 5: return this.openBraceToken;
            case 6: return this.members;
            case 7: return this.closeBraceToken;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.EnumDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEnumDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEnumDeclaration(this);
    }

    public EnumDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || enumKeyword != this.EnumKeyword || identifier != this.Identifier || baseList != this.BaseList || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.EnumDeclaration(attributes, modifiers, enumKeyword, identifier, baseList, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EnumDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.enumKeyword, this.identifier, this.baseList, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EnumDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.enumKeyword, this.identifier, this.baseList, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal EnumDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 9;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.enumKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.enumKeyword);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.baseList = (BaseListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.baseList);
      this.openBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openBraceToken);
      this.members = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.members);
      this.closeBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeBraceToken);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new EnumDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.enumKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }
  }

  /// <summary>Delegate declaration syntax.</summary>
  internal sealed partial class DelegateDeclarationSyntax : MemberDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly SyntaxToken delegateKeyword;
    private readonly TypeSyntax returnType;
    private readonly SyntaxToken identifier;
    private readonly TypeParameterListSyntax typeParameterList;
    private readonly ParameterListSyntax parameterList;
    private readonly SyntaxNode constraintClauses;
    private readonly SyntaxToken semicolonToken;

    internal DelegateDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxNode constraintClauses, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 9;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.delegateKeyword = delegateKeyword;
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(returnType);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (typeParameterList != null)
        {
            this.typeParameterList = typeParameterList;
            this.AdjustFlagsAndWidth(typeParameterList);
        }
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        if (constraintClauses != null)
        {
            this.constraintClauses = constraintClauses;
            this.AdjustFlagsAndWidth(constraintClauses);
        }
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }


    internal DelegateDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxNode constraintClauses, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 9;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.delegateKeyword = delegateKeyword;
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(returnType);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (typeParameterList != null)
        {
            this.typeParameterList = typeParameterList;
            this.AdjustFlagsAndWidth(typeParameterList);
        }
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        if (constraintClauses != null)
        {
            this.constraintClauses = constraintClauses;
            this.AdjustFlagsAndWidth(constraintClauses);
        }
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    /// <summary>Gets the modifier list.</summary>
    public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the "delegate" keyword.</summary>
    public SyntaxToken DelegateKeyword { get { return this.delegateKeyword; } }
    /// <summary>Gets the return type.</summary>
    public TypeSyntax ReturnType { get { return this.returnType; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    /// <summary>Gets the parameter list.</summary>
    public ParameterListSyntax ParameterList { get { return this.parameterList; } }
    /// <summary>Gets the constraint clause list.</summary>
    public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    /// <summary>Gets the semicolon token.</summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.delegateKeyword;
            case 3: return this.returnType;
            case 4: return this.identifier;
            case 5: return this.typeParameterList;
            case 6: return this.parameterList;
            case 7: return this.constraintClauses;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.DelegateDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDelegateDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitDelegateDeclaration(this);
    }

    public DelegateDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || delegateKeyword != this.DelegateKeyword || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.DelegateDeclaration(attributes, modifiers, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DelegateDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.delegateKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DelegateDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.delegateKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal DelegateDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 9;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.delegateKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.delegateKeyword);
      this.returnType = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.returnType);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.typeParameterList);
      this.parameterList = (ParameterListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.parameterList);
      this.constraintClauses = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.constraintClauses);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new DelegateDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.delegateKeyword);
      writer.WriteValue(this.returnType);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.semicolonToken);
    }
  }

  internal sealed partial class EnumMemberDeclarationSyntax : MemberDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxToken identifier;
    private readonly EqualsValueClauseSyntax equalsValue;

    internal EnumMemberDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (equalsValue != null)
        {
            this.equalsValue = equalsValue;
            this.AdjustFlagsAndWidth(equalsValue);
        }
    }


    internal EnumMemberDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
        : base(kind)
    {
        this.slotCount = 3;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (equalsValue != null)
        {
            this.equalsValue = equalsValue;
            this.AdjustFlagsAndWidth(equalsValue);
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public EqualsValueClauseSyntax EqualsValue { get { return this.equalsValue; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.identifier;
            case 2: return this.equalsValue;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.EnumMemberDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEnumMemberDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEnumMemberDeclaration(this);
    }

    public EnumMemberDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
        if (attributes != this.Attributes || identifier != this.Identifier || equalsValue != this.EqualsValue)
        {
            var newNode = Syntax.EnumMemberDeclaration(attributes, identifier, equalsValue);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EnumMemberDeclarationSyntax(this.Kind, this.attributes, this.identifier, this.equalsValue, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EnumMemberDeclarationSyntax(this.Kind, this.attributes, this.identifier, this.equalsValue, GetDiagnostics(), annotations);
    }

    internal EnumMemberDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.equalsValue = (EqualsValueClauseSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.equalsValue);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new EnumMemberDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.equalsValue);
    }
  }

  /// <summary>Base list syntax.</summary>
  internal sealed partial class BaseListSyntax : SyntaxNode
  {
    private readonly SyntaxToken colonToken;
    private readonly SyntaxNode types;

    internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxNode types, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
        if (types != null)
        {
            this.types = types;
            this.AdjustFlagsAndWidth(types);
        }
    }


    internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxNode types)
        : base(kind)
    {
        this.slotCount = 2;
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
        if (types != null)
        {
            this.types = types;
            this.AdjustFlagsAndWidth(types);
        }
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }
    /// <summary>Gets the base type references.</summary>
    public SeparatedSyntaxList<TypeSyntax> Types { get { return new SeparatedSyntaxList<TypeSyntax>(new SyntaxList<SyntaxNode>(this.types)); } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.colonToken;
            case 1: return this.types;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.BaseListSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBaseList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBaseList(this);
    }

    public BaseListSyntax Update(SyntaxToken colonToken, SeparatedSyntaxList<TypeSyntax> types)
    {
        if (colonToken != this.ColonToken || types != this.Types)
        {
            var newNode = Syntax.BaseList(colonToken, types);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BaseListSyntax(this.Kind, this.colonToken, this.types, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BaseListSyntax(this.Kind, this.colonToken, this.types, GetDiagnostics(), annotations);
    }

    internal BaseListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.colonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.colonToken);
      this.types = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.types);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new BaseListSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.types);
    }
  }

  /// <summary>Type parameter constraint clause.</summary>
  internal sealed partial class TypeParameterConstraintClauseSyntax : SyntaxNode
  {
    private readonly SyntaxToken whereKeyword;
    private readonly IdentifierNameSyntax identifier;
    private readonly SyntaxToken colonToken;
    private readonly SyntaxNode constraints;

    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax identifier, SyntaxToken colonToken, SyntaxNode constraints, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
        if (constraints != null)
        {
            this.constraints = constraints;
            this.AdjustFlagsAndWidth(constraints);
        }
    }


    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax identifier, SyntaxToken colonToken, SyntaxNode constraints)
        : base(kind)
    {
        this.slotCount = 4;
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
        if (constraints != null)
        {
            this.constraints = constraints;
            this.AdjustFlagsAndWidth(constraints);
        }
    }

    public SyntaxToken WhereKeyword { get { return this.whereKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public IdentifierNameSyntax Identifier { get { return this.identifier; } }
    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }
    /// <summary>Gets the constraints list.</summary>
    public SeparatedSyntaxList<TypeParameterConstraintSyntax> Constraints { get { return new SeparatedSyntaxList<TypeParameterConstraintSyntax>(new SyntaxList<SyntaxNode>(this.constraints)); } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whereKeyword;
            case 1: return this.identifier;
            case 2: return this.colonToken;
            case 3: return this.constraints;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.TypeParameterConstraintClauseSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameterConstraintClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitTypeParameterConstraintClause(this);
    }

    public TypeParameterConstraintClauseSyntax Update(SyntaxToken whereKeyword, IdentifierNameSyntax identifier, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
        if (whereKeyword != this.WhereKeyword || identifier != this.Identifier || colonToken != this.ColonToken || constraints != this.Constraints)
        {
            var newNode = Syntax.TypeParameterConstraintClause(whereKeyword, identifier, colonToken, constraints);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeParameterConstraintClauseSyntax(this.Kind, this.whereKeyword, this.identifier, this.colonToken, this.constraints, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeParameterConstraintClauseSyntax(this.Kind, this.whereKeyword, this.identifier, this.colonToken, this.constraints, GetDiagnostics(), annotations);
    }

    internal TypeParameterConstraintClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.whereKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.whereKeyword);
      this.identifier = (IdentifierNameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.colonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.colonToken);
      this.constraints = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.constraints);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new TypeParameterConstraintClauseSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whereKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.constraints);
    }
  }

  /// <summary>Base type for type parameter constraint syntax.</summary>
  internal abstract partial class TypeParameterConstraintSyntax : SyntaxNode
  {
    internal TypeParameterConstraintSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal TypeParameterConstraintSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected TypeParameterConstraintSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Constructor constraint syntax.</summary>
  internal sealed partial class ConstructorConstraintSyntax : TypeParameterConstraintSyntax
  {
    private readonly SyntaxToken newKeyword;
    private readonly SyntaxToken openParenToken;
    private readonly SyntaxToken closeParenToken;

    internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(newKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }


    internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(newKeyword);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }

    /// <summary>Gets the "new" keyword.</summary>
    public SyntaxToken NewKeyword { get { return this.newKeyword; } }
    /// <summary>Gets the open paren keyword.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Gets the close paren keyword.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.openParenToken;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ConstructorConstraintSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorConstraint(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitConstructorConstraint(this);
    }

    public ConstructorConstraintSyntax Update(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
        if (newKeyword != this.NewKeyword || openParenToken != this.OpenParenToken || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.ConstructorConstraint(newKeyword, openParenToken, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConstructorConstraintSyntax(this.Kind, this.newKeyword, this.openParenToken, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConstructorConstraintSyntax(this.Kind, this.newKeyword, this.openParenToken, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal ConstructorConstraintSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.newKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.newKeyword);
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ConstructorConstraintSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.closeParenToken);
    }
  }

  /// <summary>Base type for class or struct constraint syntax.</summary>
  internal sealed partial class ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax
  {
    private readonly SyntaxToken classOrStructKeyword;

    internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 1;
        this.classOrStructKeyword = classOrStructKeyword;
        this.AdjustFlagsAndWidth(classOrStructKeyword);
    }


    internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword)
        : base(kind)
    {
        this.slotCount = 1;
        this.classOrStructKeyword = classOrStructKeyword;
        this.AdjustFlagsAndWidth(classOrStructKeyword);
    }

    /// <summary>Gets the constraint keyword ("class" or "struct").</summary>
    public SyntaxToken ClassOrStructKeyword { get { return this.classOrStructKeyword; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.classOrStructKeyword;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ClassOrStructConstraintSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitClassOrStructConstraint(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitClassOrStructConstraint(this);
    }

    public ClassOrStructConstraintSyntax Update(SyntaxToken classOrStructKeyword)
    {
        if (classOrStructKeyword != this.ClassOrStructKeyword)
        {
            var newNode = Syntax.ClassOrStructConstraint(this.Kind, classOrStructKeyword);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ClassOrStructConstraintSyntax(this.Kind, this.classOrStructKeyword, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ClassOrStructConstraintSyntax(this.Kind, this.classOrStructKeyword, GetDiagnostics(), annotations);
    }

    internal ClassOrStructConstraintSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 1;
      this.classOrStructKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.classOrStructKeyword);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ClassOrStructConstraintSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.classOrStructKeyword);
    }
  }

  /// <summary>Type constraint syntax.</summary>
  internal sealed partial class TypeConstraintSyntax : TypeParameterConstraintSyntax
  {
    private readonly TypeSyntax type;

    internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 1;
        this.type = type;
        this.AdjustFlagsAndWidth(type);
    }


    internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type)
        : base(kind)
    {
        this.slotCount = 1;
        this.type = type;
        this.AdjustFlagsAndWidth(type);
    }

    /// <summary>Gets the type syntax.</summary>
    public TypeSyntax Type { get { return this.type; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.TypeConstraintSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeConstraint(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitTypeConstraint(this);
    }

    public TypeConstraintSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = Syntax.TypeConstraint(type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeConstraintSyntax(this.Kind, this.type, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeConstraintSyntax(this.Kind, this.type, GetDiagnostics(), annotations);
    }

    internal TypeConstraintSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 1;
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new TypeConstraintSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
    }
  }

  internal abstract partial class BaseFieldDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseFieldDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseFieldDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseFieldDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeDeclarationSyntax> Attributes { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxList<SyntaxToken> Modifiers { get; }

    public abstract VariableDeclarationSyntax Declaration { get; }

    public abstract SyntaxToken SemicolonToken { get; }
  }

  internal sealed partial class FieldDeclarationSyntax : BaseFieldDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly VariableDeclarationSyntax declaration;
    private readonly SyntaxToken semicolonToken;

    internal FieldDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(declaration);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }


    internal FieldDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 4;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(declaration);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public override SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    /// <summary>Gets the modifier list.</summary>
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public override VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.declaration;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.FieldDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFieldDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitFieldDeclaration(this);
    }

    public FieldDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.FieldDeclaration(attributes, modifiers, declaration, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new FieldDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new FieldDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal FieldDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.declaration = (VariableDeclarationSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.declaration);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new FieldDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.semicolonToken);
    }
  }

  internal sealed partial class EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly SyntaxToken eventKeyword;
    private readonly VariableDeclarationSyntax declaration;
    private readonly SyntaxToken semicolonToken;

    internal EventFieldDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 5;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(eventKeyword);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(declaration);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }


    internal EventFieldDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 5;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(eventKeyword);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(declaration);
        this.semicolonToken = semicolonToken;
        this.AdjustFlagsAndWidth(semicolonToken);
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public override SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    /// <summary>Gets the modifier list.</summary>
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public SyntaxToken EventKeyword { get { return this.eventKeyword; } }
    public override VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.eventKeyword;
            case 3: return this.declaration;
            case 4: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.EventFieldDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEventFieldDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEventFieldDeclaration(this);
    }

    public EventFieldDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.EventFieldDeclaration(attributes, modifiers, eventKeyword, declaration, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EventFieldDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.eventKeyword, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EventFieldDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.eventKeyword, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal EventFieldDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 5;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.eventKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.eventKeyword);
      this.declaration = (VariableDeclarationSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.declaration);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new EventFieldDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.eventKeyword);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.semicolonToken);
    }
  }

  internal sealed partial class ExplicitInterfaceSpecifierSyntax : SyntaxNode
  {
    private readonly NameSyntax name;
    private readonly SyntaxToken dotToken;

    internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(dotToken);
    }


    internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken)
        : base(kind)
    {
        this.slotCount = 2;
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(dotToken);
    }

    public NameSyntax Name { get { return this.name; } }
    public SyntaxToken DotToken { get { return this.dotToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.dotToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ExplicitInterfaceSpecifierSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExplicitInterfaceSpecifier(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitExplicitInterfaceSpecifier(this);
    }

    public ExplicitInterfaceSpecifierSyntax Update(NameSyntax name, SyntaxToken dotToken)
    {
        if (name != this.Name || dotToken != this.DotToken)
        {
            var newNode = Syntax.ExplicitInterfaceSpecifier(name, dotToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ExplicitInterfaceSpecifierSyntax(this.Kind, this.name, this.dotToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ExplicitInterfaceSpecifierSyntax(this.Kind, this.name, this.dotToken, GetDiagnostics(), annotations);
    }

    internal ExplicitInterfaceSpecifierSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.name = (NameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.name);
      this.dotToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.dotToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ExplicitInterfaceSpecifierSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.dotToken);
    }
  }

  /// <summary>Base type for method declaration syntax.</summary>
  internal abstract partial class BaseMethodDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseMethodDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseMethodDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseMethodDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeDeclarationSyntax> Attributes { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxList<SyntaxToken> Modifiers { get; }

    /// <summary>Gets the parameter list.</summary>
    public abstract ParameterListSyntax ParameterList { get; }

    public abstract BlockSyntax Body { get; }

    /// <summary>Gets the optional semicolon token.</summary>
    public abstract SyntaxToken SemicolonToken { get; }
  }

  /// <summary>Method declaration syntax.</summary>
  internal sealed partial class MethodDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly TypeSyntax returnType;
    private readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private readonly SyntaxToken identifier;
    private readonly TypeParameterListSyntax typeParameterList;
    private readonly ParameterListSyntax parameterList;
    private readonly SyntaxNode constraintClauses;
    private readonly BlockSyntax body;
    private readonly SyntaxToken semicolonToken;

    internal MethodDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxNode constraintClauses, BlockSyntax body, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 10;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(returnType);
        if (explicitInterfaceSpecifier != null)
        {
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (typeParameterList != null)
        {
            this.typeParameterList = typeParameterList;
            this.AdjustFlagsAndWidth(typeParameterList);
        }
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        if (constraintClauses != null)
        {
            this.constraintClauses = constraintClauses;
            this.AdjustFlagsAndWidth(constraintClauses);
        }
        if (body != null)
        {
            this.body = body;
            this.AdjustFlagsAndWidth(body);
        }
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }


    internal MethodDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxNode constraintClauses, BlockSyntax body, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 10;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(returnType);
        if (explicitInterfaceSpecifier != null)
        {
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (typeParameterList != null)
        {
            this.typeParameterList = typeParameterList;
            this.AdjustFlagsAndWidth(typeParameterList);
        }
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        if (constraintClauses != null)
        {
            this.constraintClauses = constraintClauses;
            this.AdjustFlagsAndWidth(constraintClauses);
        }
        if (body != null)
        {
            this.body = body;
            this.AdjustFlagsAndWidth(body);
        }
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the return type syntax.</summary>
    public TypeSyntax ReturnType { get { return this.returnType; } }
    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
    /// <summary>Gets the constraint clause list.</summary>
    public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    public override BlockSyntax Body { get { return this.body; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.returnType;
            case 3: return this.explicitInterfaceSpecifier;
            case 4: return this.identifier;
            case 5: return this.typeParameterList;
            case 6: return this.parameterList;
            case 7: return this.constraintClauses;
            case 8: return this.body;
            case 9: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.MethodDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMethodDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitMethodDeclaration(this);
    }

    public MethodDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || returnType != this.ReturnType || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.MethodDeclaration(attributes, modifiers, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new MethodDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.returnType, this.explicitInterfaceSpecifier, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new MethodDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.returnType, this.explicitInterfaceSpecifier, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal MethodDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 10;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.returnType = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.returnType);
      this.explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.explicitInterfaceSpecifier);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.typeParameterList);
      this.parameterList = (ParameterListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.parameterList);
      this.constraintClauses = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.constraintClauses);
      this.body = (BlockSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.body);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new MethodDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.returnType);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.body);
      writer.WriteValue(this.semicolonToken);
    }
  }

  /// <summary>Operator declaration syntax.</summary>
  internal sealed partial class OperatorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly TypeSyntax returnType;
    private readonly SyntaxToken operatorKeyword;
    private readonly SyntaxToken operatorToken;
    private readonly ParameterListSyntax parameterList;
    private readonly BlockSyntax body;
    private readonly SyntaxToken semicolonToken;

    internal OperatorDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 8;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(returnType);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operatorToken);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        if (body != null)
        {
            this.body = body;
            this.AdjustFlagsAndWidth(body);
        }
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }


    internal OperatorDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 8;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(returnType);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operatorToken);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        if (body != null)
        {
            this.body = body;
            this.AdjustFlagsAndWidth(body);
        }
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the return type.</summary>
    public TypeSyntax ReturnType { get { return this.returnType; } }
    /// <summary>Gets the "operator" keyword.</summary>
    public SyntaxToken OperatorKeyword { get { return this.operatorKeyword; } }
    /// <summary>Gets the operator token.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
    public override BlockSyntax Body { get { return this.body; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.returnType;
            case 3: return this.operatorKeyword;
            case 4: return this.operatorToken;
            case 5: return this.parameterList;
            case 6: return this.body;
            case 7: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.OperatorDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOperatorDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitOperatorDeclaration(this);
    }

    public OperatorDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || returnType != this.ReturnType || operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameterList != this.ParameterList || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.OperatorDeclaration(attributes, modifiers, returnType, operatorKeyword, operatorToken, parameterList, body, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OperatorDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.returnType, this.operatorKeyword, this.operatorToken, this.parameterList, this.body, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OperatorDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.returnType, this.operatorKeyword, this.operatorToken, this.parameterList, this.body, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal OperatorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 8;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.returnType = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.returnType);
      this.operatorKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.operatorKeyword);
      this.operatorToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.operatorToken);
      this.parameterList = (ParameterListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.parameterList);
      this.body = (BlockSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.body);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new OperatorDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.returnType);
      writer.WriteValue(this.operatorKeyword);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.body);
      writer.WriteValue(this.semicolonToken);
    }
  }

  /// <summary>Conversion operator declaration syntax.</summary>
  internal sealed partial class ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly SyntaxToken implicitOrExplicitKeyword;
    private readonly SyntaxToken operatorKeyword;
    private readonly TypeSyntax type;
    private readonly ParameterListSyntax parameterList;
    private readonly BlockSyntax body;
    private readonly SyntaxToken semicolonToken;

    internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 8;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        if (body != null)
        {
            this.body = body;
            this.AdjustFlagsAndWidth(body);
        }
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }


    internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 8;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        if (body != null)
        {
            this.body = body;
            this.AdjustFlagsAndWidth(body);
        }
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the "implicit" or "explicit" token.</summary>
    public SyntaxToken ImplicitOrExplicitKeyword { get { return this.implicitOrExplicitKeyword; } }
    /// <summary>Gets the "operator" token.</summary>
    public SyntaxToken OperatorKeyword { get { return this.operatorKeyword; } }
    /// <summary>Gets the type.</summary>
    public TypeSyntax Type { get { return this.type; } }
    public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
    public override BlockSyntax Body { get { return this.body; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.implicitOrExplicitKeyword;
            case 3: return this.operatorKeyword;
            case 4: return this.type;
            case 5: return this.parameterList;
            case 6: return this.body;
            case 7: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ConversionOperatorDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConversionOperatorDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitConversionOperatorDeclaration(this);
    }

    public ConversionOperatorDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameterList != this.ParameterList || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ConversionOperatorDeclaration(attributes, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConversionOperatorDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameterList, this.body, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConversionOperatorDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameterList, this.body, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ConversionOperatorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 8;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.implicitOrExplicitKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.implicitOrExplicitKeyword);
      this.operatorKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.operatorKeyword);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.parameterList = (ParameterListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.parameterList);
      this.body = (BlockSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.body);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ConversionOperatorDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.implicitOrExplicitKeyword);
      writer.WriteValue(this.operatorKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.body);
      writer.WriteValue(this.semicolonToken);
    }
  }

  /// <summary>Constructor declaration syntax.</summary>
  internal sealed partial class ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly SyntaxToken identifier;
    private readonly ParameterListSyntax parameterList;
    private readonly ConstructorInitializerSyntax initializer;
    private readonly BlockSyntax body;
    private readonly SyntaxToken semicolonToken;

    internal ConstructorDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 7;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        if (initializer != null)
        {
            this.initializer = initializer;
            this.AdjustFlagsAndWidth(initializer);
        }
        if (body != null)
        {
            this.body = body;
            this.AdjustFlagsAndWidth(body);
        }
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }


    internal ConstructorDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 7;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        if (initializer != null)
        {
            this.initializer = initializer;
            this.AdjustFlagsAndWidth(initializer);
        }
        if (body != null)
        {
            this.body = body;
            this.AdjustFlagsAndWidth(body);
        }
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
    public ConstructorInitializerSyntax Initializer { get { return this.initializer; } }
    public override BlockSyntax Body { get { return this.body; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.identifier;
            case 3: return this.parameterList;
            case 4: return this.initializer;
            case 5: return this.body;
            case 6: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ConstructorDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitConstructorDeclaration(this);
    }

    public ConstructorDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || identifier != this.Identifier || parameterList != this.ParameterList || initializer != this.Initializer || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ConstructorDeclaration(attributes, modifiers, identifier, parameterList, initializer, body, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConstructorDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.identifier, this.parameterList, this.initializer, this.body, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConstructorDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.identifier, this.parameterList, this.initializer, this.body, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ConstructorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 7;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.parameterList = (ParameterListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.parameterList);
      this.initializer = (ConstructorInitializerSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.initializer);
      this.body = (BlockSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.body);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ConstructorDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.initializer);
      writer.WriteValue(this.body);
      writer.WriteValue(this.semicolonToken);
    }
  }

  /// <summary>Constructor initializer syntax.</summary>
  internal sealed partial class ConstructorInitializerSyntax : SyntaxNode
  {
    private readonly SyntaxToken colonToken;
    private readonly SyntaxToken thisOrBaseKeyword;
    private readonly ArgumentListSyntax argumentList;

    internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
        this.thisOrBaseKeyword = thisOrBaseKeyword;
        this.AdjustFlagsAndWidth(thisOrBaseKeyword);
        this.argumentList = argumentList;
        this.AdjustFlagsAndWidth(argumentList);
    }


    internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
        : base(kind)
    {
        this.slotCount = 3;
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
        this.thisOrBaseKeyword = thisOrBaseKeyword;
        this.AdjustFlagsAndWidth(thisOrBaseKeyword);
        this.argumentList = argumentList;
        this.AdjustFlagsAndWidth(argumentList);
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }
    /// <summary>Gets the "this" or "base" keyword.</summary>
    public SyntaxToken ThisOrBaseKeyword { get { return this.thisOrBaseKeyword; } }
    public ArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.colonToken;
            case 1: return this.thisOrBaseKeyword;
            case 2: return this.argumentList;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ConstructorInitializerSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorInitializer(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitConstructorInitializer(this);
    }

    public ConstructorInitializerSyntax Update(SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
        if (colonToken != this.ColonToken || thisOrBaseKeyword != this.ThisOrBaseKeyword || argumentList != this.ArgumentList)
        {
            var newNode = Syntax.ConstructorInitializer(this.Kind, colonToken, thisOrBaseKeyword, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConstructorInitializerSyntax(this.Kind, this.colonToken, this.thisOrBaseKeyword, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConstructorInitializerSyntax(this.Kind, this.colonToken, this.thisOrBaseKeyword, this.argumentList, GetDiagnostics(), annotations);
    }

    internal ConstructorInitializerSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.colonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.colonToken);
      this.thisOrBaseKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.thisOrBaseKeyword);
      this.argumentList = (ArgumentListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.argumentList);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ConstructorInitializerSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.thisOrBaseKeyword);
      writer.WriteValue(this.argumentList);
    }
  }

  /// <summary>Destructor declaration syntax.</summary>
  internal sealed partial class DestructorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly SyntaxToken tildeToken;
    private readonly SyntaxToken identifier;
    private readonly ParameterListSyntax parameterList;
    private readonly BlockSyntax body;
    private readonly SyntaxToken semicolonToken;

    internal DestructorDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 7;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.tildeToken = tildeToken;
        this.AdjustFlagsAndWidth(tildeToken);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        if (body != null)
        {
            this.body = body;
            this.AdjustFlagsAndWidth(body);
        }
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }


    internal DestructorDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 7;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.tildeToken = tildeToken;
        this.AdjustFlagsAndWidth(tildeToken);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        if (body != null)
        {
            this.body = body;
            this.AdjustFlagsAndWidth(body);
        }
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the tilde token.</summary>
    public SyntaxToken TildeToken { get { return this.tildeToken; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
    public override BlockSyntax Body { get { return this.body; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.tildeToken;
            case 3: return this.identifier;
            case 4: return this.parameterList;
            case 5: return this.body;
            case 6: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.DestructorDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDestructorDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitDestructorDeclaration(this);
    }

    public DestructorDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || tildeToken != this.TildeToken || identifier != this.Identifier || parameterList != this.ParameterList || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.DestructorDeclaration(attributes, modifiers, tildeToken, identifier, parameterList, body, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DestructorDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.tildeToken, this.identifier, this.parameterList, this.body, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DestructorDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.tildeToken, this.identifier, this.parameterList, this.body, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal DestructorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 7;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.tildeToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.tildeToken);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.parameterList = (ParameterListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.parameterList);
      this.body = (BlockSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.body);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new DestructorDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.tildeToken);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.body);
      writer.WriteValue(this.semicolonToken);
    }
  }

  /// <summary>Base type for property declaration syntax.</summary>
  internal abstract partial class BasePropertyDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BasePropertyDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BasePropertyDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BasePropertyDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeDeclarationSyntax> Attributes { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxList<SyntaxToken> Modifiers { get; }

    /// <summary>Gets the type syntax.</summary>
    public abstract TypeSyntax Type { get; }

    /// <summary>Gets the optional explicit interface specifier.</summary>
    public abstract ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }

    public abstract AccessorListSyntax AccessorList { get; }
  }

  internal sealed partial class PropertyDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly TypeSyntax type;
    private readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private readonly SyntaxToken identifier;
    private readonly AccessorListSyntax accessorList;

    internal PropertyDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 6;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        if (explicitInterfaceSpecifier != null)
        {
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.accessorList = accessorList;
        this.AdjustFlagsAndWidth(accessorList);
    }


    internal PropertyDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
        : base(kind)
    {
        this.slotCount = 6;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        if (explicitInterfaceSpecifier != null)
        {
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.accessorList = accessorList;
        this.AdjustFlagsAndWidth(accessorList);
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public override TypeSyntax Type { get { return this.type; } }
    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override AccessorListSyntax AccessorList { get { return this.accessorList; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.type;
            case 3: return this.explicitInterfaceSpecifier;
            case 4: return this.identifier;
            case 5: return this.accessorList;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.PropertyDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPropertyDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitPropertyDeclaration(this);
    }

    public PropertyDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList)
        {
            var newNode = Syntax.PropertyDeclaration(attributes, modifiers, type, explicitInterfaceSpecifier, identifier, accessorList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PropertyDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PropertyDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, GetDiagnostics(), annotations);
    }

    internal PropertyDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 6;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.explicitInterfaceSpecifier);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.accessorList = (AccessorListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.accessorList);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new PropertyDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.type);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.accessorList);
    }
  }

  internal sealed partial class EventDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly SyntaxToken eventKeyword;
    private readonly TypeSyntax type;
    private readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private readonly SyntaxToken identifier;
    private readonly AccessorListSyntax accessorList;

    internal EventDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 7;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(eventKeyword);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        if (explicitInterfaceSpecifier != null)
        {
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.accessorList = accessorList;
        this.AdjustFlagsAndWidth(accessorList);
    }


    internal EventDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
        : base(kind)
    {
        this.slotCount = 7;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(eventKeyword);
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        if (explicitInterfaceSpecifier != null)
        {
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.accessorList = accessorList;
        this.AdjustFlagsAndWidth(accessorList);
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public SyntaxToken EventKeyword { get { return this.eventKeyword; } }
    public override TypeSyntax Type { get { return this.type; } }
    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override AccessorListSyntax AccessorList { get { return this.accessorList; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.eventKeyword;
            case 3: return this.type;
            case 4: return this.explicitInterfaceSpecifier;
            case 5: return this.identifier;
            case 6: return this.accessorList;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.EventDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEventDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEventDeclaration(this);
    }

    public EventDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList)
        {
            var newNode = Syntax.EventDeclaration(attributes, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EventDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.eventKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EventDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.eventKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, GetDiagnostics(), annotations);
    }

    internal EventDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 7;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.eventKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.eventKeyword);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.explicitInterfaceSpecifier);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.accessorList = (AccessorListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.accessorList);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new EventDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.eventKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.accessorList);
    }
  }

  internal sealed partial class IndexerDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly TypeSyntax type;
    private readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private readonly SyntaxToken thisKeyword;
    private readonly BracketedParameterListSyntax parameterList;
    private readonly AccessorListSyntax accessorList;

    internal IndexerDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 7;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        if (explicitInterfaceSpecifier != null)
        {
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
        }
        this.thisKeyword = thisKeyword;
        this.AdjustFlagsAndWidth(thisKeyword);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        this.accessorList = accessorList;
        this.AdjustFlagsAndWidth(accessorList);
    }


    internal IndexerDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList)
        : base(kind)
    {
        this.slotCount = 7;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.type = type;
        this.AdjustFlagsAndWidth(type);
        if (explicitInterfaceSpecifier != null)
        {
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
        }
        this.thisKeyword = thisKeyword;
        this.AdjustFlagsAndWidth(thisKeyword);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(parameterList);
        this.accessorList = accessorList;
        this.AdjustFlagsAndWidth(accessorList);
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public override TypeSyntax Type { get { return this.type; } }
    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
    public SyntaxToken ThisKeyword { get { return this.thisKeyword; } }
    /// <summary>Gets the parameter list.</summary>
    public BracketedParameterListSyntax ParameterList { get { return this.parameterList; } }
    public override AccessorListSyntax AccessorList { get { return this.accessorList; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.type;
            case 3: return this.explicitInterfaceSpecifier;
            case 4: return this.thisKeyword;
            case 5: return this.parameterList;
            case 6: return this.accessorList;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.IndexerDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIndexerDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitIndexerDeclaration(this);
    }

    public IndexerDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || thisKeyword != this.ThisKeyword || parameterList != this.ParameterList || accessorList != this.AccessorList)
        {
            var newNode = Syntax.IndexerDeclaration(attributes, modifiers, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IndexerDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.thisKeyword, this.parameterList, this.accessorList, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IndexerDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.thisKeyword, this.parameterList, this.accessorList, GetDiagnostics(), annotations);
    }

    internal IndexerDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 7;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.explicitInterfaceSpecifier);
      this.thisKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.thisKeyword);
      this.parameterList = (BracketedParameterListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.parameterList);
      this.accessorList = (AccessorListSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.accessorList);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new IndexerDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.type);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.thisKeyword);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.accessorList);
    }
  }

  internal sealed partial class AccessorListSyntax : SyntaxNode
  {
    private readonly SyntaxToken openBraceToken;
    private readonly SyntaxNode accessors;
    private readonly SyntaxToken closeBraceToken;

    internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, SyntaxNode accessors, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (accessors != null)
        {
            this.accessors = accessors;
            this.AdjustFlagsAndWidth(accessors);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
    }


    internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, SyntaxNode accessors, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        if (accessors != null)
        {
            this.accessors = accessors;
            this.AdjustFlagsAndWidth(accessors);
        }
        this.closeBraceToken = closeBraceToken;
        this.AdjustFlagsAndWidth(closeBraceToken);
    }

    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public SyntaxList<AccessorDeclarationSyntax> Accessors { get { return new SyntaxList<AccessorDeclarationSyntax>(this.accessors); } }
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.accessors;
            case 2: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.AccessorListSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAccessorList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAccessorList(this);
    }

    public AccessorListSyntax Update(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || accessors != this.Accessors || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = Syntax.AccessorList(openBraceToken, accessors, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AccessorListSyntax(this.Kind, this.openBraceToken, this.accessors, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AccessorListSyntax(this.Kind, this.openBraceToken, this.accessors, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal AccessorListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.openBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openBraceToken);
      this.accessors = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.accessors);
      this.closeBraceToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeBraceToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new AccessorListSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.accessors);
      writer.WriteValue(this.closeBraceToken);
    }
  }

  internal sealed partial class AccessorDeclarationSyntax : SyntaxNode
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly SyntaxToken keyword;
    private readonly BlockSyntax body;
    private readonly SyntaxToken semicolonToken;

    internal AccessorDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 5;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        if (body != null)
        {
            this.body = body;
            this.AdjustFlagsAndWidth(body);
        }
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }


    internal AccessorDeclarationSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.slotCount = 5;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(keyword);
        if (body != null)
        {
            this.body = body;
            this.AdjustFlagsAndWidth(body);
        }
        if (semicolonToken != null)
        {
            this.semicolonToken = semicolonToken;
            this.AdjustFlagsAndWidth(semicolonToken);
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    /// <summary>Gets the modifier list.</summary>
    public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
    public BlockSyntax Body { get { return this.body; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.body;
            case 4: return this.semicolonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.AccessorDeclarationSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAccessorDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAccessorDeclaration(this);
    }

    public AccessorDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || keyword != this.Keyword || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.AccessorDeclaration(this.Kind, attributes, modifiers, keyword, body, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AccessorDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.keyword, this.body, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AccessorDeclarationSyntax(this.Kind, this.attributes, this.modifiers, this.keyword, this.body, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal AccessorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 5;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.keyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.keyword);
      this.body = (BlockSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.body);
      this.semicolonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.semicolonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new AccessorDeclarationSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.body);
      writer.WriteValue(this.semicolonToken);
    }
  }

  /// <summary>Base type for parameter list syntax.</summary>
  internal abstract partial class BaseParameterListSyntax : SyntaxNode
  {
    internal BaseParameterListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseParameterListSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseParameterListSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the parameter list.</summary>
    public abstract SeparatedSyntaxList<ParameterSyntax> Parameters { get; }
  }

  /// <summary>Parameter list syntax.</summary>
  internal sealed partial class ParameterListSyntax : BaseParameterListSyntax
  {
    private readonly SyntaxToken openParenToken;
    private readonly SyntaxNode parameters;
    private readonly SyntaxToken closeParenToken;

    internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, SyntaxNode parameters, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        if (parameters != null)
        {
            this.parameters = parameters;
            this.AdjustFlagsAndWidth(parameters);
        }
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }


    internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, SyntaxNode parameters, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(openParenToken);
        if (parameters != null)
        {
            this.parameters = parameters;
            this.AdjustFlagsAndWidth(parameters);
        }
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public override SeparatedSyntaxList<ParameterSyntax> Parameters { get { return new SeparatedSyntaxList<ParameterSyntax>(new SyntaxList<SyntaxNode>(this.parameters)); } }
    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.parameters;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ParameterListSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParameterList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitParameterList(this);
    }

    public ParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.ParameterList(openParenToken, parameters, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal ParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.openParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openParenToken);
      this.parameters = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.parameters);
      this.closeParenToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeParenToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ParameterListSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.closeParenToken);
    }
  }

  /// <summary>Parameter list syntax with surrounding brackets.</summary>
  internal sealed partial class BracketedParameterListSyntax : BaseParameterListSyntax
  {
    private readonly SyntaxToken openBracketToken;
    private readonly SyntaxNode parameters;
    private readonly SyntaxToken closeBracketToken;

    internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, SyntaxNode parameters, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.openBracketToken = openBracketToken;
        this.AdjustFlagsAndWidth(openBracketToken);
        if (parameters != null)
        {
            this.parameters = parameters;
            this.AdjustFlagsAndWidth(parameters);
        }
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(closeBracketToken);
    }


    internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, SyntaxNode parameters, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.openBracketToken = openBracketToken;
        this.AdjustFlagsAndWidth(openBracketToken);
        if (parameters != null)
        {
            this.parameters = parameters;
            this.AdjustFlagsAndWidth(parameters);
        }
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(closeBracketToken);
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    public override SeparatedSyntaxList<ParameterSyntax> Parameters { get { return new SeparatedSyntaxList<ParameterSyntax>(new SyntaxList<SyntaxNode>(this.parameters)); } }
    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.parameters;
            case 2: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.BracketedParameterListSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBracketedParameterList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBracketedParameterList(this);
    }

    public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = Syntax.BracketedParameterList(openBracketToken, parameters, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, GetDiagnostics(), annotations);
    }

    internal BracketedParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.openBracketToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.openBracketToken);
      this.parameters = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.parameters);
      this.closeBracketToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.closeBracketToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new BracketedParameterListSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.closeBracketToken);
    }
  }

  /// <summary>Parameter syntax.</summary>
  internal sealed partial class ParameterSyntax : SyntaxNode
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly TypeSyntax type;
    private readonly SyntaxToken identifier;
    private readonly EqualsValueClauseSyntax @default;

    internal ParameterSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 5;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        if (type != null)
        {
            this.type = type;
            this.AdjustFlagsAndWidth(type);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (@default != null)
        {
            this.@default = @default;
            this.AdjustFlagsAndWidth(@default);
        }
    }


    internal ParameterSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
        : base(kind)
    {
        this.slotCount = 5;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        if (type != null)
        {
            this.type = type;
            this.AdjustFlagsAndWidth(type);
        }
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        if (@default != null)
        {
            this.@default = @default;
            this.AdjustFlagsAndWidth(@default);
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    /// <summary>Gets the modifier list.</summary>
    public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public EqualsValueClauseSyntax Default { get { return this.@default; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.type;
            case 3: return this.identifier;
            case 4: return this.@default;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ParameterSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParameter(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitParameter(this);
    }

    public ParameterSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || type != this.Type || identifier != this.Identifier || @default != this.Default)
        {
            var newNode = Syntax.Parameter(attributes, modifiers, type, identifier, @default);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ParameterSyntax(this.Kind, this.attributes, this.modifiers, this.type, this.identifier, this.@default, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ParameterSyntax(this.Kind, this.attributes, this.modifiers, this.type, this.identifier, this.@default, GetDiagnostics(), annotations);
    }

    internal ParameterSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 5;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.@default = (EqualsValueClauseSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.@default);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ParameterSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.@default);
    }
  }

  internal sealed partial class IncompleteMemberSyntax : MemberDeclarationSyntax
  {
    private readonly SyntaxNode attributes;
    private readonly SyntaxNode modifiers;
    private readonly TypeSyntax type;

    internal IncompleteMemberSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        if (type != null)
        {
            this.type = type;
            this.AdjustFlagsAndWidth(type);
        }
    }


    internal IncompleteMemberSyntax(SyntaxKind kind, SyntaxNode attributes, SyntaxNode modifiers, TypeSyntax type)
        : base(kind)
    {
        this.slotCount = 3;
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        if (modifiers != null)
        {
            this.modifiers = modifiers;
            this.AdjustFlagsAndWidth(modifiers);
        }
        if (type != null)
        {
            this.type = type;
            this.AdjustFlagsAndWidth(type);
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeDeclarationSyntax> Attributes { get { return new SyntaxList<AttributeDeclarationSyntax>(this.attributes); } }
    /// <summary>Gets the modifier list.</summary>
    public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public TypeSyntax Type { get { return this.type; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 1: return this.modifiers;
            case 2: return this.type;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.IncompleteMemberSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIncompleteMember(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitIncompleteMember(this);
    }

    public IncompleteMemberSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, TypeSyntax type)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || type != this.Type)
        {
            var newNode = Syntax.IncompleteMember(attributes, modifiers, type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IncompleteMemberSyntax(this.Kind, this.attributes, this.modifiers, this.type, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IncompleteMemberSyntax(this.Kind, this.attributes, this.modifiers, this.type, GetDiagnostics(), annotations);
    }

    internal IncompleteMemberSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.modifiers = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.modifiers);
      this.type = (TypeSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.type);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new IncompleteMemberSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.type);
    }
  }

  internal sealed partial class SkippedTokensSyntax : StructuredTriviaSyntax
  {
    private readonly SyntaxNode tokens;

    internal SkippedTokensSyntax(SyntaxKind kind, SyntaxNode tokens, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 1;
        if (tokens != null)
        {
            this.tokens = tokens;
            this.AdjustFlagsAndWidth(tokens);
        }
    }


    internal SkippedTokensSyntax(SyntaxKind kind, SyntaxNode tokens)
        : base(kind)
    {
        this.slotCount = 1;
        if (tokens != null)
        {
            this.tokens = tokens;
            this.AdjustFlagsAndWidth(tokens);
        }
    }

    public SyntaxList<SyntaxToken> Tokens { get { return new SyntaxList<SyntaxToken>(this.tokens); } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.tokens;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.SkippedTokensSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSkippedTokens(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitSkippedTokens(this);
    }

    public SkippedTokensSyntax Update(SyntaxList<SyntaxToken> tokens)
    {
        if (tokens != this.Tokens)
        {
            var newNode = Syntax.SkippedTokens(tokens);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SkippedTokensSyntax(this.Kind, this.tokens, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SkippedTokensSyntax(this.Kind, this.tokens, GetDiagnostics(), annotations);
    }

    internal SkippedTokensSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 1;
      this.tokens = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.tokens);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new SkippedTokensSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.tokens);
    }
  }

  internal sealed partial class DocumentationCommentSyntax : StructuredTriviaSyntax
  {
    private readonly SyntaxNode nodes;
    private readonly SyntaxToken endOfComment;

    internal DocumentationCommentSyntax(SyntaxKind kind, SyntaxNode nodes, SyntaxToken endOfComment, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        if (nodes != null)
        {
            this.nodes = nodes;
            this.AdjustFlagsAndWidth(nodes);
        }
        this.endOfComment = endOfComment;
        this.AdjustFlagsAndWidth(endOfComment);
    }


    internal DocumentationCommentSyntax(SyntaxKind kind, SyntaxNode nodes, SyntaxToken endOfComment)
        : base(kind)
    {
        this.slotCount = 2;
        if (nodes != null)
        {
            this.nodes = nodes;
            this.AdjustFlagsAndWidth(nodes);
        }
        this.endOfComment = endOfComment;
        this.AdjustFlagsAndWidth(endOfComment);
    }

    public SyntaxList<XmlNodeSyntax> Nodes { get { return new SyntaxList<XmlNodeSyntax>(this.nodes); } }
    public SyntaxToken EndOfComment { get { return this.endOfComment; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nodes;
            case 1: return this.endOfComment;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.DocumentationCommentSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDocumentationComment(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitDocumentationComment(this);
    }

    public DocumentationCommentSyntax Update(SyntaxList<XmlNodeSyntax> nodes, SyntaxToken endOfComment)
    {
        if (nodes != this.Nodes || endOfComment != this.EndOfComment)
        {
            var newNode = Syntax.DocumentationComment(nodes, endOfComment);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DocumentationCommentSyntax(this.Kind, this.nodes, this.endOfComment, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DocumentationCommentSyntax(this.Kind, this.nodes, this.endOfComment, GetDiagnostics(), annotations);
    }

    internal DocumentationCommentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.nodes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.nodes);
      this.endOfComment = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfComment);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new DocumentationCommentSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.nodes);
      writer.WriteValue(this.endOfComment);
    }
  }

  internal abstract partial class XmlNodeSyntax : SyntaxNode
  {
    internal XmlNodeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal XmlNodeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected XmlNodeSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class XmlElementSyntax : XmlNodeSyntax
  {
    private readonly XmlElementStartTagSyntax startTag;
    private readonly SyntaxNode content;
    private readonly XmlElementEndTagSyntax endTag;

    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, SyntaxNode content, XmlElementEndTagSyntax endTag, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.startTag = startTag;
        this.AdjustFlagsAndWidth(startTag);
        if (content != null)
        {
            this.content = content;
            this.AdjustFlagsAndWidth(content);
        }
        this.endTag = endTag;
        this.AdjustFlagsAndWidth(endTag);
    }


    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, SyntaxNode content, XmlElementEndTagSyntax endTag)
        : base(kind)
    {
        this.slotCount = 3;
        this.startTag = startTag;
        this.AdjustFlagsAndWidth(startTag);
        if (content != null)
        {
            this.content = content;
            this.AdjustFlagsAndWidth(content);
        }
        this.endTag = endTag;
        this.AdjustFlagsAndWidth(endTag);
    }

    public XmlElementStartTagSyntax StartTag { get { return this.startTag; } }
    public SyntaxList<XmlNodeSyntax> Content { get { return new SyntaxList<XmlNodeSyntax>(this.content); } }
    public XmlElementEndTagSyntax EndTag { get { return this.endTag; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startTag;
            case 1: return this.content;
            case 2: return this.endTag;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.XmlElementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlElement(this);
    }

    public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
        if (startTag != this.StartTag || content != this.Content || endTag != this.EndTag)
        {
            var newNode = Syntax.XmlElement(startTag, content, endTag);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, GetDiagnostics(), annotations);
    }

    internal XmlElementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.startTag = (XmlElementStartTagSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.startTag);
      this.content = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.content);
      this.endTag = (XmlElementEndTagSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.endTag);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new XmlElementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.startTag);
      writer.WriteValue(this.content);
      writer.WriteValue(this.endTag);
    }
  }

  internal sealed partial class XmlElementStartTagSyntax : SyntaxNode
  {
    private readonly SyntaxToken lessThanToken;
    private readonly XmlNameSyntax name;
    private readonly SyntaxNode attributes;
    private readonly SyntaxToken greaterThanToken;

    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxNode attributes, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        this.greaterThanToken = greaterThanToken;
        this.AdjustFlagsAndWidth(greaterThanToken);
    }


    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxNode attributes, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        this.greaterThanToken = greaterThanToken;
        this.AdjustFlagsAndWidth(greaterThanToken);
    }

    public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public SyntaxList<XmlAttributeSyntax> Attributes { get { return new SyntaxList<XmlAttributeSyntax>(this.attributes); } }
    public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.name;
            case 2: return this.attributes;
            case 3: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.XmlElementStartTagSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElementStartTag(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlElementStartTag(this);
    }

    public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = Syntax.XmlElementStartTag(lessThanToken, name, attributes, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlElementStartTagSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.lessThanToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.lessThanToken);
      this.name = (XmlNameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.name);
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.greaterThanToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.greaterThanToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new XmlElementStartTagSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.greaterThanToken);
    }
  }

  internal sealed partial class XmlElementEndTagSyntax : SyntaxNode
  {
    private readonly SyntaxToken lessThanSlashToken;
    private readonly XmlNameSyntax name;
    private readonly SyntaxToken greaterThanToken;

    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.lessThanSlashToken = lessThanSlashToken;
        this.AdjustFlagsAndWidth(lessThanSlashToken);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        this.greaterThanToken = greaterThanToken;
        this.AdjustFlagsAndWidth(greaterThanToken);
    }


    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.lessThanSlashToken = lessThanSlashToken;
        this.AdjustFlagsAndWidth(lessThanSlashToken);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        this.greaterThanToken = greaterThanToken;
        this.AdjustFlagsAndWidth(greaterThanToken);
    }

    public SyntaxToken LessThanSlashToken { get { return this.lessThanSlashToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanSlashToken;
            case 1: return this.name;
            case 2: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.XmlElementEndTagSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElementEndTag(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlElementEndTag(this);
    }

    public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
        if (lessThanSlashToken != this.LessThanSlashToken || name != this.Name || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = Syntax.XmlElementEndTag(lessThanSlashToken, name, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlElementEndTagSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.lessThanSlashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.lessThanSlashToken);
      this.name = (XmlNameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.name);
      this.greaterThanToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.greaterThanToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new XmlElementEndTagSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanSlashToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.greaterThanToken);
    }
  }

  internal sealed partial class XmlEmptyElementSyntax : XmlNodeSyntax
  {
    private readonly SyntaxToken lessThanToken;
    private readonly XmlNameSyntax name;
    private readonly SyntaxNode attributes;
    private readonly SyntaxToken slashGreaterThanToken;

    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxNode attributes, SyntaxToken slashGreaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        this.slashGreaterThanToken = slashGreaterThanToken;
        this.AdjustFlagsAndWidth(slashGreaterThanToken);
    }


    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxNode attributes, SyntaxToken slashGreaterThanToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        if (attributes != null)
        {
            this.attributes = attributes;
            this.AdjustFlagsAndWidth(attributes);
        }
        this.slashGreaterThanToken = slashGreaterThanToken;
        this.AdjustFlagsAndWidth(slashGreaterThanToken);
    }

    public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public SyntaxList<XmlAttributeSyntax> Attributes { get { return new SyntaxList<XmlAttributeSyntax>(this.attributes); } }
    public SyntaxToken SlashGreaterThanToken { get { return this.slashGreaterThanToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.name;
            case 2: return this.attributes;
            case 3: return this.slashGreaterThanToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.XmlEmptyElementSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlEmptyElement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlEmptyElement(this);
    }

    public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || slashGreaterThanToken != this.SlashGreaterThanToken)
        {
            var newNode = Syntax.XmlEmptyElement(lessThanToken, name, attributes, slashGreaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlEmptyElementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.lessThanToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.lessThanToken);
      this.name = (XmlNameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.name);
      this.attributes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.attributes);
      this.slashGreaterThanToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.slashGreaterThanToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new XmlEmptyElementSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.slashGreaterThanToken);
    }
  }

  internal sealed partial class XmlNameSyntax : SyntaxNode
  {
    private readonly XmlPrefixSyntax prefix;
    private readonly SyntaxToken localName;

    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax prefix, SyntaxToken localName, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        if (prefix != null)
        {
            this.prefix = prefix;
            this.AdjustFlagsAndWidth(prefix);
        }
        this.localName = localName;
        this.AdjustFlagsAndWidth(localName);
    }


    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax prefix, SyntaxToken localName)
        : base(kind)
    {
        this.slotCount = 2;
        if (prefix != null)
        {
            this.prefix = prefix;
            this.AdjustFlagsAndWidth(prefix);
        }
        this.localName = localName;
        this.AdjustFlagsAndWidth(localName);
    }

    public XmlPrefixSyntax Prefix { get { return this.prefix; } }
    public SyntaxToken LocalName { get { return this.localName; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.prefix;
            case 1: return this.localName;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.XmlNameSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlName(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlName(this);
    }

    public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
        if (prefix != this.Prefix || localName != this.LocalName)
        {
            var newNode = Syntax.XmlName(prefix, localName);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlNameSyntax(this.Kind, this.prefix, this.localName, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlNameSyntax(this.Kind, this.prefix, this.localName, GetDiagnostics(), annotations);
    }

    internal XmlNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.prefix = (XmlPrefixSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.prefix);
      this.localName = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.localName);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new XmlNameSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.prefix);
      writer.WriteValue(this.localName);
    }
  }

  internal sealed partial class XmlPrefixSyntax : SyntaxNode
  {
    private readonly SyntaxToken prefix;
    private readonly SyntaxToken colonToken;

    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 2;
        this.prefix = prefix;
        this.AdjustFlagsAndWidth(prefix);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
    }


    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken)
        : base(kind)
    {
        this.slotCount = 2;
        this.prefix = prefix;
        this.AdjustFlagsAndWidth(prefix);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(colonToken);
    }

    public SyntaxToken Prefix { get { return this.prefix; } }
    public SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.prefix;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.XmlPrefixSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlPrefix(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlPrefix(this);
    }

    public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken)
    {
        if (prefix != this.Prefix || colonToken != this.ColonToken)
        {
            var newNode = Syntax.XmlPrefix(prefix, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlPrefixSyntax(this.Kind, this.prefix, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlPrefixSyntax(this.Kind, this.prefix, this.colonToken, GetDiagnostics(), annotations);
    }

    internal XmlPrefixSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 2;
      this.prefix = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.prefix);
      this.colonToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.colonToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new XmlPrefixSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.prefix);
      writer.WriteValue(this.colonToken);
    }
  }

  internal sealed partial class XmlAttributeSyntax : SyntaxNode
  {
    private readonly XmlNameSyntax name;
    private readonly SyntaxToken equalsToken;
    private readonly SyntaxToken startQuoteToken;
    private readonly SyntaxNode textTokens;
    private readonly SyntaxToken endQuoteToken;

    internal XmlAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxNode textTokens, SyntaxToken endQuoteToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 5;
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(equalsToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        if (textTokens != null)
        {
            this.textTokens = textTokens;
            this.AdjustFlagsAndWidth(textTokens);
        }
        this.endQuoteToken = endQuoteToken;
        this.AdjustFlagsAndWidth(endQuoteToken);
    }


    internal XmlAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxNode textTokens, SyntaxToken endQuoteToken)
        : base(kind)
    {
        this.slotCount = 5;
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(equalsToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        if (textTokens != null)
        {
            this.textTokens = textTokens;
            this.AdjustFlagsAndWidth(textTokens);
        }
        this.endQuoteToken = endQuoteToken;
        this.AdjustFlagsAndWidth(endQuoteToken);
    }

    public XmlNameSyntax Name { get { return this.name; } }
    public SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public SyntaxToken StartQuoteToken { get { return this.startQuoteToken; } }
    public SyntaxList<SyntaxToken> TextTokens { get { return new SyntaxList<SyntaxToken>(this.textTokens); } }
    public SyntaxToken EndQuoteToken { get { return this.endQuoteToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.equalsToken;
            case 2: return this.startQuoteToken;
            case 3: return this.textTokens;
            case 4: return this.endQuoteToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.XmlAttributeSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlAttribute(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlAttribute(this);
    }

    public XmlAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || textTokens != this.TextTokens || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = Syntax.XmlAttribute(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, GetDiagnostics(), annotations);
    }

    internal XmlAttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 5;
      this.name = (XmlNameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.name);
      this.equalsToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.equalsToken);
      this.startQuoteToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.startQuoteToken);
      this.textTokens = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.textTokens);
      this.endQuoteToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endQuoteToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new XmlAttributeSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.startQuoteToken);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.endQuoteToken);
    }
  }

  internal sealed partial class XmlTextSyntax : XmlNodeSyntax
  {
    private readonly SyntaxNode textTokens;

    internal XmlTextSyntax(SyntaxKind kind, SyntaxNode textTokens, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 1;
        if (textTokens != null)
        {
            this.textTokens = textTokens;
            this.AdjustFlagsAndWidth(textTokens);
        }
    }


    internal XmlTextSyntax(SyntaxKind kind, SyntaxNode textTokens)
        : base(kind)
    {
        this.slotCount = 1;
        if (textTokens != null)
        {
            this.textTokens = textTokens;
            this.AdjustFlagsAndWidth(textTokens);
        }
    }

    public SyntaxList<SyntaxToken> TextTokens { get { return new SyntaxList<SyntaxToken>(this.textTokens); } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.textTokens;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.XmlTextSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlText(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlText(this);
    }

    public XmlTextSyntax Update(SyntaxList<SyntaxToken> textTokens)
    {
        if (textTokens != this.TextTokens)
        {
            var newNode = Syntax.XmlText(textTokens);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlTextSyntax(this.Kind, this.textTokens, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlTextSyntax(this.Kind, this.textTokens, GetDiagnostics(), annotations);
    }

    internal XmlTextSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 1;
      this.textTokens = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.textTokens);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new XmlTextSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.textTokens);
    }
  }

  internal sealed partial class XmlCDataSectionSyntax : XmlNodeSyntax
  {
    private readonly SyntaxToken startCDataToken;
    private readonly SyntaxNode textTokens;
    private readonly SyntaxToken endCDataToken;

    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, SyntaxNode textTokens, SyntaxToken endCDataToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.startCDataToken = startCDataToken;
        this.AdjustFlagsAndWidth(startCDataToken);
        if (textTokens != null)
        {
            this.textTokens = textTokens;
            this.AdjustFlagsAndWidth(textTokens);
        }
        this.endCDataToken = endCDataToken;
        this.AdjustFlagsAndWidth(endCDataToken);
    }


    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, SyntaxNode textTokens, SyntaxToken endCDataToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.startCDataToken = startCDataToken;
        this.AdjustFlagsAndWidth(startCDataToken);
        if (textTokens != null)
        {
            this.textTokens = textTokens;
            this.AdjustFlagsAndWidth(textTokens);
        }
        this.endCDataToken = endCDataToken;
        this.AdjustFlagsAndWidth(endCDataToken);
    }

    public SyntaxToken StartCDataToken { get { return this.startCDataToken; } }
    public SyntaxList<SyntaxToken> TextTokens { get { return new SyntaxList<SyntaxToken>(this.textTokens); } }
    public SyntaxToken EndCDataToken { get { return this.endCDataToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startCDataToken;
            case 1: return this.textTokens;
            case 2: return this.endCDataToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.XmlCDataSectionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlCDataSection(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlCDataSection(this);
    }

    public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
    {
        if (startCDataToken != this.StartCDataToken || textTokens != this.TextTokens || endCDataToken != this.EndCDataToken)
        {
            var newNode = Syntax.XmlCDataSection(startCDataToken, textTokens, endCDataToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlCDataSectionSyntax(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlCDataSectionSyntax(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, GetDiagnostics(), annotations);
    }

    internal XmlCDataSectionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.startCDataToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.startCDataToken);
      this.textTokens = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.textTokens);
      this.endCDataToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endCDataToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new XmlCDataSectionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.startCDataToken);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.endCDataToken);
    }
  }

  internal sealed partial class XmlProcessingInstructionSyntax : XmlNodeSyntax
  {
    private readonly SyntaxToken startProcessingInstructionToken;
    private readonly XmlNameSyntax name;
    private readonly SyntaxNode textTokens;
    private readonly SyntaxToken endProcessingInstructionToken;

    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxNode textTokens, SyntaxToken endProcessingInstructionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.startProcessingInstructionToken = startProcessingInstructionToken;
        this.AdjustFlagsAndWidth(startProcessingInstructionToken);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        if (textTokens != null)
        {
            this.textTokens = textTokens;
            this.AdjustFlagsAndWidth(textTokens);
        }
        this.endProcessingInstructionToken = endProcessingInstructionToken;
        this.AdjustFlagsAndWidth(endProcessingInstructionToken);
    }


    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxNode textTokens, SyntaxToken endProcessingInstructionToken)
        : base(kind)
    {
        this.slotCount = 4;
        this.startProcessingInstructionToken = startProcessingInstructionToken;
        this.AdjustFlagsAndWidth(startProcessingInstructionToken);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        if (textTokens != null)
        {
            this.textTokens = textTokens;
            this.AdjustFlagsAndWidth(textTokens);
        }
        this.endProcessingInstructionToken = endProcessingInstructionToken;
        this.AdjustFlagsAndWidth(endProcessingInstructionToken);
    }

    public SyntaxToken StartProcessingInstructionToken { get { return this.startProcessingInstructionToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public SyntaxList<SyntaxToken> TextTokens { get { return new SyntaxList<SyntaxToken>(this.textTokens); } }
    public SyntaxToken EndProcessingInstructionToken { get { return this.endProcessingInstructionToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startProcessingInstructionToken;
            case 1: return this.name;
            case 2: return this.textTokens;
            case 3: return this.endProcessingInstructionToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.XmlProcessingInstructionSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlProcessingInstruction(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlProcessingInstruction(this);
    }

    public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
    {
        if (startProcessingInstructionToken != this.StartProcessingInstructionToken || name != this.Name || textTokens != this.TextTokens || endProcessingInstructionToken != this.EndProcessingInstructionToken)
        {
            var newNode = Syntax.XmlProcessingInstruction(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlProcessingInstructionSyntax(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlProcessingInstructionSyntax(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, GetDiagnostics(), annotations);
    }

    internal XmlProcessingInstructionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.startProcessingInstructionToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.startProcessingInstructionToken);
      this.name = (XmlNameSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.name);
      this.textTokens = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.textTokens);
      this.endProcessingInstructionToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endProcessingInstructionToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new XmlProcessingInstructionSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.startProcessingInstructionToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.endProcessingInstructionToken);
    }
  }

  internal sealed partial class XmlCommentSyntax : XmlNodeSyntax
  {
    private readonly SyntaxToken lessThanExclamationMinusMinusToken;
    private readonly SyntaxNode textTokens;
    private readonly SyntaxToken minusMinusGreaterThanToken;

    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, SyntaxNode textTokens, SyntaxToken minusMinusGreaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
        this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
        if (textTokens != null)
        {
            this.textTokens = textTokens;
            this.AdjustFlagsAndWidth(textTokens);
        }
        this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
        this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
    }


    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, SyntaxNode textTokens, SyntaxToken minusMinusGreaterThanToken)
        : base(kind)
    {
        this.slotCount = 3;
        this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
        this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
        if (textTokens != null)
        {
            this.textTokens = textTokens;
            this.AdjustFlagsAndWidth(textTokens);
        }
        this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
        this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
    }

    public SyntaxToken LessThanExclamationMinusMinusToken { get { return this.lessThanExclamationMinusMinusToken; } }
    public SyntaxList<SyntaxToken> TextTokens { get { return new SyntaxList<SyntaxToken>(this.textTokens); } }
    public SyntaxToken MinusMinusGreaterThanToken { get { return this.minusMinusGreaterThanToken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanExclamationMinusMinusToken;
            case 1: return this.textTokens;
            case 2: return this.minusMinusGreaterThanToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.XmlCommentSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlComment(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlComment(this);
    }

    public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
        if (lessThanExclamationMinusMinusToken != this.LessThanExclamationMinusMinusToken || textTokens != this.TextTokens || minusMinusGreaterThanToken != this.MinusMinusGreaterThanToken)
        {
            var newNode = Syntax.XmlComment(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlCommentSyntax(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlCommentSyntax(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlCommentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.lessThanExclamationMinusMinusToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.lessThanExclamationMinusMinusToken);
      this.textTokens = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.textTokens);
      this.minusMinusGreaterThanToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.minusMinusGreaterThanToken);
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new XmlCommentSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanExclamationMinusMinusToken);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.minusMinusGreaterThanToken);
    }
  }

  internal abstract partial class DirectiveSyntax : StructuredTriviaSyntax
  {
    internal DirectiveSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
      this.flags |= NodeFlags.HasDirectives;
    }
    internal DirectiveSyntax(SyntaxKind kind)
      : base(kind)
    {
      this.flags |= NodeFlags.HasDirectives;
    }

    protected DirectiveSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract SyntaxToken HashToken { get; }

    public abstract SyntaxToken EndOfDirectiveToken { get; }

    public abstract bool IsActive { get; }
  }

  internal abstract partial class BranchingDirectiveSyntax : DirectiveSyntax
  {
    internal BranchingDirectiveSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BranchingDirectiveSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BranchingDirectiveSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract bool BranchTaken { get; }
  }

  internal abstract partial class ConditionalDirectiveSyntax : BranchingDirectiveSyntax
  {
    internal ConditionalDirectiveSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal ConditionalDirectiveSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected ConditionalDirectiveSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract ExpressionSyntax Condition { get; }

    public abstract bool ConditionValue { get; }
  }

  internal sealed partial class IfDirectiveSyntax : ConditionalDirectiveSyntax
  {
    private readonly SyntaxToken hashToken;
    private readonly SyntaxToken ifKeyword;
    private readonly ExpressionSyntax condition;
    private readonly SyntaxToken endOfDirectiveToken;
    private readonly bool isActive;
    private readonly bool branchTaken;
    private readonly bool conditionValue;

    internal IfDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.condition = condition;
        this.AdjustFlagsAndWidth(condition);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }


    internal IfDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
        : base(kind)
    {
        this.slotCount = 4;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.condition = condition;
        this.AdjustFlagsAndWidth(condition);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken IfKeyword { get { return this.ifKeyword; } }
    public override ExpressionSyntax Condition { get { return this.condition; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }
    public override bool BranchTaken { get { return this.branchTaken; } }
    public override bool ConditionValue { get { return this.conditionValue; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.ifKeyword;
            case 2: return this.condition;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.IfDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIfDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitIfDirective(this);
    }

    public IfDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
        if (hashToken != this.HashToken || ifKeyword != this.IfKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.IfDirective(hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IfDirectiveSyntax(this.Kind, this.hashToken, this.ifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IfDirectiveSyntax(this.Kind, this.hashToken, this.ifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, GetDiagnostics(), annotations);
    }

    internal IfDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.hashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.hashToken);
      this.ifKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.ifKeyword);
      this.condition = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.condition);
      this.endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfDirectiveToken);
      this.isActive = (bool)reader.ReadBoolean();
      this.branchTaken = (bool)reader.ReadBoolean();
      this.conditionValue = (bool)reader.ReadBoolean();
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new IfDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.ifKeyword);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
      writer.WriteBoolean(this.branchTaken);
      writer.WriteBoolean(this.conditionValue);
    }
  }

  internal sealed partial class ElifDirectiveSyntax : ConditionalDirectiveSyntax
  {
    private readonly SyntaxToken hashToken;
    private readonly SyntaxToken elifKeyword;
    private readonly ExpressionSyntax condition;
    private readonly SyntaxToken endOfDirectiveToken;
    private readonly bool isActive;
    private readonly bool branchTaken;
    private readonly bool conditionValue;

    internal ElifDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.elifKeyword = elifKeyword;
        this.AdjustFlagsAndWidth(elifKeyword);
        this.condition = condition;
        this.AdjustFlagsAndWidth(condition);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }


    internal ElifDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
        : base(kind)
    {
        this.slotCount = 4;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.elifKeyword = elifKeyword;
        this.AdjustFlagsAndWidth(elifKeyword);
        this.condition = condition;
        this.AdjustFlagsAndWidth(condition);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken ElifKeyword { get { return this.elifKeyword; } }
    public override ExpressionSyntax Condition { get { return this.condition; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }
    public override bool BranchTaken { get { return this.branchTaken; } }
    public override bool ConditionValue { get { return this.conditionValue; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.elifKeyword;
            case 2: return this.condition;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ElifDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElifDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitElifDirective(this);
    }

    public ElifDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
        if (hashToken != this.HashToken || elifKeyword != this.ElifKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.ElifDirective(hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ElifDirectiveSyntax(this.Kind, this.hashToken, this.elifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ElifDirectiveSyntax(this.Kind, this.hashToken, this.elifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, GetDiagnostics(), annotations);
    }

    internal ElifDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.hashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.hashToken);
      this.elifKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.elifKeyword);
      this.condition = (ExpressionSyntax)reader.ReadValue();
      AdjustFlagsAndWidth(this.condition);
      this.endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfDirectiveToken);
      this.isActive = (bool)reader.ReadBoolean();
      this.branchTaken = (bool)reader.ReadBoolean();
      this.conditionValue = (bool)reader.ReadBoolean();
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ElifDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.elifKeyword);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
      writer.WriteBoolean(this.branchTaken);
      writer.WriteBoolean(this.conditionValue);
    }
  }

  internal sealed partial class ElseDirectiveSyntax : BranchingDirectiveSyntax
  {
    private readonly SyntaxToken hashToken;
    private readonly SyntaxToken elseKeyword;
    private readonly SyntaxToken endOfDirectiveToken;
    private readonly bool isActive;
    private readonly bool branchTaken;

    internal ElseDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
        this.branchTaken = branchTaken;
    }


    internal ElseDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
        : base(kind)
    {
        this.slotCount = 3;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
        this.branchTaken = branchTaken;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken ElseKeyword { get { return this.elseKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }
    public override bool BranchTaken { get { return this.branchTaken; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.elseKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ElseDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElseDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitElseDirective(this);
    }

    public ElseDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
        if (hashToken != this.HashToken || elseKeyword != this.ElseKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.ElseDirective(hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ElseDirectiveSyntax(this.Kind, this.hashToken, this.elseKeyword, this.endOfDirectiveToken, this.isActive, this.branchTaken, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ElseDirectiveSyntax(this.Kind, this.hashToken, this.elseKeyword, this.endOfDirectiveToken, this.isActive, this.branchTaken, GetDiagnostics(), annotations);
    }

    internal ElseDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.hashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.hashToken);
      this.elseKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.elseKeyword);
      this.endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfDirectiveToken);
      this.isActive = (bool)reader.ReadBoolean();
      this.branchTaken = (bool)reader.ReadBoolean();
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ElseDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.elseKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
      writer.WriteBoolean(this.branchTaken);
    }
  }

  internal sealed partial class EndIfDirectiveSyntax : DirectiveSyntax
  {
    private readonly SyntaxToken hashToken;
    private readonly SyntaxToken endIfKeyword;
    private readonly SyntaxToken endOfDirectiveToken;
    private readonly bool isActive;

    internal EndIfDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.endIfKeyword = endIfKeyword;
        this.AdjustFlagsAndWidth(endIfKeyword);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }


    internal EndIfDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.slotCount = 3;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.endIfKeyword = endIfKeyword;
        this.AdjustFlagsAndWidth(endIfKeyword);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken EndIfKeyword { get { return this.endIfKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.endIfKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.EndIfDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEndIfDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEndIfDirective(this);
    }

    public EndIfDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || endIfKeyword != this.EndIfKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.EndIfDirective(hashToken, endIfKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EndIfDirectiveSyntax(this.Kind, this.hashToken, this.endIfKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EndIfDirectiveSyntax(this.Kind, this.hashToken, this.endIfKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal EndIfDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.hashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.hashToken);
      this.endIfKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endIfKeyword);
      this.endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfDirectiveToken);
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new EndIfDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.endIfKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }
  }

  internal sealed partial class RegionDirectiveSyntax : DirectiveSyntax
  {
    private readonly SyntaxToken hashToken;
    private readonly SyntaxToken regionKeyword;
    private readonly SyntaxToken endOfDirectiveToken;
    private readonly bool isActive;

    internal RegionDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.regionKeyword = regionKeyword;
        this.AdjustFlagsAndWidth(regionKeyword);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }


    internal RegionDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.slotCount = 3;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.regionKeyword = regionKeyword;
        this.AdjustFlagsAndWidth(regionKeyword);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken RegionKeyword { get { return this.regionKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.regionKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.RegionDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRegionDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitRegionDirective(this);
    }

    public RegionDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || regionKeyword != this.RegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.RegionDirective(hashToken, regionKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new RegionDirectiveSyntax(this.Kind, this.hashToken, this.regionKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new RegionDirectiveSyntax(this.Kind, this.hashToken, this.regionKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal RegionDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.hashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.hashToken);
      this.regionKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.regionKeyword);
      this.endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfDirectiveToken);
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new RegionDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.regionKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }
  }

  internal sealed partial class EndRegionDirectiveSyntax : DirectiveSyntax
  {
    private readonly SyntaxToken hashToken;
    private readonly SyntaxToken endRegionKeyword;
    private readonly SyntaxToken endOfDirectiveToken;
    private readonly bool isActive;

    internal EndRegionDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.endRegionKeyword = endRegionKeyword;
        this.AdjustFlagsAndWidth(endRegionKeyword);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }


    internal EndRegionDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.slotCount = 3;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.endRegionKeyword = endRegionKeyword;
        this.AdjustFlagsAndWidth(endRegionKeyword);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken EndRegionKeyword { get { return this.endRegionKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.endRegionKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.EndRegionDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEndRegionDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEndRegionDirective(this);
    }

    public EndRegionDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || endRegionKeyword != this.EndRegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.EndRegionDirective(hashToken, endRegionKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EndRegionDirectiveSyntax(this.Kind, this.hashToken, this.endRegionKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EndRegionDirectiveSyntax(this.Kind, this.hashToken, this.endRegionKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal EndRegionDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.hashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.hashToken);
      this.endRegionKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endRegionKeyword);
      this.endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfDirectiveToken);
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new EndRegionDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.endRegionKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }
  }

  internal sealed partial class ErrorDirectiveSyntax : DirectiveSyntax
  {
    private readonly SyntaxToken hashToken;
    private readonly SyntaxToken errorKeyword;
    private readonly SyntaxToken endOfDirectiveToken;
    private readonly bool isActive;

    internal ErrorDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.errorKeyword = errorKeyword;
        this.AdjustFlagsAndWidth(errorKeyword);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }


    internal ErrorDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.slotCount = 3;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.errorKeyword = errorKeyword;
        this.AdjustFlagsAndWidth(errorKeyword);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken ErrorKeyword { get { return this.errorKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.errorKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ErrorDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitErrorDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitErrorDirective(this);
    }

    public ErrorDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || errorKeyword != this.ErrorKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.ErrorDirective(hashToken, errorKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ErrorDirectiveSyntax(this.Kind, this.hashToken, this.errorKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ErrorDirectiveSyntax(this.Kind, this.hashToken, this.errorKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal ErrorDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.hashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.hashToken);
      this.errorKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.errorKeyword);
      this.endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfDirectiveToken);
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ErrorDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.errorKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }
  }

  internal sealed partial class WarningDirectiveSyntax : DirectiveSyntax
  {
    private readonly SyntaxToken hashToken;
    private readonly SyntaxToken warningKeyword;
    private readonly SyntaxToken endOfDirectiveToken;
    private readonly bool isActive;

    internal WarningDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }


    internal WarningDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.slotCount = 3;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken WarningKeyword { get { return this.warningKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.warningKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.WarningDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWarningDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitWarningDirective(this);
    }

    public WarningDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || warningKeyword != this.WarningKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.WarningDirective(hashToken, warningKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new WarningDirectiveSyntax(this.Kind, this.hashToken, this.warningKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new WarningDirectiveSyntax(this.Kind, this.hashToken, this.warningKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal WarningDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.hashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.hashToken);
      this.warningKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.warningKeyword);
      this.endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfDirectiveToken);
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new WarningDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.warningKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }
  }

  internal sealed partial class BadDirectiveSyntax : DirectiveSyntax
  {
    private readonly SyntaxToken hashToken;
    private readonly SyntaxToken identifier;
    private readonly SyntaxToken endOfDirectiveToken;
    private readonly bool isActive;

    internal BadDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 3;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }


    internal BadDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.slotCount = 3;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(identifier);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.identifier;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.BadDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBadDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBadDirective(this);
    }

    public BadDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || identifier != this.Identifier || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.BadDirective(hashToken, identifier, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BadDirectiveSyntax(this.Kind, this.hashToken, this.identifier, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BadDirectiveSyntax(this.Kind, this.hashToken, this.identifier, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal BadDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 3;
      this.hashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.hashToken);
      this.identifier = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.identifier);
      this.endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfDirectiveToken);
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new BadDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }
  }

  internal sealed partial class DefineDirectiveSyntax : DirectiveSyntax
  {
    private readonly SyntaxToken hashToken;
    private readonly SyntaxToken defineKeyword;
    private readonly SyntaxToken name;
    private readonly SyntaxToken endOfDirectiveToken;
    private readonly bool isActive;

    internal DefineDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.defineKeyword = defineKeyword;
        this.AdjustFlagsAndWidth(defineKeyword);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }


    internal DefineDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.slotCount = 4;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.defineKeyword = defineKeyword;
        this.AdjustFlagsAndWidth(defineKeyword);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken DefineKeyword { get { return this.defineKeyword; } }
    public SyntaxToken Name { get { return this.name; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.defineKeyword;
            case 2: return this.name;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.DefineDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefineDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitDefineDirective(this);
    }

    public DefineDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || defineKeyword != this.DefineKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.DefineDirective(hashToken, defineKeyword, name, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DefineDirectiveSyntax(this.Kind, this.hashToken, this.defineKeyword, this.name, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DefineDirectiveSyntax(this.Kind, this.hashToken, this.defineKeyword, this.name, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal DefineDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.hashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.hashToken);
      this.defineKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.defineKeyword);
      this.name = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.name);
      this.endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfDirectiveToken);
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new DefineDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.defineKeyword);
      writer.WriteValue(this.name);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }
  }

  internal sealed partial class UndefDirectiveSyntax : DirectiveSyntax
  {
    private readonly SyntaxToken hashToken;
    private readonly SyntaxToken undefKeyword;
    private readonly SyntaxToken name;
    private readonly SyntaxToken endOfDirectiveToken;
    private readonly bool isActive;

    internal UndefDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.undefKeyword = undefKeyword;
        this.AdjustFlagsAndWidth(undefKeyword);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }


    internal UndefDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.slotCount = 4;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.undefKeyword = undefKeyword;
        this.AdjustFlagsAndWidth(undefKeyword);
        this.name = name;
        this.AdjustFlagsAndWidth(name);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken UndefKeyword { get { return this.undefKeyword; } }
    public SyntaxToken Name { get { return this.name; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.undefKeyword;
            case 2: return this.name;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.UndefDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUndefDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitUndefDirective(this);
    }

    public UndefDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || undefKeyword != this.UndefKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.UndefDirective(hashToken, undefKeyword, name, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new UndefDirectiveSyntax(this.Kind, this.hashToken, this.undefKeyword, this.name, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new UndefDirectiveSyntax(this.Kind, this.hashToken, this.undefKeyword, this.name, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal UndefDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.hashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.hashToken);
      this.undefKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.undefKeyword);
      this.name = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.name);
      this.endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfDirectiveToken);
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new UndefDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.undefKeyword);
      writer.WriteValue(this.name);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }
  }

  internal sealed partial class LineDirectiveSyntax : DirectiveSyntax
  {
    private readonly SyntaxToken hashToken;
    private readonly SyntaxToken lineKeyword;
    private readonly SyntaxToken line;
    private readonly SyntaxToken file;
    private readonly SyntaxToken endOfDirectiveToken;
    private readonly bool isActive;

    internal LineDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 5;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.lineKeyword = lineKeyword;
        this.AdjustFlagsAndWidth(lineKeyword);
        this.line = line;
        this.AdjustFlagsAndWidth(line);
        if (file != null)
        {
            this.file = file;
            this.AdjustFlagsAndWidth(file);
        }
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }


    internal LineDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.slotCount = 5;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.lineKeyword = lineKeyword;
        this.AdjustFlagsAndWidth(lineKeyword);
        this.line = line;
        this.AdjustFlagsAndWidth(line);
        if (file != null)
        {
            this.file = file;
            this.AdjustFlagsAndWidth(file);
        }
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken LineKeyword { get { return this.lineKeyword; } }
    public SyntaxToken Line { get { return this.line; } }
    public SyntaxToken File { get { return this.file; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.lineKeyword;
            case 2: return this.line;
            case 3: return this.file;
            case 4: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.LineDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLineDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitLineDirective(this);
    }

    public LineDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || lineKeyword != this.LineKeyword || line != this.Line || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.LineDirective(hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LineDirectiveSyntax(this.Kind, this.hashToken, this.lineKeyword, this.line, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LineDirectiveSyntax(this.Kind, this.hashToken, this.lineKeyword, this.line, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal LineDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 5;
      this.hashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.hashToken);
      this.lineKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.lineKeyword);
      this.line = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.line);
      this.file = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.file);
      this.endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfDirectiveToken);
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new LineDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.lineKeyword);
      writer.WriteValue(this.line);
      writer.WriteValue(this.file);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }
  }

  internal sealed partial class PragmaWarningDirectiveSyntax : DirectiveSyntax
  {
    private readonly SyntaxToken hashToken;
    private readonly SyntaxToken pragmaKeyword;
    private readonly SyntaxToken warningKeyword;
    private readonly SyntaxToken disableOrRestoreKeyword;
    private readonly SyntaxNode errorCodes;
    private readonly SyntaxToken endOfDirectiveToken;
    private readonly bool isActive;

    internal PragmaWarningDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SyntaxNode errorCodes, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 6;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.disableOrRestoreKeyword = disableOrRestoreKeyword;
        this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
        if (errorCodes != null)
        {
            this.errorCodes = errorCodes;
            this.AdjustFlagsAndWidth(errorCodes);
        }
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }


    internal PragmaWarningDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SyntaxNode errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.slotCount = 6;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.disableOrRestoreKeyword = disableOrRestoreKeyword;
        this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
        if (errorCodes != null)
        {
            this.errorCodes = errorCodes;
            this.AdjustFlagsAndWidth(errorCodes);
        }
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken PragmaKeyword { get { return this.pragmaKeyword; } }
    public SyntaxToken WarningKeyword { get { return this.warningKeyword; } }
    public SyntaxToken DisableOrRestoreKeyword { get { return this.disableOrRestoreKeyword; } }
    public SeparatedSyntaxList<ExpressionSyntax> ErrorCodes { get { return new SeparatedSyntaxList<ExpressionSyntax>(new SyntaxList<SyntaxNode>(this.errorCodes)); } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.pragmaKeyword;
            case 2: return this.warningKeyword;
            case 3: return this.disableOrRestoreKeyword;
            case 4: return this.errorCodes;
            case 5: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.PragmaWarningDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPragmaWarningDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitPragmaWarningDirective(this);
    }

    public PragmaWarningDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || warningKeyword != this.WarningKeyword || disableOrRestoreKeyword != this.DisableOrRestoreKeyword || errorCodes != this.ErrorCodes || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.PragmaWarningDirective(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PragmaWarningDirectiveSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.warningKeyword, this.disableOrRestoreKeyword, this.errorCodes, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PragmaWarningDirectiveSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.warningKeyword, this.disableOrRestoreKeyword, this.errorCodes, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal PragmaWarningDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 6;
      this.hashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.hashToken);
      this.pragmaKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.pragmaKeyword);
      this.warningKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.warningKeyword);
      this.disableOrRestoreKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.disableOrRestoreKeyword);
      this.errorCodes = (SyntaxNode)reader.ReadValue();
      AdjustFlagsAndWidth(this.errorCodes);
      this.endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfDirectiveToken);
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new PragmaWarningDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.pragmaKeyword);
      writer.WriteValue(this.warningKeyword);
      writer.WriteValue(this.disableOrRestoreKeyword);
      writer.WriteValue(this.errorCodes);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }
  }

  internal sealed partial class PragmaChecksumDirectiveSyntax : DirectiveSyntax
  {
    private readonly SyntaxToken hashToken;
    private readonly SyntaxToken pragmaKeyword;
    private readonly SyntaxToken checksumKeyword;
    private readonly SyntaxToken file;
    private readonly SyntaxToken guid;
    private readonly SyntaxToken bytes;
    private readonly SyntaxToken endOfDirectiveToken;
    private readonly bool isActive;

    internal PragmaChecksumDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 7;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.checksumKeyword = checksumKeyword;
        this.AdjustFlagsAndWidth(checksumKeyword);
        this.file = file;
        this.AdjustFlagsAndWidth(file);
        this.guid = guid;
        this.AdjustFlagsAndWidth(guid);
        this.bytes = bytes;
        this.AdjustFlagsAndWidth(bytes);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }


    internal PragmaChecksumDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.slotCount = 7;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.checksumKeyword = checksumKeyword;
        this.AdjustFlagsAndWidth(checksumKeyword);
        this.file = file;
        this.AdjustFlagsAndWidth(file);
        this.guid = guid;
        this.AdjustFlagsAndWidth(guid);
        this.bytes = bytes;
        this.AdjustFlagsAndWidth(bytes);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken PragmaKeyword { get { return this.pragmaKeyword; } }
    public SyntaxToken ChecksumKeyword { get { return this.checksumKeyword; } }
    public SyntaxToken File { get { return this.file; } }
    public SyntaxToken Guid { get { return this.guid; } }
    public SyntaxToken Bytes { get { return this.bytes; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.pragmaKeyword;
            case 2: return this.checksumKeyword;
            case 3: return this.file;
            case 4: return this.guid;
            case 5: return this.bytes;
            case 6: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.PragmaChecksumDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPragmaChecksumDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitPragmaChecksumDirective(this);
    }

    public PragmaChecksumDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || checksumKeyword != this.ChecksumKeyword || file != this.File || guid != this.Guid || bytes != this.Bytes || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.PragmaChecksumDirective(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PragmaChecksumDirectiveSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.checksumKeyword, this.file, this.guid, this.bytes, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PragmaChecksumDirectiveSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.checksumKeyword, this.file, this.guid, this.bytes, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal PragmaChecksumDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 7;
      this.hashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.hashToken);
      this.pragmaKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.pragmaKeyword);
      this.checksumKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.checksumKeyword);
      this.file = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.file);
      this.guid = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.guid);
      this.bytes = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.bytes);
      this.endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfDirectiveToken);
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new PragmaChecksumDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.pragmaKeyword);
      writer.WriteValue(this.checksumKeyword);
      writer.WriteValue(this.file);
      writer.WriteValue(this.guid);
      writer.WriteValue(this.bytes);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }
  }

  internal sealed partial class ReferenceDirectiveSyntax : DirectiveSyntax
  {
    private readonly SyntaxToken hashToken;
    private readonly SyntaxToken referenceKeyword;
    private readonly SyntaxToken file;
    private readonly SyntaxToken endOfDirectiveToken;
    private readonly bool isActive;

    internal ReferenceDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.slotCount = 4;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.referenceKeyword = referenceKeyword;
        this.AdjustFlagsAndWidth(referenceKeyword);
        this.file = file;
        this.AdjustFlagsAndWidth(file);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }


    internal ReferenceDirectiveSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.slotCount = 4;
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(hashToken);
        this.referenceKeyword = referenceKeyword;
        this.AdjustFlagsAndWidth(referenceKeyword);
        this.file = file;
        this.AdjustFlagsAndWidth(file);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken ReferenceKeyword { get { return this.referenceKeyword; } }
    public SyntaxToken File { get { return this.file; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override SyntaxNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.referenceKeyword;
            case 2: return this.file;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override CSharp.SyntaxNode ToRed(CSharp.SyntaxNode parent, int position)
    {
      return new CSharp.ReferenceDirectiveSyntax(parent, this, position);
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitReferenceDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitReferenceDirective(this);
    }

    public ReferenceDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || referenceKeyword != this.ReferenceKeyword || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.ReferenceDirective(hashToken, referenceKeyword, file, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SyntaxNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ReferenceDirectiveSyntax(this.Kind, this.hashToken, this.referenceKeyword, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override SyntaxNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ReferenceDirectiveSyntax(this.Kind, this.hashToken, this.referenceKeyword, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal ReferenceDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.slotCount = 4;
      this.hashToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.hashToken);
      this.referenceKeyword = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.referenceKeyword);
      this.file = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.file);
      this.endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      AdjustFlagsAndWidth(this.endOfDirectiveToken);
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal static Func<ObjectReader, object> CreateInstance = o => new ReferenceDirectiveSyntax(o);

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.referenceKeyword);
      writer.WriteValue(this.file);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }
  }

  internal partial class SyntaxVisitor<TResult>
  {
    public virtual TResult VisitIdentifierName(IdentifierNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitQualifiedName(QualifiedNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitGenericName(GenericNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPredefinedType(PredefinedTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArrayType(ArrayTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPointerType(PointerTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitNullableType(NullableTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitThisExpression(ThisExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBaseExpression(BaseExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArgumentList(ArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArgument(ArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitNameColon(NameColonSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCastExpression(CastExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitQueryExpression(QueryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitQueryBody(QueryBodySyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitFromClause(FromClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLetClause(LetClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitJoinClause(JoinClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitWhereClause(WhereClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOrderByClause(OrderByClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOrdering(OrderingSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSelectClause(SelectClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitGroupClause(GroupClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitQueryContinuation(QueryContinuationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitGlobalStatement(GlobalStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBlock(BlockSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLabeledStatement(LabeledStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitGotoStatement(GotoStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBreakStatement(BreakStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitContinueStatement(ContinueStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitReturnStatement(ReturnStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitThrowStatement(ThrowStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitYieldStatement(YieldStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitWhileStatement(WhileStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDoStatement(DoStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitForStatement(ForStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitForEachStatement(ForEachStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitUsingStatement(UsingStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitFixedStatement(FixedStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCheckedStatement(CheckedStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLockStatement(LockStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIfStatement(IfStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitElseClause(ElseClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSwitchStatement(SwitchStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSwitchSection(SwitchSectionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSwitchLabel(SwitchLabelSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTryStatement(TryStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCatchClause(CatchClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitFinallyClause(FinallyClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitUsingDirective(UsingDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAttributeDeclaration(AttributeDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAttribute(AttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitNameEquals(NameEqualsSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeParameter(TypeParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitStructDeclaration(StructDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBaseList(BaseListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeConstraint(TypeConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEventDeclaration(EventDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAccessorList(AccessorListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitParameterList(ParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitParameter(ParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSkippedTokens(SkippedTokensSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDocumentationComment(DocumentationCommentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlElement(XmlElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlName(XmlNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlAttribute(XmlAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlText(XmlTextSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlComment(XmlCommentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIfDirective(IfDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitElifDirective(ElifDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitElseDirective(ElseDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEndIfDirective(EndIfDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitRegionDirective(RegionDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEndRegionDirective(EndRegionDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitErrorDirective(ErrorDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitWarningDirective(WarningDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBadDirective(BadDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDefineDirective(DefineDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitUndefDirective(UndefDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLineDirective(LineDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPragmaWarningDirective(PragmaWarningDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPragmaChecksumDirective(PragmaChecksumDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitReferenceDirective(ReferenceDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }
  }


  internal partial class SyntaxVisitor
  {
    public virtual void VisitIdentifierName(IdentifierNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitQualifiedName(QualifiedNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitGenericName(GenericNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPredefinedType(PredefinedTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArrayType(ArrayTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPointerType(PointerTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitNullableType(NullableTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitThisExpression(ThisExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBaseExpression(BaseExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArgumentList(ArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArgument(ArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitNameColon(NameColonSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCastExpression(CastExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitQueryExpression(QueryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitQueryBody(QueryBodySyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitFromClause(FromClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLetClause(LetClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitJoinClause(JoinClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitWhereClause(WhereClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOrderByClause(OrderByClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOrdering(OrderingSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSelectClause(SelectClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitGroupClause(GroupClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitQueryContinuation(QueryContinuationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitGlobalStatement(GlobalStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBlock(BlockSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEmptyStatement(EmptyStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLabeledStatement(LabeledStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitGotoStatement(GotoStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBreakStatement(BreakStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitContinueStatement(ContinueStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitReturnStatement(ReturnStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitThrowStatement(ThrowStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitYieldStatement(YieldStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitWhileStatement(WhileStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDoStatement(DoStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitForStatement(ForStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitForEachStatement(ForEachStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitUsingStatement(UsingStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitFixedStatement(FixedStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCheckedStatement(CheckedStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLockStatement(LockStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIfStatement(IfStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitElseClause(ElseClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSwitchStatement(SwitchStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSwitchSection(SwitchSectionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSwitchLabel(SwitchLabelSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTryStatement(TryStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCatchClause(CatchClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitFinallyClause(FinallyClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCompilationUnit(CompilationUnitSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitUsingDirective(UsingDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAttributeDeclaration(AttributeDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAttribute(AttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitNameEquals(NameEqualsSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeParameterList(TypeParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeParameter(TypeParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitStructDeclaration(StructDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBaseList(BaseListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeConstraint(TypeConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEventDeclaration(EventDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAccessorList(AccessorListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitParameterList(ParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitParameter(ParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSkippedTokens(SkippedTokensSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDocumentationComment(DocumentationCommentSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlElement(XmlElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlName(XmlNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlPrefix(XmlPrefixSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlAttribute(XmlAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlText(XmlTextSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlComment(XmlCommentSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIfDirective(IfDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitElifDirective(ElifDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitElseDirective(ElseDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEndIfDirective(EndIfDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitRegionDirective(RegionDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEndRegionDirective(EndRegionDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitErrorDirective(ErrorDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitWarningDirective(WarningDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBadDirective(BadDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDefineDirective(DefineDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitUndefDirective(UndefDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLineDirective(LineDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPragmaWarningDirective(PragmaWarningDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPragmaChecksumDirective(PragmaChecksumDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitReferenceDirective(ReferenceDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }
  }

  internal partial class SyntaxRewriter : SyntaxVisitor<SyntaxNode>
  {
    public override SyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(identifier);
    }

    public override SyntaxNode VisitQualifiedName(QualifiedNameSyntax node)
    {
      var left = (NameSyntax)this.Visit(node.Left);
      var dotToken = (SyntaxToken)this.Visit(node.DotToken);
      var right = (SimpleNameSyntax)this.Visit(node.Right);
      return node.Update(left, dotToken, right);
    }

    public override SyntaxNode VisitGenericName(GenericNameSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeArgumentList = (TypeArgumentListSyntax)this.Visit(node.TypeArgumentList);
      return node.Update(identifier, typeArgumentList);
    }

    public override SyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var arguments = this.VisitList(node.Arguments);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanToken, arguments, greaterThanToken);
    }

    public override SyntaxNode VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      var alias = (IdentifierNameSyntax)this.Visit(node.Alias);
      var colonColonToken = (SyntaxToken)this.Visit(node.ColonColonToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(alias, colonColonToken, name);
    }

    public override SyntaxNode VisitPredefinedType(PredefinedTypeSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      return node.Update(keyword);
    }

    public override SyntaxNode VisitArrayType(ArrayTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var rankSpecifiers = this.VisitList(node.RankSpecifiers);
      return node.Update(elementType, rankSpecifiers);
    }

    public override SyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var sizes = this.VisitList(node.Sizes);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, sizes, closeBracketToken);
    }

    public override SyntaxNode VisitPointerType(PointerTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var asteriskToken = (SyntaxToken)this.Visit(node.AsteriskToken);
      return node.Update(elementType, asteriskToken);
    }

    public override SyntaxNode VisitNullableType(NullableTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var questionToken = (SyntaxToken)this.Visit(node.QuestionToken);
      return node.Update(elementType, questionToken);
    }

    public override SyntaxNode VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      var omittedTypeArgumentToken = (SyntaxToken)this.Visit(node.OmittedTypeArgumentToken);
      return node.Update(omittedTypeArgumentToken);
    }

    public override SyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var operand = (ExpressionSyntax)this.Visit(node.Operand);
      return node.Update(operatorToken, operand);
    }

    public override SyntaxNode VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      var operand = (ExpressionSyntax)this.Visit(node.Operand);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      return node.Update(operand, operatorToken);
    }

    public override SyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(expression, operatorToken, name);
    }

    public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      var left = (ExpressionSyntax)this.Visit(node.Left);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var right = (ExpressionSyntax)this.Visit(node.Right);
      return node.Update(left, operatorToken, right);
    }

    public override SyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var questionToken = (SyntaxToken)this.Visit(node.QuestionToken);
      var whenTrue = (ExpressionSyntax)this.Visit(node.WhenTrue);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var whenFalse = (ExpressionSyntax)this.Visit(node.WhenFalse);
      return node.Update(condition, questionToken, whenTrue, colonToken, whenFalse);
    }

    public override SyntaxNode VisitThisExpression(ThisExpressionSyntax node)
    {
      var token = (SyntaxToken)this.Visit(node.Token);
      return node.Update(token);
    }

    public override SyntaxNode VisitBaseExpression(BaseExpressionSyntax node)
    {
      var token = (SyntaxToken)this.Visit(node.Token);
      return node.Update(token);
    }

    public override SyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      var token = (SyntaxToken)this.Visit(node.Token);
      return node.Update(token);
    }

    public override SyntaxNode VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var comma = (SyntaxToken)this.Visit(node.Comma);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, comma, type, closeParenToken);
    }

    public override SyntaxNode VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override SyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override SyntaxNode VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(expression, argumentList);
    }

    public override SyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(expression, argumentList);
    }

    public override SyntaxNode VisitArgumentList(ArgumentListSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override SyntaxNode VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var arguments = this.VisitList(node.Arguments);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, arguments, closeBracketToken);
    }

    public override SyntaxNode VisitArgument(ArgumentSyntax node)
    {
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var refOrOutKeyword = (SyntaxToken)this.Visit(node.RefOrOutKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameColon, refOrOutKeyword, expression);
    }

    public override SyntaxNode VisitNameColon(NameColonSyntax node)
    {
      var identifier = (IdentifierNameSyntax)this.Visit(node.Identifier);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(identifier, colonToken);
    }

    public override SyntaxNode VisitCastExpression(CastExpressionSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(openParenToken, type, closeParenToken, expression);
    }

    public override SyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      var delegateKeyword = (SyntaxToken)this.Visit(node.DelegateKeyword);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(delegateKeyword, parameterList, block);
    }

    public override SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      var parameter = (ParameterSyntax)this.Visit(node.Parameter);
      var arrowToken = (SyntaxToken)this.Visit(node.ArrowToken);
      var body = (SyntaxNode)this.Visit(node.Body);
      return node.Update(parameter, arrowToken, body);
    }

    public override SyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var arrowToken = (SyntaxToken)this.Visit(node.ArrowToken);
      var body = (SyntaxNode)this.Visit(node.Body);
      return node.Update(parameterList, arrowToken, body);
    }

    public override SyntaxNode VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var expressions = this.VisitList(node.Expressions);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, expressions, closeBraceToken);
    }

    public override SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, type, argumentList, initializer);
    }

    public override SyntaxNode VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      var nameEquals = (NameEqualsSyntax)this.Visit(node.NameEquals);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameEquals, expression);
    }

    public override SyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var initializers = this.VisitList(node.Initializers);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(newKeyword, openBraceToken, initializers, closeBraceToken);
    }

    public override SyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var type = (ArrayTypeSyntax)this.Visit(node.Type);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, type, initializer);
    }

    public override SyntaxNode VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var commas = this.VisitList(node.Commas);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
    }

    public override SyntaxNode VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      var stackAllocKeyword = (SyntaxToken)this.Visit(node.StackAllocKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(stackAllocKeyword, type);
    }

    public override SyntaxNode VisitQueryExpression(QueryExpressionSyntax node)
    {
      var fromClause = (FromClauseSyntax)this.Visit(node.FromClause);
      var body = (QueryBodySyntax)this.Visit(node.Body);
      return node.Update(fromClause, body);
    }

    public override SyntaxNode VisitQueryBody(QueryBodySyntax node)
    {
      var clauses = this.VisitList(node.Clauses);
      var selectOrGroup = (SelectOrGroupClauseSyntax)this.Visit(node.SelectOrGroup);
      var continuation = (QueryContinuationSyntax)this.Visit(node.Continuation);
      return node.Update(clauses, selectOrGroup, continuation);
    }

    public override SyntaxNode VisitFromClause(FromClauseSyntax node)
    {
      var fromKeyword = (SyntaxToken)this.Visit(node.FromKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var inKeyword = (SyntaxToken)this.Visit(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(fromKeyword, type, identifier, inKeyword, expression);
    }

    public override SyntaxNode VisitLetClause(LetClauseSyntax node)
    {
      var letKeyword = (SyntaxToken)this.Visit(node.LetKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(letKeyword, identifier, equalsToken, expression);
    }

    public override SyntaxNode VisitJoinClause(JoinClauseSyntax node)
    {
      var joinKeyword = (SyntaxToken)this.Visit(node.JoinKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var inKeyword = (SyntaxToken)this.Visit(node.InKeyword);
      var inExpression = (ExpressionSyntax)this.Visit(node.InExpression);
      var onKeyword = (SyntaxToken)this.Visit(node.OnKeyword);
      var leftExpression = (ExpressionSyntax)this.Visit(node.LeftExpression);
      var equalsKeyword = (SyntaxToken)this.Visit(node.EqualsKeyword);
      var rightExpression = (ExpressionSyntax)this.Visit(node.RightExpression);
      var into = (JoinIntoClauseSyntax)this.Visit(node.Into);
      return node.Update(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
    }

    public override SyntaxNode VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      var intoKeyword = (SyntaxToken)this.Visit(node.IntoKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(intoKeyword, identifier);
    }

    public override SyntaxNode VisitWhereClause(WhereClauseSyntax node)
    {
      var whereKeyword = (SyntaxToken)this.Visit(node.WhereKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      return node.Update(whereKeyword, condition);
    }

    public override SyntaxNode VisitOrderByClause(OrderByClauseSyntax node)
    {
      var orderByKeyword = (SyntaxToken)this.Visit(node.OrderByKeyword);
      var orderings = this.VisitList(node.Orderings);
      return node.Update(orderByKeyword, orderings);
    }

    public override SyntaxNode VisitOrdering(OrderingSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var ascendingOrDescendingKeyword = (SyntaxToken)this.Visit(node.AscendingOrDescendingKeyword);
      return node.Update(expression, ascendingOrDescendingKeyword);
    }

    public override SyntaxNode VisitSelectClause(SelectClauseSyntax node)
    {
      var selectKeyword = (SyntaxToken)this.Visit(node.SelectKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(selectKeyword, expression);
    }

    public override SyntaxNode VisitGroupClause(GroupClauseSyntax node)
    {
      var groupKeyword = (SyntaxToken)this.Visit(node.GroupKeyword);
      var groupExpression = (ExpressionSyntax)this.Visit(node.GroupExpression);
      var byKeyword = (SyntaxToken)this.Visit(node.ByKeyword);
      var byExpression = (ExpressionSyntax)this.Visit(node.ByExpression);
      return node.Update(groupKeyword, groupExpression, byKeyword, byExpression);
    }

    public override SyntaxNode VisitQueryContinuation(QueryContinuationSyntax node)
    {
      var intoKeyword = (SyntaxToken)this.Visit(node.IntoKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var body = (QueryBodySyntax)this.Visit(node.Body);
      return node.Update(intoKeyword, identifier, body);
    }

    public override SyntaxNode VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      var omittedArraySizeExpressionToken = (SyntaxToken)this.Visit(node.OmittedArraySizeExpressionToken);
      return node.Update(omittedArraySizeExpressionToken);
    }

    public override SyntaxNode VisitGlobalStatement(GlobalStatementSyntax node)
    {
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(statement);
    }

    public override SyntaxNode VisitBlock(BlockSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var statements = this.VisitList(node.Statements);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, statements, closeBraceToken);
    }

    public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      var modifiers = this.VisitList(node.Modifiers);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(modifiers, declaration, semicolonToken);
    }

    public override SyntaxNode VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var variables = this.VisitList(node.Variables);
      return node.Update(type, variables);
    }

    public override SyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      var initializer = (EqualsValueClauseSyntax)this.Visit(node.Initializer);
      return node.Update(identifier, argumentList, initializer);
    }

    public override SyntaxNode VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      return node.Update(equalsToken, value);
    }

    public override SyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(expression, semicolonToken);
    }

    public override SyntaxNode VisitEmptyStatement(EmptyStatementSyntax node)
    {
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(semicolonToken);
    }

    public override SyntaxNode VisitLabeledStatement(LabeledStatementSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(identifier, colonToken, statement);
    }

    public override SyntaxNode VisitGotoStatement(GotoStatementSyntax node)
    {
      var gotoKeyword = (SyntaxToken)this.Visit(node.GotoKeyword);
      var caseOrDefaultKeyword = (SyntaxToken)this.Visit(node.CaseOrDefaultKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitBreakStatement(BreakStatementSyntax node)
    {
      var breakKeyword = (SyntaxToken)this.Visit(node.BreakKeyword);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(breakKeyword, semicolonToken);
    }

    public override SyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
    {
      var continueKeyword = (SyntaxToken)this.Visit(node.ContinueKeyword);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(continueKeyword, semicolonToken);
    }

    public override SyntaxNode VisitReturnStatement(ReturnStatementSyntax node)
    {
      var returnKeyword = (SyntaxToken)this.Visit(node.ReturnKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(returnKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitThrowStatement(ThrowStatementSyntax node)
    {
      var throwKeyword = (SyntaxToken)this.Visit(node.ThrowKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(throwKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitYieldStatement(YieldStatementSyntax node)
    {
      var yieldKeyword = (SyntaxToken)this.Visit(node.YieldKeyword);
      var returnOrBreakKeyword = (SyntaxToken)this.Visit(node.ReturnOrBreakKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitWhileStatement(WhileStatementSyntax node)
    {
      var whileKeyword = (SyntaxToken)this.Visit(node.WhileKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(whileKeyword, openParenToken, condition, closeParenToken, statement);
    }

    public override SyntaxNode VisitDoStatement(DoStatementSyntax node)
    {
      var doKeyword = (SyntaxToken)this.Visit(node.DoKeyword);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      var whileKeyword = (SyntaxToken)this.Visit(node.WhileKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
    }

    public override SyntaxNode VisitForStatement(ForStatementSyntax node)
    {
      var forKeyword = (SyntaxToken)this.Visit(node.ForKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var initializers = this.VisitList(node.Initializers);
      var firstSemicolonToken = (SyntaxToken)this.Visit(node.FirstSemicolonToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var secondSemicolonToken = (SyntaxToken)this.Visit(node.SecondSemicolonToken);
      var incrementors = this.VisitList(node.Incrementors);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(forKeyword, openParenToken, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
    }

    public override SyntaxNode VisitForEachStatement(ForEachStatementSyntax node)
    {
      var forEachKeyword = (SyntaxToken)this.Visit(node.ForEachKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var inKeyword = (SyntaxToken)this.Visit(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
    }

    public override SyntaxNode VisitUsingStatement(UsingStatementSyntax node)
    {
      var usingKeyword = (SyntaxToken)this.Visit(node.UsingKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
    }

    public override SyntaxNode VisitFixedStatement(FixedStatementSyntax node)
    {
      var fixedKeyword = (SyntaxToken)this.Visit(node.FixedKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(fixedKeyword, openParenToken, declaration, closeParenToken, statement);
    }

    public override SyntaxNode VisitCheckedStatement(CheckedStatementSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(keyword, block);
    }

    public override SyntaxNode VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      var unsafeKeyword = (SyntaxToken)this.Visit(node.UnsafeKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(unsafeKeyword, block);
    }

    public override SyntaxNode VisitLockStatement(LockStatementSyntax node)
    {
      var lockKeyword = (SyntaxToken)this.Visit(node.LockKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(lockKeyword, openParenToken, expression, closeParenToken, statement);
    }

    public override SyntaxNode VisitIfStatement(IfStatementSyntax node)
    {
      var ifKeyword = (SyntaxToken)this.Visit(node.IfKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      var @else = (ElseClauseSyntax)this.Visit(node.Else);
      return node.Update(ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
    }

    public override SyntaxNode VisitElseClause(ElseClauseSyntax node)
    {
      var elseKeyword = (SyntaxToken)this.Visit(node.ElseKeyword);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(elseKeyword, statement);
    }

    public override SyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)
    {
      var switchKeyword = (SyntaxToken)this.Visit(node.SwitchKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var sections = this.VisitList(node.Sections);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
    }

    public override SyntaxNode VisitSwitchSection(SwitchSectionSyntax node)
    {
      var labels = this.VisitList(node.Labels);
      var statements = this.VisitList(node.Statements);
      return node.Update(labels, statements);
    }

    public override SyntaxNode VisitSwitchLabel(SwitchLabelSyntax node)
    {
      var caseOrDefaultKeyword = (SyntaxToken)this.Visit(node.CaseOrDefaultKeyword);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(caseOrDefaultKeyword, value, colonToken);
    }

    public override SyntaxNode VisitTryStatement(TryStatementSyntax node)
    {
      var tryKeyword = (SyntaxToken)this.Visit(node.TryKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      var catches = this.VisitList(node.Catches);
      var @finally = (FinallyClauseSyntax)this.Visit(node.Finally);
      return node.Update(tryKeyword, block, catches, @finally);
    }

    public override SyntaxNode VisitCatchClause(CatchClauseSyntax node)
    {
      var catchKeyword = (SyntaxToken)this.Visit(node.CatchKeyword);
      var declaration = (CatchDeclarationSyntax)this.Visit(node.Declaration);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(catchKeyword, declaration, block);
    }

    public override SyntaxNode VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, type, identifier, closeParenToken);
    }

    public override SyntaxNode VisitFinallyClause(FinallyClauseSyntax node)
    {
      var finallyKeyword = (SyntaxToken)this.Visit(node.FinallyKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(finallyKeyword, block);
    }

    public override SyntaxNode VisitCompilationUnit(CompilationUnitSyntax node)
    {
      var externs = this.VisitList(node.Externs);
      var usings = this.VisitList(node.Usings);
      var attributes = this.VisitList(node.Attributes);
      var members = this.VisitList(node.Members);
      var endOfFileToken = (SyntaxToken)this.Visit(node.EndOfFileToken);
      return node.Update(externs, usings, attributes, members, endOfFileToken);
    }

    public override SyntaxNode VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      var externKeyword = (SyntaxToken)this.Visit(node.ExternKeyword);
      var aliasKeyword = (SyntaxToken)this.Visit(node.AliasKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(externKeyword, aliasKeyword, identifier, semicolonToken);
    }

    public override SyntaxNode VisitUsingDirective(UsingDirectiveSyntax node)
    {
      var usingKeyword = (SyntaxToken)this.Visit(node.UsingKeyword);
      var alias = (NameEqualsSyntax)this.Visit(node.Alias);
      var name = (NameSyntax)this.Visit(node.Name);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(usingKeyword, alias, name, semicolonToken);
    }

    public override SyntaxNode VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      var namespaceKeyword = (SyntaxToken)this.Visit(node.NamespaceKeyword);
      var name = (NameSyntax)this.Visit(node.Name);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var externs = this.VisitList(node.Externs);
      var usings = this.VisitList(node.Usings);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitAttributeDeclaration(AttributeDeclarationSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var target = (AttributeTargetSpecifierSyntax)this.Visit(node.Target);
      var attributes = this.VisitList(node.Attributes);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, target, attributes, closeBracketToken);
    }

    public override SyntaxNode VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(identifier, colonToken);
    }

    public override SyntaxNode VisitAttribute(AttributeSyntax node)
    {
      var name = (NameSyntax)this.Visit(node.Name);
      var argumentList = (AttributeArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(name, argumentList);
    }

    public override SyntaxNode VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override SyntaxNode VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      var nameEquals = (NameEqualsSyntax)this.Visit(node.NameEquals);
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameEquals, nameColon, expression);
    }

    public override SyntaxNode VisitNameEquals(NameEqualsSyntax node)
    {
      var identifier = (IdentifierNameSyntax)this.Visit(node.Identifier);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      return node.Update(identifier, equalsToken);
    }

    public override SyntaxNode VisitTypeParameterList(TypeParameterListSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var parameters = this.VisitList(node.Parameters);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanToken, parameters, greaterThanToken);
    }

    public override SyntaxNode VisitTypeParameter(TypeParameterSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var varianceKeyword = (SyntaxToken)this.Visit(node.VarianceKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(attributes, varianceKeyword, identifier);
    }

    public override SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributes, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitStructDeclaration(StructDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributes, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributes, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var enumKeyword = (SyntaxToken)this.Visit(node.EnumKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributes, modifiers, enumKeyword, identifier, baseList, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var delegateKeyword = (SyntaxToken)this.Visit(node.DelegateKeyword);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributes, modifiers, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, semicolonToken);
    }

    public override SyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var equalsValue = (EqualsValueClauseSyntax)this.Visit(node.EqualsValue);
      return node.Update(attributes, identifier, equalsValue);
    }

    public override SyntaxNode VisitBaseList(BaseListSyntax node)
    {
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var types = this.VisitList(node.Types);
      return node.Update(colonToken, types);
    }

    public override SyntaxNode VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      var whereKeyword = (SyntaxToken)this.Visit(node.WhereKeyword);
      var identifier = (IdentifierNameSyntax)this.Visit(node.Identifier);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var constraints = this.VisitList(node.Constraints);
      return node.Update(whereKeyword, identifier, colonToken, constraints);
    }

    public override SyntaxNode VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(newKeyword, openParenToken, closeParenToken);
    }

    public override SyntaxNode VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      var classOrStructKeyword = (SyntaxToken)this.Visit(node.ClassOrStructKeyword);
      return node.Update(classOrStructKeyword);
    }

    public override SyntaxNode VisitTypeConstraint(TypeConstraintSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override SyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributes, modifiers, declaration, semicolonToken);
    }

    public override SyntaxNode VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var eventKeyword = (SyntaxToken)this.Visit(node.EventKeyword);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributes, modifiers, eventKeyword, declaration, semicolonToken);
    }

    public override SyntaxNode VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      var name = (NameSyntax)this.Visit(node.Name);
      var dotToken = (SyntaxToken)this.Visit(node.DotToken);
      return node.Update(name, dotToken);
    }

    public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributes, modifiers, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, semicolonToken);
    }

    public override SyntaxNode VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var operatorKeyword = (SyntaxToken)this.Visit(node.OperatorKeyword);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributes, modifiers, returnType, operatorKeyword, operatorToken, parameterList, body, semicolonToken);
    }

    public override SyntaxNode VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var implicitOrExplicitKeyword = (SyntaxToken)this.Visit(node.ImplicitOrExplicitKeyword);
      var operatorKeyword = (SyntaxToken)this.Visit(node.OperatorKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributes, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, semicolonToken);
    }

    public override SyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var initializer = (ConstructorInitializerSyntax)this.Visit(node.Initializer);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributes, modifiers, identifier, parameterList, initializer, body, semicolonToken);
    }

    public override SyntaxNode VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var thisOrBaseKeyword = (SyntaxToken)this.Visit(node.ThisOrBaseKeyword);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(colonToken, thisOrBaseKeyword, argumentList);
    }

    public override SyntaxNode VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var tildeToken = (SyntaxToken)this.Visit(node.TildeToken);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributes, modifiers, tildeToken, identifier, parameterList, body, semicolonToken);
    }

    public override SyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      return node.Update(attributes, modifiers, type, explicitInterfaceSpecifier, identifier, accessorList);
    }

    public override SyntaxNode VisitEventDeclaration(EventDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var eventKeyword = (SyntaxToken)this.Visit(node.EventKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      return node.Update(attributes, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList);
    }

    public override SyntaxNode VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var thisKeyword = (SyntaxToken)this.Visit(node.ThisKeyword);
      var parameterList = (BracketedParameterListSyntax)this.Visit(node.ParameterList);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      return node.Update(attributes, modifiers, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList);
    }

    public override SyntaxNode VisitAccessorList(AccessorListSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var accessors = this.VisitList(node.Accessors);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, accessors, closeBraceToken);
    }

    public override SyntaxNode VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributes, modifiers, keyword, body, semicolonToken);
    }

    public override SyntaxNode VisitParameterList(ParameterListSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var parameters = this.VisitList(node.Parameters);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, parameters, closeParenToken);
    }

    public override SyntaxNode VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var parameters = this.VisitList(node.Parameters);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, parameters, closeBracketToken);
    }

    public override SyntaxNode VisitParameter(ParameterSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var @default = (EqualsValueClauseSyntax)this.Visit(node.Default);
      return node.Update(attributes, modifiers, type, identifier, @default);
    }

    public override SyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(attributes, modifiers, type);
    }

    public override SyntaxNode VisitSkippedTokens(SkippedTokensSyntax node)
    {
      var tokens = this.VisitList(node.Tokens);
      return node.Update(tokens);
    }

    public override SyntaxNode VisitDocumentationComment(DocumentationCommentSyntax node)
    {
      var nodes = this.VisitList(node.Nodes);
      var endOfComment = (SyntaxToken)this.Visit(node.EndOfComment);
      return node.Update(nodes, endOfComment);
    }

    public override SyntaxNode VisitXmlElement(XmlElementSyntax node)
    {
      var startTag = (XmlElementStartTagSyntax)this.Visit(node.StartTag);
      var content = this.VisitList(node.Content);
      var endTag = (XmlElementEndTagSyntax)this.Visit(node.EndTag);
      return node.Update(startTag, content, endTag);
    }

    public override SyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanToken, name, attributes, greaterThanToken);
    }

    public override SyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      var lessThanSlashToken = (SyntaxToken)this.Visit(node.LessThanSlashToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanSlashToken, name, greaterThanToken);
    }

    public override SyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var slashGreaterThanToken = (SyntaxToken)this.Visit(node.SlashGreaterThanToken);
      return node.Update(lessThanToken, name, attributes, slashGreaterThanToken);
    }

    public override SyntaxNode VisitXmlName(XmlNameSyntax node)
    {
      var prefix = (XmlPrefixSyntax)this.Visit(node.Prefix);
      var localName = (SyntaxToken)this.Visit(node.LocalName);
      return node.Update(prefix, localName);
    }

    public override SyntaxNode VisitXmlPrefix(XmlPrefixSyntax node)
    {
      var prefix = (SyntaxToken)this.Visit(node.Prefix);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(prefix, colonToken);
    }

    public override SyntaxNode VisitXmlAttribute(XmlAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var startQuoteToken = (SyntaxToken)this.Visit(node.StartQuoteToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endQuoteToken = (SyntaxToken)this.Visit(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
    }

    public override SyntaxNode VisitXmlText(XmlTextSyntax node)
    {
      var textTokens = this.VisitList(node.TextTokens);
      return node.Update(textTokens);
    }

    public override SyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      var startCDataToken = (SyntaxToken)this.Visit(node.StartCDataToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endCDataToken = (SyntaxToken)this.Visit(node.EndCDataToken);
      return node.Update(startCDataToken, textTokens, endCDataToken);
    }

    public override SyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      var startProcessingInstructionToken = (SyntaxToken)this.Visit(node.StartProcessingInstructionToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var textTokens = this.VisitList(node.TextTokens);
      var endProcessingInstructionToken = (SyntaxToken)this.Visit(node.EndProcessingInstructionToken);
      return node.Update(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
    }

    public override SyntaxNode VisitXmlComment(XmlCommentSyntax node)
    {
      var lessThanExclamationMinusMinusToken = (SyntaxToken)this.Visit(node.LessThanExclamationMinusMinusToken);
      var textTokens = this.VisitList(node.TextTokens);
      var minusMinusGreaterThanToken = (SyntaxToken)this.Visit(node.MinusMinusGreaterThanToken);
      return node.Update(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
    }

    public override SyntaxNode VisitIfDirective(IfDirectiveSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var ifKeyword = (SyntaxToken)this.Visit(node.IfKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, ifKeyword, condition, endOfDirectiveToken, node.IsActive, node.BranchTaken, node.ConditionValue);
    }

    public override SyntaxNode VisitElifDirective(ElifDirectiveSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var elifKeyword = (SyntaxToken)this.Visit(node.ElifKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, elifKeyword, condition, endOfDirectiveToken, node.IsActive, node.BranchTaken, node.ConditionValue);
    }

    public override SyntaxNode VisitElseDirective(ElseDirectiveSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var elseKeyword = (SyntaxToken)this.Visit(node.ElseKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, elseKeyword, endOfDirectiveToken, node.IsActive, node.BranchTaken);
    }

    public override SyntaxNode VisitEndIfDirective(EndIfDirectiveSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var endIfKeyword = (SyntaxToken)this.Visit(node.EndIfKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, endIfKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitRegionDirective(RegionDirectiveSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var regionKeyword = (SyntaxToken)this.Visit(node.RegionKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, regionKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitEndRegionDirective(EndRegionDirectiveSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var endRegionKeyword = (SyntaxToken)this.Visit(node.EndRegionKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, endRegionKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitErrorDirective(ErrorDirectiveSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var errorKeyword = (SyntaxToken)this.Visit(node.ErrorKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, errorKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitWarningDirective(WarningDirectiveSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var warningKeyword = (SyntaxToken)this.Visit(node.WarningKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, warningKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitBadDirective(BadDirectiveSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, identifier, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitDefineDirective(DefineDirectiveSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var defineKeyword = (SyntaxToken)this.Visit(node.DefineKeyword);
      var name = (SyntaxToken)this.Visit(node.Name);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, defineKeyword, name, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitUndefDirective(UndefDirectiveSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var undefKeyword = (SyntaxToken)this.Visit(node.UndefKeyword);
      var name = (SyntaxToken)this.Visit(node.Name);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, undefKeyword, name, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitLineDirective(LineDirectiveSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var lineKeyword = (SyntaxToken)this.Visit(node.LineKeyword);
      var line = (SyntaxToken)this.Visit(node.Line);
      var file = (SyntaxToken)this.Visit(node.File);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, lineKeyword, line, file, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitPragmaWarningDirective(PragmaWarningDirectiveSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var pragmaKeyword = (SyntaxToken)this.Visit(node.PragmaKeyword);
      var warningKeyword = (SyntaxToken)this.Visit(node.WarningKeyword);
      var disableOrRestoreKeyword = (SyntaxToken)this.Visit(node.DisableOrRestoreKeyword);
      var errorCodes = this.VisitList(node.ErrorCodes);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitPragmaChecksumDirective(PragmaChecksumDirectiveSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var pragmaKeyword = (SyntaxToken)this.Visit(node.PragmaKeyword);
      var checksumKeyword = (SyntaxToken)this.Visit(node.ChecksumKeyword);
      var file = (SyntaxToken)this.Visit(node.File);
      var guid = (SyntaxToken)this.Visit(node.Guid);
      var bytes = (SyntaxToken)this.Visit(node.Bytes);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitReferenceDirective(ReferenceDirectiveSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var referenceKeyword = (SyntaxToken)this.Visit(node.ReferenceKeyword);
      var file = (SyntaxToken)this.Visit(node.File);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, referenceKeyword, file, endOfDirectiveToken, node.IsActive);
    }
  }

  internal static partial class Syntax
  {
    public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.GlobalKeyword:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      return new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier);
    }

    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
#if DEBUG
      if (left == null)
        throw new ArgumentNullException("left");
      if (dotToken == null)
        throw new ArgumentNullException("dotToken");
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      if (right == null)
        throw new ArgumentNullException("right");
#endif

      return new QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right);
    }

    public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (typeArgumentList == null)
        throw new ArgumentNullException("typeArgumentList");
#endif

      return new GenericNameSyntax(SyntaxKind.GenericName, identifier, typeArgumentList);
    }

    public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException("lessThanToken");
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (greaterThanToken == null)
        throw new ArgumentNullException("greaterThanToken");
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      return new TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken);
    }

    public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
#if DEBUG
      if (alias == null)
        throw new ArgumentNullException("alias");
      if (colonColonToken == null)
        throw new ArgumentNullException("colonColonToken");
      switch (colonColonToken.Kind)
      {
        case SyntaxKind.ColonColonToken:
          break;
        default:
          throw new ArgumentException("colonColonToken");
      }
      if (name == null)
        throw new ArgumentNullException("name");
#endif

      return new AliasQualifiedNameSyntax(SyntaxKind.AliasQualifiedName, alias, colonColonToken, name);
    }

    public static PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException("keyword");
      switch (keyword.Kind)
      {
        case SyntaxKind.BoolKeyword:
        case SyntaxKind.ByteKeyword:
        case SyntaxKind.SByteKeyword:
        case SyntaxKind.IntKeyword:
        case SyntaxKind.UIntKeyword:
        case SyntaxKind.ShortKeyword:
        case SyntaxKind.UShortKeyword:
        case SyntaxKind.LongKeyword:
        case SyntaxKind.ULongKeyword:
        case SyntaxKind.FloatKeyword:
        case SyntaxKind.DoubleKeyword:
        case SyntaxKind.DecimalKeyword:
        case SyntaxKind.StringKeyword:
        case SyntaxKind.CharKeyword:
        case SyntaxKind.ObjectKeyword:
        case SyntaxKind.VoidKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
#endif

      return new PredefinedTypeSyntax(SyntaxKind.PredefinedType, keyword);
    }

    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException("elementType");
#endif

      return new ArrayTypeSyntax(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node);
    }

    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException("openBracketToken");
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException("closeBracketToken");
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      return new ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken);
    }

    public static PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException("elementType");
      if (asteriskToken == null)
        throw new ArgumentNullException("asteriskToken");
      switch (asteriskToken.Kind)
      {
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException("asteriskToken");
      }
#endif

      return new PointerTypeSyntax(SyntaxKind.PointerType, elementType, asteriskToken);
    }

    public static NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException("elementType");
      if (questionToken == null)
        throw new ArgumentNullException("questionToken");
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("questionToken");
      }
#endif

      return new NullableTypeSyntax(SyntaxKind.NullableType, elementType, questionToken);
    }

    public static OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)
    {
#if DEBUG
      if (omittedTypeArgumentToken == null)
        throw new ArgumentNullException("omittedTypeArgumentToken");
      switch (omittedTypeArgumentToken.Kind)
      {
        case SyntaxKind.OmittedTypeArgumentToken:
          break;
        default:
          throw new ArgumentException("omittedTypeArgumentToken");
      }
#endif

      return new OmittedTypeArgumentSyntax(SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken);
    }

    public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken);
    }

    public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
    {
      switch (kind)
      {
        case SyntaxKind.PlusExpression:
        case SyntaxKind.NegateExpression:
        case SyntaxKind.BitwiseNotExpression:
        case SyntaxKind.LogicalNotExpression:
        case SyntaxKind.PreIncrementExpression:
        case SyntaxKind.PreDecrementExpression:
        case SyntaxKind.AddressOfExpression:
        case SyntaxKind.PointerIndirectionExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (operatorToken == null)
        throw new ArgumentNullException("operatorToken");
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (operand == null)
        throw new ArgumentNullException("operand");
#endif

      return new PrefixUnaryExpressionSyntax(kind, operatorToken, operand);
    }

    public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
    {
      switch (kind)
      {
        case SyntaxKind.PostIncrementExpression:
        case SyntaxKind.PostDecrementExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (operand == null)
        throw new ArgumentNullException("operand");
      if (operatorToken == null)
        throw new ArgumentNullException("operatorToken");
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
#endif

      return new PostfixUnaryExpressionSyntax(kind, operand, operatorToken);
    }

    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
      switch (kind)
      {
        case SyntaxKind.MemberAccessExpression:
        case SyntaxKind.PointerMemberAccessExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException("expression");
      if (operatorToken == null)
        throw new ArgumentNullException("operatorToken");
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotToken:
        case SyntaxKind.MinusGreaterThanToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (name == null)
        throw new ArgumentNullException("name");
#endif

      return new MemberAccessExpressionSyntax(kind, expression, operatorToken, name);
    }

    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.AddExpression:
        case SyntaxKind.SubtractExpression:
        case SyntaxKind.MultiplyExpression:
        case SyntaxKind.DivideExpression:
        case SyntaxKind.ModuloExpression:
        case SyntaxKind.LeftShiftExpression:
        case SyntaxKind.RightShiftExpression:
        case SyntaxKind.LogicalOrExpression:
        case SyntaxKind.LogicalAndExpression:
        case SyntaxKind.BitwiseOrExpression:
        case SyntaxKind.BitwiseAndExpression:
        case SyntaxKind.ExclusiveOrExpression:
        case SyntaxKind.EqualsExpression:
        case SyntaxKind.NotEqualsExpression:
        case SyntaxKind.LessThanExpression:
        case SyntaxKind.LessThanOrEqualExpression:
        case SyntaxKind.GreaterThanExpression:
        case SyntaxKind.GreaterThanOrEqualExpression:
        case SyntaxKind.IsExpression:
        case SyntaxKind.AsExpression:
        case SyntaxKind.CoalesceExpression:
        case SyntaxKind.AssignExpression:
        case SyntaxKind.AddAssignExpression:
        case SyntaxKind.SubtractAssignExpression:
        case SyntaxKind.MultiplyAssignExpression:
        case SyntaxKind.DivideAssignExpression:
        case SyntaxKind.ModuloAssignExpression:
        case SyntaxKind.AndAssignExpression:
        case SyntaxKind.ExclusiveOrAssignExpression:
        case SyntaxKind.OrAssignExpression:
        case SyntaxKind.LeftShiftAssignExpression:
        case SyntaxKind.RightShiftAssignExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (left == null)
        throw new ArgumentNullException("left");
      if (operatorToken == null)
        throw new ArgumentNullException("operatorToken");
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarBarToken:
        case SyntaxKind.AmpersandAmpersandToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.IsKeyword:
        case SyntaxKind.AsKeyword:
        case SyntaxKind.QuestionQuestionToken:
        case SyntaxKind.EqualsToken:
        case SyntaxKind.PlusEqualsToken:
        case SyntaxKind.MinusEqualsToken:
        case SyntaxKind.AsteriskEqualsToken:
        case SyntaxKind.SlashEqualsToken:
        case SyntaxKind.PercentEqualsToken:
        case SyntaxKind.AmpersandEqualsToken:
        case SyntaxKind.CaretEqualsToken:
        case SyntaxKind.BarEqualsToken:
        case SyntaxKind.LessThanLessThanEqualsToken:
        case SyntaxKind.GreaterThanGreaterThanEqualsToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (right == null)
        throw new ArgumentNullException("right");
#endif

      return new BinaryExpressionSyntax(kind, left, operatorToken, right);
    }

    public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
#if DEBUG
      if (condition == null)
        throw new ArgumentNullException("condition");
      if (questionToken == null)
        throw new ArgumentNullException("questionToken");
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("questionToken");
      }
      if (whenTrue == null)
        throw new ArgumentNullException("whenTrue");
      if (colonToken == null)
        throw new ArgumentNullException("colonToken");
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (whenFalse == null)
        throw new ArgumentNullException("whenFalse");
#endif

      return new ConditionalExpressionSyntax(SyntaxKind.ConditionalExpression, condition, questionToken, whenTrue, colonToken, whenFalse);
    }

    public static ThisExpressionSyntax ThisExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException("token");
      switch (token.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      return new ThisExpressionSyntax(SyntaxKind.ThisExpression, token);
    }

    public static BaseExpressionSyntax BaseExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException("token");
      switch (token.Kind)
      {
        case SyntaxKind.BaseKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      return new BaseExpressionSyntax(SyntaxKind.BaseExpression, token);
    }

    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
    {
      switch (kind)
      {
        case SyntaxKind.ArgListExpression:
        case SyntaxKind.NumericLiteralExpression:
        case SyntaxKind.StringLiteralExpression:
        case SyntaxKind.CharacterLiteralExpression:
        case SyntaxKind.TrueLiteralExpression:
        case SyntaxKind.FalseLiteralExpression:
        case SyntaxKind.NullLiteralExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (token == null)
        throw new ArgumentNullException("token");
      switch (token.Kind)
      {
        case SyntaxKind.ArgListKeyword:
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.CharacterLiteralToken:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.NullKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      return new LiteralExpressionSyntax(kind, token);
    }

    public static MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException("keyword");
      switch (keyword.Kind)
      {
        case SyntaxKind.MakeRefKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new MakeRefExpressionSyntax(SyntaxKind.MakeRefExpression, keyword, openParenToken, expression, closeParenToken);
    }

    public static RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException("keyword");
      switch (keyword.Kind)
      {
        case SyntaxKind.RefTypeKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new RefTypeExpressionSyntax(SyntaxKind.RefTypeExpression, keyword, openParenToken, expression, closeParenToken);
    }

    public static RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException("keyword");
      switch (keyword.Kind)
      {
        case SyntaxKind.RefValueKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      if (comma == null)
        throw new ArgumentNullException("comma");
      switch (comma.Kind)
      {
        case SyntaxKind.CommaToken:
          break;
        default:
          throw new ArgumentException("comma");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new RefValueExpressionSyntax(SyntaxKind.RefValueExpression, keyword, openParenToken, expression, comma, type, closeParenToken);
    }

    public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedExpression:
        case SyntaxKind.UncheckedExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException("keyword");
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new CheckedExpressionSyntax(kind, keyword, openParenToken, expression, closeParenToken);
    }

    public static DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException("keyword");
      switch (keyword.Kind)
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new DefaultExpressionSyntax(SyntaxKind.DefaultExpression, keyword, openParenToken, type, closeParenToken);
    }

    public static TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException("keyword");
      switch (keyword.Kind)
      {
        case SyntaxKind.TypeOfKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new TypeOfExpressionSyntax(SyntaxKind.TypeOfExpression, keyword, openParenToken, type, closeParenToken);
    }

    public static SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException("keyword");
      switch (keyword.Kind)
      {
        case SyntaxKind.SizeOfKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new SizeOfExpressionSyntax(SyntaxKind.SizeOfExpression, keyword, openParenToken, type, closeParenToken);
    }

    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException("expression");
      if (argumentList == null)
        throw new ArgumentNullException("argumentList");
#endif

      return new InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, argumentList);
    }

    public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException("expression");
      if (argumentList == null)
        throw new ArgumentNullException("argumentList");
#endif

      return new ElementAccessExpressionSyntax(SyntaxKind.ElementAccessExpression, expression, argumentList);
    }

    public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken);
    }

    public static BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException("openBracketToken");
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException("closeBracketToken");
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      return new BracketedArgumentListSyntax(SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken);
    }

    public static ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (refOrOutKeyword != null)
      {
      switch (refOrOutKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refOrOutKeyword");
      }
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
#endif

      return new ArgumentSyntax(SyntaxKind.Argument, nameColon, refOrOutKeyword, expression);
    }

    public static NameColonSyntax NameColon(IdentifierNameSyntax identifier, SyntaxToken colonToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      if (colonToken == null)
        throw new ArgumentNullException("colonToken");
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      return new NameColonSyntax(SyntaxKind.NameColon, identifier, colonToken);
    }

    public static CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
#endif

      return new CastExpressionSyntax(SyntaxKind.CastExpression, openParenToken, type, closeParenToken, expression);
    }

    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken delegateKeyword, ParameterListSyntax parameterList, BlockSyntax block)
    {
#if DEBUG
      if (delegateKeyword == null)
        throw new ArgumentNullException("delegateKeyword");
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException("delegateKeyword");
      }
      if (block == null)
        throw new ArgumentNullException("block");
#endif

      return new AnonymousMethodExpressionSyntax(SyntaxKind.AnonymousMethodExpression, delegateKeyword, parameterList, block);
    }

    public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(ParameterSyntax parameter, SyntaxToken arrowToken, SyntaxNode body)
    {
#if DEBUG
      if (parameter == null)
        throw new ArgumentNullException("parameter");
      if (arrowToken == null)
        throw new ArgumentNullException("arrowToken");
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (body == null)
        throw new ArgumentNullException("body");
#endif

      return new SimpleLambdaExpressionSyntax(SyntaxKind.SimpleLambdaExpression, parameter, arrowToken, body);
    }

    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(ParameterListSyntax parameterList, SyntaxToken arrowToken, SyntaxNode body)
    {
#if DEBUG
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      if (arrowToken == null)
        throw new ArgumentNullException("arrowToken");
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (body == null)
        throw new ArgumentNullException("body");
#endif

      return new ParenthesizedLambdaExpressionSyntax(SyntaxKind.ParenthesizedLambdaExpression, parameterList, arrowToken, body);
    }

    public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
      switch (kind)
      {
        case SyntaxKind.ObjectInitializerExpression:
        case SyntaxKind.CollectionInitializerExpression:
        case SyntaxKind.ArrayInitializerExpression:
        case SyntaxKind.ComplexElementInitializerExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException("openBraceToken");
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException("closeBraceToken");
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new InitializerExpressionSyntax(kind, openBraceToken, expressions.Node, closeBraceToken);
    }

    public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException("newKeyword");
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (type == null)
        throw new ArgumentNullException("type");
#endif

      return new ObjectCreationExpressionSyntax(SyntaxKind.ObjectCreationExpression, newKeyword, type, argumentList, initializer);
    }

    public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException("expression");
#endif

      return new AnonymousObjectMemberDeclaratorSyntax(SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression);
    }

    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException("newKeyword");
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException("openBraceToken");
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException("closeBraceToken");
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new AnonymousObjectCreationExpressionSyntax(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, openBraceToken, initializers.Node, closeBraceToken);
    }

    public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException("newKeyword");
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (type == null)
        throw new ArgumentNullException("type");
#endif

      return new ArrayCreationExpressionSyntax(SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer);
    }

    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException("newKeyword");
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (openBracketToken == null)
        throw new ArgumentNullException("openBracketToken");
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException("closeBracketToken");
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      if (initializer == null)
        throw new ArgumentNullException("initializer");
#endif

      return new ImplicitArrayCreationExpressionSyntax(SyntaxKind.ImplicitArrayCreationExpression, newKeyword, openBracketToken, commas.Node, closeBracketToken, initializer);
    }

    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type)
    {
#if DEBUG
      if (stackAllocKeyword == null)
        throw new ArgumentNullException("stackAllocKeyword");
      switch (stackAllocKeyword.Kind)
      {
        case SyntaxKind.StackAllocKeyword:
          break;
        default:
          throw new ArgumentException("stackAllocKeyword");
      }
      if (type == null)
        throw new ArgumentNullException("type");
#endif

      return new StackAllocArrayCreationExpressionSyntax(SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type);
    }

    public static QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
#if DEBUG
      if (fromClause == null)
        throw new ArgumentNullException("fromClause");
      if (body == null)
        throw new ArgumentNullException("body");
#endif

      return new QueryExpressionSyntax(SyntaxKind.QueryExpression, fromClause, body);
    }

    public static QueryBodySyntax QueryBody(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
#if DEBUG
      if (selectOrGroup == null)
        throw new ArgumentNullException("selectOrGroup");
#endif

      return new QueryBodySyntax(SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation);
    }

    public static FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (fromKeyword == null)
        throw new ArgumentNullException("fromKeyword");
      switch (fromKeyword.Kind)
      {
        case SyntaxKind.FromKeyword:
          break;
        default:
          throw new ArgumentException("fromKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (inKeyword == null)
        throw new ArgumentNullException("inKeyword");
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
#endif

      return new FromClauseSyntax(SyntaxKind.FromClause, fromKeyword, type, identifier, inKeyword, expression);
    }

    public static LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (letKeyword == null)
        throw new ArgumentNullException("letKeyword");
      switch (letKeyword.Kind)
      {
        case SyntaxKind.LetKeyword:
          break;
        default:
          throw new ArgumentException("letKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (equalsToken == null)
        throw new ArgumentNullException("equalsToken");
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
#endif

      return new LetClauseSyntax(SyntaxKind.LetClause, letKeyword, identifier, equalsToken, expression);
    }

    public static JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
#if DEBUG
      if (joinKeyword == null)
        throw new ArgumentNullException("joinKeyword");
      switch (joinKeyword.Kind)
      {
        case SyntaxKind.JoinKeyword:
          break;
        default:
          throw new ArgumentException("joinKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (inKeyword == null)
        throw new ArgumentNullException("inKeyword");
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (inExpression == null)
        throw new ArgumentNullException("inExpression");
      if (onKeyword == null)
        throw new ArgumentNullException("onKeyword");
      switch (onKeyword.Kind)
      {
        case SyntaxKind.OnKeyword:
          break;
        default:
          throw new ArgumentException("onKeyword");
      }
      if (leftExpression == null)
        throw new ArgumentNullException("leftExpression");
      if (equalsKeyword == null)
        throw new ArgumentNullException("equalsKeyword");
      switch (equalsKeyword.Kind)
      {
        case SyntaxKind.EqualsKeyword:
          break;
        default:
          throw new ArgumentException("equalsKeyword");
      }
      if (rightExpression == null)
        throw new ArgumentNullException("rightExpression");
#endif

      return new JoinClauseSyntax(SyntaxKind.JoinClause, joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
    }

    public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
#if DEBUG
      if (intoKeyword == null)
        throw new ArgumentNullException("intoKeyword");
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException("intoKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      return new JoinIntoClauseSyntax(SyntaxKind.JoinIntoClause, intoKeyword, identifier);
    }

    public static WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
#if DEBUG
      if (whereKeyword == null)
        throw new ArgumentNullException("whereKeyword");
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException("whereKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException("condition");
#endif

      return new WhereClauseSyntax(SyntaxKind.WhereClause, whereKeyword, condition);
    }

    public static OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings)
    {
#if DEBUG
      if (orderByKeyword == null)
        throw new ArgumentNullException("orderByKeyword");
      switch (orderByKeyword.Kind)
      {
        case SyntaxKind.OrderByKeyword:
          break;
        default:
          throw new ArgumentException("orderByKeyword");
      }
#endif

      return new OrderByClauseSyntax(SyntaxKind.OrderByClause, orderByKeyword, orderings.Node);
    }

    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.AscendingOrdering:
        case SyntaxKind.DescendingOrdering:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException("expression");
      if (ascendingOrDescendingKeyword != null)
      {
      switch (ascendingOrDescendingKeyword.Kind)
      {
        case SyntaxKind.AscendingKeyword:
        case SyntaxKind.DescendingKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("ascendingOrDescendingKeyword");
      }
      }
#endif

      return new OrderingSyntax(kind, expression, ascendingOrDescendingKeyword);
    }

    public static SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (selectKeyword == null)
        throw new ArgumentNullException("selectKeyword");
      switch (selectKeyword.Kind)
      {
        case SyntaxKind.SelectKeyword:
          break;
        default:
          throw new ArgumentException("selectKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
#endif

      return new SelectClauseSyntax(SyntaxKind.SelectClause, selectKeyword, expression);
    }

    public static GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
#if DEBUG
      if (groupKeyword == null)
        throw new ArgumentNullException("groupKeyword");
      switch (groupKeyword.Kind)
      {
        case SyntaxKind.GroupKeyword:
          break;
        default:
          throw new ArgumentException("groupKeyword");
      }
      if (groupExpression == null)
        throw new ArgumentNullException("groupExpression");
      if (byKeyword == null)
        throw new ArgumentNullException("byKeyword");
      switch (byKeyword.Kind)
      {
        case SyntaxKind.ByKeyword:
          break;
        default:
          throw new ArgumentException("byKeyword");
      }
      if (byExpression == null)
        throw new ArgumentNullException("byExpression");
#endif

      return new GroupClauseSyntax(SyntaxKind.GroupClause, groupKeyword, groupExpression, byKeyword, byExpression);
    }

    public static QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
#if DEBUG
      if (intoKeyword == null)
        throw new ArgumentNullException("intoKeyword");
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException("intoKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (body == null)
        throw new ArgumentNullException("body");
#endif

      return new QueryContinuationSyntax(SyntaxKind.QueryContinuation, intoKeyword, identifier, body);
    }

    public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)
    {
#if DEBUG
      if (omittedArraySizeExpressionToken == null)
        throw new ArgumentNullException("omittedArraySizeExpressionToken");
      switch (omittedArraySizeExpressionToken.Kind)
      {
        case SyntaxKind.OmittedArraySizeExpressionToken:
          break;
        default:
          throw new ArgumentException("omittedArraySizeExpressionToken");
      }
#endif

      return new OmittedArraySizeExpressionSyntax(SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken);
    }

    public static GlobalStatementSyntax GlobalStatement(StatementSyntax statement)
    {
#if DEBUG
      if (statement == null)
        throw new ArgumentNullException("statement");
#endif

      return new GlobalStatementSyntax(SyntaxKind.GlobalStatement, statement);
    }

    public static BlockSyntax Block(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException("openBraceToken");
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException("closeBraceToken");
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new BlockSyntax(SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken);
    }

    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (declaration == null)
        throw new ArgumentNullException("declaration");
      if (semicolonToken == null)
        throw new ArgumentNullException("semicolonToken");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new LocalDeclarationStatementSyntax(SyntaxKind.LocalDeclarationStatement, modifiers.Node, declaration, semicolonToken);
    }

    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException("type");
#endif

      return new VariableDeclarationSyntax(SyntaxKind.VariableDeclaration, type, variables.Node);
    }

    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      return new VariableDeclaratorSyntax(SyntaxKind.VariableDeclarator, identifier, argumentList, initializer);
    }

    public static EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value)
    {
#if DEBUG
      if (equalsToken == null)
        throw new ArgumentNullException("equalsToken");
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (value == null)
        throw new ArgumentNullException("value");
#endif

      return new EqualsValueClauseSyntax(SyntaxKind.EqualsValueClause, equalsToken, value);
    }

    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException("expression");
      if (semicolonToken == null)
        throw new ArgumentNullException("semicolonToken");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, expression, semicolonToken);
    }

    public static EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)
    {
#if DEBUG
      if (semicolonToken == null)
        throw new ArgumentNullException("semicolonToken");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new EmptyStatementSyntax(SyntaxKind.EmptyStatement, semicolonToken);
    }

    public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (colonToken == null)
        throw new ArgumentNullException("colonToken");
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
#endif

      return new LabeledStatementSyntax(SyntaxKind.LabeledStatement, identifier, colonToken, statement);
    }

    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GotoStatement:
        case SyntaxKind.GotoCaseStatement:
        case SyntaxKind.GotoDefaultStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (gotoKeyword == null)
        throw new ArgumentNullException("gotoKeyword");
      switch (gotoKeyword.Kind)
      {
        case SyntaxKind.GotoKeyword:
          break;
        default:
          throw new ArgumentException("gotoKeyword");
      }
      if (caseOrDefaultKeyword != null)
      {
      switch (caseOrDefaultKeyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("caseOrDefaultKeyword");
      }
      }
      if (semicolonToken == null)
        throw new ArgumentNullException("semicolonToken");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new GotoStatementSyntax(kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
    }

    public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (breakKeyword == null)
        throw new ArgumentNullException("breakKeyword");
      switch (breakKeyword.Kind)
      {
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException("breakKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException("semicolonToken");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new BreakStatementSyntax(SyntaxKind.BreakStatement, breakKeyword, semicolonToken);
    }

    public static ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (continueKeyword == null)
        throw new ArgumentNullException("continueKeyword");
      switch (continueKeyword.Kind)
      {
        case SyntaxKind.ContinueKeyword:
          break;
        default:
          throw new ArgumentException("continueKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException("semicolonToken");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new ContinueStatementSyntax(SyntaxKind.ContinueStatement, continueKeyword, semicolonToken);
    }

    public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnKeyword == null)
        throw new ArgumentNullException("returnKeyword");
      switch (returnKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
          break;
        default:
          throw new ArgumentException("returnKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException("semicolonToken");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new ReturnStatementSyntax(SyntaxKind.ReturnStatement, returnKeyword, expression, semicolonToken);
    }

    public static ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (throwKeyword == null)
        throw new ArgumentNullException("throwKeyword");
      switch (throwKeyword.Kind)
      {
        case SyntaxKind.ThrowKeyword:
          break;
        default:
          throw new ArgumentException("throwKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException("semicolonToken");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new ThrowStatementSyntax(SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken);
    }

    public static YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.YieldReturnStatement:
        case SyntaxKind.YieldBreakStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (yieldKeyword == null)
        throw new ArgumentNullException("yieldKeyword");
      switch (yieldKeyword.Kind)
      {
        case SyntaxKind.YieldKeyword:
          break;
        default:
          throw new ArgumentException("yieldKeyword");
      }
      if (returnOrBreakKeyword == null)
        throw new ArgumentNullException("returnOrBreakKeyword");
      switch (returnOrBreakKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException("returnOrBreakKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException("semicolonToken");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new YieldStatementSyntax(kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
    }

    public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (whileKeyword == null)
        throw new ArgumentNullException("whileKeyword");
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException("whileKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException("condition");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
#endif

      return new WhileStatementSyntax(SyntaxKind.WhileStatement, whileKeyword, openParenToken, condition, closeParenToken, statement);
    }

    public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (doKeyword == null)
        throw new ArgumentNullException("doKeyword");
      switch (doKeyword.Kind)
      {
        case SyntaxKind.DoKeyword:
          break;
        default:
          throw new ArgumentException("doKeyword");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
      if (whileKeyword == null)
        throw new ArgumentNullException("whileKeyword");
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException("whileKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException("condition");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException("semicolonToken");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new DoStatementSyntax(SyntaxKind.DoStatement, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
    }

    public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (forKeyword == null)
        throw new ArgumentNullException("forKeyword");
      switch (forKeyword.Kind)
      {
        case SyntaxKind.ForKeyword:
          break;
        default:
          throw new ArgumentException("forKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (firstSemicolonToken == null)
        throw new ArgumentNullException("firstSemicolonToken");
      switch (firstSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("firstSemicolonToken");
      }
      if (secondSemicolonToken == null)
        throw new ArgumentNullException("secondSemicolonToken");
      switch (secondSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("secondSemicolonToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
#endif

      return new ForStatementSyntax(SyntaxKind.ForStatement, forKeyword, openParenToken, declaration, initializers.Node, firstSemicolonToken, condition, secondSemicolonToken, incrementors.Node, closeParenToken, statement);
    }

    public static ForEachStatementSyntax ForEachStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (forEachKeyword == null)
        throw new ArgumentNullException("forEachKeyword");
      switch (forEachKeyword.Kind)
      {
        case SyntaxKind.ForEachKeyword:
          break;
        default:
          throw new ArgumentException("forEachKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (inKeyword == null)
        throw new ArgumentNullException("inKeyword");
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
#endif

      return new ForEachStatementSyntax(SyntaxKind.ForEachStatement, forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
    }

    public static UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (usingKeyword == null)
        throw new ArgumentNullException("usingKeyword");
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException("usingKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
#endif

      return new UsingStatementSyntax(SyntaxKind.UsingStatement, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
    }

    public static FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (fixedKeyword == null)
        throw new ArgumentNullException("fixedKeyword");
      switch (fixedKeyword.Kind)
      {
        case SyntaxKind.FixedKeyword:
          break;
        default:
          throw new ArgumentException("fixedKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (declaration == null)
        throw new ArgumentNullException("declaration");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
#endif

      return new FixedStatementSyntax(SyntaxKind.FixedStatement, fixedKeyword, openParenToken, declaration, closeParenToken, statement);
    }

    public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedStatement:
        case SyntaxKind.UncheckedStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException("keyword");
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (block == null)
        throw new ArgumentNullException("block");
#endif

      return new CheckedStatementSyntax(kind, keyword, block);
    }

    public static UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
#if DEBUG
      if (unsafeKeyword == null)
        throw new ArgumentNullException("unsafeKeyword");
      switch (unsafeKeyword.Kind)
      {
        case SyntaxKind.UnsafeKeyword:
          break;
        default:
          throw new ArgumentException("unsafeKeyword");
      }
      if (block == null)
        throw new ArgumentNullException("block");
#endif

      return new UnsafeStatementSyntax(SyntaxKind.UnsafeStatement, unsafeKeyword, block);
    }

    public static LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (lockKeyword == null)
        throw new ArgumentNullException("lockKeyword");
      switch (lockKeyword.Kind)
      {
        case SyntaxKind.LockKeyword:
          break;
        default:
          throw new ArgumentException("lockKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
#endif

      return new LockStatementSyntax(SyntaxKind.LockStatement, lockKeyword, openParenToken, expression, closeParenToken, statement);
    }

    public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
#if DEBUG
      if (ifKeyword == null)
        throw new ArgumentNullException("ifKeyword");
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException("ifKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException("condition");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
#endif

      return new IfStatementSyntax(SyntaxKind.IfStatement, ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
    }

    public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)
    {
#if DEBUG
      if (elseKeyword == null)
        throw new ArgumentNullException("elseKeyword");
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException("elseKeyword");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
#endif

      return new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, statement);
    }

    public static SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (switchKeyword == null)
        throw new ArgumentNullException("switchKeyword");
      switch (switchKeyword.Kind)
      {
        case SyntaxKind.SwitchKeyword:
          break;
        default:
          throw new ArgumentException("switchKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException("openBraceToken");
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException("closeBraceToken");
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new SwitchStatementSyntax(SyntaxKind.SwitchStatement, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections.Node, closeBraceToken);
    }

    public static SwitchSectionSyntax SwitchSection(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements)
    {
#if DEBUG
#endif

      return new SwitchSectionSyntax(SyntaxKind.SwitchSection, labels.Node, statements.Node);
    }

    public static SwitchLabelSyntax SwitchLabel(SyntaxKind kind, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
      switch (kind)
      {
        case SyntaxKind.CaseSwitchLabel:
        case SyntaxKind.DefaultSwitchLabel:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (caseOrDefaultKeyword == null)
        throw new ArgumentNullException("caseOrDefaultKeyword");
      switch (caseOrDefaultKeyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("caseOrDefaultKeyword");
      }
      if (colonToken == null)
        throw new ArgumentNullException("colonToken");
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      return new SwitchLabelSyntax(kind, caseOrDefaultKeyword, value, colonToken);
    }

    public static TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
#if DEBUG
      if (tryKeyword == null)
        throw new ArgumentNullException("tryKeyword");
      switch (tryKeyword.Kind)
      {
        case SyntaxKind.TryKeyword:
          break;
        default:
          throw new ArgumentException("tryKeyword");
      }
      if (block == null)
        throw new ArgumentNullException("block");
#endif

      return new TryStatementSyntax(SyntaxKind.TryStatement, tryKeyword, block, catches.Node, @finally);
    }

    public static CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, BlockSyntax block)
    {
#if DEBUG
      if (catchKeyword == null)
        throw new ArgumentNullException("catchKeyword");
      switch (catchKeyword.Kind)
      {
        case SyntaxKind.CatchKeyword:
          break;
        default:
          throw new ArgumentException("catchKeyword");
      }
      if (block == null)
        throw new ArgumentNullException("block");
#endif

      return new CatchClauseSyntax(SyntaxKind.CatchClause, catchKeyword, declaration, block);
    }

    public static CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      if (identifier != null)
      {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      }
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new CatchDeclarationSyntax(SyntaxKind.CatchDeclaration, openParenToken, type, identifier, closeParenToken);
    }

    public static FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)
    {
#if DEBUG
      if (finallyKeyword == null)
        throw new ArgumentNullException("finallyKeyword");
      switch (finallyKeyword.Kind)
      {
        case SyntaxKind.FinallyKeyword:
          break;
        default:
          throw new ArgumentException("finallyKeyword");
      }
      if (block == null)
        throw new ArgumentNullException("block");
#endif

      return new FinallyClauseSyntax(SyntaxKind.FinallyClause, finallyKeyword, block);
    }

    public static CompilationUnitSyntax CompilationUnit(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
#if DEBUG
      if (endOfFileToken == null)
        throw new ArgumentNullException("endOfFileToken");
      switch (endOfFileToken.Kind)
      {
        case SyntaxKind.EndOfFileToken:
          break;
        default:
          throw new ArgumentException("endOfFileToken");
      }
#endif

      return new CompilationUnitSyntax(SyntaxKind.CompilationUnit, externs.Node, usings.Node, attributes.Node, members.Node, endOfFileToken);
    }

    public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (externKeyword == null)
        throw new ArgumentNullException("externKeyword");
      switch (externKeyword.Kind)
      {
        case SyntaxKind.ExternKeyword:
          break;
        default:
          throw new ArgumentException("externKeyword");
      }
      if (aliasKeyword == null)
        throw new ArgumentNullException("aliasKeyword");
      switch (aliasKeyword.Kind)
      {
        case SyntaxKind.AliasKeyword:
          break;
        default:
          throw new ArgumentException("aliasKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException("semicolonToken");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new ExternAliasDirectiveSyntax(SyntaxKind.ExternAliasDirective, externKeyword, aliasKeyword, identifier, semicolonToken);
    }

    public static UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (usingKeyword == null)
        throw new ArgumentNullException("usingKeyword");
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException("usingKeyword");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      if (semicolonToken == null)
        throw new ArgumentNullException("semicolonToken");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new UsingDirectiveSyntax(SyntaxKind.UsingDirective, usingKeyword, alias, name, semicolonToken);
    }

    public static NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (namespaceKeyword == null)
        throw new ArgumentNullException("namespaceKeyword");
      switch (namespaceKeyword.Kind)
      {
        case SyntaxKind.NamespaceKeyword:
          break;
        default:
          throw new ArgumentException("namespaceKeyword");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      if (openBraceToken == null)
        throw new ArgumentNullException("openBraceToken");
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException("closeBraceToken");
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new NamespaceDeclarationSyntax(SyntaxKind.NamespaceDeclaration, namespaceKeyword, name, openBraceToken, externs.Node, usings.Node, members.Node, closeBraceToken, semicolonToken);
    }

    public static AttributeDeclarationSyntax AttributeDeclaration(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException("openBracketToken");
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException("closeBracketToken");
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      return new AttributeDeclarationSyntax(SyntaxKind.AttributeDeclaration, openBracketToken, target, attributes.Node, closeBracketToken);
    }

    public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      if (colonToken == null)
        throw new ArgumentNullException("colonToken");
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      return new AttributeTargetSpecifierSyntax(SyntaxKind.AttributeTargetSpecifier, identifier, colonToken);
    }

    public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException("name");
#endif

      return new AttributeSyntax(SyntaxKind.Attribute, name, argumentList);
    }

    public static AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new AttributeArgumentListSyntax(SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken);
    }

    public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException("expression");
#endif

      return new AttributeArgumentSyntax(SyntaxKind.AttributeArgument, nameEquals, nameColon, expression);
    }

    public static NameEqualsSyntax NameEquals(IdentifierNameSyntax identifier, SyntaxToken equalsToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      if (equalsToken == null)
        throw new ArgumentNullException("equalsToken");
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
#endif

      return new NameEqualsSyntax(SyntaxKind.NameEquals, identifier, equalsToken);
    }

    public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException("lessThanToken");
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (greaterThanToken == null)
        throw new ArgumentNullException("greaterThanToken");
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      return new TypeParameterListSyntax(SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken);
    }

    public static TypeParameterSyntax TypeParameter(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
#if DEBUG
      if (varianceKeyword != null)
      {
      switch (varianceKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("varianceKeyword");
      }
      }
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      return new TypeParameterSyntax(SyntaxKind.TypeParameter, attributes.Node, varianceKeyword, identifier);
    }

    public static ClassDeclarationSyntax ClassDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException("keyword");
      switch (keyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException("openBraceToken");
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException("closeBraceToken");
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new ClassDeclarationSyntax(SyntaxKind.ClassDeclaration, attributes.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static StructDeclarationSyntax StructDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException("keyword");
      switch (keyword.Kind)
      {
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException("openBraceToken");
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException("closeBraceToken");
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new StructDeclarationSyntax(SyntaxKind.StructDeclaration, attributes.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException("keyword");
      switch (keyword.Kind)
      {
        case SyntaxKind.InterfaceKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException("openBraceToken");
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException("closeBraceToken");
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new InterfaceDeclarationSyntax(SyntaxKind.InterfaceDeclaration, attributes.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static EnumDeclarationSyntax EnumDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (enumKeyword == null)
        throw new ArgumentNullException("enumKeyword");
      switch (enumKeyword.Kind)
      {
        case SyntaxKind.EnumKeyword:
          break;
        default:
          throw new ArgumentException("enumKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException("openBraceToken");
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException("closeBraceToken");
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new EnumDeclarationSyntax(SyntaxKind.EnumDeclaration, attributes.Node, modifiers.Node, enumKeyword, identifier, baseList, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (delegateKeyword == null)
        throw new ArgumentNullException("delegateKeyword");
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException("delegateKeyword");
      }
      if (returnType == null)
        throw new ArgumentNullException("returnType");
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      if (semicolonToken == null)
        throw new ArgumentNullException("semicolonToken");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new DelegateDeclarationSyntax(SyntaxKind.DelegateDeclaration, attributes.Node, modifiers.Node, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, semicolonToken);
    }

    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      return new EnumMemberDeclarationSyntax(SyntaxKind.EnumMemberDeclaration, attributes.Node, identifier, equalsValue);
    }

    public static BaseListSyntax BaseList(SyntaxToken colonToken, SeparatedSyntaxList<TypeSyntax> types)
    {
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException("colonToken");
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      return new BaseListSyntax(SyntaxKind.BaseList, colonToken, types.Node);
    }

    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax identifier, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
#if DEBUG
      if (whereKeyword == null)
        throw new ArgumentNullException("whereKeyword");
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException("whereKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      if (colonToken == null)
        throw new ArgumentNullException("colonToken");
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      return new TypeParameterConstraintClauseSyntax(SyntaxKind.TypeParameterConstraintClause, whereKeyword, identifier, colonToken, constraints.Node);
    }

    public static ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException("newKeyword");
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new ConstructorConstraintSyntax(SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken);
    }

    public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.ClassConstraint:
        case SyntaxKind.StructConstraint:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (classOrStructKeyword == null)
        throw new ArgumentNullException("classOrStructKeyword");
      switch (classOrStructKeyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException("classOrStructKeyword");
      }
#endif

      return new ClassOrStructConstraintSyntax(kind, classOrStructKeyword);
    }

    public static TypeConstraintSyntax TypeConstraint(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException("type");
#endif

      return new TypeConstraintSyntax(SyntaxKind.TypeConstraint, type);
    }

    public static FieldDeclarationSyntax FieldDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (declaration == null)
        throw new ArgumentNullException("declaration");
      if (semicolonToken == null)
        throw new ArgumentNullException("semicolonToken");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new FieldDeclarationSyntax(SyntaxKind.FieldDeclaration, attributes.Node, modifiers.Node, declaration, semicolonToken);
    }

    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (eventKeyword == null)
        throw new ArgumentNullException("eventKeyword");
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException("eventKeyword");
      }
      if (declaration == null)
        throw new ArgumentNullException("declaration");
      if (semicolonToken == null)
        throw new ArgumentNullException("semicolonToken");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new EventFieldDeclarationSyntax(SyntaxKind.EventFieldDeclaration, attributes.Node, modifiers.Node, eventKeyword, declaration, semicolonToken);
    }

    public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException("name");
      if (dotToken == null)
        throw new ArgumentNullException("dotToken");
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
#endif

      return new ExplicitInterfaceSpecifierSyntax(SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken);
    }

    public static MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException("returnType");
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new MethodDeclarationSyntax(SyntaxKind.MethodDeclaration, attributes.Node, modifiers.Node, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses.Node, body, semicolonToken);
    }

    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException("returnType");
      if (operatorKeyword == null)
        throw new ArgumentNullException("operatorKeyword");
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (operatorToken == null)
        throw new ArgumentNullException("operatorToken");
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new OperatorDeclarationSyntax(SyntaxKind.OperatorDeclaration, attributes.Node, modifiers.Node, returnType, operatorKeyword, operatorToken, parameterList, body, semicolonToken);
    }

    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (implicitOrExplicitKeyword == null)
        throw new ArgumentNullException("implicitOrExplicitKeyword");
      switch (implicitOrExplicitKeyword.Kind)
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException("implicitOrExplicitKeyword");
      }
      if (operatorKeyword == null)
        throw new ArgumentNullException("operatorKeyword");
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new ConversionOperatorDeclarationSyntax(SyntaxKind.ConversionOperatorDeclaration, attributes.Node, modifiers.Node, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, semicolonToken);
    }

    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new ConstructorDeclarationSyntax(SyntaxKind.ConstructorDeclaration, attributes.Node, modifiers.Node, identifier, parameterList, initializer, body, semicolonToken);
    }

    public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
      switch (kind)
      {
        case SyntaxKind.BaseConstructorInitializer:
        case SyntaxKind.ThisConstructorInitializer:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException("colonToken");
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (thisOrBaseKeyword == null)
        throw new ArgumentNullException("thisOrBaseKeyword");
      switch (thisOrBaseKeyword.Kind)
      {
        case SyntaxKind.BaseKeyword:
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisOrBaseKeyword");
      }
      if (argumentList == null)
        throw new ArgumentNullException("argumentList");
#endif

      return new ConstructorInitializerSyntax(kind, colonToken, thisOrBaseKeyword, argumentList);
    }

    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (tildeToken == null)
        throw new ArgumentNullException("tildeToken");
      switch (tildeToken.Kind)
      {
        case SyntaxKind.TildeToken:
          break;
        default:
          throw new ArgumentException("tildeToken");
      }
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new DestructorDeclarationSyntax(SyntaxKind.DestructorDeclaration, attributes.Node, modifiers.Node, tildeToken, identifier, parameterList, body, semicolonToken);
    }

    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException("type");
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (accessorList == null)
        throw new ArgumentNullException("accessorList");
#endif

      return new PropertyDeclarationSyntax(SyntaxKind.PropertyDeclaration, attributes.Node, modifiers.Node, type, explicitInterfaceSpecifier, identifier, accessorList);
    }

    public static EventDeclarationSyntax EventDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
#if DEBUG
      if (eventKeyword == null)
        throw new ArgumentNullException("eventKeyword");
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException("eventKeyword");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (accessorList == null)
        throw new ArgumentNullException("accessorList");
#endif

      return new EventDeclarationSyntax(SyntaxKind.EventDeclaration, attributes.Node, modifiers.Node, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList);
    }

    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException("type");
      if (thisKeyword == null)
        throw new ArgumentNullException("thisKeyword");
      switch (thisKeyword.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisKeyword");
      }
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      if (accessorList == null)
        throw new ArgumentNullException("accessorList");
#endif

      return new IndexerDeclarationSyntax(SyntaxKind.IndexerDeclaration, attributes.Node, modifiers.Node, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList);
    }

    public static AccessorListSyntax AccessorList(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException("openBraceToken");
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException("closeBraceToken");
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new AccessorListSyntax(SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken);
    }

    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GetAccessorDeclaration:
        case SyntaxKind.SetAccessorDeclaration:
        case SyntaxKind.AddAccessorDeclaration:
        case SyntaxKind.RemoveAccessorDeclaration:
        case SyntaxKind.UnknownAccessorDeclaration:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException("keyword");
      switch (keyword.Kind)
      {
        case SyntaxKind.GetKeyword:
        case SyntaxKind.SetKeyword:
        case SyntaxKind.AddKeyword:
        case SyntaxKind.RemoveKeyword:
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new AccessorDeclarationSyntax(kind, attributes.Node, modifiers.Node, keyword, body, semicolonToken);
    }

    public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException("openParenToken");
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException("closeParenToken");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken);
    }

    public static BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException("openBracketToken");
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException("closeBracketToken");
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      return new BracketedParameterListSyntax(SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken);
    }

    public static ParameterSyntax Parameter(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.ArgListKeyword:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      return new ParameterSyntax(SyntaxKind.Parameter, attributes.Node, modifiers.Node, type, identifier, @default);
    }

    public static IncompleteMemberSyntax IncompleteMember(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<SyntaxToken> modifiers, TypeSyntax type)
    {
#if DEBUG
#endif

      return new IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributes.Node, modifiers.Node, type);
    }

    public static SkippedTokensSyntax SkippedTokens(SyntaxList<SyntaxToken> tokens)
    {
#if DEBUG
#endif

      return new SkippedTokensSyntax(SyntaxKind.SkippedTokens, tokens.Node);
    }

    public static DocumentationCommentSyntax DocumentationComment(SyntaxList<XmlNodeSyntax> nodes, SyntaxToken endOfComment)
    {
#if DEBUG
      if (endOfComment == null)
        throw new ArgumentNullException("endOfComment");
      switch (endOfComment.Kind)
      {
        case SyntaxKind.EndOfDocumentationCommentToken:
          break;
        default:
          throw new ArgumentException("endOfComment");
      }
#endif

      return new DocumentationCommentSyntax(SyntaxKind.DocumentationComment, nodes.Node, endOfComment);
    }

    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
#if DEBUG
      if (startTag == null)
        throw new ArgumentNullException("startTag");
      if (endTag == null)
        throw new ArgumentNullException("endTag");
#endif

      return new XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag);
    }

    public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException("lessThanToken");
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      if (greaterThanToken == null)
        throw new ArgumentNullException("greaterThanToken");
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      return new XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken);
    }

    public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanSlashToken == null)
        throw new ArgumentNullException("lessThanSlashToken");
      switch (lessThanSlashToken.Kind)
      {
        case SyntaxKind.LessThanSlashToken:
          break;
        default:
          throw new ArgumentException("lessThanSlashToken");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      if (greaterThanToken == null)
        throw new ArgumentNullException("greaterThanToken");
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      return new XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken);
    }

    public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException("lessThanToken");
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      if (slashGreaterThanToken == null)
        throw new ArgumentNullException("slashGreaterThanToken");
      switch (slashGreaterThanToken.Kind)
      {
        case SyntaxKind.SlashGreaterThanToken:
          break;
        default:
          throw new ArgumentException("slashGreaterThanToken");
      }
#endif

      return new XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken);
    }

    public static XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
#if DEBUG
      if (localName == null)
        throw new ArgumentNullException("localName");
      switch (localName.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("localName");
      }
#endif

      return new XmlNameSyntax(SyntaxKind.XmlName, prefix, localName);
    }

    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
    {
#if DEBUG
      if (prefix == null)
        throw new ArgumentNullException("prefix");
      switch (prefix.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("prefix");
      }
      if (colonToken == null)
        throw new ArgumentNullException("colonToken");
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      return new XmlPrefixSyntax(SyntaxKind.XmlPrefix, prefix, colonToken);
    }

    public static XmlAttributeSyntax XmlAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException("name");
      if (equalsToken == null)
        throw new ArgumentNullException("equalsToken");
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException("startQuoteToken");
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (endQuoteToken == null)
        throw new ArgumentNullException("endQuoteToken");
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlAttributeSyntax(SyntaxKind.XmlAttribute, name, equalsToken, startQuoteToken, textTokens.Node, endQuoteToken);
    }

    public static XmlTextSyntax XmlText(SyntaxList<SyntaxToken> textTokens)
    {
#if DEBUG
#endif

      return new XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node);
    }

    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
    {
#if DEBUG
      if (startCDataToken == null)
        throw new ArgumentNullException("startCDataToken");
      switch (startCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataStartToken:
          break;
        default:
          throw new ArgumentException("startCDataToken");
      }
      if (endCDataToken == null)
        throw new ArgumentNullException("endCDataToken");
      switch (endCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataEndToken:
          break;
        default:
          throw new ArgumentException("endCDataToken");
      }
#endif

      return new XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken);
    }

    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
    {
#if DEBUG
      if (startProcessingInstructionToken == null)
        throw new ArgumentNullException("startProcessingInstructionToken");
      switch (startProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionStartToken:
          break;
        default:
          throw new ArgumentException("startProcessingInstructionToken");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      if (endProcessingInstructionToken == null)
        throw new ArgumentNullException("endProcessingInstructionToken");
      switch (endProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionEndToken:
          break;
        default:
          throw new ArgumentException("endProcessingInstructionToken");
      }
#endif

      return new XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, startProcessingInstructionToken, name, textTokens.Node, endProcessingInstructionToken);
    }

    public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
#if DEBUG
      if (lessThanExclamationMinusMinusToken == null)
        throw new ArgumentNullException("lessThanExclamationMinusMinusToken");
      switch (lessThanExclamationMinusMinusToken.Kind)
      {
        case SyntaxKind.XmlCommentStartToken:
          break;
        default:
          throw new ArgumentException("lessThanExclamationMinusMinusToken");
      }
      if (minusMinusGreaterThanToken == null)
        throw new ArgumentNullException("minusMinusGreaterThanToken");
      switch (minusMinusGreaterThanToken.Kind)
      {
        case SyntaxKind.XmlCommentEndToken:
          break;
        default:
          throw new ArgumentException("minusMinusGreaterThanToken");
      }
#endif

      return new XmlCommentSyntax(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken);
    }

    public static IfDirectiveSyntax IfDirective(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException("hashToken");
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (ifKeyword == null)
        throw new ArgumentNullException("ifKeyword");
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException("ifKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException("condition");
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException("endOfDirectiveToken");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new IfDirectiveSyntax(SyntaxKind.IfDirective, hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
    }

    public static ElifDirectiveSyntax ElifDirective(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException("hashToken");
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (elifKeyword == null)
        throw new ArgumentNullException("elifKeyword");
      switch (elifKeyword.Kind)
      {
        case SyntaxKind.ElifKeyword:
          break;
        default:
          throw new ArgumentException("elifKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException("condition");
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException("endOfDirectiveToken");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ElifDirectiveSyntax(SyntaxKind.ElifDirective, hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
    }

    public static ElseDirectiveSyntax ElseDirective(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException("hashToken");
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (elseKeyword == null)
        throw new ArgumentNullException("elseKeyword");
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException("elseKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException("endOfDirectiveToken");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ElseDirectiveSyntax(SyntaxKind.ElseDirective, hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken);
    }

    public static EndIfDirectiveSyntax EndIfDirective(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException("hashToken");
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (endIfKeyword == null)
        throw new ArgumentNullException("endIfKeyword");
      switch (endIfKeyword.Kind)
      {
        case SyntaxKind.EndIfKeyword:
          break;
        default:
          throw new ArgumentException("endIfKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException("endOfDirectiveToken");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new EndIfDirectiveSyntax(SyntaxKind.EndIfDirective, hashToken, endIfKeyword, endOfDirectiveToken, isActive);
    }

    public static RegionDirectiveSyntax RegionDirective(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException("hashToken");
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (regionKeyword == null)
        throw new ArgumentNullException("regionKeyword");
      switch (regionKeyword.Kind)
      {
        case SyntaxKind.RegionKeyword:
          break;
        default:
          throw new ArgumentException("regionKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException("endOfDirectiveToken");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new RegionDirectiveSyntax(SyntaxKind.RegionDirective, hashToken, regionKeyword, endOfDirectiveToken, isActive);
    }

    public static EndRegionDirectiveSyntax EndRegionDirective(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException("hashToken");
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (endRegionKeyword == null)
        throw new ArgumentNullException("endRegionKeyword");
      switch (endRegionKeyword.Kind)
      {
        case SyntaxKind.EndRegionKeyword:
          break;
        default:
          throw new ArgumentException("endRegionKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException("endOfDirectiveToken");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new EndRegionDirectiveSyntax(SyntaxKind.EndRegionDirective, hashToken, endRegionKeyword, endOfDirectiveToken, isActive);
    }

    public static ErrorDirectiveSyntax ErrorDirective(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException("hashToken");
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (errorKeyword == null)
        throw new ArgumentNullException("errorKeyword");
      switch (errorKeyword.Kind)
      {
        case SyntaxKind.ErrorKeyword:
          break;
        default:
          throw new ArgumentException("errorKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException("endOfDirectiveToken");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ErrorDirectiveSyntax(SyntaxKind.ErrorDirective, hashToken, errorKeyword, endOfDirectiveToken, isActive);
    }

    public static WarningDirectiveSyntax WarningDirective(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException("hashToken");
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (warningKeyword == null)
        throw new ArgumentNullException("warningKeyword");
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException("warningKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException("endOfDirectiveToken");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new WarningDirectiveSyntax(SyntaxKind.WarningDirective, hashToken, warningKeyword, endOfDirectiveToken, isActive);
    }

    public static BadDirectiveSyntax BadDirective(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException("hashToken");
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException("endOfDirectiveToken");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new BadDirectiveSyntax(SyntaxKind.BadDirective, hashToken, identifier, endOfDirectiveToken, isActive);
    }

    public static DefineDirectiveSyntax DefineDirective(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException("hashToken");
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (defineKeyword == null)
        throw new ArgumentNullException("defineKeyword");
      switch (defineKeyword.Kind)
      {
        case SyntaxKind.DefineKeyword:
          break;
        default:
          throw new ArgumentException("defineKeyword");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("name");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException("endOfDirectiveToken");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new DefineDirectiveSyntax(SyntaxKind.DefineDirective, hashToken, defineKeyword, name, endOfDirectiveToken, isActive);
    }

    public static UndefDirectiveSyntax UndefDirective(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException("hashToken");
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (undefKeyword == null)
        throw new ArgumentNullException("undefKeyword");
      switch (undefKeyword.Kind)
      {
        case SyntaxKind.UndefKeyword:
          break;
        default:
          throw new ArgumentException("undefKeyword");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("name");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException("endOfDirectiveToken");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new UndefDirectiveSyntax(SyntaxKind.UndefDirective, hashToken, undefKeyword, name, endOfDirectiveToken, isActive);
    }

    public static LineDirectiveSyntax LineDirective(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException("hashToken");
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (lineKeyword == null)
        throw new ArgumentNullException("lineKeyword");
      switch (lineKeyword.Kind)
      {
        case SyntaxKind.LineKeyword:
          break;
        default:
          throw new ArgumentException("lineKeyword");
      }
      if (line == null)
        throw new ArgumentNullException("line");
      switch (line.Kind)
      {
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.HiddenKeyword:
          break;
        default:
          throw new ArgumentException("line");
      }
      if (file != null)
      {
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("file");
      }
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException("endOfDirectiveToken");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new LineDirectiveSyntax(SyntaxKind.LineDirective, hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive);
    }

    public static PragmaWarningDirectiveSyntax PragmaWarningDirective(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException("hashToken");
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (pragmaKeyword == null)
        throw new ArgumentNullException("pragmaKeyword");
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException("pragmaKeyword");
      }
      if (warningKeyword == null)
        throw new ArgumentNullException("warningKeyword");
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException("warningKeyword");
      }
      if (disableOrRestoreKeyword == null)
        throw new ArgumentNullException("disableOrRestoreKeyword");
      switch (disableOrRestoreKeyword.Kind)
      {
        case SyntaxKind.DisableKeyword:
        case SyntaxKind.RestoreKeyword:
          break;
        default:
          throw new ArgumentException("disableOrRestoreKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException("endOfDirectiveToken");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new PragmaWarningDirectiveSyntax(SyntaxKind.PragmaWarningDirective, hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes.Node, endOfDirectiveToken, isActive);
    }

    public static PragmaChecksumDirectiveSyntax PragmaChecksumDirective(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException("hashToken");
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (pragmaKeyword == null)
        throw new ArgumentNullException("pragmaKeyword");
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException("pragmaKeyword");
      }
      if (checksumKeyword == null)
        throw new ArgumentNullException("checksumKeyword");
      switch (checksumKeyword.Kind)
      {
        case SyntaxKind.ChecksumKeyword:
          break;
        default:
          throw new ArgumentException("checksumKeyword");
      }
      if (file == null)
        throw new ArgumentNullException("file");
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      if (guid == null)
        throw new ArgumentNullException("guid");
      switch (guid.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("guid");
      }
      if (bytes == null)
        throw new ArgumentNullException("bytes");
      switch (bytes.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("bytes");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException("endOfDirectiveToken");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new PragmaChecksumDirectiveSyntax(SyntaxKind.PragmaChecksumDirective, hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive);
    }

    public static ReferenceDirectiveSyntax ReferenceDirective(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException("hashToken");
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (referenceKeyword == null)
        throw new ArgumentNullException("referenceKeyword");
      switch (referenceKeyword.Kind)
      {
        case SyntaxKind.ReferenceKeyword:
          break;
        default:
          throw new ArgumentException("referenceKeyword");
      }
      if (file == null)
        throw new ArgumentNullException("file");
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException("endOfDirectiveToken");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ReferenceDirectiveSyntax(SyntaxKind.ReferenceDirective, hashToken, referenceKeyword, file, endOfDirectiveToken, isActive);
    }

    internal static IEnumerable<Type> NodeTypes = new Type[] {
       typeof(IdentifierNameSyntax),
       typeof(QualifiedNameSyntax),
       typeof(GenericNameSyntax),
       typeof(TypeArgumentListSyntax),
       typeof(AliasQualifiedNameSyntax),
       typeof(PredefinedTypeSyntax),
       typeof(ArrayTypeSyntax),
       typeof(ArrayRankSpecifierSyntax),
       typeof(PointerTypeSyntax),
       typeof(NullableTypeSyntax),
       typeof(OmittedTypeArgumentSyntax),
       typeof(ParenthesizedExpressionSyntax),
       typeof(PrefixUnaryExpressionSyntax),
       typeof(PostfixUnaryExpressionSyntax),
       typeof(MemberAccessExpressionSyntax),
       typeof(BinaryExpressionSyntax),
       typeof(ConditionalExpressionSyntax),
       typeof(ThisExpressionSyntax),
       typeof(BaseExpressionSyntax),
       typeof(LiteralExpressionSyntax),
       typeof(MakeRefExpressionSyntax),
       typeof(RefTypeExpressionSyntax),
       typeof(RefValueExpressionSyntax),
       typeof(CheckedExpressionSyntax),
       typeof(DefaultExpressionSyntax),
       typeof(TypeOfExpressionSyntax),
       typeof(SizeOfExpressionSyntax),
       typeof(InvocationExpressionSyntax),
       typeof(ElementAccessExpressionSyntax),
       typeof(ArgumentListSyntax),
       typeof(BracketedArgumentListSyntax),
       typeof(ArgumentSyntax),
       typeof(NameColonSyntax),
       typeof(CastExpressionSyntax),
       typeof(AnonymousMethodExpressionSyntax),
       typeof(SimpleLambdaExpressionSyntax),
       typeof(ParenthesizedLambdaExpressionSyntax),
       typeof(InitializerExpressionSyntax),
       typeof(ObjectCreationExpressionSyntax),
       typeof(AnonymousObjectMemberDeclaratorSyntax),
       typeof(AnonymousObjectCreationExpressionSyntax),
       typeof(ArrayCreationExpressionSyntax),
       typeof(ImplicitArrayCreationExpressionSyntax),
       typeof(StackAllocArrayCreationExpressionSyntax),
       typeof(QueryExpressionSyntax),
       typeof(QueryBodySyntax),
       typeof(FromClauseSyntax),
       typeof(LetClauseSyntax),
       typeof(JoinClauseSyntax),
       typeof(JoinIntoClauseSyntax),
       typeof(WhereClauseSyntax),
       typeof(OrderByClauseSyntax),
       typeof(OrderingSyntax),
       typeof(SelectClauseSyntax),
       typeof(GroupClauseSyntax),
       typeof(QueryContinuationSyntax),
       typeof(OmittedArraySizeExpressionSyntax),
       typeof(GlobalStatementSyntax),
       typeof(BlockSyntax),
       typeof(LocalDeclarationStatementSyntax),
       typeof(VariableDeclarationSyntax),
       typeof(VariableDeclaratorSyntax),
       typeof(EqualsValueClauseSyntax),
       typeof(ExpressionStatementSyntax),
       typeof(EmptyStatementSyntax),
       typeof(LabeledStatementSyntax),
       typeof(GotoStatementSyntax),
       typeof(BreakStatementSyntax),
       typeof(ContinueStatementSyntax),
       typeof(ReturnStatementSyntax),
       typeof(ThrowStatementSyntax),
       typeof(YieldStatementSyntax),
       typeof(WhileStatementSyntax),
       typeof(DoStatementSyntax),
       typeof(ForStatementSyntax),
       typeof(ForEachStatementSyntax),
       typeof(UsingStatementSyntax),
       typeof(FixedStatementSyntax),
       typeof(CheckedStatementSyntax),
       typeof(UnsafeStatementSyntax),
       typeof(LockStatementSyntax),
       typeof(IfStatementSyntax),
       typeof(ElseClauseSyntax),
       typeof(SwitchStatementSyntax),
       typeof(SwitchSectionSyntax),
       typeof(SwitchLabelSyntax),
       typeof(TryStatementSyntax),
       typeof(CatchClauseSyntax),
       typeof(CatchDeclarationSyntax),
       typeof(FinallyClauseSyntax),
       typeof(CompilationUnitSyntax),
       typeof(ExternAliasDirectiveSyntax),
       typeof(UsingDirectiveSyntax),
       typeof(NamespaceDeclarationSyntax),
       typeof(AttributeDeclarationSyntax),
       typeof(AttributeTargetSpecifierSyntax),
       typeof(AttributeSyntax),
       typeof(AttributeArgumentListSyntax),
       typeof(AttributeArgumentSyntax),
       typeof(NameEqualsSyntax),
       typeof(TypeParameterListSyntax),
       typeof(TypeParameterSyntax),
       typeof(ClassDeclarationSyntax),
       typeof(StructDeclarationSyntax),
       typeof(InterfaceDeclarationSyntax),
       typeof(EnumDeclarationSyntax),
       typeof(DelegateDeclarationSyntax),
       typeof(EnumMemberDeclarationSyntax),
       typeof(BaseListSyntax),
       typeof(TypeParameterConstraintClauseSyntax),
       typeof(ConstructorConstraintSyntax),
       typeof(ClassOrStructConstraintSyntax),
       typeof(TypeConstraintSyntax),
       typeof(FieldDeclarationSyntax),
       typeof(EventFieldDeclarationSyntax),
       typeof(ExplicitInterfaceSpecifierSyntax),
       typeof(MethodDeclarationSyntax),
       typeof(OperatorDeclarationSyntax),
       typeof(ConversionOperatorDeclarationSyntax),
       typeof(ConstructorDeclarationSyntax),
       typeof(ConstructorInitializerSyntax),
       typeof(DestructorDeclarationSyntax),
       typeof(PropertyDeclarationSyntax),
       typeof(EventDeclarationSyntax),
       typeof(IndexerDeclarationSyntax),
       typeof(AccessorListSyntax),
       typeof(AccessorDeclarationSyntax),
       typeof(ParameterListSyntax),
       typeof(BracketedParameterListSyntax),
       typeof(ParameterSyntax),
       typeof(IncompleteMemberSyntax),
       typeof(SkippedTokensSyntax),
       typeof(DocumentationCommentSyntax),
       typeof(XmlElementSyntax),
       typeof(XmlElementStartTagSyntax),
       typeof(XmlElementEndTagSyntax),
       typeof(XmlEmptyElementSyntax),
       typeof(XmlNameSyntax),
       typeof(XmlPrefixSyntax),
       typeof(XmlAttributeSyntax),
       typeof(XmlTextSyntax),
       typeof(XmlCDataSectionSyntax),
       typeof(XmlProcessingInstructionSyntax),
       typeof(XmlCommentSyntax),
       typeof(IfDirectiveSyntax),
       typeof(ElifDirectiveSyntax),
       typeof(ElseDirectiveSyntax),
       typeof(EndIfDirectiveSyntax),
       typeof(RegionDirectiveSyntax),
       typeof(EndRegionDirectiveSyntax),
       typeof(ErrorDirectiveSyntax),
       typeof(WarningDirectiveSyntax),
       typeof(BadDirectiveSyntax),
       typeof(DefineDirectiveSyntax),
       typeof(UndefDirectiveSyntax),
       typeof(LineDirectiveSyntax),
       typeof(PragmaWarningDirectiveSyntax),
       typeof(PragmaChecksumDirectiveSyntax),
       typeof(ReferenceDirectiveSyntax),
    };
  }
}

namespace Roslyn.Compilers.CSharp
{
  /// <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class NameSyntax : TypeSyntax
  {
    internal NameSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }
  }

  /// <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class SimpleNameSyntax : NameSyntax
  {
    internal SimpleNameSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the identifier of the simple name.</summary>
    public abstract SyntaxToken Identifier { get; }
  }

  /// <summary>Class which represents the syntax node for identifier name.</summary>
  public sealed partial class IdentifierNameSyntax : SimpleNameSyntax
  {
    internal IdentifierNameSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIdentifierName(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitIdentifierName(this);
    }

    public IdentifierNameSyntax Update(SyntaxToken identifier)
    {
        if (identifier != this.Identifier)
        {
            var newNode = Syntax.IdentifierName(identifier);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IdentifierNameSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier);
    }
  }

  /// <summary>Class which represents the syntax node for qualified name.</summary>
  public sealed partial class QualifiedNameSyntax : NameSyntax
  {
    private NameSyntax left;
    private SimpleNameSyntax right;

    internal QualifiedNameSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
    public NameSyntax Left 
    {
      get { return this.GetRed(ref this.left, 0); }
    }

    /// <summary>SyntaxToken representing the dot.</summary>
    public SyntaxToken DotToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
    public SimpleNameSyntax Right 
    {
      get { return this.GetRed(ref this.right, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.left, 0);
            case 2: return this.GetRed(ref this.right, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 2: return this.right;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQualifiedName(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitQualifiedName(this);
    }

    public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
        if (left != this.Left || dotToken != this.DotToken || right != this.Right)
        {
            var newNode = Syntax.QualifiedName(left, dotToken, right);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public QualifiedNameSyntax WithLeft(NameSyntax left)
    {
        return this.Update(left, this.DotToken, this.Right);
    }

    public QualifiedNameSyntax WithDotToken(SyntaxToken dotToken)
    {
        return this.Update(this.Left, dotToken, this.Right);
    }

    public QualifiedNameSyntax WithRight(SimpleNameSyntax right)
    {
        return this.Update(this.Left, this.DotToken, right);
    }
  }

  /// <summary>Class which represents the syntax node for generic name.</summary>
  public sealed partial class GenericNameSyntax : SimpleNameSyntax
  {
    private TypeArgumentListSyntax typeArgumentList;

    internal GenericNameSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
    public TypeArgumentListSyntax TypeArgumentList 
    {
      get { return this.GetRed(ref this.typeArgumentList, 1); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.typeArgumentList, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.typeArgumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGenericName(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitGenericName(this);
    }

    public GenericNameSyntax Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
        if (identifier != this.Identifier || typeArgumentList != this.TypeArgumentList)
        {
            var newNode = Syntax.GenericName(identifier, typeArgumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public GenericNameSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier, this.TypeArgumentList);
    }

    public GenericNameSyntax WithTypeArgumentList(TypeArgumentListSyntax typeArgumentList)
    {
        return this.Update(this.Identifier, typeArgumentList);
    }

    public GenericNameSyntax AddTypeArgumentListArguments(params TypeSyntax[] items)
    {
        return this.WithTypeArgumentList(this.TypeArgumentList.WithArguments(this.TypeArgumentList.Arguments.Add(items)));
    }
  }

  /// <summary>Class which represents the syntax node for type argument list.</summary>
  public sealed partial class TypeArgumentListSyntax : SyntaxNode
  {
    private SyntaxNode arguments;

    internal TypeArgumentListSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing less than.</summary>
    public SyntaxToken LessThanToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
    public SeparatedSyntaxList<TypeSyntax> Arguments 
    {
      get { return new SeparatedSyntaxList<TypeSyntax>(this.GetRed(ref this.arguments, 1), this.GetChildIndex(1)); }
    }

    /// <summary>SyntaxToken representing greater than.</summary>
    public SyntaxToken GreaterThanToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.arguments, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.arguments;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeArgumentList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitTypeArgumentList(this);
    }

    public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || arguments != this.Arguments || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = Syntax.TypeArgumentList(lessThanToken, arguments, greaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeArgumentListSyntax WithLessThanToken(SyntaxToken lessThanToken)
    {
        return this.Update(lessThanToken, this.Arguments, this.GreaterThanToken);
    }

    public TypeArgumentListSyntax WithArguments(SeparatedSyntaxList<TypeSyntax> arguments)
    {
        return this.Update(this.LessThanToken, arguments, this.GreaterThanToken);
    }

    public TypeArgumentListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)
    {
        return this.Update(this.LessThanToken, this.Arguments, greaterThanToken);
    }

    public TypeArgumentListSyntax AddArguments(params TypeSyntax[] items)
    {
        return this.WithArguments(this.Arguments.Add(items));
    }
  }

  /// <summary>Class which represents the syntax node for alias qualified name.</summary>
  public sealed partial class AliasQualifiedNameSyntax : NameSyntax
  {
    private IdentifierNameSyntax alias;
    private SimpleNameSyntax name;

    internal AliasQualifiedNameSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>IdentifierNameSyntax node representing the name of the alias</summary>
    public IdentifierNameSyntax Alias 
    {
      get { return this.GetRed(ref this.alias, 0); }
    }

    /// <summary>SyntaxToken representing colon colon.</summary>
    public SyntaxToken ColonColonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
    public SimpleNameSyntax Name 
    {
      get { return this.GetRed(ref this.name, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.alias, 0);
            case 2: return this.GetRed(ref this.name, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.alias;
            case 2: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAliasQualifiedName(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAliasQualifiedName(this);
    }

    public AliasQualifiedNameSyntax Update(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
        if (alias != this.Alias || colonColonToken != this.ColonColonToken || name != this.Name)
        {
            var newNode = Syntax.AliasQualifiedName(alias, colonColonToken, name);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AliasQualifiedNameSyntax WithAlias(IdentifierNameSyntax alias)
    {
        return this.Update(alias, this.ColonColonToken, this.Name);
    }

    public AliasQualifiedNameSyntax WithColonColonToken(SyntaxToken colonColonToken)
    {
        return this.Update(this.Alias, colonColonToken, this.Name);
    }

    public AliasQualifiedNameSyntax WithName(SimpleNameSyntax name)
    {
        return this.Update(this.Alias, this.ColonColonToken, name);
    }
  }

  /// <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class TypeSyntax : ExpressionSyntax
  {
    internal TypeSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }
  }

  /// <summary>Class which represents the syntax node for predefined types.</summary>
  public sealed partial class PredefinedTypeSyntax : TypeSyntax
  {
    internal PredefinedTypeSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPredefinedType(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitPredefinedType(this);
    }

    public PredefinedTypeSyntax Update(SyntaxToken keyword)
    {
        if (keyword != this.Keyword)
        {
            var newNode = Syntax.PredefinedType(keyword);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PredefinedTypeSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword);
    }
  }

  /// <summary>Class which represents the syntax node for the array type.</summary>
  public sealed partial class ArrayTypeSyntax : TypeSyntax
  {
    private TypeSyntax elementType;
    private SyntaxNode rankSpecifiers;

    internal ArrayTypeSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>TypeSyntax node representing the type of the element of the array.</summary>
    public TypeSyntax ElementType 
    {
      get { return this.GetRed(ref this.elementType, 0); }
    }

    /// <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
    public SyntaxList<ArrayRankSpecifierSyntax> RankSpecifiers 
    {
      get { return new SyntaxList<ArrayRankSpecifierSyntax>(this.GetRed(ref this.rankSpecifiers, 1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.elementType, 0);
            case 1: return this.GetRed(ref this.rankSpecifiers, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            case 1: return this.rankSpecifiers;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayType(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitArrayType(this);
    }

    public ArrayTypeSyntax Update(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
        if (elementType != this.ElementType || rankSpecifiers != this.RankSpecifiers)
        {
            var newNode = Syntax.ArrayType(elementType, rankSpecifiers);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArrayTypeSyntax WithElementType(TypeSyntax elementType)
    {
        return this.Update(elementType, this.RankSpecifiers);
    }

    public ArrayTypeSyntax WithRankSpecifiers(SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
        return this.Update(this.ElementType, rankSpecifiers);
    }

    public ArrayTypeSyntax AddRankSpecifiers(params ArrayRankSpecifierSyntax[] items)
    {
        return this.WithRankSpecifiers(this.RankSpecifiers.Add(items));
    }
  }

  public sealed partial class ArrayRankSpecifierSyntax : SyntaxNode
  {
    private SyntaxNode sizes;

    internal ArrayRankSpecifierSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SeparatedSyntaxList<ExpressionSyntax> Sizes 
    {
      get { return new SeparatedSyntaxList<ExpressionSyntax>(this.GetRed(ref this.sizes, 1), this.GetChildIndex(1)); }
    }

    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.sizes, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.sizes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayRankSpecifier(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitArrayRankSpecifier(this);
    }

    public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || sizes != this.Sizes || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = Syntax.ArrayRankSpecifier(openBracketToken, sizes, closeBracketToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArrayRankSpecifierSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(openBracketToken, this.Sizes, this.CloseBracketToken);
    }

    public ArrayRankSpecifierSyntax WithSizes(SeparatedSyntaxList<ExpressionSyntax> sizes)
    {
        return this.Update(this.OpenBracketToken, sizes, this.CloseBracketToken);
    }

    public ArrayRankSpecifierSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.OpenBracketToken, this.Sizes, closeBracketToken);
    }

    public ArrayRankSpecifierSyntax AddSizes(params ExpressionSyntax[] items)
    {
        return this.WithSizes(this.Sizes.Add(items));
    }
  }

  /// <summary>Class which represents the syntax node for pointer type.</summary>
  public sealed partial class PointerTypeSyntax : TypeSyntax
  {
    private TypeSyntax elementType;

    internal PointerTypeSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>TypeSyntax node that represents the element type of the pointer.</summary>
    public TypeSyntax ElementType 
    {
      get { return this.GetRed(ref this.elementType, 0); }
    }

    /// <summary>SyntaxToken representing the asterisk.</summary>
    public SyntaxToken AsteriskToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.elementType, 0);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPointerType(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitPointerType(this);
    }

    public PointerTypeSyntax Update(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
        if (elementType != this.ElementType || asteriskToken != this.AsteriskToken)
        {
            var newNode = Syntax.PointerType(elementType, asteriskToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PointerTypeSyntax WithElementType(TypeSyntax elementType)
    {
        return this.Update(elementType, this.AsteriskToken);
    }

    public PointerTypeSyntax WithAsteriskToken(SyntaxToken asteriskToken)
    {
        return this.Update(this.ElementType, asteriskToken);
    }
  }

  /// <summary>Class which represents the syntax node for a nullable type.</summary>
  public sealed partial class NullableTypeSyntax : TypeSyntax
  {
    private TypeSyntax elementType;

    internal NullableTypeSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>TypeSyntax node representing the type of the element.</summary>
    public TypeSyntax ElementType 
    {
      get { return this.GetRed(ref this.elementType, 0); }
    }

    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken QuestionToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.elementType, 0);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNullableType(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitNullableType(this);
    }

    public NullableTypeSyntax Update(TypeSyntax elementType, SyntaxToken questionToken)
    {
        if (elementType != this.ElementType || questionToken != this.QuestionToken)
        {
            var newNode = Syntax.NullableType(elementType, questionToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public NullableTypeSyntax WithElementType(TypeSyntax elementType)
    {
        return this.Update(elementType, this.QuestionToken);
    }

    public NullableTypeSyntax WithQuestionToken(SyntaxToken questionToken)
    {
        return this.Update(this.ElementType, questionToken);
    }
  }

  /// <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
  public sealed partial class OmittedTypeArgumentSyntax : TypeSyntax
  {
    internal OmittedTypeArgumentSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the omitted type argument.</summary>
    public SyntaxToken OmittedTypeArgumentToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOmittedTypeArgument(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitOmittedTypeArgument(this);
    }

    public OmittedTypeArgumentSyntax Update(SyntaxToken omittedTypeArgumentToken)
    {
        if (omittedTypeArgumentToken != this.OmittedTypeArgumentToken)
        {
            var newNode = Syntax.OmittedTypeArgument(omittedTypeArgumentToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OmittedTypeArgumentSyntax WithOmittedTypeArgumentToken(SyntaxToken omittedTypeArgumentToken)
    {
        return this.Update(omittedTypeArgumentToken);
    }
  }

  /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class ExpressionSyntax : SyntaxNode
  {
    internal ExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }
  }

  /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
  public sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal ParenthesizedExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 1); }
    }

    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParenthesizedExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitParenthesizedExpression(this);
    }

    public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.ParenthesizedExpression(openParenToken, expression, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ParenthesizedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Expression, this.CloseParenToken);
    }

    public ParenthesizedExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.OpenParenToken, expression, this.CloseParenToken);
    }

    public ParenthesizedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Expression, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for prefix unary expression.</summary>
  public sealed partial class PrefixUnaryExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax operand;

    internal PrefixUnaryExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
    public ExpressionSyntax Operand 
    {
      get { return this.GetRed(ref this.operand, 1); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.operand, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.operand;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPrefixUnaryExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitPrefixUnaryExpression(this);
    }

    public PrefixUnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand)
    {
        if (operatorToken != this.OperatorToken || operand != this.Operand)
        {
            var newNode = Syntax.PrefixUnaryExpression(this.Kind, operatorToken, operand);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PrefixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(operatorToken, this.Operand);
    }

    public PrefixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand)
    {
        return this.Update(this.OperatorToken, operand);
    }
  }

  /// <summary>Class which represents the syntax node for postfix unary expression.</summary>
  public sealed partial class PostfixUnaryExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax operand;

    internal PostfixUnaryExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
    public ExpressionSyntax Operand 
    {
      get { return this.GetRed(ref this.operand, 0); }
    }

    /// <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.operand, 0);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operand;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPostfixUnaryExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitPostfixUnaryExpression(this);
    }

    public PostfixUnaryExpressionSyntax Update(ExpressionSyntax operand, SyntaxToken operatorToken)
    {
        if (operand != this.Operand || operatorToken != this.OperatorToken)
        {
            var newNode = Syntax.PostfixUnaryExpression(this.Kind, operand, operatorToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PostfixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand)
    {
        return this.Update(operand, this.OperatorToken);
    }

    public PostfixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.Operand, operatorToken);
    }
  }

  /// <summary>Class which represents the syntax node for member access expression.</summary>
  public sealed partial class MemberAccessExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private SimpleNameSyntax name;

    internal MemberAccessExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 0); }
    }

    /// <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SimpleNameSyntax node representing the member being accessed.</summary>
    public SimpleNameSyntax Name 
    {
      get { return this.GetRed(ref this.name, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.expression, 0);
            case 2: return this.GetRed(ref this.name, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 2: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMemberAccessExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitMemberAccessExpression(this);
    }

    public MemberAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
        if (expression != this.Expression || operatorToken != this.OperatorToken || name != this.Name)
        {
            var newNode = Syntax.MemberAccessExpression(this.Kind, expression, operatorToken, name);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public MemberAccessExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.OperatorToken, this.Name);
    }

    public MemberAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.Expression, operatorToken, this.Name);
    }

    public MemberAccessExpressionSyntax WithName(SimpleNameSyntax name)
    {
        return this.Update(this.Expression, this.OperatorToken, name);
    }
  }

  /// <summary>Class which represents an expression that has a binary operator.</summary>
  public sealed partial class BinaryExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax left;
    private ExpressionSyntax right;

    internal BinaryExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
    public ExpressionSyntax Left 
    {
      get { return this.GetRed(ref this.left, 0); }
    }

    /// <summary>SyntaxToken representing the operator of the binary expression.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
    public ExpressionSyntax Right 
    {
      get { return this.GetRed(ref this.right, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.left, 0);
            case 2: return this.GetRed(ref this.right, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 2: return this.right;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBinaryExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBinaryExpression(this);
    }

    public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
        if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
        {
            var newNode = Syntax.BinaryExpression(this.Kind, left, operatorToken, right);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BinaryExpressionSyntax WithLeft(ExpressionSyntax left)
    {
        return this.Update(left, this.OperatorToken, this.Right);
    }

    public BinaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.Left, operatorToken, this.Right);
    }

    public BinaryExpressionSyntax WithRight(ExpressionSyntax right)
    {
        return this.Update(this.Left, this.OperatorToken, right);
    }
  }

  /// <summary>Class which represents the syntax node for conditional expression.</summary>
  public sealed partial class ConditionalExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax condition;
    private ExpressionSyntax whenTrue;
    private ExpressionSyntax whenFalse;

    internal ConditionalExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
    public ExpressionSyntax Condition 
    {
      get { return this.GetRed(ref this.condition, 0); }
    }

    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken QuestionToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
    public ExpressionSyntax WhenTrue 
    {
      get { return this.GetRed(ref this.whenTrue, 2); }
    }

    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
    public ExpressionSyntax WhenFalse 
    {
      get { return this.GetRed(ref this.whenFalse, 4); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.condition, 0);
            case 2: return this.GetRed(ref this.whenTrue, 2);
            case 4: return this.GetRed(ref this.whenFalse, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.condition;
            case 2: return this.whenTrue;
            case 4: return this.whenFalse;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConditionalExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitConditionalExpression(this);
    }

    public ConditionalExpressionSyntax Update(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
        if (condition != this.Condition || questionToken != this.QuestionToken || whenTrue != this.WhenTrue || colonToken != this.ColonToken || whenFalse != this.WhenFalse)
        {
            var newNode = Syntax.ConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConditionalExpressionSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(condition, this.QuestionToken, this.WhenTrue, this.ColonToken, this.WhenFalse);
    }

    public ConditionalExpressionSyntax WithQuestionToken(SyntaxToken questionToken)
    {
        return this.Update(this.Condition, questionToken, this.WhenTrue, this.ColonToken, this.WhenFalse);
    }

    public ConditionalExpressionSyntax WithWhenTrue(ExpressionSyntax whenTrue)
    {
        return this.Update(this.Condition, this.QuestionToken, whenTrue, this.ColonToken, this.WhenFalse);
    }

    public ConditionalExpressionSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Condition, this.QuestionToken, this.WhenTrue, colonToken, this.WhenFalse);
    }

    public ConditionalExpressionSyntax WithWhenFalse(ExpressionSyntax whenFalse)
    {
        return this.Update(this.Condition, this.QuestionToken, this.WhenTrue, this.ColonToken, whenFalse);
    }
  }

  /// <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class InstanceExpressionSyntax : ExpressionSyntax
  {
    internal InstanceExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }
  }

  /// <summary>Class which represents the syntax node for a this expression.</summary>
  public sealed partial class ThisExpressionSyntax : InstanceExpressionSyntax
  {
    internal ThisExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the this keyword.</summary>
    public SyntaxToken Token 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitThisExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitThisExpression(this);
    }

    public ThisExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = Syntax.ThisExpression(token);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ThisExpressionSyntax WithToken(SyntaxToken token)
    {
        return this.Update(token);
    }
  }

  /// <summary>Class which represents the syntax node for a base expression.</summary>
  public sealed partial class BaseExpressionSyntax : InstanceExpressionSyntax
  {
    internal BaseExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the base keyword.</summary>
    public SyntaxToken Token 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBaseExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBaseExpression(this);
    }

    public BaseExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = Syntax.BaseExpression(token);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BaseExpressionSyntax WithToken(SyntaxToken token)
    {
        return this.Update(token);
    }
  }

  /// <summary>Class which represents the syntax node for a literal expression.</summary>
  public sealed partial class LiteralExpressionSyntax : ExpressionSyntax
  {
    internal LiteralExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
    public SyntaxToken Token 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLiteralExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitLiteralExpression(this);
    }

    public LiteralExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = Syntax.LiteralExpression(this.Kind, token);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LiteralExpressionSyntax WithToken(SyntaxToken token)
    {
        return this.Update(token);
    }
  }

  /// <summary>Class which represents the syntax node for MakeRef expression.</summary>
  public sealed partial class MakeRefExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal MakeRefExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the MakeRefKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 2); }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMakeRefExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitMakeRefExpression(this);
    }

    public MakeRefExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.MakeRefExpression(keyword, openParenToken, expression, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public MakeRefExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Expression, this.CloseParenToken);
    }

    public MakeRefExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Expression, this.CloseParenToken);
    }

    public MakeRefExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.Keyword, this.OpenParenToken, expression, this.CloseParenToken);
    }

    public MakeRefExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for RefType expression.</summary>
  public sealed partial class RefTypeExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal RefTypeExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the RefTypeKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 2); }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefTypeExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitRefTypeExpression(this);
    }

    public RefTypeExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.RefTypeExpression(keyword, openParenToken, expression, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public RefTypeExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Expression, this.CloseParenToken);
    }

    public RefTypeExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Expression, this.CloseParenToken);
    }

    public RefTypeExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.Keyword, this.OpenParenToken, expression, this.CloseParenToken);
    }

    public RefTypeExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for RefValue expression.</summary>
  public sealed partial class RefValueExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private TypeSyntax type;

    internal RefValueExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the RefValueKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Typed reference expression.</summary>
    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 2); }
    }

    /// <summary>Comma separating the arguments.</summary>
    public SyntaxToken Comma 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>The type of the value.</summary>
    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 4); }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(5), this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            case 4: return this.GetRed(ref this.type, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            case 4: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefValueExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitRefValueExpression(this);
    }

    public RefValueExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || comma != this.Comma || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.RefValueExpression(keyword, openParenToken, expression, comma, type, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public RefValueExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Expression, this.Comma, this.Type, this.CloseParenToken);
    }

    public RefValueExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Expression, this.Comma, this.Type, this.CloseParenToken);
    }

    public RefValueExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.Keyword, this.OpenParenToken, expression, this.Comma, this.Type, this.CloseParenToken);
    }

    public RefValueExpressionSyntax WithComma(SyntaxToken comma)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, comma, this.Type, this.CloseParenToken);
    }

    public RefValueExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, this.Comma, type, this.CloseParenToken);
    }

    public RefValueExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, this.Comma, this.Type, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
  public sealed partial class CheckedExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal CheckedExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 2); }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCheckedExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCheckedExpression(this);
    }

    public CheckedExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.CheckedExpression(this.Kind, keyword, openParenToken, expression, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CheckedExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Expression, this.CloseParenToken);
    }

    public CheckedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Expression, this.CloseParenToken);
    }

    public CheckedExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.Keyword, this.OpenParenToken, expression, this.CloseParenToken);
    }

    public CheckedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for Default expression.</summary>
  public sealed partial class DefaultExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;

    internal DefaultExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the DefaultKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Argument of the primary function.</summary>
    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 2); }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.type, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefaultExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitDefaultExpression(this);
    }

    public DefaultExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.DefaultExpression(keyword, openParenToken, type, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DefaultExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Type, this.CloseParenToken);
    }

    public DefaultExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Type, this.CloseParenToken);
    }

    public DefaultExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Keyword, this.OpenParenToken, type, this.CloseParenToken);
    }

    public DefaultExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Type, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for TypeOf expression.</summary>
  public sealed partial class TypeOfExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;

    internal TypeOfExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the TypeOfKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>The expression to return type of.</summary>
    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 2); }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.type, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeOfExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitTypeOfExpression(this);
    }

    public TypeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.TypeOfExpression(keyword, openParenToken, type, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeOfExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Type, this.CloseParenToken);
    }

    public TypeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Type, this.CloseParenToken);
    }

    public TypeOfExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Keyword, this.OpenParenToken, type, this.CloseParenToken);
    }

    public TypeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Type, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for SizeOf expression.</summary>
  public sealed partial class SizeOfExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;

    internal SizeOfExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the SizeOfKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Argument of the primary function.</summary>
    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 2); }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.type, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSizeOfExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitSizeOfExpression(this);
    }

    public SizeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.SizeOfExpression(keyword, openParenToken, type, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SizeOfExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Type, this.CloseParenToken);
    }

    public SizeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Type, this.CloseParenToken);
    }

    public SizeOfExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Keyword, this.OpenParenToken, type, this.CloseParenToken);
    }

    public SizeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Type, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for invocation expression.</summary>
  public sealed partial class InvocationExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private ArgumentListSyntax argumentList;

    internal InvocationExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 0); }
    }

    /// <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
    public ArgumentListSyntax ArgumentList 
    {
      get { return this.GetRed(ref this.argumentList, 1); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.expression, 0);
            case 1: return this.GetRed(ref this.argumentList, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInvocationExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitInvocationExpression(this);
    }

    public InvocationExpressionSyntax Update(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
        if (expression != this.Expression || argumentList != this.ArgumentList)
        {
            var newNode = Syntax.InvocationExpression(expression, argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InvocationExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.ArgumentList);
    }

    public InvocationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList)
    {
        return this.Update(this.Expression, argumentList);
    }

    public InvocationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        return this.WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.Add(items)));
    }
  }

  /// <summary>Class which represents the syntax node for element access expression.</summary>
  public sealed partial class ElementAccessExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private BracketedArgumentListSyntax argumentList;

    internal ElementAccessExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 0); }
    }

    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
    public BracketedArgumentListSyntax ArgumentList 
    {
      get { return this.GetRed(ref this.argumentList, 1); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.expression, 0);
            case 1: return this.GetRed(ref this.argumentList, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElementAccessExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitElementAccessExpression(this);
    }

    public ElementAccessExpressionSyntax Update(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
        if (expression != this.Expression || argumentList != this.ArgumentList)
        {
            var newNode = Syntax.ElementAccessExpression(expression, argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ElementAccessExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.ArgumentList);
    }

    public ElementAccessExpressionSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)
    {
        return this.Update(this.Expression, argumentList);
    }

    public ElementAccessExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        return this.WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.Add(items)));
    }
  }

  /// <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class BaseArgumentListSyntax : SyntaxNode
  {
    internal BaseArgumentListSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }

    /// <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
    public abstract SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
  }

  /// <summary>Class which represents the syntax node for the list of arguments.</summary>
  public sealed partial class ArgumentListSyntax : BaseArgumentListSyntax
  {
    private SyntaxNode arguments;

    internal ArgumentListSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public override SeparatedSyntaxList<ArgumentSyntax> Arguments 
    {
      get { return new SeparatedSyntaxList<ArgumentSyntax>(this.GetRed(ref this.arguments, 1), this.GetChildIndex(1)); }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.arguments, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.arguments;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArgumentList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitArgumentList(this);
    }

    public ArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.ArgumentList(openParenToken, arguments, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Arguments, this.CloseParenToken);
    }

    public ArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments)
    {
        return this.Update(this.OpenParenToken, arguments, this.CloseParenToken);
    }

    public ArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Arguments, closeParenToken);
    }

    public ArgumentListSyntax AddArguments(params ArgumentSyntax[] items)
    {
        return this.WithArguments(this.Arguments.Add(items));
    }
  }

  /// <summary>Class which represents the syntax node for bracketed argument list.</summary>
  public sealed partial class BracketedArgumentListSyntax : BaseArgumentListSyntax
  {
    private SyntaxNode arguments;

    internal BracketedArgumentListSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing open bracket.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public override SeparatedSyntaxList<ArgumentSyntax> Arguments 
    {
      get { return new SeparatedSyntaxList<ArgumentSyntax>(this.GetRed(ref this.arguments, 1), this.GetChildIndex(1)); }
    }

    /// <summary>SyntaxToken representing close bracket.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.arguments, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.arguments;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBracketedArgumentList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBracketedArgumentList(this);
    }

    public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || arguments != this.Arguments || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = Syntax.BracketedArgumentList(openBracketToken, arguments, closeBracketToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BracketedArgumentListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(openBracketToken, this.Arguments, this.CloseBracketToken);
    }

    public BracketedArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments)
    {
        return this.Update(this.OpenBracketToken, arguments, this.CloseBracketToken);
    }

    public BracketedArgumentListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.OpenBracketToken, this.Arguments, closeBracketToken);
    }

    public BracketedArgumentListSyntax AddArguments(params ArgumentSyntax[] items)
    {
        return this.WithArguments(this.Arguments.Add(items));
    }
  }

  /// <summary>Class which represents the syntax node for argument.</summary>
  public sealed partial class ArgumentSyntax : SyntaxNode
  {
    private NameColonSyntax nameColon;
    private ExpressionSyntax expression;

    internal ArgumentSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>NameColonSyntax node representing the optional name arguments.</summary>
    public NameColonSyntax NameColon 
    {
      get { return this.GetRed(ref this.nameColon, 0); }
    }

    /// <summary>SyntaxToken representing the optional ref or out keyword.</summary>
    public SyntaxToken RefOrOutKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>ExpressionSyntax node representing the argument.</summary>
    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.nameColon, 0);
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameColon;
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArgument(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitArgument(this);
    }

    public ArgumentSyntax Update(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)
    {
        if (nameColon != this.NameColon || refOrOutKeyword != this.RefOrOutKeyword || expression != this.Expression)
        {
            var newNode = Syntax.Argument(nameColon, refOrOutKeyword, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArgumentSyntax WithNameColon(NameColonSyntax nameColon)
    {
        return this.Update(nameColon, this.RefOrOutKeyword, this.Expression);
    }

    public ArgumentSyntax WithRefOrOutKeyword(SyntaxToken refOrOutKeyword)
    {
        return this.Update(this.NameColon, refOrOutKeyword, this.Expression);
    }

    public ArgumentSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.NameColon, this.RefOrOutKeyword, expression);
    }
  }

  /// <summary>Class which represents the syntax node for name colon syntax.</summary>
  public sealed partial class NameColonSyntax : SyntaxNode
  {
    private IdentifierNameSyntax identifier;

    internal NameColonSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the identifer name.</summary>
    public IdentifierNameSyntax Identifier 
    {
      get { return this.GetRed(ref this.identifier, 0); }
    }

    /// <summary>SyntaxToken representing colon.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.identifier, 0);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameColon(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitNameColon(this);
    }

    public NameColonSyntax Update(IdentifierNameSyntax identifier, SyntaxToken colonToken)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken)
        {
            var newNode = Syntax.NameColon(identifier, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public NameColonSyntax WithIdentifier(IdentifierNameSyntax identifier)
    {
        return this.Update(identifier, this.ColonToken);
    }

    public NameColonSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Identifier, colonToken);
    }
  }

  /// <summary>Class which represents the syntax node for cast expression.</summary>
  public sealed partial class CastExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;
    private ExpressionSyntax expression;

    internal CastExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>TypeSyntax node representing the type the expression is being casted to.</summary>
    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 1); }
    }

    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 3); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            case 3: return this.GetRed(ref this.expression, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            case 3: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCastExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCastExpression(this);
    }

    public CastExpressionSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
        if (openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken || expression != this.Expression)
        {
            var newNode = Syntax.CastExpression(openParenToken, type, closeParenToken, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CastExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Type, this.CloseParenToken, this.Expression);
    }

    public CastExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.OpenParenToken, type, this.CloseParenToken, this.Expression);
    }

    public CastExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Type, closeParenToken, this.Expression);
    }

    public CastExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.OpenParenToken, this.Type, this.CloseParenToken, expression);
    }
  }

  /// <summary>Class which represents the syntax node for anonymous method expression.</summary>
  public sealed partial class AnonymousMethodExpressionSyntax : ExpressionSyntax
  {
    private ParameterListSyntax parameterList;
    private BlockSyntax block;

    internal AnonymousMethodExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the delegate keyword.</summary>
    public SyntaxToken DelegateKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>List of parameters of the anonymous method expression.</summary>
    public ParameterListSyntax ParameterList 
    {
      get { return this.GetRed(ref this.parameterList, 1); }
    }

    /// <summary>BlockSyntax node representing the body of the anonymous method.</summary>
    public BlockSyntax Block 
    {
      get { return this.GetRed(ref this.block, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameterList, 1);
            case 2: return this.GetRed(ref this.block, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameterList;
            case 2: return this.block;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousMethodExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAnonymousMethodExpression(this);
    }

    public AnonymousMethodExpressionSyntax Update(SyntaxToken delegateKeyword, ParameterListSyntax parameterList, BlockSyntax block)
    {
        if (delegateKeyword != this.DelegateKeyword || parameterList != this.ParameterList || block != this.Block)
        {
            var newNode = Syntax.AnonymousMethodExpression(delegateKeyword, parameterList, block);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AnonymousMethodExpressionSyntax WithDelegateKeyword(SyntaxToken delegateKeyword)
    {
        return this.Update(delegateKeyword, this.ParameterList, this.Block);
    }

    public AnonymousMethodExpressionSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.DelegateKeyword, parameterList, this.Block);
    }

    public AnonymousMethodExpressionSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.DelegateKeyword, this.ParameterList, block);
    }

    public AnonymousMethodExpressionSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        var parameterList = this.ParameterList ?? Syntax.ParameterList();
        return this.WithParameterList(parameterList.WithParameters(parameterList.Parameters.Add(items)));
    }

    public AnonymousMethodExpressionSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.Add(items)));
    }
  }

  /// <summary>Class which represents the syntax node for a simple lambda expression.</summary>
  public sealed partial class SimpleLambdaExpressionSyntax : ExpressionSyntax
  {
    private ParameterSyntax parameter;
    private SyntaxNode body;

    internal SimpleLambdaExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
    public ParameterSyntax Parameter 
    {
      get { return this.GetRed(ref this.parameter, 0); }
    }

    /// <summary>SyntaxToken representing equals greater than.</summary>
    public SyntaxToken ArrowToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SyntaxNode representing the body of the lambda expression.</summary>
    public SyntaxNode Body 
    {
      get { return this.GetRed(ref this.body, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.parameter, 0);
            case 2: return this.GetRed(ref this.body, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.parameter;
            case 2: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSimpleLambdaExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitSimpleLambdaExpression(this);
    }

    public SimpleLambdaExpressionSyntax Update(ParameterSyntax parameter, SyntaxToken arrowToken, SyntaxNode body)
    {
        if (parameter != this.Parameter || arrowToken != this.ArrowToken || body != this.Body)
        {
            var newNode = Syntax.SimpleLambdaExpression(parameter, arrowToken, body);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SimpleLambdaExpressionSyntax WithParameter(ParameterSyntax parameter)
    {
        return this.Update(parameter, this.ArrowToken, this.Body);
    }

    public SimpleLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken)
    {
        return this.Update(this.Parameter, arrowToken, this.Body);
    }

    public SimpleLambdaExpressionSyntax WithBody(SyntaxNode body)
    {
        return this.Update(this.Parameter, this.ArrowToken, body);
    }

    public SimpleLambdaExpressionSyntax AddParameterAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithParameter(this.Parameter.WithAttributes(this.Parameter.Attributes.Add(items)));
    }

    public SimpleLambdaExpressionSyntax AddParameterModifiers(params SyntaxToken[] items)
    {
        return this.WithParameter(this.Parameter.WithModifiers(this.Parameter.Modifiers.Add(items)));
    }
  }

  /// <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
  public sealed partial class ParenthesizedLambdaExpressionSyntax : ExpressionSyntax
  {
    private ParameterListSyntax parameterList;
    private SyntaxNode body;

    internal ParenthesizedLambdaExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
    public ParameterListSyntax ParameterList 
    {
      get { return this.GetRed(ref this.parameterList, 0); }
    }

    /// <summary>SyntaxToken representing equals greater than.</summary>
    public SyntaxToken ArrowToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SyntaxNode representing the body of the lambda expression.</summary>
    public SyntaxNode Body 
    {
      get { return this.GetRed(ref this.body, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.parameterList, 0);
            case 2: return this.GetRed(ref this.body, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.parameterList;
            case 2: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParenthesizedLambdaExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitParenthesizedLambdaExpression(this);
    }

    public ParenthesizedLambdaExpressionSyntax Update(ParameterListSyntax parameterList, SyntaxToken arrowToken, SyntaxNode body)
    {
        if (parameterList != this.ParameterList || arrowToken != this.ArrowToken || body != this.Body)
        {
            var newNode = Syntax.ParenthesizedLambdaExpression(parameterList, arrowToken, body);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ParenthesizedLambdaExpressionSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(parameterList, this.ArrowToken, this.Body);
    }

    public ParenthesizedLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken)
    {
        return this.Update(this.ParameterList, arrowToken, this.Body);
    }

    public ParenthesizedLambdaExpressionSyntax WithBody(SyntaxNode body)
    {
        return this.Update(this.ParameterList, this.ArrowToken, body);
    }

    public ParenthesizedLambdaExpressionSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.Add(items)));
    }
  }

  /// <summary>Class which represents the syntax node for initializer expression.</summary>
  public sealed partial class InitializerExpressionSyntax : ExpressionSyntax
  {
    private SyntaxNode expressions;

    internal InitializerExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the open brace.</summary>
    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
    public SeparatedSyntaxList<ExpressionSyntax> Expressions 
    {
      get { return new SeparatedSyntaxList<ExpressionSyntax>(this.GetRed(ref this.expressions, 1), this.GetChildIndex(1)); }
    }

    /// <summary>SyntaxToken representing the close brace.</summary>
    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expressions, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expressions;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInitializerExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitInitializerExpression(this);
    }

    public InitializerExpressionSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || expressions != this.Expressions || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = Syntax.InitializerExpression(this.Kind, openBraceToken, expressions, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InitializerExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(openBraceToken, this.Expressions, this.CloseBraceToken);
    }

    public InitializerExpressionSyntax WithExpressions(SeparatedSyntaxList<ExpressionSyntax> expressions)
    {
        return this.Update(this.OpenBraceToken, expressions, this.CloseBraceToken);
    }

    public InitializerExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.OpenBraceToken, this.Expressions, closeBraceToken);
    }

    public InitializerExpressionSyntax AddExpressions(params ExpressionSyntax[] items)
    {
        return this.WithExpressions(this.Expressions.Add(items));
    }
  }

  /// <summary>Class which represents the syntax node for object creation expression.</summary>
  public sealed partial class ObjectCreationExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;
    private ArgumentListSyntax argumentList;
    private InitializerExpressionSyntax initializer;

    internal ObjectCreationExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>TypeSyntax representing the type of the object being created.</summary>
    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 1); }
    }

    /// <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
    public ArgumentListSyntax ArgumentList 
    {
      get { return this.GetRed(ref this.argumentList, 2); }
    }

    /// <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
    public InitializerExpressionSyntax Initializer 
    {
      get { return this.GetRed(ref this.initializer, 3); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            case 2: return this.GetRed(ref this.argumentList, 2);
            case 3: return this.GetRed(ref this.initializer, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            case 2: return this.argumentList;
            case 3: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitObjectCreationExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitObjectCreationExpression(this);
    }

    public ObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || type != this.Type || argumentList != this.ArgumentList || initializer != this.Initializer)
        {
            var newNode = Syntax.ObjectCreationExpression(newKeyword, type, argumentList, initializer);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)
    {
        return this.Update(newKeyword, this.Type, this.ArgumentList, this.Initializer);
    }

    public ObjectCreationExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.NewKeyword, type, this.ArgumentList, this.Initializer);
    }

    public ObjectCreationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList)
    {
        return this.Update(this.NewKeyword, this.Type, argumentList, this.Initializer);
    }

    public ObjectCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)
    {
        return this.Update(this.NewKeyword, this.Type, this.ArgumentList, initializer);
    }

    public ObjectCreationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        var argumentList = this.ArgumentList ?? Syntax.ArgumentList();
        return this.WithArgumentList(argumentList.WithArguments(argumentList.Arguments.Add(items)));
    }
  }

  public sealed partial class AnonymousObjectMemberDeclaratorSyntax : SyntaxNode
  {
    private NameEqualsSyntax nameEquals;
    private ExpressionSyntax expression;

    internal AnonymousObjectMemberDeclaratorSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>NameEqualsSyntax representing the optional name of the property being initialized.</summary>
    public NameEqualsSyntax NameEquals 
    {
      get { return this.GetRed(ref this.nameEquals, 0); }
    }

    /// <summary>ExpressionSyntax representing the value the property is initialized with.</summary>
    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 1); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.nameEquals, 0);
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameEquals;
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousObjectMemberDeclarator(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAnonymousObjectMemberDeclarator(this);
    }

    public AnonymousObjectMemberDeclaratorSyntax Update(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
        if (nameEquals != this.NameEquals || expression != this.Expression)
        {
            var newNode = Syntax.AnonymousObjectMemberDeclarator(nameEquals, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AnonymousObjectMemberDeclaratorSyntax WithNameEquals(NameEqualsSyntax nameEquals)
    {
        return this.Update(nameEquals, this.Expression);
    }

    public AnonymousObjectMemberDeclaratorSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.NameEquals, expression);
    }
  }

  /// <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
  public sealed partial class AnonymousObjectCreationExpressionSyntax : ExpressionSyntax
  {
    private SyntaxNode initializers;

    internal AnonymousObjectCreationExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>SyntaxToken representing the open brace.</summary>
    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SeparatedSyntaxList of AnonymousObjectPropertyInitializerSyntax representing the list of object property initializers.</summary>
    public SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> Initializers 
    {
      get { return new SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>(this.GetRed(ref this.initializers, 2), this.GetChildIndex(2)); }
    }

    /// <summary>SyntaxToken representing the close brace.</summary>
    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.initializers, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.initializers;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousObjectCreationExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAnonymousObjectCreationExpression(this);
    }

    public AnonymousObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
        if (newKeyword != this.NewKeyword || openBraceToken != this.OpenBraceToken || initializers != this.Initializers || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = Syntax.AnonymousObjectCreationExpression(newKeyword, openBraceToken, initializers, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AnonymousObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)
    {
        return this.Update(newKeyword, this.OpenBraceToken, this.Initializers, this.CloseBraceToken);
    }

    public AnonymousObjectCreationExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.NewKeyword, openBraceToken, this.Initializers, this.CloseBraceToken);
    }

    public AnonymousObjectCreationExpressionSyntax WithInitializers(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers)
    {
        return this.Update(this.NewKeyword, this.OpenBraceToken, initializers, this.CloseBraceToken);
    }

    public AnonymousObjectCreationExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.NewKeyword, this.OpenBraceToken, this.Initializers, closeBraceToken);
    }

    public AnonymousObjectCreationExpressionSyntax AddInitializers(params AnonymousObjectMemberDeclaratorSyntax[] items)
    {
        return this.WithInitializers(this.Initializers.Add(items));
    }
  }

  /// <summary>Class which represents the syntax node for array creation expression.</summary>
  public sealed partial class ArrayCreationExpressionSyntax : ExpressionSyntax
  {
    private ArrayTypeSyntax type;
    private InitializerExpressionSyntax initializer;

    internal ArrayCreationExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>ArrayTypeSyntax node representing the type of the array.</summary>
    public ArrayTypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 1); }
    }

    /// <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
    public InitializerExpressionSyntax Initializer 
    {
      get { return this.GetRed(ref this.initializer, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            case 2: return this.GetRed(ref this.initializer, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            case 2: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayCreationExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitArrayCreationExpression(this);
    }

    public ArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || type != this.Type || initializer != this.Initializer)
        {
            var newNode = Syntax.ArrayCreationExpression(newKeyword, type, initializer);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)
    {
        return this.Update(newKeyword, this.Type, this.Initializer);
    }

    public ArrayCreationExpressionSyntax WithType(ArrayTypeSyntax type)
    {
        return this.Update(this.NewKeyword, type, this.Initializer);
    }

    public ArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)
    {
        return this.Update(this.NewKeyword, this.Type, initializer);
    }

    public ArrayCreationExpressionSyntax AddTypeRankSpecifiers(params ArrayRankSpecifierSyntax[] items)
    {
        return this.WithType(this.Type.WithRankSpecifiers(this.Type.RankSpecifiers.Add(items)));
    }
  }

  /// <summary>Class which represents the syntax node for implicit array creation expression.</summary>
  public sealed partial class ImplicitArrayCreationExpressionSyntax : ExpressionSyntax
  {
    private InitializerExpressionSyntax initializer;

    internal ImplicitArrayCreationExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>SyntaxToken representing the open bracket.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
    public SyntaxTokenList Commas 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>SyntaxToken representing the close bracket.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
    public InitializerExpressionSyntax Initializer 
    {
      get { return this.GetRed(ref this.initializer, 4); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 4: return this.GetRed(ref this.initializer, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 4: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitImplicitArrayCreationExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitImplicitArrayCreationExpression(this);
    }

    public ImplicitArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || openBracketToken != this.OpenBracketToken || commas != this.Commas || closeBracketToken != this.CloseBracketToken || initializer != this.Initializer)
        {
            var newNode = Syntax.ImplicitArrayCreationExpression(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ImplicitArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)
    {
        return this.Update(newKeyword, this.OpenBracketToken, this.Commas, this.CloseBracketToken, this.Initializer);
    }

    public ImplicitArrayCreationExpressionSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(this.NewKeyword, openBracketToken, this.Commas, this.CloseBracketToken, this.Initializer);
    }

    public ImplicitArrayCreationExpressionSyntax WithCommas(SyntaxTokenList commas)
    {
        return this.Update(this.NewKeyword, this.OpenBracketToken, commas, this.CloseBracketToken, this.Initializer);
    }

    public ImplicitArrayCreationExpressionSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.NewKeyword, this.OpenBracketToken, this.Commas, closeBracketToken, this.Initializer);
    }

    public ImplicitArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)
    {
        return this.Update(this.NewKeyword, this.OpenBracketToken, this.Commas, this.CloseBracketToken, initializer);
    }

    public ImplicitArrayCreationExpressionSyntax AddCommas(params SyntaxToken[] items)
    {
        return this.WithCommas(this.Commas.Add(items));
    }

    public ImplicitArrayCreationExpressionSyntax AddInitializerExpressions(params ExpressionSyntax[] items)
    {
        return this.WithInitializer(this.Initializer.WithExpressions(this.Initializer.Expressions.Add(items)));
    }
  }

  /// <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
  public sealed partial class StackAllocArrayCreationExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;

    internal StackAllocArrayCreationExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the stackalloc keyword.</summary>
    public SyntaxToken StackAllocKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 1); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitStackAllocArrayCreationExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitStackAllocArrayCreationExpression(this);
    }

    public StackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, TypeSyntax type)
    {
        if (stackAllocKeyword != this.StackAllocKeyword || type != this.Type)
        {
            var newNode = Syntax.StackAllocArrayCreationExpression(stackAllocKeyword, type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public StackAllocArrayCreationExpressionSyntax WithStackAllocKeyword(SyntaxToken stackAllocKeyword)
    {
        return this.Update(stackAllocKeyword, this.Type);
    }

    public StackAllocArrayCreationExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.StackAllocKeyword, type);
    }
  }

  public abstract partial class QueryClauseSyntax : SyntaxNode
  {
    internal QueryClauseSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }
  }

  public abstract partial class SelectOrGroupClauseSyntax : SyntaxNode
  {
    internal SelectOrGroupClauseSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }
  }

  public sealed partial class QueryExpressionSyntax : ExpressionSyntax
  {
    private FromClauseSyntax fromClause;
    private QueryBodySyntax body;

    internal QueryExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public FromClauseSyntax FromClause 
    {
      get { return this.GetRed(ref this.fromClause, 0); }
    }

    public QueryBodySyntax Body 
    {
      get { return this.GetRed(ref this.body, 1); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.fromClause, 0);
            case 1: return this.GetRed(ref this.body, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.fromClause;
            case 1: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitQueryExpression(this);
    }

    public QueryExpressionSyntax Update(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
        if (fromClause != this.FromClause || body != this.Body)
        {
            var newNode = Syntax.QueryExpression(fromClause, body);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public QueryExpressionSyntax WithFromClause(FromClauseSyntax fromClause)
    {
        return this.Update(fromClause, this.Body);
    }

    public QueryExpressionSyntax WithBody(QueryBodySyntax body)
    {
        return this.Update(this.FromClause, body);
    }

    public QueryExpressionSyntax AddBodyClauses(params QueryClauseSyntax[] items)
    {
        return this.WithBody(this.Body.WithClauses(this.Body.Clauses.Add(items)));
    }
  }

  public sealed partial class QueryBodySyntax : SyntaxNode
  {
    private SyntaxNode clauses;
    private SelectOrGroupClauseSyntax selectOrGroup;
    private QueryContinuationSyntax continuation;

    internal QueryBodySyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxList<QueryClauseSyntax> Clauses 
    {
      get { return new SyntaxList<QueryClauseSyntax>(this.GetRed(ref this.clauses, 0)); }
    }

    public SelectOrGroupClauseSyntax SelectOrGroup 
    {
      get { return this.GetRed(ref this.selectOrGroup, 1); }
    }

    public QueryContinuationSyntax Continuation 
    {
      get { return this.GetRed(ref this.continuation, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.clauses, 0);
            case 1: return this.GetRed(ref this.selectOrGroup, 1);
            case 2: return this.GetRed(ref this.continuation, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.clauses;
            case 1: return this.selectOrGroup;
            case 2: return this.continuation;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryBody(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitQueryBody(this);
    }

    public QueryBodySyntax Update(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
        if (clauses != this.Clauses || selectOrGroup != this.SelectOrGroup || continuation != this.Continuation)
        {
            var newNode = Syntax.QueryBody(clauses, selectOrGroup, continuation);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public QueryBodySyntax WithClauses(SyntaxList<QueryClauseSyntax> clauses)
    {
        return this.Update(clauses, this.SelectOrGroup, this.Continuation);
    }

    public QueryBodySyntax WithSelectOrGroup(SelectOrGroupClauseSyntax selectOrGroup)
    {
        return this.Update(this.Clauses, selectOrGroup, this.Continuation);
    }

    public QueryBodySyntax WithContinuation(QueryContinuationSyntax continuation)
    {
        return this.Update(this.Clauses, this.SelectOrGroup, continuation);
    }

    public QueryBodySyntax AddClauses(params QueryClauseSyntax[] items)
    {
        return this.WithClauses(this.Clauses.Add(items));
    }
  }

  public sealed partial class FromClauseSyntax : QueryClauseSyntax
  {
    private TypeSyntax type;
    private ExpressionSyntax expression;

    internal FromClauseSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken FromKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 1); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken InKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 4); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            case 4: return this.GetRed(ref this.expression, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            case 4: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFromClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitFromClause(this);
    }

    public FromClauseSyntax Update(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
        if (fromKeyword != this.FromKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression)
        {
            var newNode = Syntax.FromClause(fromKeyword, type, identifier, inKeyword, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public FromClauseSyntax WithFromKeyword(SyntaxToken fromKeyword)
    {
        return this.Update(fromKeyword, this.Type, this.Identifier, this.InKeyword, this.Expression);
    }

    public FromClauseSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.FromKeyword, type, this.Identifier, this.InKeyword, this.Expression);
    }

    public FromClauseSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.FromKeyword, this.Type, identifier, this.InKeyword, this.Expression);
    }

    public FromClauseSyntax WithInKeyword(SyntaxToken inKeyword)
    {
        return this.Update(this.FromKeyword, this.Type, this.Identifier, inKeyword, this.Expression);
    }

    public FromClauseSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.FromKeyword, this.Type, this.Identifier, this.InKeyword, expression);
    }
  }

  public sealed partial class LetClauseSyntax : QueryClauseSyntax
  {
    private ExpressionSyntax expression;

    internal LetClauseSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken LetKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 3); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 3: return this.GetRed(ref this.expression, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 3: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLetClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitLetClause(this);
    }

    public LetClauseSyntax Update(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
        if (letKeyword != this.LetKeyword || identifier != this.Identifier || equalsToken != this.EqualsToken || expression != this.Expression)
        {
            var newNode = Syntax.LetClause(letKeyword, identifier, equalsToken, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LetClauseSyntax WithLetKeyword(SyntaxToken letKeyword)
    {
        return this.Update(letKeyword, this.Identifier, this.EqualsToken, this.Expression);
    }

    public LetClauseSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.LetKeyword, identifier, this.EqualsToken, this.Expression);
    }

    public LetClauseSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(this.LetKeyword, this.Identifier, equalsToken, this.Expression);
    }

    public LetClauseSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.LetKeyword, this.Identifier, this.EqualsToken, expression);
    }
  }

  public sealed partial class JoinClauseSyntax : QueryClauseSyntax
  {
    private TypeSyntax type;
    private ExpressionSyntax inExpression;
    private ExpressionSyntax leftExpression;
    private ExpressionSyntax rightExpression;
    private JoinIntoClauseSyntax into;

    internal JoinClauseSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken JoinKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 1); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken InKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public ExpressionSyntax InExpression 
    {
      get { return this.GetRed(ref this.inExpression, 4); }
    }

    public SyntaxToken OnKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(5), this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public ExpressionSyntax LeftExpression 
    {
      get { return this.GetRed(ref this.leftExpression, 6); }
    }

    public SyntaxToken EqualsKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(7), this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    public ExpressionSyntax RightExpression 
    {
      get { return this.GetRed(ref this.rightExpression, 8); }
    }

    public JoinIntoClauseSyntax Into 
    {
      get { return this.GetRed(ref this.into, 9); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            case 4: return this.GetRed(ref this.inExpression, 4);
            case 6: return this.GetRed(ref this.leftExpression, 6);
            case 8: return this.GetRed(ref this.rightExpression, 8);
            case 9: return this.GetRed(ref this.into, 9);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            case 4: return this.inExpression;
            case 6: return this.leftExpression;
            case 8: return this.rightExpression;
            case 9: return this.into;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitJoinClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitJoinClause(this);
    }

    public JoinClauseSyntax Update(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
        if (joinKeyword != this.JoinKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || inExpression != this.InExpression || onKeyword != this.OnKeyword || leftExpression != this.LeftExpression || equalsKeyword != this.EqualsKeyword || rightExpression != this.RightExpression || into != this.Into)
        {
            var newNode = Syntax.JoinClause(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public JoinClauseSyntax WithJoinKeyword(SyntaxToken joinKeyword)
    {
        return this.Update(joinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.JoinKeyword, type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.JoinKeyword, this.Type, identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithInKeyword(SyntaxToken inKeyword)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, inKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithInExpression(ExpressionSyntax inExpression)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, inExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithOnKeyword(SyntaxToken onKeyword)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, onKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithLeftExpression(ExpressionSyntax leftExpression)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, leftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithEqualsKeyword(SyntaxToken equalsKeyword)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, equalsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithRightExpression(ExpressionSyntax rightExpression)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, rightExpression, this.Into);
    }

    public JoinClauseSyntax WithInto(JoinIntoClauseSyntax into)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, into);
    }
  }

  public sealed partial class JoinIntoClauseSyntax : SyntaxNode
  {
    internal JoinIntoClauseSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken IntoKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitJoinIntoClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitJoinIntoClause(this);
    }

    public JoinIntoClauseSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
        if (intoKeyword != this.IntoKeyword || identifier != this.Identifier)
        {
            var newNode = Syntax.JoinIntoClause(intoKeyword, identifier);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public JoinIntoClauseSyntax WithIntoKeyword(SyntaxToken intoKeyword)
    {
        return this.Update(intoKeyword, this.Identifier);
    }

    public JoinIntoClauseSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.IntoKeyword, identifier);
    }
  }

  public sealed partial class WhereClauseSyntax : QueryClauseSyntax
  {
    private ExpressionSyntax condition;

    internal WhereClauseSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken WhereKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public ExpressionSyntax Condition 
    {
      get { return this.GetRed(ref this.condition, 1); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.condition, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.condition;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhereClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitWhereClause(this);
    }

    public WhereClauseSyntax Update(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
        if (whereKeyword != this.WhereKeyword || condition != this.Condition)
        {
            var newNode = Syntax.WhereClause(whereKeyword, condition);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public WhereClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword)
    {
        return this.Update(whereKeyword, this.Condition);
    }

    public WhereClauseSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.WhereKeyword, condition);
    }
  }

  public sealed partial class OrderByClauseSyntax : QueryClauseSyntax
  {
    private SyntaxNode orderings;

    internal OrderByClauseSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken OrderByKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SeparatedSyntaxList<OrderingSyntax> Orderings 
    {
      get { return new SeparatedSyntaxList<OrderingSyntax>(this.GetRed(ref this.orderings, 1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.orderings, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.orderings;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOrderByClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitOrderByClause(this);
    }

    public OrderByClauseSyntax Update(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings)
    {
        if (orderByKeyword != this.OrderByKeyword || orderings != this.Orderings)
        {
            var newNode = Syntax.OrderByClause(orderByKeyword, orderings);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OrderByClauseSyntax WithOrderByKeyword(SyntaxToken orderByKeyword)
    {
        return this.Update(orderByKeyword, this.Orderings);
    }

    public OrderByClauseSyntax WithOrderings(SeparatedSyntaxList<OrderingSyntax> orderings)
    {
        return this.Update(this.OrderByKeyword, orderings);
    }

    public OrderByClauseSyntax AddOrderings(params OrderingSyntax[] items)
    {
        return this.WithOrderings(this.Orderings.Add(items));
    }
  }

  public sealed partial class OrderingSyntax : SyntaxNode
  {
    private ExpressionSyntax expression;

    internal OrderingSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 0); }
    }

    public SyntaxToken AscendingOrDescendingKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.expression, 0);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOrdering(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitOrdering(this);
    }

    public OrderingSyntax Update(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
        if (expression != this.Expression || ascendingOrDescendingKeyword != this.AscendingOrDescendingKeyword)
        {
            var newNode = Syntax.Ordering(this.Kind, expression, ascendingOrDescendingKeyword);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OrderingSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.AscendingOrDescendingKeyword);
    }

    public OrderingSyntax WithAscendingOrDescendingKeyword(SyntaxToken ascendingOrDescendingKeyword)
    {
        return this.Update(this.Expression, ascendingOrDescendingKeyword);
    }
  }

  public sealed partial class SelectClauseSyntax : SelectOrGroupClauseSyntax
  {
    private ExpressionSyntax expression;

    internal SelectClauseSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken SelectKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 1); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSelectClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitSelectClause(this);
    }

    public SelectClauseSyntax Update(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
        if (selectKeyword != this.SelectKeyword || expression != this.Expression)
        {
            var newNode = Syntax.SelectClause(selectKeyword, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SelectClauseSyntax WithSelectKeyword(SyntaxToken selectKeyword)
    {
        return this.Update(selectKeyword, this.Expression);
    }

    public SelectClauseSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.SelectKeyword, expression);
    }
  }

  public sealed partial class GroupClauseSyntax : SelectOrGroupClauseSyntax
  {
    private ExpressionSyntax groupExpression;
    private ExpressionSyntax byExpression;

    internal GroupClauseSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken GroupKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public ExpressionSyntax GroupExpression 
    {
      get { return this.GetRed(ref this.groupExpression, 1); }
    }

    public SyntaxToken ByKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public ExpressionSyntax ByExpression 
    {
      get { return this.GetRed(ref this.byExpression, 3); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.groupExpression, 1);
            case 3: return this.GetRed(ref this.byExpression, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.groupExpression;
            case 3: return this.byExpression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGroupClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitGroupClause(this);
    }

    public GroupClauseSyntax Update(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
        if (groupKeyword != this.GroupKeyword || groupExpression != this.GroupExpression || byKeyword != this.ByKeyword || byExpression != this.ByExpression)
        {
            var newNode = Syntax.GroupClause(groupKeyword, groupExpression, byKeyword, byExpression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public GroupClauseSyntax WithGroupKeyword(SyntaxToken groupKeyword)
    {
        return this.Update(groupKeyword, this.GroupExpression, this.ByKeyword, this.ByExpression);
    }

    public GroupClauseSyntax WithGroupExpression(ExpressionSyntax groupExpression)
    {
        return this.Update(this.GroupKeyword, groupExpression, this.ByKeyword, this.ByExpression);
    }

    public GroupClauseSyntax WithByKeyword(SyntaxToken byKeyword)
    {
        return this.Update(this.GroupKeyword, this.GroupExpression, byKeyword, this.ByExpression);
    }

    public GroupClauseSyntax WithByExpression(ExpressionSyntax byExpression)
    {
        return this.Update(this.GroupKeyword, this.GroupExpression, this.ByKeyword, byExpression);
    }
  }

  public sealed partial class QueryContinuationSyntax : SyntaxNode
  {
    private QueryBodySyntax body;

    internal QueryContinuationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken IntoKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public QueryBodySyntax Body 
    {
      get { return this.GetRed(ref this.body, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.body, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryContinuation(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitQueryContinuation(this);
    }

    public QueryContinuationSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
        if (intoKeyword != this.IntoKeyword || identifier != this.Identifier || body != this.Body)
        {
            var newNode = Syntax.QueryContinuation(intoKeyword, identifier, body);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public QueryContinuationSyntax WithIntoKeyword(SyntaxToken intoKeyword)
    {
        return this.Update(intoKeyword, this.Identifier, this.Body);
    }

    public QueryContinuationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.IntoKeyword, identifier, this.Body);
    }

    public QueryContinuationSyntax WithBody(QueryBodySyntax body)
    {
        return this.Update(this.IntoKeyword, this.Identifier, body);
    }

    public QueryContinuationSyntax AddBodyClauses(params QueryClauseSyntax[] items)
    {
        return this.WithBody(this.Body.WithClauses(this.Body.Clauses.Add(items)));
    }
  }

  /// <summary>Class which represents a placeholder in an array size list.</summary>
  public sealed partial class OmittedArraySizeExpressionSyntax : ExpressionSyntax
  {
    internal OmittedArraySizeExpressionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the omitted array size expression.</summary>
    public SyntaxToken OmittedArraySizeExpressionToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOmittedArraySizeExpression(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitOmittedArraySizeExpression(this);
    }

    public OmittedArraySizeExpressionSyntax Update(SyntaxToken omittedArraySizeExpressionToken)
    {
        if (omittedArraySizeExpressionToken != this.OmittedArraySizeExpressionToken)
        {
            var newNode = Syntax.OmittedArraySizeExpression(omittedArraySizeExpressionToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OmittedArraySizeExpressionSyntax WithOmittedArraySizeExpressionToken(SyntaxToken omittedArraySizeExpressionToken)
    {
        return this.Update(omittedArraySizeExpressionToken);
    }
  }

  public sealed partial class GlobalStatementSyntax : MemberDeclarationSyntax
  {
    private StatementSyntax statement;

    internal GlobalStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public StatementSyntax Statement 
    {
      get { return this.GetRed(ref this.statement, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.statement, 0);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGlobalStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitGlobalStatement(this);
    }

    public GlobalStatementSyntax Update(StatementSyntax statement)
    {
        if (statement != this.Statement)
        {
            var newNode = Syntax.GlobalStatement(statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public GlobalStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(statement);
    }
  }

  /// <summary>Represents the base class for all statements syntax classes.</summary>
  public abstract partial class StatementSyntax : SyntaxNode
  {
    internal StatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }
  }

  public sealed partial class BlockSyntax : StatementSyntax
  {
    private SyntaxNode statements;

    internal BlockSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxList<StatementSyntax> Statements 
    {
      get { return new SyntaxList<StatementSyntax>(this.GetRed(ref this.statements, 1)); }
    }

    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.statements, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.statements;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBlock(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBlock(this);
    }

    public BlockSyntax Update(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || statements != this.Statements || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = Syntax.Block(openBraceToken, statements, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BlockSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(openBraceToken, this.Statements, this.CloseBraceToken);
    }

    public BlockSyntax WithStatements(SyntaxList<StatementSyntax> statements)
    {
        return this.Update(this.OpenBraceToken, statements, this.CloseBraceToken);
    }

    public BlockSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.OpenBraceToken, this.Statements, closeBraceToken);
    }

    public BlockSyntax AddStatements(params StatementSyntax[] items)
    {
        return this.WithStatements(this.Statements.Add(items));
    }
  }

  public sealed partial class LocalDeclarationStatementSyntax : StatementSyntax
  {
    private VariableDeclarationSyntax declaration;

    internal LocalDeclarationStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the modifier list.</summary>
    public SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public VariableDeclarationSyntax Declaration 
    {
      get { return this.GetRed(ref this.declaration, 1); }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.declaration, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.declaration;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLocalDeclarationStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitLocalDeclarationStatement(this);
    }

    public LocalDeclarationStatementSyntax Update(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.LocalDeclarationStatement(modifiers, declaration, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LocalDeclarationStatementSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(modifiers, this.Declaration, this.SemicolonToken);
    }

    public LocalDeclarationStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.Modifiers, declaration, this.SemicolonToken);
    }

    public LocalDeclarationStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Modifiers, this.Declaration, semicolonToken);
    }

    public LocalDeclarationStatementSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public LocalDeclarationStatementSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)
    {
        return this.WithDeclaration(this.Declaration.WithVariables(this.Declaration.Variables.Add(items)));
    }
  }

  public sealed partial class VariableDeclarationSyntax : SyntaxNode
  {
    private TypeSyntax type;
    private SyntaxNode variables;

    internal VariableDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 0); }
    }

    public SeparatedSyntaxList<VariableDeclaratorSyntax> Variables 
    {
      get { return new SeparatedSyntaxList<VariableDeclaratorSyntax>(this.GetRed(ref this.variables, 1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.type, 0);
            case 1: return this.GetRed(ref this.variables, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.variables;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitVariableDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitVariableDeclaration(this);
    }

    public VariableDeclarationSyntax Update(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
    {
        if (type != this.Type || variables != this.Variables)
        {
            var newNode = Syntax.VariableDeclaration(type, variables);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public VariableDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(type, this.Variables);
    }

    public VariableDeclarationSyntax WithVariables(SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
    {
        return this.Update(this.Type, variables);
    }

    public VariableDeclarationSyntax AddVariables(params VariableDeclaratorSyntax[] items)
    {
        return this.WithVariables(this.Variables.Add(items));
    }
  }

  public sealed partial class VariableDeclaratorSyntax : SyntaxNode
  {
    private BracketedArgumentListSyntax argumentList;
    private EqualsValueClauseSyntax initializer;

    internal VariableDeclaratorSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public BracketedArgumentListSyntax ArgumentList 
    {
      get { return this.GetRed(ref this.argumentList, 1); }
    }

    public EqualsValueClauseSyntax Initializer 
    {
      get { return this.GetRed(ref this.initializer, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.argumentList, 1);
            case 2: return this.GetRed(ref this.initializer, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.argumentList;
            case 2: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitVariableDeclarator(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitVariableDeclarator(this);
    }

    public VariableDeclaratorSyntax Update(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
        if (identifier != this.Identifier || argumentList != this.ArgumentList || initializer != this.Initializer)
        {
            var newNode = Syntax.VariableDeclarator(identifier, argumentList, initializer);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public VariableDeclaratorSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier, this.ArgumentList, this.Initializer);
    }

    public VariableDeclaratorSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)
    {
        return this.Update(this.Identifier, argumentList, this.Initializer);
    }

    public VariableDeclaratorSyntax WithInitializer(EqualsValueClauseSyntax initializer)
    {
        return this.Update(this.Identifier, this.ArgumentList, initializer);
    }

    public VariableDeclaratorSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        var argumentList = this.ArgumentList ?? Syntax.BracketedArgumentList();
        return this.WithArgumentList(argumentList.WithArguments(argumentList.Arguments.Add(items)));
    }
  }

  public sealed partial class EqualsValueClauseSyntax : SyntaxNode
  {
    private ExpressionSyntax value;

    internal EqualsValueClauseSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public ExpressionSyntax Value 
    {
      get { return this.GetRed(ref this.value, 1); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.value, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.value;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEqualsValueClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEqualsValueClause(this);
    }

    public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, ExpressionSyntax value)
    {
        if (equalsToken != this.EqualsToken || value != this.Value)
        {
            var newNode = Syntax.EqualsValueClause(equalsToken, value);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EqualsValueClauseSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(equalsToken, this.Value);
    }

    public EqualsValueClauseSyntax WithValue(ExpressionSyntax value)
    {
        return this.Update(this.EqualsToken, value);
    }
  }

  public sealed partial class ExpressionStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;

    internal ExpressionStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 0); }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.expression, 0);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExpressionStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitExpressionStatement(this);
    }

    public ExpressionStatementSyntax Update(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ExpressionStatement(expression, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ExpressionStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.SemicolonToken);
    }

    public ExpressionStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Expression, semicolonToken);
    }
  }

  public sealed partial class EmptyStatementSyntax : StatementSyntax
  {
    internal EmptyStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEmptyStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEmptyStatement(this);
    }

    public EmptyStatementSyntax Update(SyntaxToken semicolonToken)
    {
        if (semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.EmptyStatement(semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EmptyStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(semicolonToken);
    }
  }

  /// <summary>Represents a labeled statement syntax.</summary>
  public sealed partial class LabeledStatementSyntax : StatementSyntax
  {
    private StatementSyntax statement;

    internal LabeledStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>Gets a SyntaxToken that represents the colon succeeding the statement's label.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public StatementSyntax Statement 
    {
      get { return this.GetRed(ref this.statement, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.statement, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLabeledStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitLabeledStatement(this);
    }

    public LabeledStatementSyntax Update(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken || statement != this.Statement)
        {
            var newNode = Syntax.LabeledStatement(identifier, colonToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LabeledStatementSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier, this.ColonToken, this.Statement);
    }

    public LabeledStatementSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Identifier, colonToken, this.Statement);
    }

    public LabeledStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.Identifier, this.ColonToken, statement);
    }
  }

  /// <summary>
  /// Represents a goto statement syntax
  /// </summary>
  public sealed partial class GotoStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;

    internal GotoStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the goto keyword.
    /// </summary>
    public SyntaxToken GotoKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken CaseOrDefaultKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>
    /// Gets a constant expression for a goto case statement.
    /// </summary>
    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 2); }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the semi-colon at the end of the statement.
    /// </summary>
    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGotoStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitGotoStatement(this);
    }

    public GotoStatementSyntax Update(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (gotoKeyword != this.GotoKeyword || caseOrDefaultKeyword != this.CaseOrDefaultKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.GotoStatement(this.Kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public GotoStatementSyntax WithGotoKeyword(SyntaxToken gotoKeyword)
    {
        return this.Update(gotoKeyword, this.CaseOrDefaultKeyword, this.Expression, this.SemicolonToken);
    }

    public GotoStatementSyntax WithCaseOrDefaultKeyword(SyntaxToken caseOrDefaultKeyword)
    {
        return this.Update(this.GotoKeyword, caseOrDefaultKeyword, this.Expression, this.SemicolonToken);
    }

    public GotoStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.GotoKeyword, this.CaseOrDefaultKeyword, expression, this.SemicolonToken);
    }

    public GotoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.GotoKeyword, this.CaseOrDefaultKeyword, this.Expression, semicolonToken);
    }
  }

  public sealed partial class BreakStatementSyntax : StatementSyntax
  {
    internal BreakStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken BreakKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBreakStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBreakStatement(this);
    }

    public BreakStatementSyntax Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
        if (breakKeyword != this.BreakKeyword || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.BreakStatement(breakKeyword, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BreakStatementSyntax WithBreakKeyword(SyntaxToken breakKeyword)
    {
        return this.Update(breakKeyword, this.SemicolonToken);
    }

    public BreakStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.BreakKeyword, semicolonToken);
    }
  }

  public sealed partial class ContinueStatementSyntax : StatementSyntax
  {
    internal ContinueStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken ContinueKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitContinueStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitContinueStatement(this);
    }

    public ContinueStatementSyntax Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
        if (continueKeyword != this.ContinueKeyword || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ContinueStatement(continueKeyword, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ContinueStatementSyntax WithContinueKeyword(SyntaxToken continueKeyword)
    {
        return this.Update(continueKeyword, this.SemicolonToken);
    }

    public ContinueStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.ContinueKeyword, semicolonToken);
    }
  }

  public sealed partial class ReturnStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;

    internal ReturnStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken ReturnKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 1); }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitReturnStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitReturnStatement(this);
    }

    public ReturnStatementSyntax Update(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (returnKeyword != this.ReturnKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ReturnStatement(returnKeyword, expression, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ReturnStatementSyntax WithReturnKeyword(SyntaxToken returnKeyword)
    {
        return this.Update(returnKeyword, this.Expression, this.SemicolonToken);
    }

    public ReturnStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.ReturnKeyword, expression, this.SemicolonToken);
    }

    public ReturnStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.ReturnKeyword, this.Expression, semicolonToken);
    }
  }

  public sealed partial class ThrowStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;

    internal ThrowStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken ThrowKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 1); }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitThrowStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitThrowStatement(this);
    }

    public ThrowStatementSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (throwKeyword != this.ThrowKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ThrowStatement(throwKeyword, expression, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ThrowStatementSyntax WithThrowKeyword(SyntaxToken throwKeyword)
    {
        return this.Update(throwKeyword, this.Expression, this.SemicolonToken);
    }

    public ThrowStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.ThrowKeyword, expression, this.SemicolonToken);
    }

    public ThrowStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.ThrowKeyword, this.Expression, semicolonToken);
    }
  }

  public sealed partial class YieldStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;

    internal YieldStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken YieldKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken ReturnOrBreakKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 2); }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitYieldStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitYieldStatement(this);
    }

    public YieldStatementSyntax Update(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (yieldKeyword != this.YieldKeyword || returnOrBreakKeyword != this.ReturnOrBreakKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.YieldStatement(this.Kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public YieldStatementSyntax WithYieldKeyword(SyntaxToken yieldKeyword)
    {
        return this.Update(yieldKeyword, this.ReturnOrBreakKeyword, this.Expression, this.SemicolonToken);
    }

    public YieldStatementSyntax WithReturnOrBreakKeyword(SyntaxToken returnOrBreakKeyword)
    {
        return this.Update(this.YieldKeyword, returnOrBreakKeyword, this.Expression, this.SemicolonToken);
    }

    public YieldStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.YieldKeyword, this.ReturnOrBreakKeyword, expression, this.SemicolonToken);
    }

    public YieldStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.YieldKeyword, this.ReturnOrBreakKeyword, this.Expression, semicolonToken);
    }
  }

  public sealed partial class WhileStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax condition;
    private StatementSyntax statement;

    internal WhileStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken WhileKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public ExpressionSyntax Condition 
    {
      get { return this.GetRed(ref this.condition, 2); }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public StatementSyntax Statement 
    {
      get { return this.GetRed(ref this.statement, 4); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.condition, 2);
            case 4: return this.GetRed(ref this.statement, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.condition;
            case 4: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhileStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitWhileStatement(this);
    }

    public WhileStatementSyntax Update(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = Syntax.WhileStatement(whileKeyword, openParenToken, condition, closeParenToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public WhileStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword)
    {
        return this.Update(whileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.Statement);
    }

    public WhileStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.WhileKeyword, openParenToken, this.Condition, this.CloseParenToken, this.Statement);
    }

    public WhileStatementSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.WhileKeyword, this.OpenParenToken, condition, this.CloseParenToken, this.Statement);
    }

    public WhileStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.WhileKeyword, this.OpenParenToken, this.Condition, closeParenToken, this.Statement);
    }

    public WhileStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.WhileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, statement);
    }
  }

  public sealed partial class DoStatementSyntax : StatementSyntax
  {
    private StatementSyntax statement;
    private ExpressionSyntax condition;

    internal DoStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken DoKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public StatementSyntax Statement 
    {
      get { return this.GetRed(ref this.statement, 1); }
    }

    public SyntaxToken WhileKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public ExpressionSyntax Condition 
    {
      get { return this.GetRed(ref this.condition, 4); }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(5), this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(6), this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.statement, 1);
            case 4: return this.GetRed(ref this.condition, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.statement;
            case 4: return this.condition;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDoStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitDoStatement(this);
    }

    public DoStatementSyntax Update(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
        if (doKeyword != this.DoKeyword || statement != this.Statement || whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.DoStatement(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DoStatementSyntax WithDoKeyword(SyntaxToken doKeyword)
    {
        return this.Update(doKeyword, this.Statement, this.WhileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.SemicolonToken);
    }

    public DoStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.DoKeyword, statement, this.WhileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.SemicolonToken);
    }

    public DoStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword)
    {
        return this.Update(this.DoKeyword, this.Statement, whileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.SemicolonToken);
    }

    public DoStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.DoKeyword, this.Statement, this.WhileKeyword, openParenToken, this.Condition, this.CloseParenToken, this.SemicolonToken);
    }

    public DoStatementSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.DoKeyword, this.Statement, this.WhileKeyword, this.OpenParenToken, condition, this.CloseParenToken, this.SemicolonToken);
    }

    public DoStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.DoKeyword, this.Statement, this.WhileKeyword, this.OpenParenToken, this.Condition, closeParenToken, this.SemicolonToken);
    }

    public DoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.DoKeyword, this.Statement, this.WhileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, semicolonToken);
    }
  }

  public sealed partial class ForStatementSyntax : StatementSyntax
  {
    private VariableDeclarationSyntax declaration;
    private SyntaxNode initializers;
    private ExpressionSyntax condition;
    private SyntaxNode incrementors;
    private StatementSyntax statement;

    internal ForStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken ForKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public VariableDeclarationSyntax Declaration 
    {
      get { return this.GetRed(ref this.declaration, 2); }
    }

    public SeparatedSyntaxList<ExpressionSyntax> Initializers 
    {
      get { return new SeparatedSyntaxList<ExpressionSyntax>(this.GetRed(ref this.initializers, 3), this.GetChildIndex(3)); }
    }

    public SyntaxToken FirstSemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(4), this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public ExpressionSyntax Condition 
    {
      get { return this.GetRed(ref this.condition, 5); }
    }

    public SyntaxToken SecondSemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(6), this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    public SeparatedSyntaxList<ExpressionSyntax> Incrementors 
    {
      get { return new SeparatedSyntaxList<ExpressionSyntax>(this.GetRed(ref this.incrementors, 7), this.GetChildIndex(7)); }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(8), this.GetChildPosition(8), this.GetChildIndex(8)); }
    }

    public StatementSyntax Statement 
    {
      get { return this.GetRed(ref this.statement, 9); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.declaration, 2);
            case 3: return this.GetRed(ref this.initializers, 3);
            case 5: return this.GetRed(ref this.condition, 5);
            case 7: return this.GetRed(ref this.incrementors, 7);
            case 9: return this.GetRed(ref this.statement, 9);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.declaration;
            case 3: return this.initializers;
            case 5: return this.condition;
            case 7: return this.incrementors;
            case 9: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitForStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitForStatement(this);
    }

    public ForStatementSyntax Update(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (forKeyword != this.ForKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || initializers != this.Initializers || firstSemicolonToken != this.FirstSemicolonToken || condition != this.Condition || secondSemicolonToken != this.SecondSemicolonToken || incrementors != this.Incrementors || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = Syntax.ForStatement(forKeyword, openParenToken, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ForStatementSyntax WithForKeyword(SyntaxToken forKeyword)
    {
        return this.Update(forKeyword, this.OpenParenToken, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.ForKeyword, openParenToken, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithInitializers(SeparatedSyntaxList<ExpressionSyntax> initializers)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, this.Declaration, initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithFirstSemicolonToken(SyntaxToken firstSemicolonToken)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, this.Declaration, this.Initializers, firstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, this.Declaration, this.Initializers, this.FirstSemicolonToken, condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithSecondSemicolonToken(SyntaxToken secondSemicolonToken)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, secondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithIncrementors(SeparatedSyntaxList<ExpressionSyntax> incrementors)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, closeParenToken, this.Statement);
    }

    public ForStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, statement);
    }

    public ForStatementSyntax AddInitializers(params ExpressionSyntax[] items)
    {
        return this.WithInitializers(this.Initializers.Add(items));
    }

    public ForStatementSyntax AddIncrementors(params ExpressionSyntax[] items)
    {
        return this.WithIncrementors(this.Incrementors.Add(items));
    }
  }

  public sealed partial class ForEachStatementSyntax : StatementSyntax
  {
    private TypeSyntax type;
    private ExpressionSyntax expression;
    private StatementSyntax statement;

    internal ForEachStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken ForEachKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 2); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public SyntaxToken InKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(4), this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 5); }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(6), this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    public StatementSyntax Statement 
    {
      get { return this.GetRed(ref this.statement, 7); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.type, 2);
            case 5: return this.GetRed(ref this.expression, 5);
            case 7: return this.GetRed(ref this.statement, 7);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.type;
            case 5: return this.expression;
            case 7: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitForEachStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitForEachStatement(this);
    }

    public ForEachStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (forEachKeyword != this.ForEachKeyword || openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = Syntax.ForEachStatement(forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ForEachStatementSyntax WithForEachKeyword(SyntaxToken forEachKeyword)
    {
        return this.Update(forEachKeyword, this.OpenParenToken, this.Type, this.Identifier, this.InKeyword, this.Expression, this.CloseParenToken, this.Statement);
    }

    public ForEachStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.ForEachKeyword, openParenToken, this.Type, this.Identifier, this.InKeyword, this.Expression, this.CloseParenToken, this.Statement);
    }

    public ForEachStatementSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.ForEachKeyword, this.OpenParenToken, type, this.Identifier, this.InKeyword, this.Expression, this.CloseParenToken, this.Statement);
    }

    public ForEachStatementSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.ForEachKeyword, this.OpenParenToken, this.Type, identifier, this.InKeyword, this.Expression, this.CloseParenToken, this.Statement);
    }

    public ForEachStatementSyntax WithInKeyword(SyntaxToken inKeyword)
    {
        return this.Update(this.ForEachKeyword, this.OpenParenToken, this.Type, this.Identifier, inKeyword, this.Expression, this.CloseParenToken, this.Statement);
    }

    public ForEachStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.ForEachKeyword, this.OpenParenToken, this.Type, this.Identifier, this.InKeyword, expression, this.CloseParenToken, this.Statement);
    }

    public ForEachStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.ForEachKeyword, this.OpenParenToken, this.Type, this.Identifier, this.InKeyword, this.Expression, closeParenToken, this.Statement);
    }

    public ForEachStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.ForEachKeyword, this.OpenParenToken, this.Type, this.Identifier, this.InKeyword, this.Expression, this.CloseParenToken, statement);
    }
  }

  public sealed partial class UsingStatementSyntax : StatementSyntax
  {
    private VariableDeclarationSyntax declaration;
    private ExpressionSyntax expression;
    private StatementSyntax statement;

    internal UsingStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken UsingKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public VariableDeclarationSyntax Declaration 
    {
      get { return this.GetRed(ref this.declaration, 2); }
    }

    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 3); }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(4), this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public StatementSyntax Statement 
    {
      get { return this.GetRed(ref this.statement, 5); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.declaration, 2);
            case 3: return this.GetRed(ref this.expression, 3);
            case 5: return this.GetRed(ref this.statement, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.declaration;
            case 3: return this.expression;
            case 5: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUsingStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitUsingStatement(this);
    }

    public UsingStatementSyntax Update(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (usingKeyword != this.UsingKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = Syntax.UsingStatement(usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public UsingStatementSyntax WithUsingKeyword(SyntaxToken usingKeyword)
    {
        return this.Update(usingKeyword, this.OpenParenToken, this.Declaration, this.Expression, this.CloseParenToken, this.Statement);
    }

    public UsingStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.UsingKeyword, openParenToken, this.Declaration, this.Expression, this.CloseParenToken, this.Statement);
    }

    public UsingStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.UsingKeyword, this.OpenParenToken, declaration, this.Expression, this.CloseParenToken, this.Statement);
    }

    public UsingStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.UsingKeyword, this.OpenParenToken, this.Declaration, expression, this.CloseParenToken, this.Statement);
    }

    public UsingStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.UsingKeyword, this.OpenParenToken, this.Declaration, this.Expression, closeParenToken, this.Statement);
    }

    public UsingStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.UsingKeyword, this.OpenParenToken, this.Declaration, this.Expression, this.CloseParenToken, statement);
    }
  }

  public sealed partial class FixedStatementSyntax : StatementSyntax
  {
    private VariableDeclarationSyntax declaration;
    private StatementSyntax statement;

    internal FixedStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken FixedKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public VariableDeclarationSyntax Declaration 
    {
      get { return this.GetRed(ref this.declaration, 2); }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public StatementSyntax Statement 
    {
      get { return this.GetRed(ref this.statement, 4); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.declaration, 2);
            case 4: return this.GetRed(ref this.statement, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.declaration;
            case 4: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFixedStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitFixedStatement(this);
    }

    public FixedStatementSyntax Update(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (fixedKeyword != this.FixedKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = Syntax.FixedStatement(fixedKeyword, openParenToken, declaration, closeParenToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public FixedStatementSyntax WithFixedKeyword(SyntaxToken fixedKeyword)
    {
        return this.Update(fixedKeyword, this.OpenParenToken, this.Declaration, this.CloseParenToken, this.Statement);
    }

    public FixedStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.FixedKeyword, openParenToken, this.Declaration, this.CloseParenToken, this.Statement);
    }

    public FixedStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.FixedKeyword, this.OpenParenToken, declaration, this.CloseParenToken, this.Statement);
    }

    public FixedStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.FixedKeyword, this.OpenParenToken, this.Declaration, closeParenToken, this.Statement);
    }

    public FixedStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.FixedKeyword, this.OpenParenToken, this.Declaration, this.CloseParenToken, statement);
    }

    public FixedStatementSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)
    {
        return this.WithDeclaration(this.Declaration.WithVariables(this.Declaration.Variables.Add(items)));
    }
  }

  public sealed partial class CheckedStatementSyntax : StatementSyntax
  {
    private BlockSyntax block;

    internal CheckedStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public BlockSyntax Block 
    {
      get { return this.GetRed(ref this.block, 1); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.block, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.block;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCheckedStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCheckedStatement(this);
    }

    public CheckedStatementSyntax Update(SyntaxToken keyword, BlockSyntax block)
    {
        if (keyword != this.Keyword || block != this.Block)
        {
            var newNode = Syntax.CheckedStatement(this.Kind, keyword, block);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CheckedStatementSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.Block);
    }

    public CheckedStatementSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.Keyword, block);
    }

    public CheckedStatementSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.Add(items)));
    }
  }

  public sealed partial class UnsafeStatementSyntax : StatementSyntax
  {
    private BlockSyntax block;

    internal UnsafeStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken UnsafeKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public BlockSyntax Block 
    {
      get { return this.GetRed(ref this.block, 1); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.block, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.block;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUnsafeStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitUnsafeStatement(this);
    }

    public UnsafeStatementSyntax Update(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
        if (unsafeKeyword != this.UnsafeKeyword || block != this.Block)
        {
            var newNode = Syntax.UnsafeStatement(unsafeKeyword, block);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public UnsafeStatementSyntax WithUnsafeKeyword(SyntaxToken unsafeKeyword)
    {
        return this.Update(unsafeKeyword, this.Block);
    }

    public UnsafeStatementSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.UnsafeKeyword, block);
    }

    public UnsafeStatementSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.Add(items)));
    }
  }

  public sealed partial class LockStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;
    private StatementSyntax statement;

    internal LockStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken LockKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 2); }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public StatementSyntax Statement 
    {
      get { return this.GetRed(ref this.statement, 4); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            case 4: return this.GetRed(ref this.statement, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            case 4: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLockStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitLockStatement(this);
    }

    public LockStatementSyntax Update(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (lockKeyword != this.LockKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = Syntax.LockStatement(lockKeyword, openParenToken, expression, closeParenToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LockStatementSyntax WithLockKeyword(SyntaxToken lockKeyword)
    {
        return this.Update(lockKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, this.Statement);
    }

    public LockStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.LockKeyword, openParenToken, this.Expression, this.CloseParenToken, this.Statement);
    }

    public LockStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.LockKeyword, this.OpenParenToken, expression, this.CloseParenToken, this.Statement);
    }

    public LockStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.LockKeyword, this.OpenParenToken, this.Expression, closeParenToken, this.Statement);
    }

    public LockStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.LockKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, statement);
    }
  }

  /// <summary>
  /// Represents an if statement syntax.
  /// </summary>
  public sealed partial class IfStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax condition;
    private StatementSyntax statement;
    private ElseClauseSyntax @else;

    internal IfStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the if keyword.
    /// </summary>
    public SyntaxToken IfKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
    /// </summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>
    /// Gets an ExpressionSyntax that represents the condition of the if statement.
    /// </summary>
    public ExpressionSyntax Condition 
    {
      get { return this.GetRed(ref this.condition, 2); }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
    /// </summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>
    /// Gets a StatementSyntax the represents the statement to be executed when the condition is true.
    /// </summary>
    public StatementSyntax Statement 
    {
      get { return this.GetRed(ref this.statement, 4); }
    }

    /// <summary>
    /// Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
    /// </summary>
    public ElseClauseSyntax Else 
    {
      get { return this.GetRed(ref this.@else, 5); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.condition, 2);
            case 4: return this.GetRed(ref this.statement, 4);
            case 5: return this.GetRed(ref this.@else, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.condition;
            case 4: return this.statement;
            case 5: return this.@else;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIfStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitIfStatement(this);
    }

    public IfStatementSyntax Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
        if (ifKeyword != this.IfKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement || @else != this.Else)
        {
            var newNode = Syntax.IfStatement(ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IfStatementSyntax WithIfKeyword(SyntaxToken ifKeyword)
    {
        return this.Update(ifKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.Statement, this.Else);
    }

    public IfStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.IfKeyword, openParenToken, this.Condition, this.CloseParenToken, this.Statement, this.Else);
    }

    public IfStatementSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.IfKeyword, this.OpenParenToken, condition, this.CloseParenToken, this.Statement, this.Else);
    }

    public IfStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.IfKeyword, this.OpenParenToken, this.Condition, closeParenToken, this.Statement, this.Else);
    }

    public IfStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.IfKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, statement, this.Else);
    }

    public IfStatementSyntax WithElse(ElseClauseSyntax @else)
    {
        return this.Update(this.IfKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.Statement, @else);
    }
  }

  /// <summary>Represents an else statement syntax.</summary>
  public sealed partial class ElseClauseSyntax : SyntaxNode
  {
    private StatementSyntax statement;

    internal ElseClauseSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>
    /// Gets a syntax token
    /// </summary>
    public SyntaxToken ElseKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public StatementSyntax Statement 
    {
      get { return this.GetRed(ref this.statement, 1); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.statement, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElseClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitElseClause(this);
    }

    public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementSyntax statement)
    {
        if (elseKeyword != this.ElseKeyword || statement != this.Statement)
        {
            var newNode = Syntax.ElseClause(elseKeyword, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ElseClauseSyntax WithElseKeyword(SyntaxToken elseKeyword)
    {
        return this.Update(elseKeyword, this.Statement);
    }

    public ElseClauseSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.ElseKeyword, statement);
    }
  }

  /// <summary>Represents a switch statement syntax.</summary>
  public sealed partial class SwitchStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;
    private SyntaxNode sections;

    internal SwitchStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the switch keyword.
    /// </summary>
    public SyntaxToken SwitchKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the open parenthesis preceding the switch expression.
    /// </summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>
    /// Gets an ExpressionSyntax representing the expression of the switch statement.
    /// </summary>
    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 2); }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the close parenthesis succeeding the switch expression.
    /// </summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the open braces preceding the switch sections.
    /// </summary>
    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(4), this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    /// <summary>
    /// Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
    /// </summary>
    public SyntaxList<SwitchSectionSyntax> Sections 
    {
      get { return new SyntaxList<SwitchSectionSyntax>(this.GetRed(ref this.sections, 5)); }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the open braces succeeding the switch sections.
    /// </summary>
    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(6), this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            case 5: return this.GetRed(ref this.sections, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            case 5: return this.sections;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitSwitchStatement(this);
    }

    public SwitchStatementSyntax Update(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
        if (switchKeyword != this.SwitchKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || openBraceToken != this.OpenBraceToken || sections != this.Sections || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = Syntax.SwitchStatement(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SwitchStatementSyntax WithSwitchKeyword(SyntaxToken switchKeyword)
    {
        return this.Update(switchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, this.Sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.SwitchKeyword, openParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, this.Sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.SwitchKeyword, this.OpenParenToken, expression, this.CloseParenToken, this.OpenBraceToken, this.Sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.SwitchKeyword, this.OpenParenToken, this.Expression, closeParenToken, this.OpenBraceToken, this.Sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.SwitchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, openBraceToken, this.Sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithSections(SyntaxList<SwitchSectionSyntax> sections)
    {
        return this.Update(this.SwitchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.SwitchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, this.Sections, closeBraceToken);
    }

    public SwitchStatementSyntax AddSections(params SwitchSectionSyntax[] items)
    {
        return this.WithSections(this.Sections.Add(items));
    }
  }

  /// <summary>Represents a switch section syntax of a switch statement.</summary>
  public sealed partial class SwitchSectionSyntax : SyntaxNode
  {
    private SyntaxNode labels;
    private SyntaxNode statements;

    internal SwitchSectionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
    /// </summary>
    public SyntaxList<SwitchLabelSyntax> Labels 
    {
      get { return new SyntaxList<SwitchLabelSyntax>(this.GetRed(ref this.labels, 0)); }
    }

    /// <summary>
    /// Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
    /// </summary>
    public SyntaxList<StatementSyntax> Statements 
    {
      get { return new SyntaxList<StatementSyntax>(this.GetRed(ref this.statements, 1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.labels, 0);
            case 1: return this.GetRed(ref this.statements, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.labels;
            case 1: return this.statements;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchSection(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitSwitchSection(this);
    }

    public SwitchSectionSyntax Update(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements)
    {
        if (labels != this.Labels || statements != this.Statements)
        {
            var newNode = Syntax.SwitchSection(labels, statements);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SwitchSectionSyntax WithLabels(SyntaxList<SwitchLabelSyntax> labels)
    {
        return this.Update(labels, this.Statements);
    }

    public SwitchSectionSyntax WithStatements(SyntaxList<StatementSyntax> statements)
    {
        return this.Update(this.Labels, statements);
    }

    public SwitchSectionSyntax AddLabels(params SwitchLabelSyntax[] items)
    {
        return this.WithLabels(this.Labels.Add(items));
    }

    public SwitchSectionSyntax AddStatements(params StatementSyntax[] items)
    {
        return this.WithStatements(this.Statements.Add(items));
    }
  }

  /// <summary>Represents a switch label within a switch statement.</summary>
  public sealed partial class SwitchLabelSyntax : SyntaxNode
  {
    private ExpressionSyntax value;

    internal SwitchLabelSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents a case or default keywords that belongs to a switch label.
    /// </summary>
    public SyntaxToken CaseOrDefaultKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>
    /// Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label. For default label the property returns null.
    /// </summary>
    public ExpressionSyntax Value 
    {
      get { return this.GetRed(ref this.value, 1); }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the colon that terminates the switch label.
    /// </summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.value, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.value;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchLabel(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitSwitchLabel(this);
    }

    public SwitchLabelSyntax Update(SyntaxToken caseOrDefaultKeyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
        if (caseOrDefaultKeyword != this.CaseOrDefaultKeyword || value != this.Value || colonToken != this.ColonToken)
        {
            var newNode = Syntax.SwitchLabel(this.Kind, caseOrDefaultKeyword, value, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SwitchLabelSyntax WithCaseOrDefaultKeyword(SyntaxToken caseOrDefaultKeyword)
    {
        return this.Update(caseOrDefaultKeyword, this.Value, this.ColonToken);
    }

    public SwitchLabelSyntax WithValue(ExpressionSyntax value)
    {
        return this.Update(this.CaseOrDefaultKeyword, value, this.ColonToken);
    }

    public SwitchLabelSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.CaseOrDefaultKeyword, this.Value, colonToken);
    }
  }

  public sealed partial class TryStatementSyntax : StatementSyntax
  {
    private BlockSyntax block;
    private SyntaxNode catches;
    private FinallyClauseSyntax @finally;

    internal TryStatementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken TryKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public BlockSyntax Block 
    {
      get { return this.GetRed(ref this.block, 1); }
    }

    public SyntaxList<CatchClauseSyntax> Catches 
    {
      get { return new SyntaxList<CatchClauseSyntax>(this.GetRed(ref this.catches, 2)); }
    }

    public FinallyClauseSyntax Finally 
    {
      get { return this.GetRed(ref this.@finally, 3); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.block, 1);
            case 2: return this.GetRed(ref this.catches, 2);
            case 3: return this.GetRed(ref this.@finally, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.block;
            case 2: return this.catches;
            case 3: return this.@finally;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTryStatement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitTryStatement(this);
    }

    public TryStatementSyntax Update(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
        if (tryKeyword != this.TryKeyword || block != this.Block || catches != this.Catches || @finally != this.Finally)
        {
            var newNode = Syntax.TryStatement(tryKeyword, block, catches, @finally);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TryStatementSyntax WithTryKeyword(SyntaxToken tryKeyword)
    {
        return this.Update(tryKeyword, this.Block, this.Catches, this.Finally);
    }

    public TryStatementSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.TryKeyword, block, this.Catches, this.Finally);
    }

    public TryStatementSyntax WithCatches(SyntaxList<CatchClauseSyntax> catches)
    {
        return this.Update(this.TryKeyword, this.Block, catches, this.Finally);
    }

    public TryStatementSyntax WithFinally(FinallyClauseSyntax @finally)
    {
        return this.Update(this.TryKeyword, this.Block, this.Catches, @finally);
    }

    public TryStatementSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.Add(items)));
    }

    public TryStatementSyntax AddCatches(params CatchClauseSyntax[] items)
    {
        return this.WithCatches(this.Catches.Add(items));
    }
  }

  public sealed partial class CatchClauseSyntax : SyntaxNode
  {
    private CatchDeclarationSyntax declaration;
    private BlockSyntax block;

    internal CatchClauseSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken CatchKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public CatchDeclarationSyntax Declaration 
    {
      get { return this.GetRed(ref this.declaration, 1); }
    }

    public BlockSyntax Block 
    {
      get { return this.GetRed(ref this.block, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.declaration, 1);
            case 2: return this.GetRed(ref this.block, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.declaration;
            case 2: return this.block;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCatchClause(this);
    }

    public CatchClauseSyntax Update(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, BlockSyntax block)
    {
        if (catchKeyword != this.CatchKeyword || declaration != this.Declaration || block != this.Block)
        {
            var newNode = Syntax.CatchClause(catchKeyword, declaration, block);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CatchClauseSyntax WithCatchKeyword(SyntaxToken catchKeyword)
    {
        return this.Update(catchKeyword, this.Declaration, this.Block);
    }

    public CatchClauseSyntax WithDeclaration(CatchDeclarationSyntax declaration)
    {
        return this.Update(this.CatchKeyword, declaration, this.Block);
    }

    public CatchClauseSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.CatchKeyword, this.Declaration, block);
    }

    public CatchClauseSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.Add(items)));
    }
  }

  public sealed partial class CatchDeclarationSyntax : SyntaxNode
  {
    private TypeSyntax type;

    internal CatchDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 1); }
    }

    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCatchDeclaration(this);
    }

    public CatchDeclarationSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.CatchDeclaration(openParenToken, type, identifier, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CatchDeclarationSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Type, this.Identifier, this.CloseParenToken);
    }

    public CatchDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.OpenParenToken, type, this.Identifier, this.CloseParenToken);
    }

    public CatchDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.OpenParenToken, this.Type, identifier, this.CloseParenToken);
    }

    public CatchDeclarationSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Type, this.Identifier, closeParenToken);
    }
  }

  public sealed partial class FinallyClauseSyntax : SyntaxNode
  {
    private BlockSyntax block;

    internal FinallyClauseSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken FinallyKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public BlockSyntax Block 
    {
      get { return this.GetRed(ref this.block, 1); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.block, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.block;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFinallyClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitFinallyClause(this);
    }

    public FinallyClauseSyntax Update(SyntaxToken finallyKeyword, BlockSyntax block)
    {
        if (finallyKeyword != this.FinallyKeyword || block != this.Block)
        {
            var newNode = Syntax.FinallyClause(finallyKeyword, block);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public FinallyClauseSyntax WithFinallyKeyword(SyntaxToken finallyKeyword)
    {
        return this.Update(finallyKeyword, this.Block);
    }

    public FinallyClauseSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.FinallyKeyword, block);
    }

    public FinallyClauseSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.Add(items)));
    }
  }

  public sealed partial class CompilationUnitSyntax : SyntaxNode
  {
    private SyntaxNode externs;
    private SyntaxNode usings;
    private SyntaxNode attributes;
    private SyntaxNode members;

    internal CompilationUnitSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxList<ExternAliasDirectiveSyntax> Externs 
    {
      get { return new SyntaxList<ExternAliasDirectiveSyntax>(this.GetRed(ref this.externs, 0)); }
    }

    public SyntaxList<UsingDirectiveSyntax> Usings 
    {
      get { return new SyntaxList<UsingDirectiveSyntax>(this.GetRed(ref this.usings, 1)); }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 2)); }
    }

    public SyntaxList<MemberDeclarationSyntax> Members 
    {
      get { return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 3)); }
    }

    public SyntaxToken EndOfFileToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(4), this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.externs, 0);
            case 1: return this.GetRed(ref this.usings, 1);
            case 2: return this.GetRed(ref this.attributes, 2);
            case 3: return this.GetRed(ref this.members, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.externs;
            case 1: return this.usings;
            case 2: return this.attributes;
            case 3: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCompilationUnit(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitCompilationUnit(this);
    }

    public CompilationUnitSyntax Update(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
        if (externs != this.Externs || usings != this.Usings || attributes != this.Attributes || members != this.Members || endOfFileToken != this.EndOfFileToken)
        {
            var newNode = Syntax.CompilationUnit(externs, usings, attributes, members, endOfFileToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CompilationUnitSyntax WithExterns(SyntaxList<ExternAliasDirectiveSyntax> externs)
    {
        return this.Update(externs, this.Usings, this.Attributes, this.Members, this.EndOfFileToken);
    }

    public CompilationUnitSyntax WithUsings(SyntaxList<UsingDirectiveSyntax> usings)
    {
        return this.Update(this.Externs, usings, this.Attributes, this.Members, this.EndOfFileToken);
    }

    public CompilationUnitSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(this.Externs, this.Usings, attributes, this.Members, this.EndOfFileToken);
    }

    public CompilationUnitSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.Externs, this.Usings, this.Attributes, members, this.EndOfFileToken);
    }

    public CompilationUnitSyntax WithEndOfFileToken(SyntaxToken endOfFileToken)
    {
        return this.Update(this.Externs, this.Usings, this.Attributes, this.Members, endOfFileToken);
    }

    public CompilationUnitSyntax AddExterns(params ExternAliasDirectiveSyntax[] items)
    {
        return this.WithExterns(this.Externs.Add(items));
    }

    public CompilationUnitSyntax AddUsings(params UsingDirectiveSyntax[] items)
    {
        return this.WithUsings(this.Usings.Add(items));
    }

    public CompilationUnitSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public CompilationUnitSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.Add(items));
    }
  }

  /// <summary>
  /// Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
  /// </summary>
  public sealed partial class ExternAliasDirectiveSyntax : SyntaxNode
  {
    internal ExternAliasDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>SyntaxToken representing the extern keyword.</summary>
    public SyntaxToken ExternKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>SyntaxToken representing the alias keyword.</summary>
    public SyntaxToken AliasKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>SyntaxToken representing the semicolon token.</summary>
    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExternAliasDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitExternAliasDirective(this);
    }

    public ExternAliasDirectiveSyntax Update(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
        if (externKeyword != this.ExternKeyword || aliasKeyword != this.AliasKeyword || identifier != this.Identifier || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ExternAliasDirective(externKeyword, aliasKeyword, identifier, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ExternAliasDirectiveSyntax WithExternKeyword(SyntaxToken externKeyword)
    {
        return this.Update(externKeyword, this.AliasKeyword, this.Identifier, this.SemicolonToken);
    }

    public ExternAliasDirectiveSyntax WithAliasKeyword(SyntaxToken aliasKeyword)
    {
        return this.Update(this.ExternKeyword, aliasKeyword, this.Identifier, this.SemicolonToken);
    }

    public ExternAliasDirectiveSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.ExternKeyword, this.AliasKeyword, identifier, this.SemicolonToken);
    }

    public ExternAliasDirectiveSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.ExternKeyword, this.AliasKeyword, this.Identifier, semicolonToken);
    }
  }

  public sealed partial class UsingDirectiveSyntax : SyntaxNode
  {
    private NameEqualsSyntax alias;
    private NameSyntax name;

    internal UsingDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken UsingKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public NameEqualsSyntax Alias 
    {
      get { return this.GetRed(ref this.alias, 1); }
    }

    public NameSyntax Name 
    {
      get { return this.GetRed(ref this.name, 2); }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.alias, 1);
            case 2: return this.GetRed(ref this.name, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.alias;
            case 2: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUsingDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitUsingDirective(this);
    }

    public UsingDirectiveSyntax Update(SyntaxToken usingKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
        if (usingKeyword != this.UsingKeyword || alias != this.Alias || name != this.Name || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.UsingDirective(usingKeyword, alias, name, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public UsingDirectiveSyntax WithUsingKeyword(SyntaxToken usingKeyword)
    {
        return this.Update(usingKeyword, this.Alias, this.Name, this.SemicolonToken);
    }

    public UsingDirectiveSyntax WithAlias(NameEqualsSyntax alias)
    {
        return this.Update(this.UsingKeyword, alias, this.Name, this.SemicolonToken);
    }

    public UsingDirectiveSyntax WithName(NameSyntax name)
    {
        return this.Update(this.UsingKeyword, this.Alias, name, this.SemicolonToken);
    }

    public UsingDirectiveSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.UsingKeyword, this.Alias, this.Name, semicolonToken);
    }
  }

  /// <summary>Member declaration syntax.</summary>
  public abstract partial class MemberDeclarationSyntax : SyntaxNode
  {
    internal MemberDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }
  }

  public sealed partial class NamespaceDeclarationSyntax : MemberDeclarationSyntax
  {
    private NameSyntax name;
    private SyntaxNode externs;
    private SyntaxNode usings;
    private SyntaxNode members;

    internal NamespaceDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken NamespaceKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public NameSyntax Name 
    {
      get { return this.GetRed(ref this.name, 1); }
    }

    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxList<ExternAliasDirectiveSyntax> Externs 
    {
      get { return new SyntaxList<ExternAliasDirectiveSyntax>(this.GetRed(ref this.externs, 3)); }
    }

    public SyntaxList<UsingDirectiveSyntax> Usings 
    {
      get { return new SyntaxList<UsingDirectiveSyntax>(this.GetRed(ref this.usings, 4)); }
    }

    public SyntaxList<MemberDeclarationSyntax> Members 
    {
      get { return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 5)); }
    }

    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(6), this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(7), this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            case 3: return this.GetRed(ref this.externs, 3);
            case 4: return this.GetRed(ref this.usings, 4);
            case 5: return this.GetRed(ref this.members, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            case 3: return this.externs;
            case 4: return this.usings;
            case 5: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNamespaceDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitNamespaceDeclaration(this);
    }

    public NamespaceDeclarationSyntax Update(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (namespaceKeyword != this.NamespaceKeyword || name != this.Name || openBraceToken != this.OpenBraceToken || externs != this.Externs || usings != this.Usings || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.NamespaceDeclaration(namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public NamespaceDeclarationSyntax WithNamespaceKeyword(SyntaxToken namespaceKeyword)
    {
        return this.Update(namespaceKeyword, this.Name, this.OpenBraceToken, this.Externs, this.Usings, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public NamespaceDeclarationSyntax WithName(NameSyntax name)
    {
        return this.Update(this.NamespaceKeyword, name, this.OpenBraceToken, this.Externs, this.Usings, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public NamespaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.NamespaceKeyword, this.Name, openBraceToken, this.Externs, this.Usings, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public NamespaceDeclarationSyntax WithExterns(SyntaxList<ExternAliasDirectiveSyntax> externs)
    {
        return this.Update(this.NamespaceKeyword, this.Name, this.OpenBraceToken, externs, this.Usings, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public NamespaceDeclarationSyntax WithUsings(SyntaxList<UsingDirectiveSyntax> usings)
    {
        return this.Update(this.NamespaceKeyword, this.Name, this.OpenBraceToken, this.Externs, usings, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public NamespaceDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.NamespaceKeyword, this.Name, this.OpenBraceToken, this.Externs, this.Usings, members, this.CloseBraceToken, this.SemicolonToken);
    }

    public NamespaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.NamespaceKeyword, this.Name, this.OpenBraceToken, this.Externs, this.Usings, this.Members, closeBraceToken, this.SemicolonToken);
    }

    public NamespaceDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.NamespaceKeyword, this.Name, this.OpenBraceToken, this.Externs, this.Usings, this.Members, this.CloseBraceToken, semicolonToken);
    }

    public NamespaceDeclarationSyntax AddExterns(params ExternAliasDirectiveSyntax[] items)
    {
        return this.WithExterns(this.Externs.Add(items));
    }

    public NamespaceDeclarationSyntax AddUsings(params UsingDirectiveSyntax[] items)
    {
        return this.WithUsings(this.Usings.Add(items));
    }

    public NamespaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.Add(items));
    }
  }

  /// <summary>Class representing one or more attributes applied to a language construct.</summary>
  public sealed partial class AttributeDeclarationSyntax : SyntaxNode
  {
    private AttributeTargetSpecifierSyntax target;
    private SyntaxNode attributes;

    internal AttributeDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public AttributeTargetSpecifierSyntax Target 
    {
      get { return this.GetRed(ref this.target, 1); }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SeparatedSyntaxList<AttributeSyntax> Attributes 
    {
      get { return new SeparatedSyntaxList<AttributeSyntax>(this.GetRed(ref this.attributes, 2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.target, 1);
            case 2: return this.GetRed(ref this.attributes, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.target;
            case 2: return this.attributes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAttributeDeclaration(this);
    }

    public AttributeDeclarationSyntax Update(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || target != this.Target || attributes != this.Attributes || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = Syntax.AttributeDeclaration(openBracketToken, target, attributes, closeBracketToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AttributeDeclarationSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(openBracketToken, this.Target, this.Attributes, this.CloseBracketToken);
    }

    public AttributeDeclarationSyntax WithTarget(AttributeTargetSpecifierSyntax target)
    {
        return this.Update(this.OpenBracketToken, target, this.Attributes, this.CloseBracketToken);
    }

    public AttributeDeclarationSyntax WithAttributes(SeparatedSyntaxList<AttributeSyntax> attributes)
    {
        return this.Update(this.OpenBracketToken, this.Target, attributes, this.CloseBracketToken);
    }

    public AttributeDeclarationSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.OpenBracketToken, this.Target, this.Attributes, closeBracketToken);
    }

    public AttributeDeclarationSyntax AddAttributes(params AttributeSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }
  }

  /// <summary>Class representing what language construct an attribute targets.</summary>
  public sealed partial class AttributeTargetSpecifierSyntax : SyntaxNode
  {
    internal AttributeTargetSpecifierSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeTargetSpecifier(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAttributeTargetSpecifier(this);
    }

    public AttributeTargetSpecifierSyntax Update(SyntaxToken identifier, SyntaxToken colonToken)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken)
        {
            var newNode = Syntax.AttributeTargetSpecifier(identifier, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AttributeTargetSpecifierSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier, this.ColonToken);
    }

    public AttributeTargetSpecifierSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Identifier, colonToken);
    }
  }

  /// <summary>Attribute syntax.</summary>
  public sealed partial class AttributeSyntax : SyntaxNode
  {
    private NameSyntax name;
    private AttributeArgumentListSyntax argumentList;

    internal AttributeSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the name.</summary>
    public NameSyntax Name 
    {
      get { return this.GetRed(ref this.name, 0); }
    }

    public AttributeArgumentListSyntax ArgumentList 
    {
      get { return this.GetRed(ref this.argumentList, 1); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.name, 0);
            case 1: return this.GetRed(ref this.argumentList, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttribute(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAttribute(this);
    }

    public AttributeSyntax Update(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
        if (name != this.Name || argumentList != this.ArgumentList)
        {
            var newNode = Syntax.Attribute(name, argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AttributeSyntax WithName(NameSyntax name)
    {
        return this.Update(name, this.ArgumentList);
    }

    public AttributeSyntax WithArgumentList(AttributeArgumentListSyntax argumentList)
    {
        return this.Update(this.Name, argumentList);
    }

    public AttributeSyntax AddArgumentListArguments(params AttributeArgumentSyntax[] items)
    {
        var argumentList = this.ArgumentList ?? Syntax.AttributeArgumentList();
        return this.WithArgumentList(argumentList.WithArguments(argumentList.Arguments.Add(items)));
    }
  }

  /// <summary>Attribute argument list syntax.</summary>
  public sealed partial class AttributeArgumentListSyntax : SyntaxNode
  {
    private SyntaxNode arguments;

    internal AttributeArgumentListSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>Gets the arguments syntax list.</summary>
    public SeparatedSyntaxList<AttributeArgumentSyntax> Arguments 
    {
      get { return new SeparatedSyntaxList<AttributeArgumentSyntax>(this.GetRed(ref this.arguments, 1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.arguments, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.arguments;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeArgumentList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAttributeArgumentList(this);
    }

    public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.AttributeArgumentList(openParenToken, arguments, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AttributeArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Arguments, this.CloseParenToken);
    }

    public AttributeArgumentListSyntax WithArguments(SeparatedSyntaxList<AttributeArgumentSyntax> arguments)
    {
        return this.Update(this.OpenParenToken, arguments, this.CloseParenToken);
    }

    public AttributeArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Arguments, closeParenToken);
    }

    public AttributeArgumentListSyntax AddArguments(params AttributeArgumentSyntax[] items)
    {
        return this.WithArguments(this.Arguments.Add(items));
    }
  }

  /// <summary>Attribute argument syntax.</summary>
  public sealed partial class AttributeArgumentSyntax : SyntaxNode
  {
    private NameEqualsSyntax nameEquals;
    private NameColonSyntax nameColon;
    private ExpressionSyntax expression;

    internal AttributeArgumentSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public NameEqualsSyntax NameEquals 
    {
      get { return this.GetRed(ref this.nameEquals, 0); }
    }

    public NameColonSyntax NameColon 
    {
      get { return this.GetRed(ref this.nameColon, 1); }
    }

    /// <summary>Gets the expression.</summary>
    public ExpressionSyntax Expression 
    {
      get { return this.GetRed(ref this.expression, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.nameEquals, 0);
            case 1: return this.GetRed(ref this.nameColon, 1);
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameEquals;
            case 1: return this.nameColon;
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeArgument(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAttributeArgument(this);
    }

    public AttributeArgumentSyntax Update(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
        if (nameEquals != this.NameEquals || nameColon != this.NameColon || expression != this.Expression)
        {
            var newNode = Syntax.AttributeArgument(nameEquals, nameColon, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AttributeArgumentSyntax WithNameEquals(NameEqualsSyntax nameEquals)
    {
        return this.Update(nameEquals, this.NameColon, this.Expression);
    }

    public AttributeArgumentSyntax WithNameColon(NameColonSyntax nameColon)
    {
        return this.Update(this.NameEquals, nameColon, this.Expression);
    }

    public AttributeArgumentSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.NameEquals, this.NameColon, expression);
    }
  }

  /// <summary>Class representing an identifier followed by an equals token.</summary>
  public sealed partial class NameEqualsSyntax : SyntaxNode
  {
    private IdentifierNameSyntax identifier;

    internal NameEqualsSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the identifier.</summary>
    public IdentifierNameSyntax Identifier 
    {
      get { return this.GetRed(ref this.identifier, 0); }
    }

    public SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.identifier, 0);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameEquals(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitNameEquals(this);
    }

    public NameEqualsSyntax Update(IdentifierNameSyntax identifier, SyntaxToken equalsToken)
    {
        if (identifier != this.Identifier || equalsToken != this.EqualsToken)
        {
            var newNode = Syntax.NameEquals(identifier, equalsToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public NameEqualsSyntax WithIdentifier(IdentifierNameSyntax identifier)
    {
        return this.Update(identifier, this.EqualsToken);
    }

    public NameEqualsSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(this.Identifier, equalsToken);
    }
  }

  /// <summary>Type parameter list syntax.</summary>
  public sealed partial class TypeParameterListSyntax : SyntaxNode
  {
    private SyntaxNode parameters;

    internal TypeParameterListSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the &lt; token.</summary>
    public SyntaxToken LessThanToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>Gets the parameter list.</summary>
    public SeparatedSyntaxList<TypeParameterSyntax> Parameters 
    {
      get { return new SeparatedSyntaxList<TypeParameterSyntax>(this.GetRed(ref this.parameters, 1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the &gt; token.</summary>
    public SyntaxToken GreaterThanToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameterList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitTypeParameterList(this);
    }

    public TypeParameterListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || parameters != this.Parameters || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = Syntax.TypeParameterList(lessThanToken, parameters, greaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeParameterListSyntax WithLessThanToken(SyntaxToken lessThanToken)
    {
        return this.Update(lessThanToken, this.Parameters, this.GreaterThanToken);
    }

    public TypeParameterListSyntax WithParameters(SeparatedSyntaxList<TypeParameterSyntax> parameters)
    {
        return this.Update(this.LessThanToken, parameters, this.GreaterThanToken);
    }

    public TypeParameterListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)
    {
        return this.Update(this.LessThanToken, this.Parameters, greaterThanToken);
    }

    public TypeParameterListSyntax AddParameters(params TypeParameterSyntax[] items)
    {
        return this.WithParameters(this.Parameters.Add(items));
    }
  }

  /// <summary>Type parameter syntax.</summary>
  public sealed partial class TypeParameterSyntax : SyntaxNode
  {
    private SyntaxNode attributes;

    internal TypeParameterSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    public SyntaxToken VarianceKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameter(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitTypeParameter(this);
    }

    public TypeParameterSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
        if (attributes != this.Attributes || varianceKeyword != this.VarianceKeyword || identifier != this.Identifier)
        {
            var newNode = Syntax.TypeParameter(attributes, varianceKeyword, identifier);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeParameterSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.VarianceKeyword, this.Identifier);
    }

    public TypeParameterSyntax WithVarianceKeyword(SyntaxToken varianceKeyword)
    {
        return this.Update(this.Attributes, varianceKeyword, this.Identifier);
    }

    public TypeParameterSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Attributes, this.VarianceKeyword, identifier);
    }

    public TypeParameterSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }
  }

  /// <summary>Base class for type declaration syntax.</summary>
  public abstract partial class BaseTypeDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseTypeDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeDeclarationSyntax> Attributes { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxTokenList Modifiers { get; }

    /// <summary>Gets the identifier.</summary>
    public abstract SyntaxToken Identifier { get; }

    /// <summary>Gets the base type list.</summary>
    public abstract BaseListSyntax BaseList { get; }

    /// <summary>Gets the open brace token.</summary>
    public abstract SyntaxToken OpenBraceToken { get; }

    /// <summary>Gets the close brace token.</summary>
    public abstract SyntaxToken CloseBraceToken { get; }

    /// <summary>Gets the optional semicolon token.</summary>
    public abstract SyntaxToken SemicolonToken { get; }
  }

  /// <summary>Base class for type declaration syntax (class, struct, interface).</summary>
  public abstract partial class TypeDeclarationSyntax : BaseTypeDeclarationSyntax
  {
    internal TypeDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }

    /// <summary>Gets the type keyword token ("class", "struct", "interface").</summary>
    public abstract SyntaxToken Keyword { get; }

    public abstract TypeParameterListSyntax TypeParameterList { get; }

    /// <summary>Gets the type constraint list.</summary>
    public abstract SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }

    /// <summary>Gets the member declarations.</summary>
    public abstract SyntaxList<MemberDeclarationSyntax> Members { get; }
  }

  /// <summary>Class type declaration syntax.</summary>
  public sealed partial class ClassDeclarationSyntax : TypeDeclarationSyntax
  {
    private SyntaxNode attributes;
    private TypeParameterListSyntax typeParameterList;
    private BaseListSyntax baseList;
    private SyntaxNode constraintClauses;
    private SyntaxNode members;

    internal ClassDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    public override SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the class keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override TypeParameterListSyntax TypeParameterList 
    {
      get { return this.GetRed(ref this.typeParameterList, 4); }
    }

    public override BaseListSyntax BaseList 
    {
      get { return this.GetRed(ref this.baseList, 5); }
    }

    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
      get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 6)); }
    }

    public override SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(7), this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    public override SyntaxList<MemberDeclarationSyntax> Members 
    {
      get { return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 8)); }
    }

    public override SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(9), this.GetChildPosition(9), this.GetChildIndex(9)); }
    }

    public override SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(10), this.GetChildPosition(10), this.GetChildIndex(10)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 4: return this.GetRed(ref this.typeParameterList, 4);
            case 5: return this.GetRed(ref this.baseList, 5);
            case 6: return this.GetRed(ref this.constraintClauses, 6);
            case 8: return this.GetRed(ref this.members, 8);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 8: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitClassDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitClassDeclaration(this);
    }

    public ClassDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ClassDeclaration(attributes, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ClassDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(this.Attributes, this.Modifiers, keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, typeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithBaseList(BaseListSyntax baseList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, baseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, constraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, openBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, closeBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, semicolonToken);
    }

    public ClassDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public ClassDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public ClassDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? Syntax.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.Add(items)));
    }

    public ClassDeclarationSyntax AddBaseListTypes(params TypeSyntax[] items)
    {
        var baseList = this.BaseList ?? Syntax.BaseList();
        return this.WithBaseList(baseList.WithTypes(baseList.Types.Add(items)));
    }

    public ClassDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.Add(items));
    }

    public ClassDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.Add(items));
    }
  }

  /// <summary>Struct type declaration syntax.</summary>
  public sealed partial class StructDeclarationSyntax : TypeDeclarationSyntax
  {
    private SyntaxNode attributes;
    private TypeParameterListSyntax typeParameterList;
    private BaseListSyntax baseList;
    private SyntaxNode constraintClauses;
    private SyntaxNode members;

    internal StructDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    public override SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the struct keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override TypeParameterListSyntax TypeParameterList 
    {
      get { return this.GetRed(ref this.typeParameterList, 4); }
    }

    public override BaseListSyntax BaseList 
    {
      get { return this.GetRed(ref this.baseList, 5); }
    }

    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
      get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 6)); }
    }

    public override SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(7), this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    public override SyntaxList<MemberDeclarationSyntax> Members 
    {
      get { return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 8)); }
    }

    public override SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(9), this.GetChildPosition(9), this.GetChildIndex(9)); }
    }

    public override SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(10), this.GetChildPosition(10), this.GetChildIndex(10)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 4: return this.GetRed(ref this.typeParameterList, 4);
            case 5: return this.GetRed(ref this.baseList, 5);
            case 6: return this.GetRed(ref this.constraintClauses, 6);
            case 8: return this.GetRed(ref this.members, 8);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 8: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitStructDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitStructDeclaration(this);
    }

    public StructDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.StructDeclaration(attributes, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public StructDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(this.Attributes, this.Modifiers, keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, typeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithBaseList(BaseListSyntax baseList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, baseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, constraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, openBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, closeBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, semicolonToken);
    }

    public StructDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public StructDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public StructDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? Syntax.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.Add(items)));
    }

    public StructDeclarationSyntax AddBaseListTypes(params TypeSyntax[] items)
    {
        var baseList = this.BaseList ?? Syntax.BaseList();
        return this.WithBaseList(baseList.WithTypes(baseList.Types.Add(items)));
    }

    public StructDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.Add(items));
    }

    public StructDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.Add(items));
    }
  }

  /// <summary>Interface type declaration syntax.</summary>
  public sealed partial class InterfaceDeclarationSyntax : TypeDeclarationSyntax
  {
    private SyntaxNode attributes;
    private TypeParameterListSyntax typeParameterList;
    private BaseListSyntax baseList;
    private SyntaxNode constraintClauses;
    private SyntaxNode members;

    internal InterfaceDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    public override SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the interface keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override TypeParameterListSyntax TypeParameterList 
    {
      get { return this.GetRed(ref this.typeParameterList, 4); }
    }

    public override BaseListSyntax BaseList 
    {
      get { return this.GetRed(ref this.baseList, 5); }
    }

    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
      get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 6)); }
    }

    public override SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(7), this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    public override SyntaxList<MemberDeclarationSyntax> Members 
    {
      get { return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 8)); }
    }

    public override SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(9), this.GetChildPosition(9), this.GetChildIndex(9)); }
    }

    public override SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(10), this.GetChildPosition(10), this.GetChildIndex(10)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 4: return this.GetRed(ref this.typeParameterList, 4);
            case 5: return this.GetRed(ref this.baseList, 5);
            case 6: return this.GetRed(ref this.constraintClauses, 6);
            case 8: return this.GetRed(ref this.members, 8);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 8: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterfaceDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitInterfaceDeclaration(this);
    }

    public InterfaceDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.InterfaceDeclaration(attributes, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InterfaceDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(this.Attributes, this.Modifiers, keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, typeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithBaseList(BaseListSyntax baseList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, baseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, constraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, openBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, closeBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, semicolonToken);
    }

    public InterfaceDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public InterfaceDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public InterfaceDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? Syntax.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.Add(items)));
    }

    public InterfaceDeclarationSyntax AddBaseListTypes(params TypeSyntax[] items)
    {
        var baseList = this.BaseList ?? Syntax.BaseList();
        return this.WithBaseList(baseList.WithTypes(baseList.Types.Add(items)));
    }

    public InterfaceDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.Add(items));
    }

    public InterfaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.Add(items));
    }
  }

  /// <summary>Enum type declaration syntax.</summary>
  public sealed partial class EnumDeclarationSyntax : BaseTypeDeclarationSyntax
  {
    private SyntaxNode attributes;
    private BaseListSyntax baseList;
    private SyntaxNode members;

    internal EnumDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    public override SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the enum keyword token.</summary>
    public SyntaxToken EnumKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override BaseListSyntax BaseList 
    {
      get { return this.GetRed(ref this.baseList, 4); }
    }

    public override SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(5), this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    /// <summary>Gets the members declaration list.</summary>
    public SeparatedSyntaxList<EnumMemberDeclarationSyntax> Members 
    {
      get { return new SeparatedSyntaxList<EnumMemberDeclarationSyntax>(this.GetRed(ref this.members, 6), this.GetChildIndex(6)); }
    }

    public override SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(7), this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(8), this.GetChildPosition(8), this.GetChildIndex(8)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 4: return this.GetRed(ref this.baseList, 4);
            case 6: return this.GetRed(ref this.members, 6);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 4: return this.baseList;
            case 6: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEnumDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEnumDeclaration(this);
    }

    public EnumDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || enumKeyword != this.EnumKeyword || identifier != this.Identifier || baseList != this.BaseList || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.EnumDeclaration(attributes, modifiers, enumKeyword, identifier, baseList, openBraceToken, members, closeBraceToken, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EnumDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.EnumKeyword, this.Identifier, this.BaseList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.EnumKeyword, this.Identifier, this.BaseList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithEnumKeyword(SyntaxToken enumKeyword)
    {
        return this.Update(this.Attributes, this.Modifiers, enumKeyword, this.Identifier, this.BaseList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Attributes, this.Modifiers, this.EnumKeyword, identifier, this.BaseList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithBaseList(BaseListSyntax baseList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.EnumKeyword, this.Identifier, baseList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.EnumKeyword, this.Identifier, this.BaseList, openBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithMembers(SeparatedSyntaxList<EnumMemberDeclarationSyntax> members)
    {
        return this.Update(this.Attributes, this.Modifiers, this.EnumKeyword, this.Identifier, this.BaseList, this.OpenBraceToken, members, this.CloseBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.EnumKeyword, this.Identifier, this.BaseList, this.OpenBraceToken, this.Members, closeBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.EnumKeyword, this.Identifier, this.BaseList, this.OpenBraceToken, this.Members, this.CloseBraceToken, semicolonToken);
    }

    public EnumDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public EnumDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public EnumDeclarationSyntax AddBaseListTypes(params TypeSyntax[] items)
    {
        var baseList = this.BaseList ?? Syntax.BaseList();
        return this.WithBaseList(baseList.WithTypes(baseList.Types.Add(items)));
    }

    public EnumDeclarationSyntax AddMembers(params EnumMemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.Add(items));
    }
  }

  /// <summary>Delegate declaration syntax.</summary>
  public sealed partial class DelegateDeclarationSyntax : MemberDeclarationSyntax
  {
    private SyntaxNode attributes;
    private TypeSyntax returnType;
    private TypeParameterListSyntax typeParameterList;
    private ParameterListSyntax parameterList;
    private SyntaxNode constraintClauses;

    internal DelegateDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    /// <summary>Gets the modifier list.</summary>
    public SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the "delegate" keyword.</summary>
    public SyntaxToken DelegateKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the return type.</summary>
    public TypeSyntax ReturnType 
    {
      get { return this.GetRed(ref this.returnType, 3); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(4), this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public TypeParameterListSyntax TypeParameterList 
    {
      get { return this.GetRed(ref this.typeParameterList, 5); }
    }

    /// <summary>Gets the parameter list.</summary>
    public ParameterListSyntax ParameterList 
    {
      get { return this.GetRed(ref this.parameterList, 6); }
    }

    /// <summary>Gets the constraint clause list.</summary>
    public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
      get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 7)); }
    }

    /// <summary>Gets the semicolon token.</summary>
    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(8), this.GetChildPosition(8), this.GetChildIndex(8)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 3: return this.GetRed(ref this.returnType, 3);
            case 5: return this.GetRed(ref this.typeParameterList, 5);
            case 6: return this.GetRed(ref this.parameterList, 6);
            case 7: return this.GetRed(ref this.constraintClauses, 7);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 3: return this.returnType;
            case 5: return this.typeParameterList;
            case 6: return this.parameterList;
            case 7: return this.constraintClauses;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDelegateDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitDelegateDeclaration(this);
    }

    public DelegateDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || delegateKeyword != this.DelegateKeyword || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.DelegateDeclaration(attributes, modifiers, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DelegateDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.DelegateKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.DelegateKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithDelegateKeyword(SyntaxToken delegateKeyword)
    {
        return this.Update(this.Attributes, this.Modifiers, delegateKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithReturnType(TypeSyntax returnType)
    {
        return this.Update(this.Attributes, this.Modifiers, this.DelegateKeyword, returnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Attributes, this.Modifiers, this.DelegateKeyword, this.ReturnType, identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.DelegateKeyword, this.ReturnType, this.Identifier, typeParameterList, this.ParameterList, this.ConstraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.DelegateKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, parameterList, this.ConstraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.Attributes, this.Modifiers, this.DelegateKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, constraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.DelegateKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, semicolonToken);
    }

    public DelegateDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public DelegateDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public DelegateDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? Syntax.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.Add(items)));
    }

    public DelegateDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.Add(items)));
    }

    public DelegateDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.Add(items));
    }
  }

  public sealed partial class EnumMemberDeclarationSyntax : MemberDeclarationSyntax
  {
    private SyntaxNode attributes;
    private EqualsValueClauseSyntax equalsValue;

    internal EnumMemberDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public EqualsValueClauseSyntax EqualsValue 
    {
      get { return this.GetRed(ref this.equalsValue, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 2: return this.GetRed(ref this.equalsValue, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 2: return this.equalsValue;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEnumMemberDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEnumMemberDeclaration(this);
    }

    public EnumMemberDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
        if (attributes != this.Attributes || identifier != this.Identifier || equalsValue != this.EqualsValue)
        {
            var newNode = Syntax.EnumMemberDeclaration(attributes, identifier, equalsValue);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EnumMemberDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Identifier, this.EqualsValue);
    }

    public EnumMemberDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Attributes, identifier, this.EqualsValue);
    }

    public EnumMemberDeclarationSyntax WithEqualsValue(EqualsValueClauseSyntax equalsValue)
    {
        return this.Update(this.Attributes, this.Identifier, equalsValue);
    }

    public EnumMemberDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }
  }

  /// <summary>Base list syntax.</summary>
  public sealed partial class BaseListSyntax : SyntaxNode
  {
    private SyntaxNode types;

    internal BaseListSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>Gets the base type references.</summary>
    public SeparatedSyntaxList<TypeSyntax> Types 
    {
      get { return new SeparatedSyntaxList<TypeSyntax>(this.GetRed(ref this.types, 1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.types, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.types;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBaseList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBaseList(this);
    }

    public BaseListSyntax Update(SyntaxToken colonToken, SeparatedSyntaxList<TypeSyntax> types)
    {
        if (colonToken != this.ColonToken || types != this.Types)
        {
            var newNode = Syntax.BaseList(colonToken, types);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BaseListSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(colonToken, this.Types);
    }

    public BaseListSyntax WithTypes(SeparatedSyntaxList<TypeSyntax> types)
    {
        return this.Update(this.ColonToken, types);
    }

    public BaseListSyntax AddTypes(params TypeSyntax[] items)
    {
        return this.WithTypes(this.Types.Add(items));
    }
  }

  /// <summary>Type parameter constraint clause.</summary>
  public sealed partial class TypeParameterConstraintClauseSyntax : SyntaxNode
  {
    private IdentifierNameSyntax identifier;
    private SyntaxNode constraints;

    internal TypeParameterConstraintClauseSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken WhereKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>Gets the identifier.</summary>
    public IdentifierNameSyntax Identifier 
    {
      get { return this.GetRed(ref this.identifier, 1); }
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the constraints list.</summary>
    public SeparatedSyntaxList<TypeParameterConstraintSyntax> Constraints 
    {
      get { return new SeparatedSyntaxList<TypeParameterConstraintSyntax>(this.GetRed(ref this.constraints, 3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.identifier, 1);
            case 3: return this.GetRed(ref this.constraints, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.identifier;
            case 3: return this.constraints;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameterConstraintClause(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitTypeParameterConstraintClause(this);
    }

    public TypeParameterConstraintClauseSyntax Update(SyntaxToken whereKeyword, IdentifierNameSyntax identifier, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
        if (whereKeyword != this.WhereKeyword || identifier != this.Identifier || colonToken != this.ColonToken || constraints != this.Constraints)
        {
            var newNode = Syntax.TypeParameterConstraintClause(whereKeyword, identifier, colonToken, constraints);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeParameterConstraintClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword)
    {
        return this.Update(whereKeyword, this.Identifier, this.ColonToken, this.Constraints);
    }

    public TypeParameterConstraintClauseSyntax WithIdentifier(IdentifierNameSyntax identifier)
    {
        return this.Update(this.WhereKeyword, identifier, this.ColonToken, this.Constraints);
    }

    public TypeParameterConstraintClauseSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.WhereKeyword, this.Identifier, colonToken, this.Constraints);
    }

    public TypeParameterConstraintClauseSyntax WithConstraints(SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
        return this.Update(this.WhereKeyword, this.Identifier, this.ColonToken, constraints);
    }

    public TypeParameterConstraintClauseSyntax AddConstraints(params TypeParameterConstraintSyntax[] items)
    {
        return this.WithConstraints(this.Constraints.Add(items));
    }
  }

  /// <summary>Base type for type parameter constraint syntax.</summary>
  public abstract partial class TypeParameterConstraintSyntax : SyntaxNode
  {
    internal TypeParameterConstraintSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }
  }

  /// <summary>Constructor constraint syntax.</summary>
  public sealed partial class ConstructorConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal ConstructorConstraintSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the "new" keyword.</summary>
    public SyntaxToken NewKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>Gets the open paren keyword.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the close paren keyword.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorConstraint(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitConstructorConstraint(this);
    }

    public ConstructorConstraintSyntax Update(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
        if (newKeyword != this.NewKeyword || openParenToken != this.OpenParenToken || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.ConstructorConstraint(newKeyword, openParenToken, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConstructorConstraintSyntax WithNewKeyword(SyntaxToken newKeyword)
    {
        return this.Update(newKeyword, this.OpenParenToken, this.CloseParenToken);
    }

    public ConstructorConstraintSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.NewKeyword, openParenToken, this.CloseParenToken);
    }

    public ConstructorConstraintSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.NewKeyword, this.OpenParenToken, closeParenToken);
    }
  }

  /// <summary>Base type for class or struct constraint syntax.</summary>
  public sealed partial class ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal ClassOrStructConstraintSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the constraint keyword ("class" or "struct").</summary>
    public SyntaxToken ClassOrStructKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitClassOrStructConstraint(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitClassOrStructConstraint(this);
    }

    public ClassOrStructConstraintSyntax Update(SyntaxToken classOrStructKeyword)
    {
        if (classOrStructKeyword != this.ClassOrStructKeyword)
        {
            var newNode = Syntax.ClassOrStructConstraint(this.Kind, classOrStructKeyword);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ClassOrStructConstraintSyntax WithClassOrStructKeyword(SyntaxToken classOrStructKeyword)
    {
        return this.Update(classOrStructKeyword);
    }
  }

  /// <summary>Type constraint syntax.</summary>
  public sealed partial class TypeConstraintSyntax : TypeParameterConstraintSyntax
  {
    private TypeSyntax type;

    internal TypeConstraintSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the type syntax.</summary>
    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.type, 0);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeConstraint(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitTypeConstraint(this);
    }

    public TypeConstraintSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = Syntax.TypeConstraint(type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeConstraintSyntax WithType(TypeSyntax type)
    {
        return this.Update(type);
    }
  }

  public abstract partial class BaseFieldDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseFieldDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeDeclarationSyntax> Attributes { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxTokenList Modifiers { get; }

    public abstract VariableDeclarationSyntax Declaration { get; }

    public abstract SyntaxToken SemicolonToken { get; }
  }

  public sealed partial class FieldDeclarationSyntax : BaseFieldDeclarationSyntax
  {
    private SyntaxNode attributes;
    private VariableDeclarationSyntax declaration;

    internal FieldDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public override SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    /// <summary>Gets the modifier list.</summary>
    public override SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override VariableDeclarationSyntax Declaration 
    {
      get { return this.GetRed(ref this.declaration, 2); }
    }

    public override SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 2: return this.GetRed(ref this.declaration, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 2: return this.declaration;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFieldDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitFieldDeclaration(this);
    }

    public FieldDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.FieldDeclaration(attributes, modifiers, declaration, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public FieldDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.Declaration, this.SemicolonToken);
    }

    public FieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.Declaration, this.SemicolonToken);
    }

    public FieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.Attributes, this.Modifiers, declaration, this.SemicolonToken);
    }

    public FieldDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Declaration, semicolonToken);
    }

    public FieldDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public FieldDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public FieldDeclarationSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)
    {
        return this.WithDeclaration(this.Declaration.WithVariables(this.Declaration.Variables.Add(items)));
    }
  }

  public sealed partial class EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax
  {
    private SyntaxNode attributes;
    private VariableDeclarationSyntax declaration;

    internal EventFieldDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public override SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    /// <summary>Gets the modifier list.</summary>
    public override SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken EventKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override VariableDeclarationSyntax Declaration 
    {
      get { return this.GetRed(ref this.declaration, 3); }
    }

    public override SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(4), this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 3: return this.GetRed(ref this.declaration, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 3: return this.declaration;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEventFieldDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEventFieldDeclaration(this);
    }

    public EventFieldDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.EventFieldDeclaration(attributes, modifiers, eventKeyword, declaration, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EventFieldDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.EventKeyword, this.Declaration, this.SemicolonToken);
    }

    public EventFieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.EventKeyword, this.Declaration, this.SemicolonToken);
    }

    public EventFieldDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword)
    {
        return this.Update(this.Attributes, this.Modifiers, eventKeyword, this.Declaration, this.SemicolonToken);
    }

    public EventFieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.Attributes, this.Modifiers, this.EventKeyword, declaration, this.SemicolonToken);
    }

    public EventFieldDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.EventKeyword, this.Declaration, semicolonToken);
    }

    public EventFieldDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public EventFieldDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public EventFieldDeclarationSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)
    {
        return this.WithDeclaration(this.Declaration.WithVariables(this.Declaration.Variables.Add(items)));
    }
  }

  public sealed partial class ExplicitInterfaceSpecifierSyntax : SyntaxNode
  {
    private NameSyntax name;

    internal ExplicitInterfaceSpecifierSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public NameSyntax Name 
    {
      get { return this.GetRed(ref this.name, 0); }
    }

    public SyntaxToken DotToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.name, 0);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExplicitInterfaceSpecifier(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitExplicitInterfaceSpecifier(this);
    }

    public ExplicitInterfaceSpecifierSyntax Update(NameSyntax name, SyntaxToken dotToken)
    {
        if (name != this.Name || dotToken != this.DotToken)
        {
            var newNode = Syntax.ExplicitInterfaceSpecifier(name, dotToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ExplicitInterfaceSpecifierSyntax WithName(NameSyntax name)
    {
        return this.Update(name, this.DotToken);
    }

    public ExplicitInterfaceSpecifierSyntax WithDotToken(SyntaxToken dotToken)
    {
        return this.Update(this.Name, dotToken);
    }
  }

  /// <summary>Base type for method declaration syntax.</summary>
  public abstract partial class BaseMethodDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseMethodDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeDeclarationSyntax> Attributes { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxTokenList Modifiers { get; }

    /// <summary>Gets the parameter list.</summary>
    public abstract ParameterListSyntax ParameterList { get; }

    public abstract BlockSyntax Body { get; }

    /// <summary>Gets the optional semicolon token.</summary>
    public abstract SyntaxToken SemicolonToken { get; }
  }

  /// <summary>Method declaration syntax.</summary>
  public sealed partial class MethodDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private SyntaxNode attributes;
    private TypeSyntax returnType;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private TypeParameterListSyntax typeParameterList;
    private ParameterListSyntax parameterList;
    private SyntaxNode constraintClauses;
    private BlockSyntax body;

    internal MethodDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    public override SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the return type syntax.</summary>
    public TypeSyntax ReturnType 
    {
      get { return this.GetRed(ref this.returnType, 2); }
    }

    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier 
    {
      get { return this.GetRed(ref this.explicitInterfaceSpecifier, 3); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(4), this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public TypeParameterListSyntax TypeParameterList 
    {
      get { return this.GetRed(ref this.typeParameterList, 5); }
    }

    public override ParameterListSyntax ParameterList 
    {
      get { return this.GetRed(ref this.parameterList, 6); }
    }

    /// <summary>Gets the constraint clause list.</summary>
    public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
      get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 7)); }
    }

    public override BlockSyntax Body 
    {
      get { return this.GetRed(ref this.body, 8); }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(9), this.GetChildPosition(9), this.GetChildIndex(9)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 2: return this.GetRed(ref this.returnType, 2);
            case 3: return this.GetRed(ref this.explicitInterfaceSpecifier, 3);
            case 5: return this.GetRed(ref this.typeParameterList, 5);
            case 6: return this.GetRed(ref this.parameterList, 6);
            case 7: return this.GetRed(ref this.constraintClauses, 7);
            case 8: return this.GetRed(ref this.body, 8);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 2: return this.returnType;
            case 3: return this.explicitInterfaceSpecifier;
            case 5: return this.typeParameterList;
            case 6: return this.parameterList;
            case 7: return this.constraintClauses;
            case 8: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMethodDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitMethodDeclaration(this);
    }

    public MethodDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || returnType != this.ReturnType || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.MethodDeclaration(attributes, modifiers, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public MethodDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithReturnType(TypeSyntax returnType)
    {
        return this.Update(this.Attributes, this.Modifiers, returnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ReturnType, explicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ReturnType, this.ExplicitInterfaceSpecifier, identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, typeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, parameterList, this.ConstraintClauses, this.Body, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, constraintClauses, this.Body, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, body, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, semicolonToken);
    }

    public MethodDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public MethodDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public MethodDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? Syntax.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.Add(items)));
    }

    public MethodDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.Add(items)));
    }

    public MethodDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.Add(items));
    }

    public MethodDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? Syntax.Block();
        return this.WithBody(body.WithStatements(body.Statements.Add(items)));
    }
  }

  /// <summary>Operator declaration syntax.</summary>
  public sealed partial class OperatorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private SyntaxNode attributes;
    private TypeSyntax returnType;
    private ParameterListSyntax parameterList;
    private BlockSyntax body;

    internal OperatorDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    public override SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the return type.</summary>
    public TypeSyntax ReturnType 
    {
      get { return this.GetRed(ref this.returnType, 2); }
    }

    /// <summary>Gets the "operator" keyword.</summary>
    public SyntaxToken OperatorKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>Gets the operator token.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(4), this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public override ParameterListSyntax ParameterList 
    {
      get { return this.GetRed(ref this.parameterList, 5); }
    }

    public override BlockSyntax Body 
    {
      get { return this.GetRed(ref this.body, 6); }
    }

    public override SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(7), this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 2: return this.GetRed(ref this.returnType, 2);
            case 5: return this.GetRed(ref this.parameterList, 5);
            case 6: return this.GetRed(ref this.body, 6);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 2: return this.returnType;
            case 5: return this.parameterList;
            case 6: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOperatorDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitOperatorDeclaration(this);
    }

    public OperatorDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || returnType != this.ReturnType || operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameterList != this.ParameterList || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.OperatorDeclaration(attributes, modifiers, returnType, operatorKeyword, operatorToken, parameterList, body, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OperatorDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public OperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public OperatorDeclarationSyntax WithReturnType(TypeSyntax returnType)
    {
        return this.Update(this.Attributes, this.Modifiers, returnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public OperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ReturnType, operatorKeyword, this.OperatorToken, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public OperatorDeclarationSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ReturnType, this.OperatorKeyword, operatorToken, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public OperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, parameterList, this.Body, this.SemicolonToken);
    }

    public OperatorDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, body, this.SemicolonToken);
    }

    public OperatorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, this.Body, semicolonToken);
    }

    public OperatorDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public OperatorDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public OperatorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.Add(items)));
    }

    public OperatorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? Syntax.Block();
        return this.WithBody(body.WithStatements(body.Statements.Add(items)));
    }
  }

  /// <summary>Conversion operator declaration syntax.</summary>
  public sealed partial class ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private SyntaxNode attributes;
    private TypeSyntax type;
    private ParameterListSyntax parameterList;
    private BlockSyntax body;

    internal ConversionOperatorDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    public override SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the "implicit" or "explicit" token.</summary>
    public SyntaxToken ImplicitOrExplicitKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the "operator" token.</summary>
    public SyntaxToken OperatorKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>Gets the type.</summary>
    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 4); }
    }

    public override ParameterListSyntax ParameterList 
    {
      get { return this.GetRed(ref this.parameterList, 5); }
    }

    public override BlockSyntax Body 
    {
      get { return this.GetRed(ref this.body, 6); }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(7), this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 4: return this.GetRed(ref this.type, 4);
            case 5: return this.GetRed(ref this.parameterList, 5);
            case 6: return this.GetRed(ref this.body, 6);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 4: return this.type;
            case 5: return this.parameterList;
            case 6: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConversionOperatorDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitConversionOperatorDeclaration(this);
    }

    public ConversionOperatorDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameterList != this.ParameterList || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ConversionOperatorDeclaration(attributes, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConversionOperatorDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public ConversionOperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public ConversionOperatorDeclarationSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword)
    {
        return this.Update(this.Attributes, this.Modifiers, implicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public ConversionOperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ImplicitOrExplicitKeyword, operatorKeyword, this.Type, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public ConversionOperatorDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, type, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public ConversionOperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, parameterList, this.Body, this.SemicolonToken);
    }

    public ConversionOperatorDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, body, this.SemicolonToken);
    }

    public ConversionOperatorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, this.Body, semicolonToken);
    }

    public ConversionOperatorDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public ConversionOperatorDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public ConversionOperatorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.Add(items)));
    }

    public ConversionOperatorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? Syntax.Block();
        return this.WithBody(body.WithStatements(body.Statements.Add(items)));
    }
  }

  /// <summary>Constructor declaration syntax.</summary>
  public sealed partial class ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private SyntaxNode attributes;
    private ParameterListSyntax parameterList;
    private ConstructorInitializerSyntax initializer;
    private BlockSyntax body;

    internal ConstructorDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    public override SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override ParameterListSyntax ParameterList 
    {
      get { return this.GetRed(ref this.parameterList, 3); }
    }

    public ConstructorInitializerSyntax Initializer 
    {
      get { return this.GetRed(ref this.initializer, 4); }
    }

    public override BlockSyntax Body 
    {
      get { return this.GetRed(ref this.body, 5); }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(6), this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 3: return this.GetRed(ref this.parameterList, 3);
            case 4: return this.GetRed(ref this.initializer, 4);
            case 5: return this.GetRed(ref this.body, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 3: return this.parameterList;
            case 4: return this.initializer;
            case 5: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitConstructorDeclaration(this);
    }

    public ConstructorDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || identifier != this.Identifier || parameterList != this.ParameterList || initializer != this.Initializer || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.ConstructorDeclaration(attributes, modifiers, identifier, parameterList, initializer, body, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConstructorDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.Identifier, this.ParameterList, this.Initializer, this.Body, this.SemicolonToken);
    }

    public ConstructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.Identifier, this.ParameterList, this.Initializer, this.Body, this.SemicolonToken);
    }

    public ConstructorDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Attributes, this.Modifiers, identifier, this.ParameterList, this.Initializer, this.Body, this.SemicolonToken);
    }

    public ConstructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Identifier, parameterList, this.Initializer, this.Body, this.SemicolonToken);
    }

    public ConstructorDeclarationSyntax WithInitializer(ConstructorInitializerSyntax initializer)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Identifier, this.ParameterList, initializer, this.Body, this.SemicolonToken);
    }

    public ConstructorDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Identifier, this.ParameterList, this.Initializer, body, this.SemicolonToken);
    }

    public ConstructorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Identifier, this.ParameterList, this.Initializer, this.Body, semicolonToken);
    }

    public ConstructorDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public ConstructorDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public ConstructorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.Add(items)));
    }

    public ConstructorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? Syntax.Block();
        return this.WithBody(body.WithStatements(body.Statements.Add(items)));
    }
  }

  /// <summary>Constructor initializer syntax.</summary>
  public sealed partial class ConstructorInitializerSyntax : SyntaxNode
  {
    private ArgumentListSyntax argumentList;

    internal ConstructorInitializerSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    /// <summary>Gets the "this" or "base" keyword.</summary>
    public SyntaxToken ThisOrBaseKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public ArgumentListSyntax ArgumentList 
    {
      get { return this.GetRed(ref this.argumentList, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.argumentList, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorInitializer(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitConstructorInitializer(this);
    }

    public ConstructorInitializerSyntax Update(SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
        if (colonToken != this.ColonToken || thisOrBaseKeyword != this.ThisOrBaseKeyword || argumentList != this.ArgumentList)
        {
            var newNode = Syntax.ConstructorInitializer(this.Kind, colonToken, thisOrBaseKeyword, argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConstructorInitializerSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(colonToken, this.ThisOrBaseKeyword, this.ArgumentList);
    }

    public ConstructorInitializerSyntax WithThisOrBaseKeyword(SyntaxToken thisOrBaseKeyword)
    {
        return this.Update(this.ColonToken, thisOrBaseKeyword, this.ArgumentList);
    }

    public ConstructorInitializerSyntax WithArgumentList(ArgumentListSyntax argumentList)
    {
        return this.Update(this.ColonToken, this.ThisOrBaseKeyword, argumentList);
    }

    public ConstructorInitializerSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        return this.WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.Add(items)));
    }
  }

  /// <summary>Destructor declaration syntax.</summary>
  public sealed partial class DestructorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private SyntaxNode attributes;
    private ParameterListSyntax parameterList;
    private BlockSyntax body;

    internal DestructorDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    public override SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the tilde token.</summary>
    public SyntaxToken TildeToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override ParameterListSyntax ParameterList 
    {
      get { return this.GetRed(ref this.parameterList, 4); }
    }

    public override BlockSyntax Body 
    {
      get { return this.GetRed(ref this.body, 5); }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(6), this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 4: return this.GetRed(ref this.parameterList, 4);
            case 5: return this.GetRed(ref this.body, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 4: return this.parameterList;
            case 5: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDestructorDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitDestructorDeclaration(this);
    }

    public DestructorDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || tildeToken != this.TildeToken || identifier != this.Identifier || parameterList != this.ParameterList || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.DestructorDeclaration(attributes, modifiers, tildeToken, identifier, parameterList, body, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DestructorDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.TildeToken, this.Identifier, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public DestructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.TildeToken, this.Identifier, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public DestructorDeclarationSyntax WithTildeToken(SyntaxToken tildeToken)
    {
        return this.Update(this.Attributes, this.Modifiers, tildeToken, this.Identifier, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public DestructorDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Attributes, this.Modifiers, this.TildeToken, identifier, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public DestructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.TildeToken, this.Identifier, parameterList, this.Body, this.SemicolonToken);
    }

    public DestructorDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.Attributes, this.Modifiers, this.TildeToken, this.Identifier, this.ParameterList, body, this.SemicolonToken);
    }

    public DestructorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.TildeToken, this.Identifier, this.ParameterList, this.Body, semicolonToken);
    }

    public DestructorDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public DestructorDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public DestructorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.Add(items)));
    }

    public DestructorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? Syntax.Block();
        return this.WithBody(body.WithStatements(body.Statements.Add(items)));
    }
  }

  /// <summary>Base type for property declaration syntax.</summary>
  public abstract partial class BasePropertyDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BasePropertyDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeDeclarationSyntax> Attributes { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxTokenList Modifiers { get; }

    /// <summary>Gets the type syntax.</summary>
    public abstract TypeSyntax Type { get; }

    /// <summary>Gets the optional explicit interface specifier.</summary>
    public abstract ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }

    public abstract AccessorListSyntax AccessorList { get; }
  }

  public sealed partial class PropertyDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    private SyntaxNode attributes;
    private TypeSyntax type;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private AccessorListSyntax accessorList;

    internal PropertyDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    public override SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 2); }
    }

    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier 
    {
      get { return this.GetRed(ref this.explicitInterfaceSpecifier, 3); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(4), this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public override AccessorListSyntax AccessorList 
    {
      get { return this.GetRed(ref this.accessorList, 5); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 2: return this.GetRed(ref this.type, 2);
            case 3: return this.GetRed(ref this.explicitInterfaceSpecifier, 3);
            case 5: return this.GetRed(ref this.accessorList, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 2: return this.type;
            case 3: return this.explicitInterfaceSpecifier;
            case 5: return this.accessorList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPropertyDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitPropertyDeclaration(this);
    }

    public PropertyDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList)
        {
            var newNode = Syntax.PropertyDeclaration(attributes, modifiers, type, explicitInterfaceSpecifier, identifier, accessorList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PropertyDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList);
    }

    public PropertyDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList);
    }

    public PropertyDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Attributes, this.Modifiers, type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList);
    }

    public PropertyDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Type, explicitInterfaceSpecifier, this.Identifier, this.AccessorList);
    }

    public PropertyDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Type, this.ExplicitInterfaceSpecifier, identifier, this.AccessorList);
    }

    public PropertyDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, accessorList);
    }

    public PropertyDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public PropertyDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public PropertyDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items)
    {
        return this.WithAccessorList(this.AccessorList.WithAccessors(this.AccessorList.Accessors.Add(items)));
    }
  }

  public sealed partial class EventDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    private SyntaxNode attributes;
    private TypeSyntax type;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private AccessorListSyntax accessorList;

    internal EventDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    public override SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken EventKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 3); }
    }

    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier 
    {
      get { return this.GetRed(ref this.explicitInterfaceSpecifier, 4); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(5), this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public override AccessorListSyntax AccessorList 
    {
      get { return this.GetRed(ref this.accessorList, 6); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 3: return this.GetRed(ref this.type, 3);
            case 4: return this.GetRed(ref this.explicitInterfaceSpecifier, 4);
            case 6: return this.GetRed(ref this.accessorList, 6);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 3: return this.type;
            case 4: return this.explicitInterfaceSpecifier;
            case 6: return this.accessorList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEventDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEventDeclaration(this);
    }

    public EventDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList)
        {
            var newNode = Syntax.EventDeclaration(attributes, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EventDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.EventKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList);
    }

    public EventDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.EventKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList);
    }

    public EventDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword)
    {
        return this.Update(this.Attributes, this.Modifiers, eventKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList);
    }

    public EventDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Attributes, this.Modifiers, this.EventKeyword, type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList);
    }

    public EventDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)
    {
        return this.Update(this.Attributes, this.Modifiers, this.EventKeyword, this.Type, explicitInterfaceSpecifier, this.Identifier, this.AccessorList);
    }

    public EventDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Attributes, this.Modifiers, this.EventKeyword, this.Type, this.ExplicitInterfaceSpecifier, identifier, this.AccessorList);
    }

    public EventDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.EventKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, accessorList);
    }

    public EventDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public EventDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public EventDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items)
    {
        return this.WithAccessorList(this.AccessorList.WithAccessors(this.AccessorList.Accessors.Add(items)));
    }
  }

  public sealed partial class IndexerDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    private SyntaxNode attributes;
    private TypeSyntax type;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private BracketedParameterListSyntax parameterList;
    private AccessorListSyntax accessorList;

    internal IndexerDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    public override SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 2); }
    }

    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier 
    {
      get { return this.GetRed(ref this.explicitInterfaceSpecifier, 3); }
    }

    public SyntaxToken ThisKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(4), this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    /// <summary>Gets the parameter list.</summary>
    public BracketedParameterListSyntax ParameterList 
    {
      get { return this.GetRed(ref this.parameterList, 5); }
    }

    public override AccessorListSyntax AccessorList 
    {
      get { return this.GetRed(ref this.accessorList, 6); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 2: return this.GetRed(ref this.type, 2);
            case 3: return this.GetRed(ref this.explicitInterfaceSpecifier, 3);
            case 5: return this.GetRed(ref this.parameterList, 5);
            case 6: return this.GetRed(ref this.accessorList, 6);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 2: return this.type;
            case 3: return this.explicitInterfaceSpecifier;
            case 5: return this.parameterList;
            case 6: return this.accessorList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIndexerDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitIndexerDeclaration(this);
    }

    public IndexerDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || thisKeyword != this.ThisKeyword || parameterList != this.ParameterList || accessorList != this.AccessorList)
        {
            var newNode = Syntax.IndexerDeclaration(attributes, modifiers, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IndexerDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.Type, this.ExplicitInterfaceSpecifier, this.ThisKeyword, this.ParameterList, this.AccessorList);
    }

    public IndexerDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.Type, this.ExplicitInterfaceSpecifier, this.ThisKeyword, this.ParameterList, this.AccessorList);
    }

    public IndexerDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Attributes, this.Modifiers, type, this.ExplicitInterfaceSpecifier, this.ThisKeyword, this.ParameterList, this.AccessorList);
    }

    public IndexerDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Type, explicitInterfaceSpecifier, this.ThisKeyword, this.ParameterList, this.AccessorList);
    }

    public IndexerDeclarationSyntax WithThisKeyword(SyntaxToken thisKeyword)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Type, this.ExplicitInterfaceSpecifier, thisKeyword, this.ParameterList, this.AccessorList);
    }

    public IndexerDeclarationSyntax WithParameterList(BracketedParameterListSyntax parameterList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Type, this.ExplicitInterfaceSpecifier, this.ThisKeyword, parameterList, this.AccessorList);
    }

    public IndexerDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Type, this.ExplicitInterfaceSpecifier, this.ThisKeyword, this.ParameterList, accessorList);
    }

    public IndexerDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public IndexerDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public IndexerDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.Add(items)));
    }

    public IndexerDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items)
    {
        return this.WithAccessorList(this.AccessorList.WithAccessors(this.AccessorList.Accessors.Add(items)));
    }
  }

  public sealed partial class AccessorListSyntax : SyntaxNode
  {
    private SyntaxNode accessors;

    internal AccessorListSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxList<AccessorDeclarationSyntax> Accessors 
    {
      get { return new SyntaxList<AccessorDeclarationSyntax>(this.GetRed(ref this.accessors, 1)); }
    }

    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.accessors, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.accessors;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAccessorList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAccessorList(this);
    }

    public AccessorListSyntax Update(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || accessors != this.Accessors || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = Syntax.AccessorList(openBraceToken, accessors, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AccessorListSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(openBraceToken, this.Accessors, this.CloseBraceToken);
    }

    public AccessorListSyntax WithAccessors(SyntaxList<AccessorDeclarationSyntax> accessors)
    {
        return this.Update(this.OpenBraceToken, accessors, this.CloseBraceToken);
    }

    public AccessorListSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.OpenBraceToken, this.Accessors, closeBraceToken);
    }

    public AccessorListSyntax AddAccessors(params AccessorDeclarationSyntax[] items)
    {
        return this.WithAccessors(this.Accessors.Add(items));
    }
  }

  public sealed partial class AccessorDeclarationSyntax : SyntaxNode
  {
    private SyntaxNode attributes;
    private BlockSyntax body;

    internal AccessorDeclarationSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    /// <summary>Gets the modifier list.</summary>
    public SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
    public BlockSyntax Body 
    {
      get { return this.GetRed(ref this.body, 3); }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(4), this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 3: return this.GetRed(ref this.body, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 3: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAccessorDeclaration(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitAccessorDeclaration(this);
    }

    public AccessorDeclarationSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || keyword != this.Keyword || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = Syntax.AccessorDeclaration(this.Kind, attributes, modifiers, keyword, body, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AccessorDeclarationSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.Keyword, this.Body, this.SemicolonToken);
    }

    public AccessorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.Keyword, this.Body, this.SemicolonToken);
    }

    public AccessorDeclarationSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(this.Attributes, this.Modifiers, keyword, this.Body, this.SemicolonToken);
    }

    public AccessorDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, body, this.SemicolonToken);
    }

    public AccessorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Keyword, this.Body, semicolonToken);
    }

    public AccessorDeclarationSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public AccessorDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }

    public AccessorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? Syntax.Block();
        return this.WithBody(body.WithStatements(body.Statements.Add(items)));
    }
  }

  /// <summary>Base type for parameter list syntax.</summary>
  public abstract partial class BaseParameterListSyntax : SyntaxNode
  {
    internal BaseParameterListSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }

    /// <summary>Gets the parameter list.</summary>
    public abstract SeparatedSyntaxList<ParameterSyntax> Parameters { get; }
  }

  /// <summary>Parameter list syntax.</summary>
  public sealed partial class ParameterListSyntax : BaseParameterListSyntax
  {
    private SyntaxNode parameters;

    internal ParameterListSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public override SeparatedSyntaxList<ParameterSyntax> Parameters 
    {
      get { return new SeparatedSyntaxList<ParameterSyntax>(this.GetRed(ref this.parameters, 1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParameterList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitParameterList(this);
    }

    public ParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
        {
            var newNode = Syntax.ParameterList(openParenToken, parameters, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Parameters, this.CloseParenToken);
    }

    public ParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters)
    {
        return this.Update(this.OpenParenToken, parameters, this.CloseParenToken);
    }

    public ParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Parameters, closeParenToken);
    }

    public ParameterListSyntax AddParameters(params ParameterSyntax[] items)
    {
        return this.WithParameters(this.Parameters.Add(items));
    }
  }

  /// <summary>Parameter list syntax with surrounding brackets.</summary>
  public sealed partial class BracketedParameterListSyntax : BaseParameterListSyntax
  {
    private SyntaxNode parameters;

    internal BracketedParameterListSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public override SeparatedSyntaxList<ParameterSyntax> Parameters 
    {
      get { return new SeparatedSyntaxList<ParameterSyntax>(this.GetRed(ref this.parameters, 1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBracketedParameterList(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBracketedParameterList(this);
    }

    public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = Syntax.BracketedParameterList(openBracketToken, parameters, closeBracketToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(openBracketToken, this.Parameters, this.CloseBracketToken);
    }

    public BracketedParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters)
    {
        return this.Update(this.OpenBracketToken, parameters, this.CloseBracketToken);
    }

    public BracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.OpenBracketToken, this.Parameters, closeBracketToken);
    }

    public BracketedParameterListSyntax AddParameters(params ParameterSyntax[] items)
    {
        return this.WithParameters(this.Parameters.Add(items));
    }
  }

  /// <summary>Parameter syntax.</summary>
  public sealed partial class ParameterSyntax : SyntaxNode
  {
    private SyntaxNode attributes;
    private TypeSyntax type;
    private EqualsValueClauseSyntax @default;

    internal ParameterSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    /// <summary>Gets the modifier list.</summary>
    public SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 2); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public EqualsValueClauseSyntax Default 
    {
      get { return this.GetRed(ref this.@default, 4); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 2: return this.GetRed(ref this.type, 2);
            case 4: return this.GetRed(ref this.@default, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 2: return this.type;
            case 4: return this.@default;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParameter(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitParameter(this);
    }

    public ParameterSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || type != this.Type || identifier != this.Identifier || @default != this.Default)
        {
            var newNode = Syntax.Parameter(attributes, modifiers, type, identifier, @default);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ParameterSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.Type, this.Identifier, this.Default);
    }

    public ParameterSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.Type, this.Identifier, this.Default);
    }

    public ParameterSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Attributes, this.Modifiers, type, this.Identifier, this.Default);
    }

    public ParameterSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Type, identifier, this.Default);
    }

    public ParameterSyntax WithDefault(EqualsValueClauseSyntax @default)
    {
        return this.Update(this.Attributes, this.Modifiers, this.Type, this.Identifier, @default);
    }

    public ParameterSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public ParameterSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }
  }

  public sealed partial class IncompleteMemberSyntax : MemberDeclarationSyntax
  {
    private SyntaxNode attributes;
    private TypeSyntax type;

    internal IncompleteMemberSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeDeclarationSyntax> Attributes 
    {
      get { return new SyntaxList<AttributeDeclarationSyntax>(this.GetRed(ref this.attributes, 0)); }
    }

    /// <summary>Gets the modifier list.</summary>
    public SyntaxTokenList Modifiers 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public TypeSyntax Type 
    {
      get { return this.GetRed(ref this.type, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.attributes, 0);
            case 2: return this.GetRed(ref this.type, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributes;
            case 2: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIncompleteMember(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitIncompleteMember(this);
    }

    public IncompleteMemberSyntax Update(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax type)
    {
        if (attributes != this.Attributes || modifiers != this.Modifiers || type != this.Type)
        {
            var newNode = Syntax.IncompleteMember(attributes, modifiers, type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IncompleteMemberSyntax WithAttributes(SyntaxList<AttributeDeclarationSyntax> attributes)
    {
        return this.Update(attributes, this.Modifiers, this.Type);
    }

    public IncompleteMemberSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.Attributes, modifiers, this.Type);
    }

    public IncompleteMemberSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Attributes, this.Modifiers, type);
    }

    public IncompleteMemberSyntax AddAttributes(params AttributeDeclarationSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }

    public IncompleteMemberSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.Add(items));
    }
  }

  public sealed partial class SkippedTokensSyntax : StructuredTriviaSyntax
  {
    internal SkippedTokensSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxTokenList Tokens 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSkippedTokens(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitSkippedTokens(this);
    }

    public SkippedTokensSyntax Update(SyntaxTokenList tokens)
    {
        if (tokens != this.Tokens)
        {
            var newNode = Syntax.SkippedTokens(tokens);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SkippedTokensSyntax WithTokens(SyntaxTokenList tokens)
    {
        return this.Update(tokens);
    }

    public SkippedTokensSyntax AddTokens(params SyntaxToken[] items)
    {
        return this.WithTokens(this.Tokens.Add(items));
    }
  }

  public sealed partial class DocumentationCommentSyntax : StructuredTriviaSyntax
  {
    private SyntaxNode nodes;

    internal DocumentationCommentSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxList<XmlNodeSyntax> Nodes 
    {
      get { return new SyntaxList<XmlNodeSyntax>(this.GetRed(ref this.nodes, 0)); }
    }

    public SyntaxToken EndOfComment 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.nodes, 0);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nodes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDocumentationComment(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitDocumentationComment(this);
    }

    public DocumentationCommentSyntax Update(SyntaxList<XmlNodeSyntax> nodes, SyntaxToken endOfComment)
    {
        if (nodes != this.Nodes || endOfComment != this.EndOfComment)
        {
            var newNode = Syntax.DocumentationComment(nodes, endOfComment);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DocumentationCommentSyntax WithNodes(SyntaxList<XmlNodeSyntax> nodes)
    {
        return this.Update(nodes, this.EndOfComment);
    }

    public DocumentationCommentSyntax WithEndOfComment(SyntaxToken endOfComment)
    {
        return this.Update(this.Nodes, endOfComment);
    }

    public DocumentationCommentSyntax AddNodes(params XmlNodeSyntax[] items)
    {
        return this.WithNodes(this.Nodes.Add(items));
    }
  }

  public abstract partial class XmlNodeSyntax : SyntaxNode
  {
    internal XmlNodeSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }
  }

  public sealed partial class XmlElementSyntax : XmlNodeSyntax
  {
    private XmlElementStartTagSyntax startTag;
    private SyntaxNode content;
    private XmlElementEndTagSyntax endTag;

    internal XmlElementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public XmlElementStartTagSyntax StartTag 
    {
      get { return this.GetRed(ref this.startTag, 0); }
    }

    public SyntaxList<XmlNodeSyntax> Content 
    {
      get { return new SyntaxList<XmlNodeSyntax>(this.GetRed(ref this.content, 1)); }
    }

    public XmlElementEndTagSyntax EndTag 
    {
      get { return this.GetRed(ref this.endTag, 2); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.startTag, 0);
            case 1: return this.GetRed(ref this.content, 1);
            case 2: return this.GetRed(ref this.endTag, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startTag;
            case 1: return this.content;
            case 2: return this.endTag;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlElement(this);
    }

    public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
        if (startTag != this.StartTag || content != this.Content || endTag != this.EndTag)
        {
            var newNode = Syntax.XmlElement(startTag, content, endTag);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlElementSyntax WithStartTag(XmlElementStartTagSyntax startTag)
    {
        return this.Update(startTag, this.Content, this.EndTag);
    }

    public XmlElementSyntax WithContent(SyntaxList<XmlNodeSyntax> content)
    {
        return this.Update(this.StartTag, content, this.EndTag);
    }

    public XmlElementSyntax WithEndTag(XmlElementEndTagSyntax endTag)
    {
        return this.Update(this.StartTag, this.Content, endTag);
    }

    public XmlElementSyntax AddStartTagAttributes(params XmlAttributeSyntax[] items)
    {
        return this.WithStartTag(this.StartTag.WithAttributes(this.StartTag.Attributes.Add(items)));
    }

    public XmlElementSyntax AddContent(params XmlNodeSyntax[] items)
    {
        return this.WithContent(this.Content.Add(items));
    }
  }

  public sealed partial class XmlElementStartTagSyntax : SyntaxNode
  {
    private XmlNameSyntax name;
    private SyntaxNode attributes;

    internal XmlElementStartTagSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken LessThanToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public XmlNameSyntax Name 
    {
      get { return this.GetRed(ref this.name, 1); }
    }

    public SyntaxList<XmlAttributeSyntax> Attributes 
    {
      get { return new SyntaxList<XmlAttributeSyntax>(this.GetRed(ref this.attributes, 2)); }
    }

    public SyntaxToken GreaterThanToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            case 2: return this.GetRed(ref this.attributes, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            case 2: return this.attributes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElementStartTag(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlElementStartTag(this);
    }

    public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = Syntax.XmlElementStartTag(lessThanToken, name, attributes, greaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlElementStartTagSyntax WithLessThanToken(SyntaxToken lessThanToken)
    {
        return this.Update(lessThanToken, this.Name, this.Attributes, this.GreaterThanToken);
    }

    public XmlElementStartTagSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(this.LessThanToken, name, this.Attributes, this.GreaterThanToken);
    }

    public XmlElementStartTagSyntax WithAttributes(SyntaxList<XmlAttributeSyntax> attributes)
    {
        return this.Update(this.LessThanToken, this.Name, attributes, this.GreaterThanToken);
    }

    public XmlElementStartTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)
    {
        return this.Update(this.LessThanToken, this.Name, this.Attributes, greaterThanToken);
    }

    public XmlElementStartTagSyntax AddAttributes(params XmlAttributeSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }
  }

  public sealed partial class XmlElementEndTagSyntax : SyntaxNode
  {
    private XmlNameSyntax name;

    internal XmlElementEndTagSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken LessThanSlashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public XmlNameSyntax Name 
    {
      get { return this.GetRed(ref this.name, 1); }
    }

    public SyntaxToken GreaterThanToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElementEndTag(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlElementEndTag(this);
    }

    public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
        if (lessThanSlashToken != this.LessThanSlashToken || name != this.Name || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = Syntax.XmlElementEndTag(lessThanSlashToken, name, greaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlElementEndTagSyntax WithLessThanSlashToken(SyntaxToken lessThanSlashToken)
    {
        return this.Update(lessThanSlashToken, this.Name, this.GreaterThanToken);
    }

    public XmlElementEndTagSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(this.LessThanSlashToken, name, this.GreaterThanToken);
    }

    public XmlElementEndTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)
    {
        return this.Update(this.LessThanSlashToken, this.Name, greaterThanToken);
    }
  }

  public sealed partial class XmlEmptyElementSyntax : XmlNodeSyntax
  {
    private XmlNameSyntax name;
    private SyntaxNode attributes;

    internal XmlEmptyElementSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken LessThanToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public XmlNameSyntax Name 
    {
      get { return this.GetRed(ref this.name, 1); }
    }

    public SyntaxList<XmlAttributeSyntax> Attributes 
    {
      get { return new SyntaxList<XmlAttributeSyntax>(this.GetRed(ref this.attributes, 2)); }
    }

    public SyntaxToken SlashGreaterThanToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            case 2: return this.GetRed(ref this.attributes, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            case 2: return this.attributes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlEmptyElement(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlEmptyElement(this);
    }

    public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || slashGreaterThanToken != this.SlashGreaterThanToken)
        {
            var newNode = Syntax.XmlEmptyElement(lessThanToken, name, attributes, slashGreaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlEmptyElementSyntax WithLessThanToken(SyntaxToken lessThanToken)
    {
        return this.Update(lessThanToken, this.Name, this.Attributes, this.SlashGreaterThanToken);
    }

    public XmlEmptyElementSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(this.LessThanToken, name, this.Attributes, this.SlashGreaterThanToken);
    }

    public XmlEmptyElementSyntax WithAttributes(SyntaxList<XmlAttributeSyntax> attributes)
    {
        return this.Update(this.LessThanToken, this.Name, attributes, this.SlashGreaterThanToken);
    }

    public XmlEmptyElementSyntax WithSlashGreaterThanToken(SyntaxToken slashGreaterThanToken)
    {
        return this.Update(this.LessThanToken, this.Name, this.Attributes, slashGreaterThanToken);
    }

    public XmlEmptyElementSyntax AddAttributes(params XmlAttributeSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.Add(items));
    }
  }

  public sealed partial class XmlNameSyntax : SyntaxNode
  {
    private XmlPrefixSyntax prefix;

    internal XmlNameSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public XmlPrefixSyntax Prefix 
    {
      get { return this.GetRed(ref this.prefix, 0); }
    }

    public SyntaxToken LocalName 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.prefix, 0);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.prefix;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlName(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlName(this);
    }

    public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
        if (prefix != this.Prefix || localName != this.LocalName)
        {
            var newNode = Syntax.XmlName(prefix, localName);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlNameSyntax WithPrefix(XmlPrefixSyntax prefix)
    {
        return this.Update(prefix, this.LocalName);
    }

    public XmlNameSyntax WithLocalName(SyntaxToken localName)
    {
        return this.Update(this.Prefix, localName);
    }
  }

  public sealed partial class XmlPrefixSyntax : SyntaxNode
  {
    internal XmlPrefixSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken Prefix 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlPrefix(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlPrefix(this);
    }

    public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken)
    {
        if (prefix != this.Prefix || colonToken != this.ColonToken)
        {
            var newNode = Syntax.XmlPrefix(prefix, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlPrefixSyntax WithPrefix(SyntaxToken prefix)
    {
        return this.Update(prefix, this.ColonToken);
    }

    public XmlPrefixSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Prefix, colonToken);
    }
  }

  public sealed partial class XmlAttributeSyntax : SyntaxNode
  {
    private XmlNameSyntax name;

    internal XmlAttributeSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public XmlNameSyntax Name 
    {
      get { return this.GetRed(ref this.name, 0); }
    }

    public SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken StartQuoteToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxTokenList TextTokens 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public SyntaxToken EndQuoteToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(4), this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRed(ref this.name, 0);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlAttribute(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlAttribute(this);
    }

    public XmlAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || textTokens != this.TextTokens || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = Syntax.XmlAttribute(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlAttributeSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(name, this.EqualsToken, this.StartQuoteToken, this.TextTokens, this.EndQuoteToken);
    }

    public XmlAttributeSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(this.Name, equalsToken, this.StartQuoteToken, this.TextTokens, this.EndQuoteToken);
    }

    public XmlAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken)
    {
        return this.Update(this.Name, this.EqualsToken, startQuoteToken, this.TextTokens, this.EndQuoteToken);
    }

    public XmlAttributeSyntax WithTextTokens(SyntaxTokenList textTokens)
    {
        return this.Update(this.Name, this.EqualsToken, this.StartQuoteToken, textTokens, this.EndQuoteToken);
    }

    public XmlAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken)
    {
        return this.Update(this.Name, this.EqualsToken, this.StartQuoteToken, this.TextTokens, endQuoteToken);
    }

    public XmlAttributeSyntax AddTextTokens(params SyntaxToken[] items)
    {
        return this.WithTextTokens(this.TextTokens.Add(items));
    }
  }

  public sealed partial class XmlTextSyntax : XmlNodeSyntax
  {
    internal XmlTextSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxTokenList TextTokens 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlText(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlText(this);
    }

    public XmlTextSyntax Update(SyntaxTokenList textTokens)
    {
        if (textTokens != this.TextTokens)
        {
            var newNode = Syntax.XmlText(textTokens);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlTextSyntax WithTextTokens(SyntaxTokenList textTokens)
    {
        return this.Update(textTokens);
    }

    public XmlTextSyntax AddTextTokens(params SyntaxToken[] items)
    {
        return this.WithTextTokens(this.TextTokens.Add(items));
    }
  }

  public sealed partial class XmlCDataSectionSyntax : XmlNodeSyntax
  {
    internal XmlCDataSectionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken StartCDataToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxTokenList TextTokens 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken EndCDataToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlCDataSection(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlCDataSection(this);
    }

    public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken)
    {
        if (startCDataToken != this.StartCDataToken || textTokens != this.TextTokens || endCDataToken != this.EndCDataToken)
        {
            var newNode = Syntax.XmlCDataSection(startCDataToken, textTokens, endCDataToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlCDataSectionSyntax WithStartCDataToken(SyntaxToken startCDataToken)
    {
        return this.Update(startCDataToken, this.TextTokens, this.EndCDataToken);
    }

    public XmlCDataSectionSyntax WithTextTokens(SyntaxTokenList textTokens)
    {
        return this.Update(this.StartCDataToken, textTokens, this.EndCDataToken);
    }

    public XmlCDataSectionSyntax WithEndCDataToken(SyntaxToken endCDataToken)
    {
        return this.Update(this.StartCDataToken, this.TextTokens, endCDataToken);
    }

    public XmlCDataSectionSyntax AddTextTokens(params SyntaxToken[] items)
    {
        return this.WithTextTokens(this.TextTokens.Add(items));
    }
  }

  public sealed partial class XmlProcessingInstructionSyntax : XmlNodeSyntax
  {
    private XmlNameSyntax name;

    internal XmlProcessingInstructionSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken StartProcessingInstructionToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public XmlNameSyntax Name 
    {
      get { return this.GetRed(ref this.name, 1); }
    }

    public SyntaxTokenList TextTokens 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken EndProcessingInstructionToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlProcessingInstruction(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlProcessingInstruction(this);
    }

    public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken)
    {
        if (startProcessingInstructionToken != this.StartProcessingInstructionToken || name != this.Name || textTokens != this.TextTokens || endProcessingInstructionToken != this.EndProcessingInstructionToken)
        {
            var newNode = Syntax.XmlProcessingInstruction(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlProcessingInstructionSyntax WithStartProcessingInstructionToken(SyntaxToken startProcessingInstructionToken)
    {
        return this.Update(startProcessingInstructionToken, this.Name, this.TextTokens, this.EndProcessingInstructionToken);
    }

    public XmlProcessingInstructionSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(this.StartProcessingInstructionToken, name, this.TextTokens, this.EndProcessingInstructionToken);
    }

    public XmlProcessingInstructionSyntax WithTextTokens(SyntaxTokenList textTokens)
    {
        return this.Update(this.StartProcessingInstructionToken, this.Name, textTokens, this.EndProcessingInstructionToken);
    }

    public XmlProcessingInstructionSyntax WithEndProcessingInstructionToken(SyntaxToken endProcessingInstructionToken)
    {
        return this.Update(this.StartProcessingInstructionToken, this.Name, this.TextTokens, endProcessingInstructionToken);
    }

    public XmlProcessingInstructionSyntax AddTextTokens(params SyntaxToken[] items)
    {
        return this.WithTextTokens(this.TextTokens.Add(items));
    }
  }

  public sealed partial class XmlCommentSyntax : XmlNodeSyntax
  {
    internal XmlCommentSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public SyntaxToken LessThanExclamationMinusMinusToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxTokenList TextTokens 
    {
      get { return new SyntaxTokenList(this, this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken MinusMinusGreaterThanToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlComment(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitXmlComment(this);
    }

    public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
        if (lessThanExclamationMinusMinusToken != this.LessThanExclamationMinusMinusToken || textTokens != this.TextTokens || minusMinusGreaterThanToken != this.MinusMinusGreaterThanToken)
        {
            var newNode = Syntax.XmlComment(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlCommentSyntax WithLessThanExclamationMinusMinusToken(SyntaxToken lessThanExclamationMinusMinusToken)
    {
        return this.Update(lessThanExclamationMinusMinusToken, this.TextTokens, this.MinusMinusGreaterThanToken);
    }

    public XmlCommentSyntax WithTextTokens(SyntaxTokenList textTokens)
    {
        return this.Update(this.LessThanExclamationMinusMinusToken, textTokens, this.MinusMinusGreaterThanToken);
    }

    public XmlCommentSyntax WithMinusMinusGreaterThanToken(SyntaxToken minusMinusGreaterThanToken)
    {
        return this.Update(this.LessThanExclamationMinusMinusToken, this.TextTokens, minusMinusGreaterThanToken);
    }

    public XmlCommentSyntax AddTextTokens(params SyntaxToken[] items)
    {
        return this.WithTextTokens(this.TextTokens.Add(items));
    }
  }

  public abstract partial class DirectiveSyntax : StructuredTriviaSyntax
  {
    internal DirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }

    public abstract SyntaxToken HashToken { get; }

    public abstract SyntaxToken EndOfDirectiveToken { get; }

    public abstract bool IsActive { get; }
  }

  public abstract partial class BranchingDirectiveSyntax : DirectiveSyntax
  {
    internal BranchingDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }

    public abstract bool BranchTaken { get; }
  }

  public abstract partial class ConditionalDirectiveSyntax : BranchingDirectiveSyntax
  {
    internal ConditionalDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
      : base(parent, green, position)
    {
    }

    public abstract ExpressionSyntax Condition { get; }

    public abstract bool ConditionValue { get; }
  }

  public sealed partial class IfDirectiveSyntax : ConditionalDirectiveSyntax
  {
    private ExpressionSyntax condition;

    internal IfDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken IfKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override ExpressionSyntax Condition 
    {
      get { return this.GetRed(ref this.condition, 2); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((InternalSyntax.IfDirectiveSyntax)this.Green).IsActive; } }

    public override bool BranchTaken { get { return ((InternalSyntax.IfDirectiveSyntax)this.Green).BranchTaken; } }

    public override bool ConditionValue { get { return ((InternalSyntax.IfDirectiveSyntax)this.Green).ConditionValue; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.condition, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.condition;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIfDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitIfDirective(this);
    }

    public IfDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
        if (hashToken != this.HashToken || ifKeyword != this.IfKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.IfDirective(hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IfDirectiveSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.IfKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public IfDirectiveSyntax WithIfKeyword(SyntaxToken ifKeyword)
    {
        return this.Update(this.HashToken, ifKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public IfDirectiveSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.HashToken, this.IfKeyword, condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public IfDirectiveSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.IfKeyword, this.Condition, endOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public IfDirectiveSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.IfKeyword, this.Condition, this.EndOfDirectiveToken, isActive, this.BranchTaken, this.ConditionValue);
    }

    public IfDirectiveSyntax WithBranchTaken(bool branchTaken)
    {
        return this.Update(this.HashToken, this.IfKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, branchTaken, this.ConditionValue);
    }

    public IfDirectiveSyntax WithConditionValue(bool conditionValue)
    {
        return this.Update(this.HashToken, this.IfKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, conditionValue);
    }
  }

  public sealed partial class ElifDirectiveSyntax : ConditionalDirectiveSyntax
  {
    private ExpressionSyntax condition;

    internal ElifDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken ElifKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override ExpressionSyntax Condition 
    {
      get { return this.GetRed(ref this.condition, 2); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((InternalSyntax.ElifDirectiveSyntax)this.Green).IsActive; } }

    public override bool BranchTaken { get { return ((InternalSyntax.ElifDirectiveSyntax)this.Green).BranchTaken; } }

    public override bool ConditionValue { get { return ((InternalSyntax.ElifDirectiveSyntax)this.Green).ConditionValue; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.condition, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.condition;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElifDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitElifDirective(this);
    }

    public ElifDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
        if (hashToken != this.HashToken || elifKeyword != this.ElifKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.ElifDirective(hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ElifDirectiveSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.ElifKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public ElifDirectiveSyntax WithElifKeyword(SyntaxToken elifKeyword)
    {
        return this.Update(this.HashToken, elifKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public ElifDirectiveSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.HashToken, this.ElifKeyword, condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public ElifDirectiveSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.ElifKeyword, this.Condition, endOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public ElifDirectiveSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.ElifKeyword, this.Condition, this.EndOfDirectiveToken, isActive, this.BranchTaken, this.ConditionValue);
    }

    public ElifDirectiveSyntax WithBranchTaken(bool branchTaken)
    {
        return this.Update(this.HashToken, this.ElifKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, branchTaken, this.ConditionValue);
    }

    public ElifDirectiveSyntax WithConditionValue(bool conditionValue)
    {
        return this.Update(this.HashToken, this.ElifKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, conditionValue);
    }
  }

  public sealed partial class ElseDirectiveSyntax : BranchingDirectiveSyntax
  {
    internal ElseDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken ElseKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((InternalSyntax.ElseDirectiveSyntax)this.Green).IsActive; } }

    public override bool BranchTaken { get { return ((InternalSyntax.ElseDirectiveSyntax)this.Green).BranchTaken; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElseDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitElseDirective(this);
    }

    public ElseDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
        if (hashToken != this.HashToken || elseKeyword != this.ElseKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.ElseDirective(hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ElseDirectiveSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.ElseKeyword, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken);
    }

    public ElseDirectiveSyntax WithElseKeyword(SyntaxToken elseKeyword)
    {
        return this.Update(this.HashToken, elseKeyword, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken);
    }

    public ElseDirectiveSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.ElseKeyword, endOfDirectiveToken, this.IsActive, this.BranchTaken);
    }

    public ElseDirectiveSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.ElseKeyword, this.EndOfDirectiveToken, isActive, this.BranchTaken);
    }

    public ElseDirectiveSyntax WithBranchTaken(bool branchTaken)
    {
        return this.Update(this.HashToken, this.ElseKeyword, this.EndOfDirectiveToken, this.IsActive, branchTaken);
    }
  }

  public sealed partial class EndIfDirectiveSyntax : DirectiveSyntax
  {
    internal EndIfDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken EndIfKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((InternalSyntax.EndIfDirectiveSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEndIfDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEndIfDirective(this);
    }

    public EndIfDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || endIfKeyword != this.EndIfKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.EndIfDirective(hashToken, endIfKeyword, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EndIfDirectiveSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.EndIfKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public EndIfDirectiveSyntax WithEndIfKeyword(SyntaxToken endIfKeyword)
    {
        return this.Update(this.HashToken, endIfKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public EndIfDirectiveSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.EndIfKeyword, endOfDirectiveToken, this.IsActive);
    }

    public EndIfDirectiveSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.EndIfKeyword, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class RegionDirectiveSyntax : DirectiveSyntax
  {
    internal RegionDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken RegionKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((InternalSyntax.RegionDirectiveSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRegionDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitRegionDirective(this);
    }

    public RegionDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || regionKeyword != this.RegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.RegionDirective(hashToken, regionKeyword, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public RegionDirectiveSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.RegionKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public RegionDirectiveSyntax WithRegionKeyword(SyntaxToken regionKeyword)
    {
        return this.Update(this.HashToken, regionKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public RegionDirectiveSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.RegionKeyword, endOfDirectiveToken, this.IsActive);
    }

    public RegionDirectiveSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.RegionKeyword, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class EndRegionDirectiveSyntax : DirectiveSyntax
  {
    internal EndRegionDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken EndRegionKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((InternalSyntax.EndRegionDirectiveSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEndRegionDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitEndRegionDirective(this);
    }

    public EndRegionDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || endRegionKeyword != this.EndRegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.EndRegionDirective(hashToken, endRegionKeyword, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EndRegionDirectiveSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.EndRegionKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public EndRegionDirectiveSyntax WithEndRegionKeyword(SyntaxToken endRegionKeyword)
    {
        return this.Update(this.HashToken, endRegionKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public EndRegionDirectiveSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.EndRegionKeyword, endOfDirectiveToken, this.IsActive);
    }

    public EndRegionDirectiveSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.EndRegionKeyword, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class ErrorDirectiveSyntax : DirectiveSyntax
  {
    internal ErrorDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken ErrorKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((InternalSyntax.ErrorDirectiveSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitErrorDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitErrorDirective(this);
    }

    public ErrorDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || errorKeyword != this.ErrorKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.ErrorDirective(hashToken, errorKeyword, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ErrorDirectiveSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.ErrorKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public ErrorDirectiveSyntax WithErrorKeyword(SyntaxToken errorKeyword)
    {
        return this.Update(this.HashToken, errorKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public ErrorDirectiveSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.ErrorKeyword, endOfDirectiveToken, this.IsActive);
    }

    public ErrorDirectiveSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.ErrorKeyword, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class WarningDirectiveSyntax : DirectiveSyntax
  {
    internal WarningDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken WarningKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((InternalSyntax.WarningDirectiveSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWarningDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitWarningDirective(this);
    }

    public WarningDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || warningKeyword != this.WarningKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.WarningDirective(hashToken, warningKeyword, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public WarningDirectiveSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.WarningKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public WarningDirectiveSyntax WithWarningKeyword(SyntaxToken warningKeyword)
    {
        return this.Update(this.HashToken, warningKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public WarningDirectiveSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.WarningKeyword, endOfDirectiveToken, this.IsActive);
    }

    public WarningDirectiveSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.WarningKeyword, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class BadDirectiveSyntax : DirectiveSyntax
  {
    internal BadDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((InternalSyntax.BadDirectiveSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBadDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitBadDirective(this);
    }

    public BadDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || identifier != this.Identifier || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.BadDirective(hashToken, identifier, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BadDirectiveSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.Identifier, this.EndOfDirectiveToken, this.IsActive);
    }

    public BadDirectiveSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.HashToken, identifier, this.EndOfDirectiveToken, this.IsActive);
    }

    public BadDirectiveSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.Identifier, endOfDirectiveToken, this.IsActive);
    }

    public BadDirectiveSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.Identifier, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class DefineDirectiveSyntax : DirectiveSyntax
  {
    internal DefineDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken DefineKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken Name 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((InternalSyntax.DefineDirectiveSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefineDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitDefineDirective(this);
    }

    public DefineDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || defineKeyword != this.DefineKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.DefineDirective(hashToken, defineKeyword, name, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DefineDirectiveSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.DefineKeyword, this.Name, this.EndOfDirectiveToken, this.IsActive);
    }

    public DefineDirectiveSyntax WithDefineKeyword(SyntaxToken defineKeyword)
    {
        return this.Update(this.HashToken, defineKeyword, this.Name, this.EndOfDirectiveToken, this.IsActive);
    }

    public DefineDirectiveSyntax WithName(SyntaxToken name)
    {
        return this.Update(this.HashToken, this.DefineKeyword, name, this.EndOfDirectiveToken, this.IsActive);
    }

    public DefineDirectiveSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.DefineKeyword, this.Name, endOfDirectiveToken, this.IsActive);
    }

    public DefineDirectiveSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.DefineKeyword, this.Name, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class UndefDirectiveSyntax : DirectiveSyntax
  {
    internal UndefDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken UndefKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken Name 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((InternalSyntax.UndefDirectiveSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUndefDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitUndefDirective(this);
    }

    public UndefDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || undefKeyword != this.UndefKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.UndefDirective(hashToken, undefKeyword, name, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public UndefDirectiveSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.UndefKeyword, this.Name, this.EndOfDirectiveToken, this.IsActive);
    }

    public UndefDirectiveSyntax WithUndefKeyword(SyntaxToken undefKeyword)
    {
        return this.Update(this.HashToken, undefKeyword, this.Name, this.EndOfDirectiveToken, this.IsActive);
    }

    public UndefDirectiveSyntax WithName(SyntaxToken name)
    {
        return this.Update(this.HashToken, this.UndefKeyword, name, this.EndOfDirectiveToken, this.IsActive);
    }

    public UndefDirectiveSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.UndefKeyword, this.Name, endOfDirectiveToken, this.IsActive);
    }

    public UndefDirectiveSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.UndefKeyword, this.Name, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class LineDirectiveSyntax : DirectiveSyntax
  {
    internal LineDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken LineKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken Line 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken File 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(4), this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public override bool IsActive { get { return ((InternalSyntax.LineDirectiveSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLineDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitLineDirective(this);
    }

    public LineDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || lineKeyword != this.LineKeyword || line != this.Line || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.LineDirective(hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LineDirectiveSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.LineKeyword, this.Line, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public LineDirectiveSyntax WithLineKeyword(SyntaxToken lineKeyword)
    {
        return this.Update(this.HashToken, lineKeyword, this.Line, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public LineDirectiveSyntax WithLine(SyntaxToken line)
    {
        return this.Update(this.HashToken, this.LineKeyword, line, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public LineDirectiveSyntax WithFile(SyntaxToken file)
    {
        return this.Update(this.HashToken, this.LineKeyword, this.Line, file, this.EndOfDirectiveToken, this.IsActive);
    }

    public LineDirectiveSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.LineKeyword, this.Line, this.File, endOfDirectiveToken, this.IsActive);
    }

    public LineDirectiveSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.LineKeyword, this.Line, this.File, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class PragmaWarningDirectiveSyntax : DirectiveSyntax
  {
    private SyntaxNode errorCodes;

    internal PragmaWarningDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken PragmaKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken WarningKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken DisableOrRestoreKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public SeparatedSyntaxList<ExpressionSyntax> ErrorCodes 
    {
      get { return new SeparatedSyntaxList<ExpressionSyntax>(this.GetRed(ref this.errorCodes, 4), this.GetChildIndex(4)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(5), this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public override bool IsActive { get { return ((InternalSyntax.PragmaWarningDirectiveSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 4: return this.GetRed(ref this.errorCodes, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 4: return this.errorCodes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPragmaWarningDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitPragmaWarningDirective(this);
    }

    public PragmaWarningDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || warningKeyword != this.WarningKeyword || disableOrRestoreKeyword != this.DisableOrRestoreKeyword || errorCodes != this.ErrorCodes || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.PragmaWarningDirective(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PragmaWarningDirectiveSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.PragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, this.ErrorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword)
    {
        return this.Update(this.HashToken, pragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, this.ErrorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveSyntax WithWarningKeyword(SyntaxToken warningKeyword)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, warningKeyword, this.DisableOrRestoreKeyword, this.ErrorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveSyntax WithDisableOrRestoreKeyword(SyntaxToken disableOrRestoreKeyword)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.WarningKeyword, disableOrRestoreKeyword, this.ErrorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveSyntax WithErrorCodes(SeparatedSyntaxList<ExpressionSyntax> errorCodes)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, errorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, this.ErrorCodes, endOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, this.ErrorCodes, this.EndOfDirectiveToken, isActive);
    }

    public PragmaWarningDirectiveSyntax AddErrorCodes(params ExpressionSyntax[] items)
    {
        return this.WithErrorCodes(this.ErrorCodes.Add(items));
    }
  }

  public sealed partial class PragmaChecksumDirectiveSyntax : DirectiveSyntax
  {
    internal PragmaChecksumDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken PragmaKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken ChecksumKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken File 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public SyntaxToken Guid 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(4), this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public SyntaxToken Bytes 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(5), this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(6), this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    public override bool IsActive { get { return ((InternalSyntax.PragmaChecksumDirectiveSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPragmaChecksumDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitPragmaChecksumDirective(this);
    }

    public PragmaChecksumDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || checksumKeyword != this.ChecksumKeyword || file != this.File || guid != this.Guid || bytes != this.Bytes || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.PragmaChecksumDirective(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PragmaChecksumDirectiveSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.PragmaKeyword, this.ChecksumKeyword, this.File, this.Guid, this.Bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword)
    {
        return this.Update(this.HashToken, pragmaKeyword, this.ChecksumKeyword, this.File, this.Guid, this.Bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveSyntax WithChecksumKeyword(SyntaxToken checksumKeyword)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, checksumKeyword, this.File, this.Guid, this.Bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveSyntax WithFile(SyntaxToken file)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.ChecksumKeyword, file, this.Guid, this.Bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveSyntax WithGuid(SyntaxToken guid)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.ChecksumKeyword, this.File, guid, this.Bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveSyntax WithBytes(SyntaxToken bytes)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.ChecksumKeyword, this.File, this.Guid, bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.ChecksumKeyword, this.File, this.Guid, this.Bytes, endOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.ChecksumKeyword, this.File, this.Guid, this.Bytes, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class ReferenceDirectiveSyntax : DirectiveSyntax
  {
    internal ReferenceDirectiveSyntax(SyntaxNode parent, InternalSyntax.SyntaxNode green, int position)
        : base(parent, green, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(0), this.GetChildPosition(0), this.GetChildIndex(0)); }
    }

    public SyntaxToken ReferenceKeyword 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(1), this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken File 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(2), this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, (InternalSyntax.SyntaxToken)this.Green.GetSlot(3), this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((InternalSyntax.ReferenceDirectiveSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitReferenceDirective(this);
    }

    public override void Accept(SyntaxVisitor visitor)
    {
        visitor.VisitReferenceDirective(this);
    }

    public ReferenceDirectiveSyntax Update(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || referenceKeyword != this.ReferenceKeyword || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = Syntax.ReferenceDirective(hashToken, referenceKeyword, file, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ReferenceDirectiveSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.ReferenceKeyword, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public ReferenceDirectiveSyntax WithReferenceKeyword(SyntaxToken referenceKeyword)
    {
        return this.Update(this.HashToken, referenceKeyword, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public ReferenceDirectiveSyntax WithFile(SyntaxToken file)
    {
        return this.Update(this.HashToken, this.ReferenceKeyword, file, this.EndOfDirectiveToken, this.IsActive);
    }

    public ReferenceDirectiveSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.ReferenceKeyword, this.File, endOfDirectiveToken, this.IsActive);
    }

    public ReferenceDirectiveSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.ReferenceKeyword, this.File, this.EndOfDirectiveToken, isActive);
    }
  }

  public partial class SyntaxVisitor<TResult>
  {
    /// <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
    public virtual TResult VisitIdentifierName(IdentifierNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QualifiedNameSyntax node.</summary>
    public virtual TResult VisitQualifiedName(QualifiedNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GenericNameSyntax node.</summary>
    public virtual TResult VisitGenericName(GenericNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
    public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AliasQualifiedNameSyntax node.</summary>
    public virtual TResult VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PredefinedTypeSyntax node.</summary>
    public virtual TResult VisitPredefinedType(PredefinedTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
    public virtual TResult VisitArrayType(ArrayTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayRankSpecifierSyntax node.</summary>
    public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PointerTypeSyntax node.</summary>
    public virtual TResult VisitPointerType(PointerTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NullableTypeSyntax node.</summary>
    public virtual TResult VisitNullableType(NullableTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OmittedTypeArgumentSyntax node.</summary>
    public virtual TResult VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
    public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PrefixUnaryExpressionSyntax node.</summary>
    public virtual TResult VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PostfixUnaryExpressionSyntax node.</summary>
    public virtual TResult VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
    public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
    public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConditionalExpressionSyntax node.</summary>
    public virtual TResult VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ThisExpressionSyntax node.</summary>
    public virtual TResult VisitThisExpression(ThisExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BaseExpressionSyntax node.</summary>
    public virtual TResult VisitBaseExpression(BaseExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
    public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MakeRefExpressionSyntax node.</summary>
    public virtual TResult VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefTypeExpressionSyntax node.</summary>
    public virtual TResult VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefValueExpressionSyntax node.</summary>
    public virtual TResult VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CheckedExpressionSyntax node.</summary>
    public virtual TResult VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefaultExpressionSyntax node.</summary>
    public virtual TResult VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeOfExpressionSyntax node.</summary>
    public virtual TResult VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SizeOfExpressionSyntax node.</summary>
    public virtual TResult VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
    public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
    public virtual TResult VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
    public virtual TResult VisitArgumentList(ArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BracketedArgumentListSyntax node.</summary>
    public virtual TResult VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
    public virtual TResult VisitArgument(ArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameColonSyntax node.</summary>
    public virtual TResult VisitNameColon(NameColonSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CastExpressionSyntax node.</summary>
    public virtual TResult VisitCastExpression(CastExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousMethodExpressionSyntax node.</summary>
    public virtual TResult VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SimpleLambdaExpressionSyntax node.</summary>
    public virtual TResult VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParenthesizedLambdaExpressionSyntax node.</summary>
    public virtual TResult VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InitializerExpressionSyntax node.</summary>
    public virtual TResult VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ObjectCreationExpressionSyntax node.</summary>
    public virtual TResult VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousObjectMemberDeclaratorSyntax node.</summary>
    public virtual TResult VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousObjectCreationExpressionSyntax node.</summary>
    public virtual TResult VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayCreationExpressionSyntax node.</summary>
    public virtual TResult VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ImplicitArrayCreationExpressionSyntax node.</summary>
    public virtual TResult VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a StackAllocArrayCreationExpressionSyntax node.</summary>
    public virtual TResult VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryExpressionSyntax node.</summary>
    public virtual TResult VisitQueryExpression(QueryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryBodySyntax node.</summary>
    public virtual TResult VisitQueryBody(QueryBodySyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FromClauseSyntax node.</summary>
    public virtual TResult VisitFromClause(FromClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LetClauseSyntax node.</summary>
    public virtual TResult VisitLetClause(LetClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a JoinClauseSyntax node.</summary>
    public virtual TResult VisitJoinClause(JoinClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a JoinIntoClauseSyntax node.</summary>
    public virtual TResult VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhereClauseSyntax node.</summary>
    public virtual TResult VisitWhereClause(WhereClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OrderByClauseSyntax node.</summary>
    public virtual TResult VisitOrderByClause(OrderByClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OrderingSyntax node.</summary>
    public virtual TResult VisitOrdering(OrderingSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SelectClauseSyntax node.</summary>
    public virtual TResult VisitSelectClause(SelectClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GroupClauseSyntax node.</summary>
    public virtual TResult VisitGroupClause(GroupClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryContinuationSyntax node.</summary>
    public virtual TResult VisitQueryContinuation(QueryContinuationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OmittedArraySizeExpressionSyntax node.</summary>
    public virtual TResult VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GlobalStatementSyntax node.</summary>
    public virtual TResult VisitGlobalStatement(GlobalStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BlockSyntax node.</summary>
    public virtual TResult VisitBlock(BlockSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LocalDeclarationStatementSyntax node.</summary>
    public virtual TResult VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VariableDeclarationSyntax node.</summary>
    public virtual TResult VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VariableDeclaratorSyntax node.</summary>
    public virtual TResult VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EqualsValueClauseSyntax node.</summary>
    public virtual TResult VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
    public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
    public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
    public virtual TResult VisitLabeledStatement(LabeledStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
    public virtual TResult VisitGotoStatement(GotoStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
    public virtual TResult VisitBreakStatement(BreakStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
    public virtual TResult VisitContinueStatement(ContinueStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
    public virtual TResult VisitReturnStatement(ReturnStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ThrowStatementSyntax node.</summary>
    public virtual TResult VisitThrowStatement(ThrowStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a YieldStatementSyntax node.</summary>
    public virtual TResult VisitYieldStatement(YieldStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
    public virtual TResult VisitWhileStatement(WhileStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
    public virtual TResult VisitDoStatement(DoStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
    public virtual TResult VisitForStatement(ForStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ForEachStatementSyntax node.</summary>
    public virtual TResult VisitForEachStatement(ForEachStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UsingStatementSyntax node.</summary>
    public virtual TResult VisitUsingStatement(UsingStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FixedStatementSyntax node.</summary>
    public virtual TResult VisitFixedStatement(FixedStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CheckedStatementSyntax node.</summary>
    public virtual TResult VisitCheckedStatement(CheckedStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UnsafeStatementSyntax node.</summary>
    public virtual TResult VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LockStatementSyntax node.</summary>
    public virtual TResult VisitLockStatement(LockStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
    public virtual TResult VisitIfStatement(IfStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
    public virtual TResult VisitElseClause(ElseClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchStatementSyntax node.</summary>
    public virtual TResult VisitSwitchStatement(SwitchStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchSectionSyntax node.</summary>
    public virtual TResult VisitSwitchSection(SwitchSectionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchLabelSyntax node.</summary>
    public virtual TResult VisitSwitchLabel(SwitchLabelSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TryStatementSyntax node.</summary>
    public virtual TResult VisitTryStatement(TryStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchClauseSyntax node.</summary>
    public virtual TResult VisitCatchClause(CatchClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchDeclarationSyntax node.</summary>
    public virtual TResult VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FinallyClauseSyntax node.</summary>
    public virtual TResult VisitFinallyClause(FinallyClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
    public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExternAliasDirectiveSyntax node.</summary>
    public virtual TResult VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UsingDirectiveSyntax node.</summary>
    public virtual TResult VisitUsingDirective(UsingDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NamespaceDeclarationSyntax node.</summary>
    public virtual TResult VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeDeclarationSyntax node.</summary>
    public virtual TResult VisitAttributeDeclaration(AttributeDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeTargetSpecifierSyntax node.</summary>
    public virtual TResult VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeSyntax node.</summary>
    public virtual TResult VisitAttribute(AttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeArgumentListSyntax node.</summary>
    public virtual TResult VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeArgumentSyntax node.</summary>
    public virtual TResult VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameEqualsSyntax node.</summary>
    public virtual TResult VisitNameEquals(NameEqualsSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
    public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
    public virtual TResult VisitTypeParameter(TypeParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ClassDeclarationSyntax node.</summary>
    public virtual TResult VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a StructDeclarationSyntax node.</summary>
    public virtual TResult VisitStructDeclaration(StructDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterfaceDeclarationSyntax node.</summary>
    public virtual TResult VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EnumDeclarationSyntax node.</summary>
    public virtual TResult VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DelegateDeclarationSyntax node.</summary>
    public virtual TResult VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EnumMemberDeclarationSyntax node.</summary>
    public virtual TResult VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BaseListSyntax node.</summary>
    public virtual TResult VisitBaseList(BaseListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterConstraintClauseSyntax node.</summary>
    public virtual TResult VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorConstraintSyntax node.</summary>
    public virtual TResult VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ClassOrStructConstraintSyntax node.</summary>
    public virtual TResult VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeConstraintSyntax node.</summary>
    public virtual TResult VisitTypeConstraint(TypeConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FieldDeclarationSyntax node.</summary>
    public virtual TResult VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EventFieldDeclarationSyntax node.</summary>
    public virtual TResult VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExplicitInterfaceSpecifierSyntax node.</summary>
    public virtual TResult VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MethodDeclarationSyntax node.</summary>
    public virtual TResult VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OperatorDeclarationSyntax node.</summary>
    public virtual TResult VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConversionOperatorDeclarationSyntax node.</summary>
    public virtual TResult VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorDeclarationSyntax node.</summary>
    public virtual TResult VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorInitializerSyntax node.</summary>
    public virtual TResult VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DestructorDeclarationSyntax node.</summary>
    public virtual TResult VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PropertyDeclarationSyntax node.</summary>
    public virtual TResult VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EventDeclarationSyntax node.</summary>
    public virtual TResult VisitEventDeclaration(EventDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IndexerDeclarationSyntax node.</summary>
    public virtual TResult VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AccessorListSyntax node.</summary>
    public virtual TResult VisitAccessorList(AccessorListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AccessorDeclarationSyntax node.</summary>
    public virtual TResult VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
    public virtual TResult VisitParameterList(ParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BracketedParameterListSyntax node.</summary>
    public virtual TResult VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParameterSyntax node.</summary>
    public virtual TResult VisitParameter(ParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IncompleteMemberSyntax node.</summary>
    public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SkippedTokensSyntax node.</summary>
    public virtual TResult VisitSkippedTokens(SkippedTokensSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DocumentationCommentSyntax node.</summary>
    public virtual TResult VisitDocumentationComment(DocumentationCommentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementSyntax node.</summary>
    public virtual TResult VisitXmlElement(XmlElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementStartTagSyntax node.</summary>
    public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementEndTagSyntax node.</summary>
    public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlEmptyElementSyntax node.</summary>
    public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlNameSyntax node.</summary>
    public virtual TResult VisitXmlName(XmlNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlPrefixSyntax node.</summary>
    public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlAttributeSyntax node.</summary>
    public virtual TResult VisitXmlAttribute(XmlAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlTextSyntax node.</summary>
    public virtual TResult VisitXmlText(XmlTextSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCDataSectionSyntax node.</summary>
    public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlProcessingInstructionSyntax node.</summary>
    public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCommentSyntax node.</summary>
    public virtual TResult VisitXmlComment(XmlCommentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IfDirectiveSyntax node.</summary>
    public virtual TResult VisitIfDirective(IfDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElifDirectiveSyntax node.</summary>
    public virtual TResult VisitElifDirective(ElifDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElseDirectiveSyntax node.</summary>
    public virtual TResult VisitElseDirective(ElseDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EndIfDirectiveSyntax node.</summary>
    public virtual TResult VisitEndIfDirective(EndIfDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RegionDirectiveSyntax node.</summary>
    public virtual TResult VisitRegionDirective(RegionDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EndRegionDirectiveSyntax node.</summary>
    public virtual TResult VisitEndRegionDirective(EndRegionDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ErrorDirectiveSyntax node.</summary>
    public virtual TResult VisitErrorDirective(ErrorDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WarningDirectiveSyntax node.</summary>
    public virtual TResult VisitWarningDirective(WarningDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BadDirectiveSyntax node.</summary>
    public virtual TResult VisitBadDirective(BadDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefineDirectiveSyntax node.</summary>
    public virtual TResult VisitDefineDirective(DefineDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UndefDirectiveSyntax node.</summary>
    public virtual TResult VisitUndefDirective(UndefDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LineDirectiveSyntax node.</summary>
    public virtual TResult VisitLineDirective(LineDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PragmaWarningDirectiveSyntax node.</summary>
    public virtual TResult VisitPragmaWarningDirective(PragmaWarningDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PragmaChecksumDirectiveSyntax node.</summary>
    public virtual TResult VisitPragmaChecksumDirective(PragmaChecksumDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ReferenceDirectiveSyntax node.</summary>
    public virtual TResult VisitReferenceDirective(ReferenceDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }
  }

  public partial class SyntaxVisitor
  {
    /// <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
    public virtual void VisitIdentifierName(IdentifierNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QualifiedNameSyntax node.</summary>
    public virtual void VisitQualifiedName(QualifiedNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GenericNameSyntax node.</summary>
    public virtual void VisitGenericName(GenericNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
    public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AliasQualifiedNameSyntax node.</summary>
    public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PredefinedTypeSyntax node.</summary>
    public virtual void VisitPredefinedType(PredefinedTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
    public virtual void VisitArrayType(ArrayTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayRankSpecifierSyntax node.</summary>
    public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PointerTypeSyntax node.</summary>
    public virtual void VisitPointerType(PointerTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NullableTypeSyntax node.</summary>
    public virtual void VisitNullableType(NullableTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OmittedTypeArgumentSyntax node.</summary>
    public virtual void VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
    public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PrefixUnaryExpressionSyntax node.</summary>
    public virtual void VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PostfixUnaryExpressionSyntax node.</summary>
    public virtual void VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
    public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
    public virtual void VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConditionalExpressionSyntax node.</summary>
    public virtual void VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ThisExpressionSyntax node.</summary>
    public virtual void VisitThisExpression(ThisExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BaseExpressionSyntax node.</summary>
    public virtual void VisitBaseExpression(BaseExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
    public virtual void VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MakeRefExpressionSyntax node.</summary>
    public virtual void VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefTypeExpressionSyntax node.</summary>
    public virtual void VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefValueExpressionSyntax node.</summary>
    public virtual void VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CheckedExpressionSyntax node.</summary>
    public virtual void VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefaultExpressionSyntax node.</summary>
    public virtual void VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeOfExpressionSyntax node.</summary>
    public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SizeOfExpressionSyntax node.</summary>
    public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
    public virtual void VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
    public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
    public virtual void VisitArgumentList(ArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BracketedArgumentListSyntax node.</summary>
    public virtual void VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
    public virtual void VisitArgument(ArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameColonSyntax node.</summary>
    public virtual void VisitNameColon(NameColonSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CastExpressionSyntax node.</summary>
    public virtual void VisitCastExpression(CastExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousMethodExpressionSyntax node.</summary>
    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SimpleLambdaExpressionSyntax node.</summary>
    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParenthesizedLambdaExpressionSyntax node.</summary>
    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InitializerExpressionSyntax node.</summary>
    public virtual void VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ObjectCreationExpressionSyntax node.</summary>
    public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousObjectMemberDeclaratorSyntax node.</summary>
    public virtual void VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousObjectCreationExpressionSyntax node.</summary>
    public virtual void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayCreationExpressionSyntax node.</summary>
    public virtual void VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ImplicitArrayCreationExpressionSyntax node.</summary>
    public virtual void VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a StackAllocArrayCreationExpressionSyntax node.</summary>
    public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryExpressionSyntax node.</summary>
    public virtual void VisitQueryExpression(QueryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryBodySyntax node.</summary>
    public virtual void VisitQueryBody(QueryBodySyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FromClauseSyntax node.</summary>
    public virtual void VisitFromClause(FromClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LetClauseSyntax node.</summary>
    public virtual void VisitLetClause(LetClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a JoinClauseSyntax node.</summary>
    public virtual void VisitJoinClause(JoinClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a JoinIntoClauseSyntax node.</summary>
    public virtual void VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhereClauseSyntax node.</summary>
    public virtual void VisitWhereClause(WhereClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OrderByClauseSyntax node.</summary>
    public virtual void VisitOrderByClause(OrderByClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OrderingSyntax node.</summary>
    public virtual void VisitOrdering(OrderingSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SelectClauseSyntax node.</summary>
    public virtual void VisitSelectClause(SelectClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GroupClauseSyntax node.</summary>
    public virtual void VisitGroupClause(GroupClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryContinuationSyntax node.</summary>
    public virtual void VisitQueryContinuation(QueryContinuationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OmittedArraySizeExpressionSyntax node.</summary>
    public virtual void VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GlobalStatementSyntax node.</summary>
    public virtual void VisitGlobalStatement(GlobalStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BlockSyntax node.</summary>
    public virtual void VisitBlock(BlockSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LocalDeclarationStatementSyntax node.</summary>
    public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VariableDeclarationSyntax node.</summary>
    public virtual void VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VariableDeclaratorSyntax node.</summary>
    public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EqualsValueClauseSyntax node.</summary>
    public virtual void VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
    public virtual void VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
    public virtual void VisitEmptyStatement(EmptyStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
    public virtual void VisitLabeledStatement(LabeledStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
    public virtual void VisitGotoStatement(GotoStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
    public virtual void VisitBreakStatement(BreakStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
    public virtual void VisitContinueStatement(ContinueStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
    public virtual void VisitReturnStatement(ReturnStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ThrowStatementSyntax node.</summary>
    public virtual void VisitThrowStatement(ThrowStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a YieldStatementSyntax node.</summary>
    public virtual void VisitYieldStatement(YieldStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
    public virtual void VisitWhileStatement(WhileStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
    public virtual void VisitDoStatement(DoStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
    public virtual void VisitForStatement(ForStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ForEachStatementSyntax node.</summary>
    public virtual void VisitForEachStatement(ForEachStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UsingStatementSyntax node.</summary>
    public virtual void VisitUsingStatement(UsingStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FixedStatementSyntax node.</summary>
    public virtual void VisitFixedStatement(FixedStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CheckedStatementSyntax node.</summary>
    public virtual void VisitCheckedStatement(CheckedStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UnsafeStatementSyntax node.</summary>
    public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LockStatementSyntax node.</summary>
    public virtual void VisitLockStatement(LockStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
    public virtual void VisitIfStatement(IfStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
    public virtual void VisitElseClause(ElseClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchStatementSyntax node.</summary>
    public virtual void VisitSwitchStatement(SwitchStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchSectionSyntax node.</summary>
    public virtual void VisitSwitchSection(SwitchSectionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchLabelSyntax node.</summary>
    public virtual void VisitSwitchLabel(SwitchLabelSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TryStatementSyntax node.</summary>
    public virtual void VisitTryStatement(TryStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchClauseSyntax node.</summary>
    public virtual void VisitCatchClause(CatchClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchDeclarationSyntax node.</summary>
    public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FinallyClauseSyntax node.</summary>
    public virtual void VisitFinallyClause(FinallyClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
    public virtual void VisitCompilationUnit(CompilationUnitSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExternAliasDirectiveSyntax node.</summary>
    public virtual void VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UsingDirectiveSyntax node.</summary>
    public virtual void VisitUsingDirective(UsingDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NamespaceDeclarationSyntax node.</summary>
    public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeDeclarationSyntax node.</summary>
    public virtual void VisitAttributeDeclaration(AttributeDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeTargetSpecifierSyntax node.</summary>
    public virtual void VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeSyntax node.</summary>
    public virtual void VisitAttribute(AttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeArgumentListSyntax node.</summary>
    public virtual void VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeArgumentSyntax node.</summary>
    public virtual void VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameEqualsSyntax node.</summary>
    public virtual void VisitNameEquals(NameEqualsSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
    public virtual void VisitTypeParameterList(TypeParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
    public virtual void VisitTypeParameter(TypeParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ClassDeclarationSyntax node.</summary>
    public virtual void VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a StructDeclarationSyntax node.</summary>
    public virtual void VisitStructDeclaration(StructDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterfaceDeclarationSyntax node.</summary>
    public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EnumDeclarationSyntax node.</summary>
    public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DelegateDeclarationSyntax node.</summary>
    public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EnumMemberDeclarationSyntax node.</summary>
    public virtual void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BaseListSyntax node.</summary>
    public virtual void VisitBaseList(BaseListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterConstraintClauseSyntax node.</summary>
    public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorConstraintSyntax node.</summary>
    public virtual void VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ClassOrStructConstraintSyntax node.</summary>
    public virtual void VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeConstraintSyntax node.</summary>
    public virtual void VisitTypeConstraint(TypeConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FieldDeclarationSyntax node.</summary>
    public virtual void VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EventFieldDeclarationSyntax node.</summary>
    public virtual void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExplicitInterfaceSpecifierSyntax node.</summary>
    public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MethodDeclarationSyntax node.</summary>
    public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OperatorDeclarationSyntax node.</summary>
    public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConversionOperatorDeclarationSyntax node.</summary>
    public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorDeclarationSyntax node.</summary>
    public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorInitializerSyntax node.</summary>
    public virtual void VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DestructorDeclarationSyntax node.</summary>
    public virtual void VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PropertyDeclarationSyntax node.</summary>
    public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EventDeclarationSyntax node.</summary>
    public virtual void VisitEventDeclaration(EventDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IndexerDeclarationSyntax node.</summary>
    public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AccessorListSyntax node.</summary>
    public virtual void VisitAccessorList(AccessorListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AccessorDeclarationSyntax node.</summary>
    public virtual void VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
    public virtual void VisitParameterList(ParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BracketedParameterListSyntax node.</summary>
    public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParameterSyntax node.</summary>
    public virtual void VisitParameter(ParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IncompleteMemberSyntax node.</summary>
    public virtual void VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SkippedTokensSyntax node.</summary>
    public virtual void VisitSkippedTokens(SkippedTokensSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DocumentationCommentSyntax node.</summary>
    public virtual void VisitDocumentationComment(DocumentationCommentSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementSyntax node.</summary>
    public virtual void VisitXmlElement(XmlElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementStartTagSyntax node.</summary>
    public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementEndTagSyntax node.</summary>
    public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlEmptyElementSyntax node.</summary>
    public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlNameSyntax node.</summary>
    public virtual void VisitXmlName(XmlNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlPrefixSyntax node.</summary>
    public virtual void VisitXmlPrefix(XmlPrefixSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlAttributeSyntax node.</summary>
    public virtual void VisitXmlAttribute(XmlAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlTextSyntax node.</summary>
    public virtual void VisitXmlText(XmlTextSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCDataSectionSyntax node.</summary>
    public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlProcessingInstructionSyntax node.</summary>
    public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCommentSyntax node.</summary>
    public virtual void VisitXmlComment(XmlCommentSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IfDirectiveSyntax node.</summary>
    public virtual void VisitIfDirective(IfDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElifDirectiveSyntax node.</summary>
    public virtual void VisitElifDirective(ElifDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElseDirectiveSyntax node.</summary>
    public virtual void VisitElseDirective(ElseDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EndIfDirectiveSyntax node.</summary>
    public virtual void VisitEndIfDirective(EndIfDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RegionDirectiveSyntax node.</summary>
    public virtual void VisitRegionDirective(RegionDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EndRegionDirectiveSyntax node.</summary>
    public virtual void VisitEndRegionDirective(EndRegionDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ErrorDirectiveSyntax node.</summary>
    public virtual void VisitErrorDirective(ErrorDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WarningDirectiveSyntax node.</summary>
    public virtual void VisitWarningDirective(WarningDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BadDirectiveSyntax node.</summary>
    public virtual void VisitBadDirective(BadDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefineDirectiveSyntax node.</summary>
    public virtual void VisitDefineDirective(DefineDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UndefDirectiveSyntax node.</summary>
    public virtual void VisitUndefDirective(UndefDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LineDirectiveSyntax node.</summary>
    public virtual void VisitLineDirective(LineDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PragmaWarningDirectiveSyntax node.</summary>
    public virtual void VisitPragmaWarningDirective(PragmaWarningDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PragmaChecksumDirectiveSyntax node.</summary>
    public virtual void VisitPragmaChecksumDirective(PragmaChecksumDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ReferenceDirectiveSyntax node.</summary>
    public virtual void VisitReferenceDirective(ReferenceDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }
  }

  public partial class SyntaxRewriter : SyntaxVisitor<SyntaxNode>
  {
    public override SyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      return node.Update(identifier);
    }

    public override SyntaxNode VisitQualifiedName(QualifiedNameSyntax node)
    {
      var left = (NameSyntax)this.Visit(node.Left);
      var dotToken = this.VisitToken(node.DotToken);
      var right = (SimpleNameSyntax)this.Visit(node.Right);
      return node.Update(left, dotToken, right);
    }

    public override SyntaxNode VisitGenericName(GenericNameSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      var typeArgumentList = (TypeArgumentListSyntax)this.Visit(node.TypeArgumentList);
      return node.Update(identifier, typeArgumentList);
    }

    public override SyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      var lessThanToken = this.VisitToken(node.LessThanToken);
      var arguments = this.VisitList(node.Arguments);
      var greaterThanToken = this.VisitToken(node.GreaterThanToken);
      return node.Update(lessThanToken, arguments, greaterThanToken);
    }

    public override SyntaxNode VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      var alias = (IdentifierNameSyntax)this.Visit(node.Alias);
      var colonColonToken = this.VisitToken(node.ColonColonToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(alias, colonColonToken, name);
    }

    public override SyntaxNode VisitPredefinedType(PredefinedTypeSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      return node.Update(keyword);
    }

    public override SyntaxNode VisitArrayType(ArrayTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var rankSpecifiers = this.VisitList(node.RankSpecifiers);
      return node.Update(elementType, rankSpecifiers);
    }

    public override SyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var sizes = this.VisitList(node.Sizes);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      return node.Update(openBracketToken, sizes, closeBracketToken);
    }

    public override SyntaxNode VisitPointerType(PointerTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var asteriskToken = this.VisitToken(node.AsteriskToken);
      return node.Update(elementType, asteriskToken);
    }

    public override SyntaxNode VisitNullableType(NullableTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var questionToken = this.VisitToken(node.QuestionToken);
      return node.Update(elementType, questionToken);
    }

    public override SyntaxNode VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      var omittedTypeArgumentToken = this.VisitToken(node.OmittedTypeArgumentToken);
      return node.Update(omittedTypeArgumentToken);
    }

    public override SyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      var operatorToken = this.VisitToken(node.OperatorToken);
      var operand = (ExpressionSyntax)this.Visit(node.Operand);
      return node.Update(operatorToken, operand);
    }

    public override SyntaxNode VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      var operand = (ExpressionSyntax)this.Visit(node.Operand);
      var operatorToken = this.VisitToken(node.OperatorToken);
      return node.Update(operand, operatorToken);
    }

    public override SyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(expression, operatorToken, name);
    }

    public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      var left = (ExpressionSyntax)this.Visit(node.Left);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var right = (ExpressionSyntax)this.Visit(node.Right);
      return node.Update(left, operatorToken, right);
    }

    public override SyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var questionToken = this.VisitToken(node.QuestionToken);
      var whenTrue = (ExpressionSyntax)this.Visit(node.WhenTrue);
      var colonToken = this.VisitToken(node.ColonToken);
      var whenFalse = (ExpressionSyntax)this.Visit(node.WhenFalse);
      return node.Update(condition, questionToken, whenTrue, colonToken, whenFalse);
    }

    public override SyntaxNode VisitThisExpression(ThisExpressionSyntax node)
    {
      var token = this.VisitToken(node.Token);
      return node.Update(token);
    }

    public override SyntaxNode VisitBaseExpression(BaseExpressionSyntax node)
    {
      var token = this.VisitToken(node.Token);
      return node.Update(token);
    }

    public override SyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      var token = this.VisitToken(node.Token);
      return node.Update(token);
    }

    public override SyntaxNode VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var comma = this.VisitToken(node.Comma);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, comma, type, closeParenToken);
    }

    public override SyntaxNode VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override SyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override SyntaxNode VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(expression, argumentList);
    }

    public override SyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(expression, argumentList);
    }

    public override SyntaxNode VisitArgumentList(ArgumentListSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override SyntaxNode VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var arguments = this.VisitList(node.Arguments);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      return node.Update(openBracketToken, arguments, closeBracketToken);
    }

    public override SyntaxNode VisitArgument(ArgumentSyntax node)
    {
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var refOrOutKeyword = this.VisitToken(node.RefOrOutKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameColon, refOrOutKeyword, expression);
    }

    public override SyntaxNode VisitNameColon(NameColonSyntax node)
    {
      var identifier = (IdentifierNameSyntax)this.Visit(node.Identifier);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(identifier, colonToken);
    }

    public override SyntaxNode VisitCastExpression(CastExpressionSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(openParenToken, type, closeParenToken, expression);
    }

    public override SyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      var delegateKeyword = this.VisitToken(node.DelegateKeyword);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(delegateKeyword, parameterList, block);
    }

    public override SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      var parameter = (ParameterSyntax)this.Visit(node.Parameter);
      var arrowToken = this.VisitToken(node.ArrowToken);
      var body = (SyntaxNode)this.Visit(node.Body);
      return node.Update(parameter, arrowToken, body);
    }

    public override SyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var arrowToken = this.VisitToken(node.ArrowToken);
      var body = (SyntaxNode)this.Visit(node.Body);
      return node.Update(parameterList, arrowToken, body);
    }

    public override SyntaxNode VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var expressions = this.VisitList(node.Expressions);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(openBraceToken, expressions, closeBraceToken);
    }

    public override SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      var newKeyword = this.VisitToken(node.NewKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, type, argumentList, initializer);
    }

    public override SyntaxNode VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      var nameEquals = (NameEqualsSyntax)this.Visit(node.NameEquals);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameEquals, expression);
    }

    public override SyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      var newKeyword = this.VisitToken(node.NewKeyword);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var initializers = this.VisitList(node.Initializers);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(newKeyword, openBraceToken, initializers, closeBraceToken);
    }

    public override SyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      var newKeyword = this.VisitToken(node.NewKeyword);
      var type = (ArrayTypeSyntax)this.Visit(node.Type);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, type, initializer);
    }

    public override SyntaxNode VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      var newKeyword = this.VisitToken(node.NewKeyword);
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var commas = this.VisitList(node.Commas);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
    }

    public override SyntaxNode VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      var stackAllocKeyword = this.VisitToken(node.StackAllocKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(stackAllocKeyword, type);
    }

    public override SyntaxNode VisitQueryExpression(QueryExpressionSyntax node)
    {
      var fromClause = (FromClauseSyntax)this.Visit(node.FromClause);
      var body = (QueryBodySyntax)this.Visit(node.Body);
      return node.Update(fromClause, body);
    }

    public override SyntaxNode VisitQueryBody(QueryBodySyntax node)
    {
      var clauses = this.VisitList(node.Clauses);
      var selectOrGroup = (SelectOrGroupClauseSyntax)this.Visit(node.SelectOrGroup);
      var continuation = (QueryContinuationSyntax)this.Visit(node.Continuation);
      return node.Update(clauses, selectOrGroup, continuation);
    }

    public override SyntaxNode VisitFromClause(FromClauseSyntax node)
    {
      var fromKeyword = this.VisitToken(node.FromKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      var inKeyword = this.VisitToken(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(fromKeyword, type, identifier, inKeyword, expression);
    }

    public override SyntaxNode VisitLetClause(LetClauseSyntax node)
    {
      var letKeyword = this.VisitToken(node.LetKeyword);
      var identifier = this.VisitToken(node.Identifier);
      var equalsToken = this.VisitToken(node.EqualsToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(letKeyword, identifier, equalsToken, expression);
    }

    public override SyntaxNode VisitJoinClause(JoinClauseSyntax node)
    {
      var joinKeyword = this.VisitToken(node.JoinKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      var inKeyword = this.VisitToken(node.InKeyword);
      var inExpression = (ExpressionSyntax)this.Visit(node.InExpression);
      var onKeyword = this.VisitToken(node.OnKeyword);
      var leftExpression = (ExpressionSyntax)this.Visit(node.LeftExpression);
      var equalsKeyword = this.VisitToken(node.EqualsKeyword);
      var rightExpression = (ExpressionSyntax)this.Visit(node.RightExpression);
      var into = (JoinIntoClauseSyntax)this.Visit(node.Into);
      return node.Update(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
    }

    public override SyntaxNode VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      var intoKeyword = this.VisitToken(node.IntoKeyword);
      var identifier = this.VisitToken(node.Identifier);
      return node.Update(intoKeyword, identifier);
    }

    public override SyntaxNode VisitWhereClause(WhereClauseSyntax node)
    {
      var whereKeyword = this.VisitToken(node.WhereKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      return node.Update(whereKeyword, condition);
    }

    public override SyntaxNode VisitOrderByClause(OrderByClauseSyntax node)
    {
      var orderByKeyword = this.VisitToken(node.OrderByKeyword);
      var orderings = this.VisitList(node.Orderings);
      return node.Update(orderByKeyword, orderings);
    }

    public override SyntaxNode VisitOrdering(OrderingSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var ascendingOrDescendingKeyword = this.VisitToken(node.AscendingOrDescendingKeyword);
      return node.Update(expression, ascendingOrDescendingKeyword);
    }

    public override SyntaxNode VisitSelectClause(SelectClauseSyntax node)
    {
      var selectKeyword = this.VisitToken(node.SelectKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(selectKeyword, expression);
    }

    public override SyntaxNode VisitGroupClause(GroupClauseSyntax node)
    {
      var groupKeyword = this.VisitToken(node.GroupKeyword);
      var groupExpression = (ExpressionSyntax)this.Visit(node.GroupExpression);
      var byKeyword = this.VisitToken(node.ByKeyword);
      var byExpression = (ExpressionSyntax)this.Visit(node.ByExpression);
      return node.Update(groupKeyword, groupExpression, byKeyword, byExpression);
    }

    public override SyntaxNode VisitQueryContinuation(QueryContinuationSyntax node)
    {
      var intoKeyword = this.VisitToken(node.IntoKeyword);
      var identifier = this.VisitToken(node.Identifier);
      var body = (QueryBodySyntax)this.Visit(node.Body);
      return node.Update(intoKeyword, identifier, body);
    }

    public override SyntaxNode VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      var omittedArraySizeExpressionToken = this.VisitToken(node.OmittedArraySizeExpressionToken);
      return node.Update(omittedArraySizeExpressionToken);
    }

    public override SyntaxNode VisitGlobalStatement(GlobalStatementSyntax node)
    {
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(statement);
    }

    public override SyntaxNode VisitBlock(BlockSyntax node)
    {
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var statements = this.VisitList(node.Statements);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(openBraceToken, statements, closeBraceToken);
    }

    public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      var modifiers = this.VisitList(node.Modifiers);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(modifiers, declaration, semicolonToken);
    }

    public override SyntaxNode VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var variables = this.VisitList(node.Variables);
      return node.Update(type, variables);
    }

    public override SyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      var initializer = (EqualsValueClauseSyntax)this.Visit(node.Initializer);
      return node.Update(identifier, argumentList, initializer);
    }

    public override SyntaxNode VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      var equalsToken = this.VisitToken(node.EqualsToken);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      return node.Update(equalsToken, value);
    }

    public override SyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(expression, semicolonToken);
    }

    public override SyntaxNode VisitEmptyStatement(EmptyStatementSyntax node)
    {
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(semicolonToken);
    }

    public override SyntaxNode VisitLabeledStatement(LabeledStatementSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      var colonToken = this.VisitToken(node.ColonToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(identifier, colonToken, statement);
    }

    public override SyntaxNode VisitGotoStatement(GotoStatementSyntax node)
    {
      var gotoKeyword = this.VisitToken(node.GotoKeyword);
      var caseOrDefaultKeyword = this.VisitToken(node.CaseOrDefaultKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitBreakStatement(BreakStatementSyntax node)
    {
      var breakKeyword = this.VisitToken(node.BreakKeyword);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(breakKeyword, semicolonToken);
    }

    public override SyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
    {
      var continueKeyword = this.VisitToken(node.ContinueKeyword);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(continueKeyword, semicolonToken);
    }

    public override SyntaxNode VisitReturnStatement(ReturnStatementSyntax node)
    {
      var returnKeyword = this.VisitToken(node.ReturnKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(returnKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitThrowStatement(ThrowStatementSyntax node)
    {
      var throwKeyword = this.VisitToken(node.ThrowKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(throwKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitYieldStatement(YieldStatementSyntax node)
    {
      var yieldKeyword = this.VisitToken(node.YieldKeyword);
      var returnOrBreakKeyword = this.VisitToken(node.ReturnOrBreakKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitWhileStatement(WhileStatementSyntax node)
    {
      var whileKeyword = this.VisitToken(node.WhileKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(whileKeyword, openParenToken, condition, closeParenToken, statement);
    }

    public override SyntaxNode VisitDoStatement(DoStatementSyntax node)
    {
      var doKeyword = this.VisitToken(node.DoKeyword);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      var whileKeyword = this.VisitToken(node.WhileKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
    }

    public override SyntaxNode VisitForStatement(ForStatementSyntax node)
    {
      var forKeyword = this.VisitToken(node.ForKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var initializers = this.VisitList(node.Initializers);
      var firstSemicolonToken = this.VisitToken(node.FirstSemicolonToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var secondSemicolonToken = this.VisitToken(node.SecondSemicolonToken);
      var incrementors = this.VisitList(node.Incrementors);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(forKeyword, openParenToken, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
    }

    public override SyntaxNode VisitForEachStatement(ForEachStatementSyntax node)
    {
      var forEachKeyword = this.VisitToken(node.ForEachKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      var inKeyword = this.VisitToken(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
    }

    public override SyntaxNode VisitUsingStatement(UsingStatementSyntax node)
    {
      var usingKeyword = this.VisitToken(node.UsingKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
    }

    public override SyntaxNode VisitFixedStatement(FixedStatementSyntax node)
    {
      var fixedKeyword = this.VisitToken(node.FixedKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(fixedKeyword, openParenToken, declaration, closeParenToken, statement);
    }

    public override SyntaxNode VisitCheckedStatement(CheckedStatementSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(keyword, block);
    }

    public override SyntaxNode VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      var unsafeKeyword = this.VisitToken(node.UnsafeKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(unsafeKeyword, block);
    }

    public override SyntaxNode VisitLockStatement(LockStatementSyntax node)
    {
      var lockKeyword = this.VisitToken(node.LockKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(lockKeyword, openParenToken, expression, closeParenToken, statement);
    }

    public override SyntaxNode VisitIfStatement(IfStatementSyntax node)
    {
      var ifKeyword = this.VisitToken(node.IfKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      var @else = (ElseClauseSyntax)this.Visit(node.Else);
      return node.Update(ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
    }

    public override SyntaxNode VisitElseClause(ElseClauseSyntax node)
    {
      var elseKeyword = this.VisitToken(node.ElseKeyword);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(elseKeyword, statement);
    }

    public override SyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)
    {
      var switchKeyword = this.VisitToken(node.SwitchKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var sections = this.VisitList(node.Sections);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
    }

    public override SyntaxNode VisitSwitchSection(SwitchSectionSyntax node)
    {
      var labels = this.VisitList(node.Labels);
      var statements = this.VisitList(node.Statements);
      return node.Update(labels, statements);
    }

    public override SyntaxNode VisitSwitchLabel(SwitchLabelSyntax node)
    {
      var caseOrDefaultKeyword = this.VisitToken(node.CaseOrDefaultKeyword);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(caseOrDefaultKeyword, value, colonToken);
    }

    public override SyntaxNode VisitTryStatement(TryStatementSyntax node)
    {
      var tryKeyword = this.VisitToken(node.TryKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      var catches = this.VisitList(node.Catches);
      var @finally = (FinallyClauseSyntax)this.Visit(node.Finally);
      return node.Update(tryKeyword, block, catches, @finally);
    }

    public override SyntaxNode VisitCatchClause(CatchClauseSyntax node)
    {
      var catchKeyword = this.VisitToken(node.CatchKeyword);
      var declaration = (CatchDeclarationSyntax)this.Visit(node.Declaration);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(catchKeyword, declaration, block);
    }

    public override SyntaxNode VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, type, identifier, closeParenToken);
    }

    public override SyntaxNode VisitFinallyClause(FinallyClauseSyntax node)
    {
      var finallyKeyword = this.VisitToken(node.FinallyKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(finallyKeyword, block);
    }

    public override SyntaxNode VisitCompilationUnit(CompilationUnitSyntax node)
    {
      var externs = this.VisitList(node.Externs);
      var usings = this.VisitList(node.Usings);
      var attributes = this.VisitList(node.Attributes);
      var members = this.VisitList(node.Members);
      var endOfFileToken = this.VisitToken(node.EndOfFileToken);
      return node.Update(externs, usings, attributes, members, endOfFileToken);
    }

    public override SyntaxNode VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      var externKeyword = this.VisitToken(node.ExternKeyword);
      var aliasKeyword = this.VisitToken(node.AliasKeyword);
      var identifier = this.VisitToken(node.Identifier);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(externKeyword, aliasKeyword, identifier, semicolonToken);
    }

    public override SyntaxNode VisitUsingDirective(UsingDirectiveSyntax node)
    {
      var usingKeyword = this.VisitToken(node.UsingKeyword);
      var alias = (NameEqualsSyntax)this.Visit(node.Alias);
      var name = (NameSyntax)this.Visit(node.Name);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(usingKeyword, alias, name, semicolonToken);
    }

    public override SyntaxNode VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      var namespaceKeyword = this.VisitToken(node.NamespaceKeyword);
      var name = (NameSyntax)this.Visit(node.Name);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var externs = this.VisitList(node.Externs);
      var usings = this.VisitList(node.Usings);
      var members = this.VisitList(node.Members);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitAttributeDeclaration(AttributeDeclarationSyntax node)
    {
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var target = (AttributeTargetSpecifierSyntax)this.Visit(node.Target);
      var attributes = this.VisitList(node.Attributes);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      return node.Update(openBracketToken, target, attributes, closeBracketToken);
    }

    public override SyntaxNode VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(identifier, colonToken);
    }

    public override SyntaxNode VisitAttribute(AttributeSyntax node)
    {
      var name = (NameSyntax)this.Visit(node.Name);
      var argumentList = (AttributeArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(name, argumentList);
    }

    public override SyntaxNode VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override SyntaxNode VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      var nameEquals = (NameEqualsSyntax)this.Visit(node.NameEquals);
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameEquals, nameColon, expression);
    }

    public override SyntaxNode VisitNameEquals(NameEqualsSyntax node)
    {
      var identifier = (IdentifierNameSyntax)this.Visit(node.Identifier);
      var equalsToken = this.VisitToken(node.EqualsToken);
      return node.Update(identifier, equalsToken);
    }

    public override SyntaxNode VisitTypeParameterList(TypeParameterListSyntax node)
    {
      var lessThanToken = this.VisitToken(node.LessThanToken);
      var parameters = this.VisitList(node.Parameters);
      var greaterThanToken = this.VisitToken(node.GreaterThanToken);
      return node.Update(lessThanToken, parameters, greaterThanToken);
    }

    public override SyntaxNode VisitTypeParameter(TypeParameterSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var varianceKeyword = this.VisitToken(node.VarianceKeyword);
      var identifier = this.VisitToken(node.Identifier);
      return node.Update(attributes, varianceKeyword, identifier);
    }

    public override SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = this.VisitToken(node.Keyword);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributes, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitStructDeclaration(StructDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = this.VisitToken(node.Keyword);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributes, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = this.VisitToken(node.Keyword);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributes, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var enumKeyword = this.VisitToken(node.EnumKeyword);
      var identifier = this.VisitToken(node.Identifier);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributes, modifiers, enumKeyword, identifier, baseList, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var delegateKeyword = this.VisitToken(node.DelegateKeyword);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributes, modifiers, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, semicolonToken);
    }

    public override SyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var identifier = this.VisitToken(node.Identifier);
      var equalsValue = (EqualsValueClauseSyntax)this.Visit(node.EqualsValue);
      return node.Update(attributes, identifier, equalsValue);
    }

    public override SyntaxNode VisitBaseList(BaseListSyntax node)
    {
      var colonToken = this.VisitToken(node.ColonToken);
      var types = this.VisitList(node.Types);
      return node.Update(colonToken, types);
    }

    public override SyntaxNode VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      var whereKeyword = this.VisitToken(node.WhereKeyword);
      var identifier = (IdentifierNameSyntax)this.Visit(node.Identifier);
      var colonToken = this.VisitToken(node.ColonToken);
      var constraints = this.VisitList(node.Constraints);
      return node.Update(whereKeyword, identifier, colonToken, constraints);
    }

    public override SyntaxNode VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      var newKeyword = this.VisitToken(node.NewKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(newKeyword, openParenToken, closeParenToken);
    }

    public override SyntaxNode VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      var classOrStructKeyword = this.VisitToken(node.ClassOrStructKeyword);
      return node.Update(classOrStructKeyword);
    }

    public override SyntaxNode VisitTypeConstraint(TypeConstraintSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override SyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributes, modifiers, declaration, semicolonToken);
    }

    public override SyntaxNode VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var eventKeyword = this.VisitToken(node.EventKeyword);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributes, modifiers, eventKeyword, declaration, semicolonToken);
    }

    public override SyntaxNode VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      var name = (NameSyntax)this.Visit(node.Name);
      var dotToken = this.VisitToken(node.DotToken);
      return node.Update(name, dotToken);
    }

    public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributes, modifiers, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, semicolonToken);
    }

    public override SyntaxNode VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var operatorKeyword = this.VisitToken(node.OperatorKeyword);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributes, modifiers, returnType, operatorKeyword, operatorToken, parameterList, body, semicolonToken);
    }

    public override SyntaxNode VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var implicitOrExplicitKeyword = this.VisitToken(node.ImplicitOrExplicitKeyword);
      var operatorKeyword = this.VisitToken(node.OperatorKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributes, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, semicolonToken);
    }

    public override SyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var identifier = this.VisitToken(node.Identifier);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var initializer = (ConstructorInitializerSyntax)this.Visit(node.Initializer);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributes, modifiers, identifier, parameterList, initializer, body, semicolonToken);
    }

    public override SyntaxNode VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      var colonToken = this.VisitToken(node.ColonToken);
      var thisOrBaseKeyword = this.VisitToken(node.ThisOrBaseKeyword);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(colonToken, thisOrBaseKeyword, argumentList);
    }

    public override SyntaxNode VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var tildeToken = this.VisitToken(node.TildeToken);
      var identifier = this.VisitToken(node.Identifier);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributes, modifiers, tildeToken, identifier, parameterList, body, semicolonToken);
    }

    public override SyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = this.VisitToken(node.Identifier);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      return node.Update(attributes, modifiers, type, explicitInterfaceSpecifier, identifier, accessorList);
    }

    public override SyntaxNode VisitEventDeclaration(EventDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var eventKeyword = this.VisitToken(node.EventKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = this.VisitToken(node.Identifier);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      return node.Update(attributes, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList);
    }

    public override SyntaxNode VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var thisKeyword = this.VisitToken(node.ThisKeyword);
      var parameterList = (BracketedParameterListSyntax)this.Visit(node.ParameterList);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      return node.Update(attributes, modifiers, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList);
    }

    public override SyntaxNode VisitAccessorList(AccessorListSyntax node)
    {
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var accessors = this.VisitList(node.Accessors);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(openBraceToken, accessors, closeBraceToken);
    }

    public override SyntaxNode VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = this.VisitToken(node.Keyword);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributes, modifiers, keyword, body, semicolonToken);
    }

    public override SyntaxNode VisitParameterList(ParameterListSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var parameters = this.VisitList(node.Parameters);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, parameters, closeParenToken);
    }

    public override SyntaxNode VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var parameters = this.VisitList(node.Parameters);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      return node.Update(openBracketToken, parameters, closeBracketToken);
    }

    public override SyntaxNode VisitParameter(ParameterSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      var @default = (EqualsValueClauseSyntax)this.Visit(node.Default);
      return node.Update(attributes, modifiers, type, identifier, @default);
    }

    public override SyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      var attributes = this.VisitList(node.Attributes);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(attributes, modifiers, type);
    }

    public override SyntaxNode VisitSkippedTokens(SkippedTokensSyntax node)
    {
      var tokens = this.VisitList(node.Tokens);
      return node.Update(tokens);
    }

    public override SyntaxNode VisitDocumentationComment(DocumentationCommentSyntax node)
    {
      var nodes = this.VisitList(node.Nodes);
      var endOfComment = this.VisitToken(node.EndOfComment);
      return node.Update(nodes, endOfComment);
    }

    public override SyntaxNode VisitXmlElement(XmlElementSyntax node)
    {
      var startTag = (XmlElementStartTagSyntax)this.Visit(node.StartTag);
      var content = this.VisitList(node.Content);
      var endTag = (XmlElementEndTagSyntax)this.Visit(node.EndTag);
      return node.Update(startTag, content, endTag);
    }

    public override SyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      var lessThanToken = this.VisitToken(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var greaterThanToken = this.VisitToken(node.GreaterThanToken);
      return node.Update(lessThanToken, name, attributes, greaterThanToken);
    }

    public override SyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      var lessThanSlashToken = this.VisitToken(node.LessThanSlashToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var greaterThanToken = this.VisitToken(node.GreaterThanToken);
      return node.Update(lessThanSlashToken, name, greaterThanToken);
    }

    public override SyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      var lessThanToken = this.VisitToken(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var slashGreaterThanToken = this.VisitToken(node.SlashGreaterThanToken);
      return node.Update(lessThanToken, name, attributes, slashGreaterThanToken);
    }

    public override SyntaxNode VisitXmlName(XmlNameSyntax node)
    {
      var prefix = (XmlPrefixSyntax)this.Visit(node.Prefix);
      var localName = this.VisitToken(node.LocalName);
      return node.Update(prefix, localName);
    }

    public override SyntaxNode VisitXmlPrefix(XmlPrefixSyntax node)
    {
      var prefix = this.VisitToken(node.Prefix);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(prefix, colonToken);
    }

    public override SyntaxNode VisitXmlAttribute(XmlAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = this.VisitToken(node.EqualsToken);
      var startQuoteToken = this.VisitToken(node.StartQuoteToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endQuoteToken = this.VisitToken(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
    }

    public override SyntaxNode VisitXmlText(XmlTextSyntax node)
    {
      var textTokens = this.VisitList(node.TextTokens);
      return node.Update(textTokens);
    }

    public override SyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      var startCDataToken = this.VisitToken(node.StartCDataToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endCDataToken = this.VisitToken(node.EndCDataToken);
      return node.Update(startCDataToken, textTokens, endCDataToken);
    }

    public override SyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      var startProcessingInstructionToken = this.VisitToken(node.StartProcessingInstructionToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var textTokens = this.VisitList(node.TextTokens);
      var endProcessingInstructionToken = this.VisitToken(node.EndProcessingInstructionToken);
      return node.Update(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
    }

    public override SyntaxNode VisitXmlComment(XmlCommentSyntax node)
    {
      var lessThanExclamationMinusMinusToken = this.VisitToken(node.LessThanExclamationMinusMinusToken);
      var textTokens = this.VisitList(node.TextTokens);
      var minusMinusGreaterThanToken = this.VisitToken(node.MinusMinusGreaterThanToken);
      return node.Update(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
    }

    public override SyntaxNode VisitIfDirective(IfDirectiveSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var ifKeyword = this.VisitToken(node.IfKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, ifKeyword, condition, endOfDirectiveToken, node.IsActive, node.BranchTaken, node.ConditionValue);
    }

    public override SyntaxNode VisitElifDirective(ElifDirectiveSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var elifKeyword = this.VisitToken(node.ElifKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, elifKeyword, condition, endOfDirectiveToken, node.IsActive, node.BranchTaken, node.ConditionValue);
    }

    public override SyntaxNode VisitElseDirective(ElseDirectiveSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var elseKeyword = this.VisitToken(node.ElseKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, elseKeyword, endOfDirectiveToken, node.IsActive, node.BranchTaken);
    }

    public override SyntaxNode VisitEndIfDirective(EndIfDirectiveSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var endIfKeyword = this.VisitToken(node.EndIfKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, endIfKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitRegionDirective(RegionDirectiveSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var regionKeyword = this.VisitToken(node.RegionKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, regionKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitEndRegionDirective(EndRegionDirectiveSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var endRegionKeyword = this.VisitToken(node.EndRegionKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, endRegionKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitErrorDirective(ErrorDirectiveSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var errorKeyword = this.VisitToken(node.ErrorKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, errorKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitWarningDirective(WarningDirectiveSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var warningKeyword = this.VisitToken(node.WarningKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, warningKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitBadDirective(BadDirectiveSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var identifier = this.VisitToken(node.Identifier);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, identifier, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitDefineDirective(DefineDirectiveSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var defineKeyword = this.VisitToken(node.DefineKeyword);
      var name = this.VisitToken(node.Name);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, defineKeyword, name, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitUndefDirective(UndefDirectiveSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var undefKeyword = this.VisitToken(node.UndefKeyword);
      var name = this.VisitToken(node.Name);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, undefKeyword, name, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitLineDirective(LineDirectiveSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var lineKeyword = this.VisitToken(node.LineKeyword);
      var line = this.VisitToken(node.Line);
      var file = this.VisitToken(node.File);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, lineKeyword, line, file, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitPragmaWarningDirective(PragmaWarningDirectiveSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var pragmaKeyword = this.VisitToken(node.PragmaKeyword);
      var warningKeyword = this.VisitToken(node.WarningKeyword);
      var disableOrRestoreKeyword = this.VisitToken(node.DisableOrRestoreKeyword);
      var errorCodes = this.VisitList(node.ErrorCodes);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitPragmaChecksumDirective(PragmaChecksumDirectiveSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var pragmaKeyword = this.VisitToken(node.PragmaKeyword);
      var checksumKeyword = this.VisitToken(node.ChecksumKeyword);
      var file = this.VisitToken(node.File);
      var guid = this.VisitToken(node.Guid);
      var bytes = this.VisitToken(node.Bytes);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitReferenceDirective(ReferenceDirectiveSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var referenceKeyword = this.VisitToken(node.ReferenceKeyword);
      var file = this.VisitToken(node.File);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, referenceKeyword, file, endOfDirectiveToken, node.IsActive);
    }
  }

  public static partial class Syntax
  {
    /// <summary>Creates a new IdentifierNameSyntax instance.</summary>
    public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
    {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.GlobalKeyword:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      return (IdentifierNameSyntax)InternalSyntax.Syntax.IdentifierName(identifier.Node).ToRed();
    }

    /// <summary>Creates a new QualifiedNameSyntax instance.</summary>
    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
      if (left == null)
        throw new ArgumentNullException("left");
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      if (right == null)
        throw new ArgumentNullException("right");
      return (QualifiedNameSyntax)InternalSyntax.Syntax.QualifiedName(left == null ? null : (InternalSyntax.NameSyntax)left.Green, dotToken.Node, right == null ? null : (InternalSyntax.SimpleNameSyntax)right.Green).ToRed();
    }

    /// <summary>Creates a new QualifiedNameSyntax instance.</summary>
    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SimpleNameSyntax right)
    {
      return Syntax.QualifiedName(left, Syntax.Token(SyntaxKind.DotToken), right);
    }

    /// <summary>Creates a new GenericNameSyntax instance.</summary>
    public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (typeArgumentList == null)
        throw new ArgumentNullException("typeArgumentList");
      return (GenericNameSyntax)InternalSyntax.Syntax.GenericName(identifier.Node, typeArgumentList == null ? null : (InternalSyntax.TypeArgumentListSyntax)typeArgumentList.Green).ToRed();
    }

    /// <summary>Creates a new GenericNameSyntax instance.</summary>
    public static GenericNameSyntax GenericName(SyntaxToken identifier)
    {
      return Syntax.GenericName(identifier, Syntax.TypeArgumentList());
    }

    /// <summary>Creates a new GenericNameSyntax instance.</summary>
    public static GenericNameSyntax GenericName(string identifier)
    {
      return Syntax.GenericName(Syntax.Identifier(identifier), Syntax.TypeArgumentList());
    }

    /// <summary>Creates a new TypeArgumentListSyntax instance.</summary>
    public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
      return (TypeArgumentListSyntax)InternalSyntax.Syntax.TypeArgumentList(lessThanToken.Node, arguments.Node.ToGreenSeparatedList<InternalSyntax.TypeSyntax>(), greaterThanToken.Node).ToRed();
    }

    /// <summary>Creates a new TypeArgumentListSyntax instance.</summary>
    public static TypeArgumentListSyntax TypeArgumentList(SeparatedSyntaxList<TypeSyntax> arguments = default(SeparatedSyntaxList<TypeSyntax>))
    {
      return Syntax.TypeArgumentList(Syntax.Token(SyntaxKind.LessThanToken), arguments, Syntax.Token(SyntaxKind.GreaterThanToken));
    }

    /// <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
    public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
      if (alias == null)
        throw new ArgumentNullException("alias");
      switch (colonColonToken.Kind)
      {
        case SyntaxKind.ColonColonToken:
          break;
        default:
          throw new ArgumentException("colonColonToken");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      return (AliasQualifiedNameSyntax)InternalSyntax.Syntax.AliasQualifiedName(alias == null ? null : (InternalSyntax.IdentifierNameSyntax)alias.Green, colonColonToken.Node, name == null ? null : (InternalSyntax.SimpleNameSyntax)name.Green).ToRed();
    }

    /// <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
    public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SimpleNameSyntax name)
    {
      return Syntax.AliasQualifiedName(alias, Syntax.Token(SyntaxKind.ColonColonToken), name);
    }

    /// <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
    public static AliasQualifiedNameSyntax AliasQualifiedName(string alias, SimpleNameSyntax name)
    {
      return Syntax.AliasQualifiedName(Syntax.IdentifierName(alias), Syntax.Token(SyntaxKind.ColonColonToken), name);
    }

    /// <summary>Creates a new PredefinedTypeSyntax instance.</summary>
    public static PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)
    {
      switch (keyword.Kind)
      {
        case SyntaxKind.BoolKeyword:
        case SyntaxKind.ByteKeyword:
        case SyntaxKind.SByteKeyword:
        case SyntaxKind.IntKeyword:
        case SyntaxKind.UIntKeyword:
        case SyntaxKind.ShortKeyword:
        case SyntaxKind.UShortKeyword:
        case SyntaxKind.LongKeyword:
        case SyntaxKind.ULongKeyword:
        case SyntaxKind.FloatKeyword:
        case SyntaxKind.DoubleKeyword:
        case SyntaxKind.DecimalKeyword:
        case SyntaxKind.StringKeyword:
        case SyntaxKind.CharKeyword:
        case SyntaxKind.ObjectKeyword:
        case SyntaxKind.VoidKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      return (PredefinedTypeSyntax)InternalSyntax.Syntax.PredefinedType(keyword.Node).ToRed();
    }

    /// <summary>Creates a new ArrayTypeSyntax instance.</summary>
    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
      if (elementType == null)
        throw new ArgumentNullException("elementType");
      return (ArrayTypeSyntax)InternalSyntax.Syntax.ArrayType(elementType == null ? null : (InternalSyntax.TypeSyntax)elementType.Green, rankSpecifiers.Node.ToGreenList<InternalSyntax.ArrayRankSpecifierSyntax>()).ToRed();
    }

    /// <summary>Creates a new ArrayTypeSyntax instance.</summary>
    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType)
    {
      return Syntax.ArrayType(elementType, default(SyntaxList<ArrayRankSpecifierSyntax>));
    }

    /// <summary>Creates a new ArrayRankSpecifierSyntax instance.</summary>
    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      return (ArrayRankSpecifierSyntax)InternalSyntax.Syntax.ArrayRankSpecifier(openBracketToken.Node, sizes.Node.ToGreenSeparatedList<InternalSyntax.ExpressionSyntax>(), closeBracketToken.Node).ToRed();
    }

    /// <summary>Creates a new ArrayRankSpecifierSyntax instance.</summary>
    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SeparatedSyntaxList<ExpressionSyntax> sizes = default(SeparatedSyntaxList<ExpressionSyntax>))
    {
      return Syntax.ArrayRankSpecifier(Syntax.Token(SyntaxKind.OpenBracketToken), sizes, Syntax.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new PointerTypeSyntax instance.</summary>
    public static PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
      if (elementType == null)
        throw new ArgumentNullException("elementType");
      switch (asteriskToken.Kind)
      {
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException("asteriskToken");
      }
      return (PointerTypeSyntax)InternalSyntax.Syntax.PointerType(elementType == null ? null : (InternalSyntax.TypeSyntax)elementType.Green, asteriskToken.Node).ToRed();
    }

    /// <summary>Creates a new PointerTypeSyntax instance.</summary>
    public static PointerTypeSyntax PointerType(TypeSyntax elementType)
    {
      return Syntax.PointerType(elementType, Syntax.Token(SyntaxKind.AsteriskToken));
    }

    /// <summary>Creates a new NullableTypeSyntax instance.</summary>
    public static NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)
    {
      if (elementType == null)
        throw new ArgumentNullException("elementType");
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("questionToken");
      }
      return (NullableTypeSyntax)InternalSyntax.Syntax.NullableType(elementType == null ? null : (InternalSyntax.TypeSyntax)elementType.Green, questionToken.Node).ToRed();
    }

    /// <summary>Creates a new NullableTypeSyntax instance.</summary>
    public static NullableTypeSyntax NullableType(TypeSyntax elementType)
    {
      return Syntax.NullableType(elementType, Syntax.Token(SyntaxKind.QuestionToken));
    }

    /// <summary>Creates a new OmittedTypeArgumentSyntax instance.</summary>
    public static OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)
    {
      switch (omittedTypeArgumentToken.Kind)
      {
        case SyntaxKind.OmittedTypeArgumentToken:
          break;
        default:
          throw new ArgumentException("omittedTypeArgumentToken");
      }
      return (OmittedTypeArgumentSyntax)InternalSyntax.Syntax.OmittedTypeArgument(omittedTypeArgumentToken.Node).ToRed();
    }

    /// <summary>Creates a new OmittedTypeArgumentSyntax instance.</summary>
    public static OmittedTypeArgumentSyntax OmittedTypeArgument()
    {
      return Syntax.OmittedTypeArgument(Syntax.Token(SyntaxKind.OmittedTypeArgumentToken));
    }

    /// <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
    public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (ParenthesizedExpressionSyntax)InternalSyntax.Syntax.ParenthesizedExpression(openParenToken.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, closeParenToken.Node).ToRed();
    }

    /// <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
    public static ParenthesizedExpressionSyntax ParenthesizedExpression(ExpressionSyntax expression)
    {
      return Syntax.ParenthesizedExpression(Syntax.Token(SyntaxKind.OpenParenToken), expression, Syntax.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new PrefixUnaryExpressionSyntax instance.</summary>
    public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
    {
      switch (kind)
      {
        case SyntaxKind.PlusExpression:
        case SyntaxKind.NegateExpression:
        case SyntaxKind.BitwiseNotExpression:
        case SyntaxKind.LogicalNotExpression:
        case SyntaxKind.PreIncrementExpression:
        case SyntaxKind.PreDecrementExpression:
        case SyntaxKind.AddressOfExpression:
        case SyntaxKind.PointerIndirectionExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (operand == null)
        throw new ArgumentNullException("operand");
      return (PrefixUnaryExpressionSyntax)InternalSyntax.Syntax.PrefixUnaryExpression(kind, operatorToken.Node, operand == null ? null : (InternalSyntax.ExpressionSyntax)operand.Green).ToRed();
    }

    /// <summary>Creates a new PrefixUnaryExpressionSyntax instance.</summary>
    public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand)
    {
      return Syntax.PrefixUnaryExpression(kind, Syntax.Token(GetPrefixUnaryExpressionOperatorTokenKind(kind)), operand);
    }

    private static SyntaxKind GetPrefixUnaryExpressionOperatorTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.PlusExpression:
          return SyntaxKind.PlusToken;
        case SyntaxKind.NegateExpression:
          return SyntaxKind.MinusToken;
        case SyntaxKind.BitwiseNotExpression:
          return SyntaxKind.TildeToken;
        case SyntaxKind.LogicalNotExpression:
          return SyntaxKind.ExclamationToken;
        case SyntaxKind.PreIncrementExpression:
          return SyntaxKind.PlusPlusToken;
        case SyntaxKind.PreDecrementExpression:
          return SyntaxKind.MinusMinusToken;
        case SyntaxKind.AddressOfExpression:
          return SyntaxKind.AmpersandToken;
        case SyntaxKind.PointerIndirectionExpression:
          return SyntaxKind.AsteriskToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new PostfixUnaryExpressionSyntax instance.</summary>
    public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
    {
      switch (kind)
      {
        case SyntaxKind.PostIncrementExpression:
        case SyntaxKind.PostDecrementExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
      if (operand == null)
        throw new ArgumentNullException("operand");
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      return (PostfixUnaryExpressionSyntax)InternalSyntax.Syntax.PostfixUnaryExpression(kind, operand == null ? null : (InternalSyntax.ExpressionSyntax)operand.Green, operatorToken.Node).ToRed();
    }

    /// <summary>Creates a new PostfixUnaryExpressionSyntax instance.</summary>
    public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand)
    {
      return Syntax.PostfixUnaryExpression(kind, operand, Syntax.Token(GetPostfixUnaryExpressionOperatorTokenKind(kind)));
    }

    private static SyntaxKind GetPostfixUnaryExpressionOperatorTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.PostIncrementExpression:
          return SyntaxKind.PlusPlusToken;
        case SyntaxKind.PostDecrementExpression:
          return SyntaxKind.MinusMinusToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new MemberAccessExpressionSyntax instance.</summary>
    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
      switch (kind)
      {
        case SyntaxKind.MemberAccessExpression:
        case SyntaxKind.PointerMemberAccessExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotToken:
        case SyntaxKind.MinusGreaterThanToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      return (MemberAccessExpressionSyntax)InternalSyntax.Syntax.MemberAccessExpression(kind, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, operatorToken.Node, name == null ? null : (InternalSyntax.SimpleNameSyntax)name.Green).ToRed();
    }

    /// <summary>Creates a new MemberAccessExpressionSyntax instance.</summary>
    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SimpleNameSyntax name)
    {
      return Syntax.MemberAccessExpression(kind, expression, Syntax.Token(GetMemberAccessExpressionOperatorTokenKind(kind)), name);
    }

    private static SyntaxKind GetMemberAccessExpressionOperatorTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.MemberAccessExpression:
          return SyntaxKind.DotToken;
        case SyntaxKind.PointerMemberAccessExpression:
          return SyntaxKind.MinusGreaterThanToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new BinaryExpressionSyntax instance.</summary>
    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.AddExpression:
        case SyntaxKind.SubtractExpression:
        case SyntaxKind.MultiplyExpression:
        case SyntaxKind.DivideExpression:
        case SyntaxKind.ModuloExpression:
        case SyntaxKind.LeftShiftExpression:
        case SyntaxKind.RightShiftExpression:
        case SyntaxKind.LogicalOrExpression:
        case SyntaxKind.LogicalAndExpression:
        case SyntaxKind.BitwiseOrExpression:
        case SyntaxKind.BitwiseAndExpression:
        case SyntaxKind.ExclusiveOrExpression:
        case SyntaxKind.EqualsExpression:
        case SyntaxKind.NotEqualsExpression:
        case SyntaxKind.LessThanExpression:
        case SyntaxKind.LessThanOrEqualExpression:
        case SyntaxKind.GreaterThanExpression:
        case SyntaxKind.GreaterThanOrEqualExpression:
        case SyntaxKind.IsExpression:
        case SyntaxKind.AsExpression:
        case SyntaxKind.CoalesceExpression:
        case SyntaxKind.AssignExpression:
        case SyntaxKind.AddAssignExpression:
        case SyntaxKind.SubtractAssignExpression:
        case SyntaxKind.MultiplyAssignExpression:
        case SyntaxKind.DivideAssignExpression:
        case SyntaxKind.ModuloAssignExpression:
        case SyntaxKind.AndAssignExpression:
        case SyntaxKind.ExclusiveOrAssignExpression:
        case SyntaxKind.OrAssignExpression:
        case SyntaxKind.LeftShiftAssignExpression:
        case SyntaxKind.RightShiftAssignExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
      if (left == null)
        throw new ArgumentNullException("left");
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarBarToken:
        case SyntaxKind.AmpersandAmpersandToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.IsKeyword:
        case SyntaxKind.AsKeyword:
        case SyntaxKind.QuestionQuestionToken:
        case SyntaxKind.EqualsToken:
        case SyntaxKind.PlusEqualsToken:
        case SyntaxKind.MinusEqualsToken:
        case SyntaxKind.AsteriskEqualsToken:
        case SyntaxKind.SlashEqualsToken:
        case SyntaxKind.PercentEqualsToken:
        case SyntaxKind.AmpersandEqualsToken:
        case SyntaxKind.CaretEqualsToken:
        case SyntaxKind.BarEqualsToken:
        case SyntaxKind.LessThanLessThanEqualsToken:
        case SyntaxKind.GreaterThanGreaterThanEqualsToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (right == null)
        throw new ArgumentNullException("right");
      return (BinaryExpressionSyntax)InternalSyntax.Syntax.BinaryExpression(kind, left == null ? null : (InternalSyntax.ExpressionSyntax)left.Green, operatorToken.Node, right == null ? null : (InternalSyntax.ExpressionSyntax)right.Green).ToRed();
    }

    /// <summary>Creates a new BinaryExpressionSyntax instance.</summary>
    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right)
    {
      return Syntax.BinaryExpression(kind, left, Syntax.Token(GetBinaryExpressionOperatorTokenKind(kind)), right);
    }

    private static SyntaxKind GetBinaryExpressionOperatorTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.AddExpression:
          return SyntaxKind.PlusToken;
        case SyntaxKind.SubtractExpression:
          return SyntaxKind.MinusToken;
        case SyntaxKind.MultiplyExpression:
          return SyntaxKind.AsteriskToken;
        case SyntaxKind.DivideExpression:
          return SyntaxKind.SlashToken;
        case SyntaxKind.ModuloExpression:
          return SyntaxKind.PercentToken;
        case SyntaxKind.LeftShiftExpression:
          return SyntaxKind.LessThanLessThanToken;
        case SyntaxKind.RightShiftExpression:
          return SyntaxKind.GreaterThanGreaterThanToken;
        case SyntaxKind.LogicalOrExpression:
          return SyntaxKind.BarBarToken;
        case SyntaxKind.LogicalAndExpression:
          return SyntaxKind.AmpersandAmpersandToken;
        case SyntaxKind.BitwiseOrExpression:
          return SyntaxKind.BarToken;
        case SyntaxKind.BitwiseAndExpression:
          return SyntaxKind.AmpersandToken;
        case SyntaxKind.ExclusiveOrExpression:
          return SyntaxKind.CaretToken;
        case SyntaxKind.EqualsExpression:
          return SyntaxKind.EqualsEqualsToken;
        case SyntaxKind.NotEqualsExpression:
          return SyntaxKind.ExclamationEqualsToken;
        case SyntaxKind.LessThanExpression:
          return SyntaxKind.LessThanToken;
        case SyntaxKind.LessThanOrEqualExpression:
          return SyntaxKind.LessThanEqualsToken;
        case SyntaxKind.GreaterThanExpression:
          return SyntaxKind.GreaterThanToken;
        case SyntaxKind.GreaterThanOrEqualExpression:
          return SyntaxKind.GreaterThanEqualsToken;
        case SyntaxKind.IsExpression:
          return SyntaxKind.IsKeyword;
        case SyntaxKind.AsExpression:
          return SyntaxKind.AsKeyword;
        case SyntaxKind.CoalesceExpression:
          return SyntaxKind.QuestionQuestionToken;
        case SyntaxKind.AssignExpression:
          return SyntaxKind.EqualsToken;
        case SyntaxKind.AddAssignExpression:
          return SyntaxKind.PlusEqualsToken;
        case SyntaxKind.SubtractAssignExpression:
          return SyntaxKind.MinusEqualsToken;
        case SyntaxKind.MultiplyAssignExpression:
          return SyntaxKind.AsteriskEqualsToken;
        case SyntaxKind.DivideAssignExpression:
          return SyntaxKind.SlashEqualsToken;
        case SyntaxKind.ModuloAssignExpression:
          return SyntaxKind.PercentEqualsToken;
        case SyntaxKind.AndAssignExpression:
          return SyntaxKind.AmpersandEqualsToken;
        case SyntaxKind.ExclusiveOrAssignExpression:
          return SyntaxKind.CaretEqualsToken;
        case SyntaxKind.OrAssignExpression:
          return SyntaxKind.BarEqualsToken;
        case SyntaxKind.LeftShiftAssignExpression:
          return SyntaxKind.LessThanLessThanEqualsToken;
        case SyntaxKind.RightShiftAssignExpression:
          return SyntaxKind.GreaterThanGreaterThanEqualsToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new ConditionalExpressionSyntax instance.</summary>
    public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
      if (condition == null)
        throw new ArgumentNullException("condition");
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("questionToken");
      }
      if (whenTrue == null)
        throw new ArgumentNullException("whenTrue");
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (whenFalse == null)
        throw new ArgumentNullException("whenFalse");
      return (ConditionalExpressionSyntax)InternalSyntax.Syntax.ConditionalExpression(condition == null ? null : (InternalSyntax.ExpressionSyntax)condition.Green, questionToken.Node, whenTrue == null ? null : (InternalSyntax.ExpressionSyntax)whenTrue.Green, colonToken.Node, whenFalse == null ? null : (InternalSyntax.ExpressionSyntax)whenFalse.Green).ToRed();
    }

    /// <summary>Creates a new ConditionalExpressionSyntax instance.</summary>
    public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse)
    {
      return Syntax.ConditionalExpression(condition, Syntax.Token(SyntaxKind.QuestionToken), whenTrue, Syntax.Token(SyntaxKind.ColonToken), whenFalse);
    }

    /// <summary>Creates a new ThisExpressionSyntax instance.</summary>
    public static ThisExpressionSyntax ThisExpression(SyntaxToken token)
    {
      switch (token.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
      return (ThisExpressionSyntax)InternalSyntax.Syntax.ThisExpression(token.Node).ToRed();
    }

    /// <summary>Creates a new ThisExpressionSyntax instance.</summary>
    public static ThisExpressionSyntax ThisExpression()
    {
      return Syntax.ThisExpression(Syntax.Token(SyntaxKind.ThisKeyword));
    }

    /// <summary>Creates a new BaseExpressionSyntax instance.</summary>
    public static BaseExpressionSyntax BaseExpression(SyntaxToken token)
    {
      switch (token.Kind)
      {
        case SyntaxKind.BaseKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
      return (BaseExpressionSyntax)InternalSyntax.Syntax.BaseExpression(token.Node).ToRed();
    }

    /// <summary>Creates a new BaseExpressionSyntax instance.</summary>
    public static BaseExpressionSyntax BaseExpression()
    {
      return Syntax.BaseExpression(Syntax.Token(SyntaxKind.BaseKeyword));
    }

    /// <summary>Creates a new LiteralExpressionSyntax instance.</summary>
    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
    {
      switch (kind)
      {
        case SyntaxKind.ArgListExpression:
        case SyntaxKind.NumericLiteralExpression:
        case SyntaxKind.StringLiteralExpression:
        case SyntaxKind.CharacterLiteralExpression:
        case SyntaxKind.TrueLiteralExpression:
        case SyntaxKind.FalseLiteralExpression:
        case SyntaxKind.NullLiteralExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (token.Kind)
      {
        case SyntaxKind.ArgListKeyword:
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.CharacterLiteralToken:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.NullKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
      return (LiteralExpressionSyntax)InternalSyntax.Syntax.LiteralExpression(kind, token.Node).ToRed();
    }

    /// <summary>Creates a new LiteralExpressionSyntax instance.</summary>
    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind)
    {
      return Syntax.LiteralExpression(kind, Syntax.Token(GetLiteralExpressionTokenKind(kind)));
    }

    private static SyntaxKind GetLiteralExpressionTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.ArgListExpression:
          return SyntaxKind.ArgListKeyword;
        case SyntaxKind.NumericLiteralExpression:
          return SyntaxKind.NumericLiteralToken;
        case SyntaxKind.StringLiteralExpression:
          return SyntaxKind.StringLiteralToken;
        case SyntaxKind.CharacterLiteralExpression:
          return SyntaxKind.CharacterLiteralToken;
        case SyntaxKind.TrueLiteralExpression:
          return SyntaxKind.TrueKeyword;
        case SyntaxKind.FalseLiteralExpression:
          return SyntaxKind.FalseKeyword;
        case SyntaxKind.NullLiteralExpression:
          return SyntaxKind.NullKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new MakeRefExpressionSyntax instance.</summary>
    public static MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind)
      {
        case SyntaxKind.MakeRefKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (MakeRefExpressionSyntax)InternalSyntax.Syntax.MakeRefExpression(keyword.Node, openParenToken.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, closeParenToken.Node).ToRed();
    }

    /// <summary>Creates a new MakeRefExpressionSyntax instance.</summary>
    public static MakeRefExpressionSyntax MakeRefExpression(ExpressionSyntax expression)
    {
      return Syntax.MakeRefExpression(Syntax.Token(SyntaxKind.MakeRefKeyword), Syntax.Token(SyntaxKind.OpenParenToken), expression, Syntax.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new RefTypeExpressionSyntax instance.</summary>
    public static RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind)
      {
        case SyntaxKind.RefTypeKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (RefTypeExpressionSyntax)InternalSyntax.Syntax.RefTypeExpression(keyword.Node, openParenToken.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, closeParenToken.Node).ToRed();
    }

    /// <summary>Creates a new RefTypeExpressionSyntax instance.</summary>
    public static RefTypeExpressionSyntax RefTypeExpression(ExpressionSyntax expression)
    {
      return Syntax.RefTypeExpression(Syntax.Token(SyntaxKind.RefTypeKeyword), Syntax.Token(SyntaxKind.OpenParenToken), expression, Syntax.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new RefValueExpressionSyntax instance.</summary>
    public static RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind)
      {
        case SyntaxKind.RefValueKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      switch (comma.Kind)
      {
        case SyntaxKind.CommaToken:
          break;
        default:
          throw new ArgumentException("comma");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (RefValueExpressionSyntax)InternalSyntax.Syntax.RefValueExpression(keyword.Node, openParenToken.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, comma.Node, type == null ? null : (InternalSyntax.TypeSyntax)type.Green, closeParenToken.Node).ToRed();
    }

    /// <summary>Creates a new RefValueExpressionSyntax instance.</summary>
    public static RefValueExpressionSyntax RefValueExpression(ExpressionSyntax expression, TypeSyntax type)
    {
      return Syntax.RefValueExpression(Syntax.Token(SyntaxKind.RefValueKeyword), Syntax.Token(SyntaxKind.OpenParenToken), expression, Syntax.Token(SyntaxKind.CommaToken), type, Syntax.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new CheckedExpressionSyntax instance.</summary>
    public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedExpression:
        case SyntaxKind.UncheckedExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (CheckedExpressionSyntax)InternalSyntax.Syntax.CheckedExpression(kind, keyword.Node, openParenToken.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, closeParenToken.Node).ToRed();
    }

    /// <summary>Creates a new CheckedExpressionSyntax instance.</summary>
    public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, ExpressionSyntax expression)
    {
      return Syntax.CheckedExpression(kind, Syntax.Token(GetCheckedExpressionKeywordKind(kind)), Syntax.Token(SyntaxKind.OpenParenToken), expression, Syntax.Token(SyntaxKind.CloseParenToken));
    }

    private static SyntaxKind GetCheckedExpressionKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedExpression:
          return SyntaxKind.CheckedKeyword;
        case SyntaxKind.UncheckedExpression:
          return SyntaxKind.UncheckedKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new DefaultExpressionSyntax instance.</summary>
    public static DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind)
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (DefaultExpressionSyntax)InternalSyntax.Syntax.DefaultExpression(keyword.Node, openParenToken.Node, type == null ? null : (InternalSyntax.TypeSyntax)type.Green, closeParenToken.Node).ToRed();
    }

    /// <summary>Creates a new DefaultExpressionSyntax instance.</summary>
    public static DefaultExpressionSyntax DefaultExpression(TypeSyntax type)
    {
      return Syntax.DefaultExpression(Syntax.Token(SyntaxKind.DefaultKeyword), Syntax.Token(SyntaxKind.OpenParenToken), type, Syntax.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new TypeOfExpressionSyntax instance.</summary>
    public static TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind)
      {
        case SyntaxKind.TypeOfKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (TypeOfExpressionSyntax)InternalSyntax.Syntax.TypeOfExpression(keyword.Node, openParenToken.Node, type == null ? null : (InternalSyntax.TypeSyntax)type.Green, closeParenToken.Node).ToRed();
    }

    /// <summary>Creates a new TypeOfExpressionSyntax instance.</summary>
    public static TypeOfExpressionSyntax TypeOfExpression(TypeSyntax type)
    {
      return Syntax.TypeOfExpression(Syntax.Token(SyntaxKind.TypeOfKeyword), Syntax.Token(SyntaxKind.OpenParenToken), type, Syntax.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new SizeOfExpressionSyntax instance.</summary>
    public static SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind)
      {
        case SyntaxKind.SizeOfKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (SizeOfExpressionSyntax)InternalSyntax.Syntax.SizeOfExpression(keyword.Node, openParenToken.Node, type == null ? null : (InternalSyntax.TypeSyntax)type.Green, closeParenToken.Node).ToRed();
    }

    /// <summary>Creates a new SizeOfExpressionSyntax instance.</summary>
    public static SizeOfExpressionSyntax SizeOfExpression(TypeSyntax type)
    {
      return Syntax.SizeOfExpression(Syntax.Token(SyntaxKind.SizeOfKeyword), Syntax.Token(SyntaxKind.OpenParenToken), type, Syntax.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new InvocationExpressionSyntax instance.</summary>
    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
      if (expression == null)
        throw new ArgumentNullException("expression");
      if (argumentList == null)
        throw new ArgumentNullException("argumentList");
      return (InvocationExpressionSyntax)InternalSyntax.Syntax.InvocationExpression(expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, argumentList == null ? null : (InternalSyntax.ArgumentListSyntax)argumentList.Green).ToRed();
    }

    /// <summary>Creates a new InvocationExpressionSyntax instance.</summary>
    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression)
    {
      return Syntax.InvocationExpression(expression, Syntax.ArgumentList());
    }

    /// <summary>Creates a new ElementAccessExpressionSyntax instance.</summary>
    public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
      if (expression == null)
        throw new ArgumentNullException("expression");
      if (argumentList == null)
        throw new ArgumentNullException("argumentList");
      return (ElementAccessExpressionSyntax)InternalSyntax.Syntax.ElementAccessExpression(expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, argumentList == null ? null : (InternalSyntax.BracketedArgumentListSyntax)argumentList.Green).ToRed();
    }

    /// <summary>Creates a new ElementAccessExpressionSyntax instance.</summary>
    public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression)
    {
      return Syntax.ElementAccessExpression(expression, Syntax.BracketedArgumentList());
    }

    /// <summary>Creates a new ArgumentListSyntax instance.</summary>
    public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (ArgumentListSyntax)InternalSyntax.Syntax.ArgumentList(openParenToken.Node, arguments.Node.ToGreenSeparatedList<InternalSyntax.ArgumentSyntax>(), closeParenToken.Node).ToRed();
    }

    /// <summary>Creates a new ArgumentListSyntax instance.</summary>
    public static ArgumentListSyntax ArgumentList(SeparatedSyntaxList<ArgumentSyntax> arguments = default(SeparatedSyntaxList<ArgumentSyntax>))
    {
      return Syntax.ArgumentList(Syntax.Token(SyntaxKind.OpenParenToken), arguments, Syntax.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new BracketedArgumentListSyntax instance.</summary>
    public static BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      return (BracketedArgumentListSyntax)InternalSyntax.Syntax.BracketedArgumentList(openBracketToken.Node, arguments.Node.ToGreenSeparatedList<InternalSyntax.ArgumentSyntax>(), closeBracketToken.Node).ToRed();
    }

    /// <summary>Creates a new BracketedArgumentListSyntax instance.</summary>
    public static BracketedArgumentListSyntax BracketedArgumentList(SeparatedSyntaxList<ArgumentSyntax> arguments = default(SeparatedSyntaxList<ArgumentSyntax>))
    {
      return Syntax.BracketedArgumentList(Syntax.Token(SyntaxKind.OpenBracketToken), arguments, Syntax.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new ArgumentSyntax instance.</summary>
    public static ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)
    {
      switch (refOrOutKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refOrOutKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      return (ArgumentSyntax)InternalSyntax.Syntax.Argument(nameColon == null ? null : (InternalSyntax.NameColonSyntax)nameColon.Green, refOrOutKeyword.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green).ToRed();
    }

    /// <summary>Creates a new ArgumentSyntax instance.</summary>
    public static ArgumentSyntax Argument(ExpressionSyntax expression)
    {
      return Syntax.Argument(default(NameColonSyntax), default(SyntaxToken), expression);
    }

    /// <summary>Creates a new NameColonSyntax instance.</summary>
    public static NameColonSyntax NameColon(IdentifierNameSyntax identifier, SyntaxToken colonToken)
    {
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      return (NameColonSyntax)InternalSyntax.Syntax.NameColon(identifier == null ? null : (InternalSyntax.IdentifierNameSyntax)identifier.Green, colonToken.Node).ToRed();
    }

    /// <summary>Creates a new NameColonSyntax instance.</summary>
    public static NameColonSyntax NameColon(IdentifierNameSyntax identifier)
    {
      return Syntax.NameColon(identifier, Syntax.Token(SyntaxKind.ColonToken));
    }

    /// <summary>Creates a new NameColonSyntax instance.</summary>
    public static NameColonSyntax NameColon(string identifier)
    {
      return Syntax.NameColon(Syntax.IdentifierName(identifier), Syntax.Token(SyntaxKind.ColonToken));
    }

    /// <summary>Creates a new CastExpressionSyntax instance.</summary>
    public static CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      return (CastExpressionSyntax)InternalSyntax.Syntax.CastExpression(openParenToken.Node, type == null ? null : (InternalSyntax.TypeSyntax)type.Green, closeParenToken.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green).ToRed();
    }

    /// <summary>Creates a new CastExpressionSyntax instance.</summary>
    public static CastExpressionSyntax CastExpression(TypeSyntax type, ExpressionSyntax expression)
    {
      return Syntax.CastExpression(Syntax.Token(SyntaxKind.OpenParenToken), type, Syntax.Token(SyntaxKind.CloseParenToken), expression);
    }

    /// <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken delegateKeyword, ParameterListSyntax parameterList, BlockSyntax block)
    {
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException("delegateKeyword");
      }
      if (block == null)
        throw new ArgumentNullException("block");
      return (AnonymousMethodExpressionSyntax)InternalSyntax.Syntax.AnonymousMethodExpression(delegateKeyword.Node, parameterList == null ? null : (InternalSyntax.ParameterListSyntax)parameterList.Green, block == null ? null : (InternalSyntax.BlockSyntax)block.Green).ToRed();
    }

    /// <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(ParameterListSyntax parameterList, BlockSyntax block)
    {
      return Syntax.AnonymousMethodExpression(Syntax.Token(SyntaxKind.DelegateKeyword), parameterList, block);
    }

    /// <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression()
    {
      return Syntax.AnonymousMethodExpression(Syntax.Token(SyntaxKind.DelegateKeyword), default(ParameterListSyntax), Syntax.Block());
    }

    /// <summary>Creates a new SimpleLambdaExpressionSyntax instance.</summary>
    public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(ParameterSyntax parameter, SyntaxToken arrowToken, SyntaxNode body)
    {
      if (parameter == null)
        throw new ArgumentNullException("parameter");
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (body == null)
        throw new ArgumentNullException("body");
      return (SimpleLambdaExpressionSyntax)InternalSyntax.Syntax.SimpleLambdaExpression(parameter == null ? null : (InternalSyntax.ParameterSyntax)parameter.Green, arrowToken.Node, body == null ? null : (InternalSyntax.SyntaxNode)body.Green).ToRed();
    }

    /// <summary>Creates a new SimpleLambdaExpressionSyntax instance.</summary>
    public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(ParameterSyntax parameter, SyntaxNode body)
    {
      return Syntax.SimpleLambdaExpression(parameter, Syntax.Token(SyntaxKind.EqualsGreaterThanToken), body);
    }

    /// <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(ParameterListSyntax parameterList, SyntaxToken arrowToken, SyntaxNode body)
    {
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (body == null)
        throw new ArgumentNullException("body");
      return (ParenthesizedLambdaExpressionSyntax)InternalSyntax.Syntax.ParenthesizedLambdaExpression(parameterList == null ? null : (InternalSyntax.ParameterListSyntax)parameterList.Green, arrowToken.Node, body == null ? null : (InternalSyntax.SyntaxNode)body.Green).ToRed();
    }

    /// <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(ParameterListSyntax parameterList, SyntaxNode body)
    {
      return Syntax.ParenthesizedLambdaExpression(parameterList, Syntax.Token(SyntaxKind.EqualsGreaterThanToken), body);
    }

    /// <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxNode body)
    {
      return Syntax.ParenthesizedLambdaExpression(Syntax.ParameterList(), Syntax.Token(SyntaxKind.EqualsGreaterThanToken), body);
    }

    /// <summary>Creates a new InitializerExpressionSyntax instance.</summary>
    public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
      switch (kind)
      {
        case SyntaxKind.ObjectInitializerExpression:
        case SyntaxKind.CollectionInitializerExpression:
        case SyntaxKind.ArrayInitializerExpression:
        case SyntaxKind.ComplexElementInitializerExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      return (InitializerExpressionSyntax)InternalSyntax.Syntax.InitializerExpression(kind, openBraceToken.Node, expressions.Node.ToGreenSeparatedList<InternalSyntax.ExpressionSyntax>(), closeBraceToken.Node).ToRed();
    }

    /// <summary>Creates a new InitializerExpressionSyntax instance.</summary>
    public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SeparatedSyntaxList<ExpressionSyntax> expressions = default(SeparatedSyntaxList<ExpressionSyntax>))
    {
      return Syntax.InitializerExpression(kind, Syntax.Token(SyntaxKind.OpenBraceToken), expressions, Syntax.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      return (ObjectCreationExpressionSyntax)InternalSyntax.Syntax.ObjectCreationExpression(newKeyword.Node, type == null ? null : (InternalSyntax.TypeSyntax)type.Green, argumentList == null ? null : (InternalSyntax.ArgumentListSyntax)argumentList.Green, initializer == null ? null : (InternalSyntax.InitializerExpressionSyntax)initializer.Green).ToRed();
    }

    /// <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
      return Syntax.ObjectCreationExpression(Syntax.Token(SyntaxKind.NewKeyword), type, argumentList, initializer);
    }

    /// <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type)
    {
      return Syntax.ObjectCreationExpression(Syntax.Token(SyntaxKind.NewKeyword), type, default(ArgumentListSyntax), default(InitializerExpressionSyntax));
    }

    /// <summary>Creates a new AnonymousObjectMemberDeclaratorSyntax instance.</summary>
    public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
      if (expression == null)
        throw new ArgumentNullException("expression");
      return (AnonymousObjectMemberDeclaratorSyntax)InternalSyntax.Syntax.AnonymousObjectMemberDeclarator(nameEquals == null ? null : (InternalSyntax.NameEqualsSyntax)nameEquals.Green, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green).ToRed();
    }

    /// <summary>Creates a new AnonymousObjectMemberDeclaratorSyntax instance.</summary>
    public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(ExpressionSyntax expression)
    {
      return Syntax.AnonymousObjectMemberDeclarator(default(NameEqualsSyntax), expression);
    }

    /// <summary>Creates a new AnonymousObjectCreationExpressionSyntax instance.</summary>
    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      return (AnonymousObjectCreationExpressionSyntax)InternalSyntax.Syntax.AnonymousObjectCreationExpression(newKeyword.Node, openBraceToken.Node, initializers.Node.ToGreenSeparatedList<InternalSyntax.AnonymousObjectMemberDeclaratorSyntax>(), closeBraceToken.Node).ToRed();
    }

    /// <summary>Creates a new AnonymousObjectCreationExpressionSyntax instance.</summary>
    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers = default(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>))
    {
      return Syntax.AnonymousObjectCreationExpression(Syntax.Token(SyntaxKind.NewKeyword), Syntax.Token(SyntaxKind.OpenBraceToken), initializers, Syntax.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      return (ArrayCreationExpressionSyntax)InternalSyntax.Syntax.ArrayCreationExpression(newKeyword.Node, type == null ? null : (InternalSyntax.ArrayTypeSyntax)type.Green, initializer == null ? null : (InternalSyntax.InitializerExpressionSyntax)initializer.Green).ToRed();
    }

    /// <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
      return Syntax.ArrayCreationExpression(Syntax.Token(SyntaxKind.NewKeyword), type, initializer);
    }

    /// <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(ArrayTypeSyntax type)
    {
      return Syntax.ArrayCreationExpression(Syntax.Token(SyntaxKind.NewKeyword), type, default(InitializerExpressionSyntax));
    }

    /// <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      if (initializer == null)
        throw new ArgumentNullException("initializer");
      return (ImplicitArrayCreationExpressionSyntax)InternalSyntax.Syntax.ImplicitArrayCreationExpression(newKeyword.Node, openBracketToken.Node, commas.Node.ToGreenList<InternalSyntax.SyntaxNode>(), closeBracketToken.Node, initializer == null ? null : (InternalSyntax.InitializerExpressionSyntax)initializer.Green).ToRed();
    }

    /// <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxTokenList commas, InitializerExpressionSyntax initializer)
    {
      return Syntax.ImplicitArrayCreationExpression(Syntax.Token(SyntaxKind.NewKeyword), Syntax.Token(SyntaxKind.OpenBracketToken), commas, Syntax.Token(SyntaxKind.CloseBracketToken), initializer);
    }

    /// <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(InitializerExpressionSyntax initializer)
    {
      return Syntax.ImplicitArrayCreationExpression(Syntax.Token(SyntaxKind.NewKeyword), Syntax.Token(SyntaxKind.OpenBracketToken), default(SyntaxTokenList), Syntax.Token(SyntaxKind.CloseBracketToken), initializer);
    }

    /// <summary>Creates a new StackAllocArrayCreationExpressionSyntax instance.</summary>
    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type)
    {
      switch (stackAllocKeyword.Kind)
      {
        case SyntaxKind.StackAllocKeyword:
          break;
        default:
          throw new ArgumentException("stackAllocKeyword");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      return (StackAllocArrayCreationExpressionSyntax)InternalSyntax.Syntax.StackAllocArrayCreationExpression(stackAllocKeyword.Node, type == null ? null : (InternalSyntax.TypeSyntax)type.Green).ToRed();
    }

    /// <summary>Creates a new StackAllocArrayCreationExpressionSyntax instance.</summary>
    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(TypeSyntax type)
    {
      return Syntax.StackAllocArrayCreationExpression(Syntax.Token(SyntaxKind.StackAllocKeyword), type);
    }

    /// <summary>Creates a new QueryExpressionSyntax instance.</summary>
    public static QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
      if (fromClause == null)
        throw new ArgumentNullException("fromClause");
      if (body == null)
        throw new ArgumentNullException("body");
      return (QueryExpressionSyntax)InternalSyntax.Syntax.QueryExpression(fromClause == null ? null : (InternalSyntax.FromClauseSyntax)fromClause.Green, body == null ? null : (InternalSyntax.QueryBodySyntax)body.Green).ToRed();
    }

    /// <summary>Creates a new QueryBodySyntax instance.</summary>
    public static QueryBodySyntax QueryBody(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
      if (selectOrGroup == null)
        throw new ArgumentNullException("selectOrGroup");
      return (QueryBodySyntax)InternalSyntax.Syntax.QueryBody(clauses.Node.ToGreenList<InternalSyntax.QueryClauseSyntax>(), selectOrGroup == null ? null : (InternalSyntax.SelectOrGroupClauseSyntax)selectOrGroup.Green, continuation == null ? null : (InternalSyntax.QueryContinuationSyntax)continuation.Green).ToRed();
    }

    /// <summary>Creates a new QueryBodySyntax instance.</summary>
    public static QueryBodySyntax QueryBody(SelectOrGroupClauseSyntax selectOrGroup)
    {
      return Syntax.QueryBody(default(SyntaxList<QueryClauseSyntax>), selectOrGroup, default(QueryContinuationSyntax));
    }

    /// <summary>Creates a new FromClauseSyntax instance.</summary>
    public static FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
      switch (fromKeyword.Kind)
      {
        case SyntaxKind.FromKeyword:
          break;
        default:
          throw new ArgumentException("fromKeyword");
      }
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      return (FromClauseSyntax)InternalSyntax.Syntax.FromClause(fromKeyword.Node, type == null ? null : (InternalSyntax.TypeSyntax)type.Green, identifier.Node, inKeyword.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green).ToRed();
    }

    /// <summary>Creates a new FromClauseSyntax instance.</summary>
    public static FromClauseSyntax FromClause(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax expression)
    {
      return Syntax.FromClause(Syntax.Token(SyntaxKind.FromKeyword), type, identifier, Syntax.Token(SyntaxKind.InKeyword), expression);
    }

    /// <summary>Creates a new FromClauseSyntax instance.</summary>
    public static FromClauseSyntax FromClause(SyntaxToken identifier, ExpressionSyntax expression)
    {
      return Syntax.FromClause(Syntax.Token(SyntaxKind.FromKeyword), default(TypeSyntax), identifier, Syntax.Token(SyntaxKind.InKeyword), expression);
    }

    /// <summary>Creates a new FromClauseSyntax instance.</summary>
    public static FromClauseSyntax FromClause(string identifier, ExpressionSyntax expression)
    {
      return Syntax.FromClause(Syntax.Token(SyntaxKind.FromKeyword), default(TypeSyntax), Syntax.Identifier(identifier), Syntax.Token(SyntaxKind.InKeyword), expression);
    }

    /// <summary>Creates a new LetClauseSyntax instance.</summary>
    public static LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
      switch (letKeyword.Kind)
      {
        case SyntaxKind.LetKeyword:
          break;
        default:
          throw new ArgumentException("letKeyword");
      }
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      return (LetClauseSyntax)InternalSyntax.Syntax.LetClause(letKeyword.Node, identifier.Node, equalsToken.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green).ToRed();
    }

    /// <summary>Creates a new LetClauseSyntax instance.</summary>
    public static LetClauseSyntax LetClause(SyntaxToken identifier, ExpressionSyntax expression)
    {
      return Syntax.LetClause(Syntax.Token(SyntaxKind.LetKeyword), identifier, Syntax.Token(SyntaxKind.EqualsToken), expression);
    }

    /// <summary>Creates a new LetClauseSyntax instance.</summary>
    public static LetClauseSyntax LetClause(string identifier, ExpressionSyntax expression)
    {
      return Syntax.LetClause(Syntax.Token(SyntaxKind.LetKeyword), Syntax.Identifier(identifier), Syntax.Token(SyntaxKind.EqualsToken), expression);
    }

    /// <summary>Creates a new JoinClauseSyntax instance.</summary>
    public static JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
      switch (joinKeyword.Kind)
      {
        case SyntaxKind.JoinKeyword:
          break;
        default:
          throw new ArgumentException("joinKeyword");
      }
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (inExpression == null)
        throw new ArgumentNullException("inExpression");
      switch (onKeyword.Kind)
      {
        case SyntaxKind.OnKeyword:
          break;
        default:
          throw new ArgumentException("onKeyword");
      }
      if (leftExpression == null)
        throw new ArgumentNullException("leftExpression");
      switch (equalsKeyword.Kind)
      {
        case SyntaxKind.EqualsKeyword:
          break;
        default:
          throw new ArgumentException("equalsKeyword");
      }
      if (rightExpression == null)
        throw new ArgumentNullException("rightExpression");
      return (JoinClauseSyntax)InternalSyntax.Syntax.JoinClause(joinKeyword.Node, type == null ? null : (InternalSyntax.TypeSyntax)type.Green, identifier.Node, inKeyword.Node, inExpression == null ? null : (InternalSyntax.ExpressionSyntax)inExpression.Green, onKeyword.Node, leftExpression == null ? null : (InternalSyntax.ExpressionSyntax)leftExpression.Green, equalsKeyword.Node, rightExpression == null ? null : (InternalSyntax.ExpressionSyntax)rightExpression.Green, into == null ? null : (InternalSyntax.JoinIntoClauseSyntax)into.Green).ToRed();
    }

    /// <summary>Creates a new JoinClauseSyntax instance.</summary>
    public static JoinClauseSyntax JoinClause(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
      return Syntax.JoinClause(Syntax.Token(SyntaxKind.JoinKeyword), type, identifier, Syntax.Token(SyntaxKind.InKeyword), inExpression, Syntax.Token(SyntaxKind.OnKeyword), leftExpression, Syntax.Token(SyntaxKind.EqualsKeyword), rightExpression, into);
    }

    /// <summary>Creates a new JoinClauseSyntax instance.</summary>
    public static JoinClauseSyntax JoinClause(SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression)
    {
      return Syntax.JoinClause(Syntax.Token(SyntaxKind.JoinKeyword), default(TypeSyntax), identifier, Syntax.Token(SyntaxKind.InKeyword), inExpression, Syntax.Token(SyntaxKind.OnKeyword), leftExpression, Syntax.Token(SyntaxKind.EqualsKeyword), rightExpression, default(JoinIntoClauseSyntax));
    }

    /// <summary>Creates a new JoinClauseSyntax instance.</summary>
    public static JoinClauseSyntax JoinClause(string identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression)
    {
      return Syntax.JoinClause(Syntax.Token(SyntaxKind.JoinKeyword), default(TypeSyntax), Syntax.Identifier(identifier), Syntax.Token(SyntaxKind.InKeyword), inExpression, Syntax.Token(SyntaxKind.OnKeyword), leftExpression, Syntax.Token(SyntaxKind.EqualsKeyword), rightExpression, default(JoinIntoClauseSyntax));
    }

    /// <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
    public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException("intoKeyword");
      }
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      return (JoinIntoClauseSyntax)InternalSyntax.Syntax.JoinIntoClause(intoKeyword.Node, identifier.Node).ToRed();
    }

    /// <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
    public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken identifier)
    {
      return Syntax.JoinIntoClause(Syntax.Token(SyntaxKind.IntoKeyword), identifier);
    }

    /// <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
    public static JoinIntoClauseSyntax JoinIntoClause(string identifier)
    {
      return Syntax.JoinIntoClause(Syntax.Token(SyntaxKind.IntoKeyword), Syntax.Identifier(identifier));
    }

    /// <summary>Creates a new WhereClauseSyntax instance.</summary>
    public static WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException("whereKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException("condition");
      return (WhereClauseSyntax)InternalSyntax.Syntax.WhereClause(whereKeyword.Node, condition == null ? null : (InternalSyntax.ExpressionSyntax)condition.Green).ToRed();
    }

    /// <summary>Creates a new WhereClauseSyntax instance.</summary>
    public static WhereClauseSyntax WhereClause(ExpressionSyntax condition)
    {
      return Syntax.WhereClause(Syntax.Token(SyntaxKind.WhereKeyword), condition);
    }

    /// <summary>Creates a new OrderByClauseSyntax instance.</summary>
    public static OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings)
    {
      switch (orderByKeyword.Kind)
      {
        case SyntaxKind.OrderByKeyword:
          break;
        default:
          throw new ArgumentException("orderByKeyword");
      }
      return (OrderByClauseSyntax)InternalSyntax.Syntax.OrderByClause(orderByKeyword.Node, orderings.Node.ToGreenSeparatedList<InternalSyntax.OrderingSyntax>()).ToRed();
    }

    /// <summary>Creates a new OrderByClauseSyntax instance.</summary>
    public static OrderByClauseSyntax OrderByClause(SeparatedSyntaxList<OrderingSyntax> orderings = default(SeparatedSyntaxList<OrderingSyntax>))
    {
      return Syntax.OrderByClause(Syntax.Token(SyntaxKind.OrderByKeyword), orderings);
    }

    /// <summary>Creates a new OrderingSyntax instance.</summary>
    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.AscendingOrdering:
        case SyntaxKind.DescendingOrdering:
          break;
        default:
          throw new ArgumentException("kind");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      switch (ascendingOrDescendingKeyword.Kind)
      {
        case SyntaxKind.AscendingKeyword:
        case SyntaxKind.DescendingKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("ascendingOrDescendingKeyword");
      }
      return (OrderingSyntax)InternalSyntax.Syntax.Ordering(kind, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, ascendingOrDescendingKeyword.Node).ToRed();
    }

    /// <summary>Creates a new OrderingSyntax instance.</summary>
    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression)
    {
      return Syntax.Ordering(kind, expression, default(SyntaxToken));
    }

    private static SyntaxKind GetOrderingAscendingOrDescendingKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.AscendingOrdering:
          return SyntaxKind.AscendingKeyword;
        case SyntaxKind.DescendingOrdering:
          return SyntaxKind.DescendingKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new SelectClauseSyntax instance.</summary>
    public static SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
      switch (selectKeyword.Kind)
      {
        case SyntaxKind.SelectKeyword:
          break;
        default:
          throw new ArgumentException("selectKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      return (SelectClauseSyntax)InternalSyntax.Syntax.SelectClause(selectKeyword.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green).ToRed();
    }

    /// <summary>Creates a new SelectClauseSyntax instance.</summary>
    public static SelectClauseSyntax SelectClause(ExpressionSyntax expression)
    {
      return Syntax.SelectClause(Syntax.Token(SyntaxKind.SelectKeyword), expression);
    }

    /// <summary>Creates a new GroupClauseSyntax instance.</summary>
    public static GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
      switch (groupKeyword.Kind)
      {
        case SyntaxKind.GroupKeyword:
          break;
        default:
          throw new ArgumentException("groupKeyword");
      }
      if (groupExpression == null)
        throw new ArgumentNullException("groupExpression");
      switch (byKeyword.Kind)
      {
        case SyntaxKind.ByKeyword:
          break;
        default:
          throw new ArgumentException("byKeyword");
      }
      if (byExpression == null)
        throw new ArgumentNullException("byExpression");
      return (GroupClauseSyntax)InternalSyntax.Syntax.GroupClause(groupKeyword.Node, groupExpression == null ? null : (InternalSyntax.ExpressionSyntax)groupExpression.Green, byKeyword.Node, byExpression == null ? null : (InternalSyntax.ExpressionSyntax)byExpression.Green).ToRed();
    }

    /// <summary>Creates a new GroupClauseSyntax instance.</summary>
    public static GroupClauseSyntax GroupClause(ExpressionSyntax groupExpression, ExpressionSyntax byExpression)
    {
      return Syntax.GroupClause(Syntax.Token(SyntaxKind.GroupKeyword), groupExpression, Syntax.Token(SyntaxKind.ByKeyword), byExpression);
    }

    /// <summary>Creates a new QueryContinuationSyntax instance.</summary>
    public static QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException("intoKeyword");
      }
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (body == null)
        throw new ArgumentNullException("body");
      return (QueryContinuationSyntax)InternalSyntax.Syntax.QueryContinuation(intoKeyword.Node, identifier.Node, body == null ? null : (InternalSyntax.QueryBodySyntax)body.Green).ToRed();
    }

    /// <summary>Creates a new QueryContinuationSyntax instance.</summary>
    public static QueryContinuationSyntax QueryContinuation(SyntaxToken identifier, QueryBodySyntax body)
    {
      return Syntax.QueryContinuation(Syntax.Token(SyntaxKind.IntoKeyword), identifier, body);
    }

    /// <summary>Creates a new QueryContinuationSyntax instance.</summary>
    public static QueryContinuationSyntax QueryContinuation(string identifier, QueryBodySyntax body)
    {
      return Syntax.QueryContinuation(Syntax.Token(SyntaxKind.IntoKeyword), Syntax.Identifier(identifier), body);
    }

    /// <summary>Creates a new OmittedArraySizeExpressionSyntax instance.</summary>
    public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)
    {
      switch (omittedArraySizeExpressionToken.Kind)
      {
        case SyntaxKind.OmittedArraySizeExpressionToken:
          break;
        default:
          throw new ArgumentException("omittedArraySizeExpressionToken");
      }
      return (OmittedArraySizeExpressionSyntax)InternalSyntax.Syntax.OmittedArraySizeExpression(omittedArraySizeExpressionToken.Node).ToRed();
    }

    /// <summary>Creates a new OmittedArraySizeExpressionSyntax instance.</summary>
    public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression()
    {
      return Syntax.OmittedArraySizeExpression(Syntax.Token(SyntaxKind.OmittedArraySizeExpressionToken));
    }

    /// <summary>Creates a new GlobalStatementSyntax instance.</summary>
    public static GlobalStatementSyntax GlobalStatement(StatementSyntax statement)
    {
      if (statement == null)
        throw new ArgumentNullException("statement");
      return (GlobalStatementSyntax)InternalSyntax.Syntax.GlobalStatement(statement == null ? null : (InternalSyntax.StatementSyntax)statement.Green).ToRed();
    }

    /// <summary>Creates a new BlockSyntax instance.</summary>
    public static BlockSyntax Block(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      return (BlockSyntax)InternalSyntax.Syntax.Block(openBraceToken.Node, statements.Node.ToGreenList<InternalSyntax.StatementSyntax>(), closeBraceToken.Node).ToRed();
    }

    /// <summary>Creates a new BlockSyntax instance.</summary>
    public static BlockSyntax Block(SyntaxList<StatementSyntax> statements = default(SyntaxList<StatementSyntax>))
    {
      return Syntax.Block(Syntax.Token(SyntaxKind.OpenBraceToken), statements, Syntax.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
      if (declaration == null)
        throw new ArgumentNullException("declaration");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (LocalDeclarationStatementSyntax)InternalSyntax.Syntax.LocalDeclarationStatement(modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), declaration == null ? null : (InternalSyntax.VariableDeclarationSyntax)declaration.Green, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration)
    {
      return Syntax.LocalDeclarationStatement(modifiers, declaration, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(VariableDeclarationSyntax declaration)
    {
      return Syntax.LocalDeclarationStatement(default(SyntaxTokenList), declaration, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new VariableDeclarationSyntax instance.</summary>
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
    {
      if (type == null)
        throw new ArgumentNullException("type");
      return (VariableDeclarationSyntax)InternalSyntax.Syntax.VariableDeclaration(type == null ? null : (InternalSyntax.TypeSyntax)type.Green, variables.Node.ToGreenSeparatedList<InternalSyntax.VariableDeclaratorSyntax>()).ToRed();
    }

    /// <summary>Creates a new VariableDeclarationSyntax instance.</summary>
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type)
    {
      return Syntax.VariableDeclaration(type, default(SeparatedSyntaxList<VariableDeclaratorSyntax>));
    }

    /// <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      return (VariableDeclaratorSyntax)InternalSyntax.Syntax.VariableDeclarator(identifier.Node, argumentList == null ? null : (InternalSyntax.BracketedArgumentListSyntax)argumentList.Green, initializer == null ? null : (InternalSyntax.EqualsValueClauseSyntax)initializer.Green).ToRed();
    }

    /// <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier)
    {
      return Syntax.VariableDeclarator(identifier, default(BracketedArgumentListSyntax), default(EqualsValueClauseSyntax));
    }

    /// <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
    public static VariableDeclaratorSyntax VariableDeclarator(string identifier)
    {
      return Syntax.VariableDeclarator(Syntax.Identifier(identifier), default(BracketedArgumentListSyntax), default(EqualsValueClauseSyntax));
    }

    /// <summary>Creates a new EqualsValueClauseSyntax instance.</summary>
    public static EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value)
    {
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (value == null)
        throw new ArgumentNullException("value");
      return (EqualsValueClauseSyntax)InternalSyntax.Syntax.EqualsValueClause(equalsToken.Node, value == null ? null : (InternalSyntax.ExpressionSyntax)value.Green).ToRed();
    }

    /// <summary>Creates a new EqualsValueClauseSyntax instance.</summary>
    public static EqualsValueClauseSyntax EqualsValueClause(ExpressionSyntax value)
    {
      return Syntax.EqualsValueClause(Syntax.Token(SyntaxKind.EqualsToken), value);
    }

    /// <summary>Creates a new ExpressionStatementSyntax instance.</summary>
    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      if (expression == null)
        throw new ArgumentNullException("expression");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ExpressionStatementSyntax)InternalSyntax.Syntax.ExpressionStatement(expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new ExpressionStatementSyntax instance.</summary>
    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression)
    {
      return Syntax.ExpressionStatement(expression, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new EmptyStatementSyntax instance.</summary>
    public static EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)
    {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (EmptyStatementSyntax)InternalSyntax.Syntax.EmptyStatement(semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new EmptyStatementSyntax instance.</summary>
    public static EmptyStatementSyntax EmptyStatement()
    {
      return Syntax.EmptyStatement(Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new LabeledStatementSyntax instance.</summary>
    public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
      return (LabeledStatementSyntax)InternalSyntax.Syntax.LabeledStatement(identifier.Node, colonToken.Node, statement == null ? null : (InternalSyntax.StatementSyntax)statement.Green).ToRed();
    }

    /// <summary>Creates a new LabeledStatementSyntax instance.</summary>
    public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, StatementSyntax statement)
    {
      return Syntax.LabeledStatement(identifier, Syntax.Token(SyntaxKind.ColonToken), statement);
    }

    /// <summary>Creates a new LabeledStatementSyntax instance.</summary>
    public static LabeledStatementSyntax LabeledStatement(string identifier, StatementSyntax statement)
    {
      return Syntax.LabeledStatement(Syntax.Identifier(identifier), Syntax.Token(SyntaxKind.ColonToken), statement);
    }

    /// <summary>Creates a new GotoStatementSyntax instance.</summary>
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GotoStatement:
        case SyntaxKind.GotoCaseStatement:
        case SyntaxKind.GotoDefaultStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (gotoKeyword.Kind)
      {
        case SyntaxKind.GotoKeyword:
          break;
        default:
          throw new ArgumentException("gotoKeyword");
      }
      switch (caseOrDefaultKeyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("caseOrDefaultKeyword");
      }
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (GotoStatementSyntax)InternalSyntax.Syntax.GotoStatement(kind, gotoKeyword.Node, caseOrDefaultKeyword.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new GotoStatementSyntax instance.</summary>
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression)
    {
      return Syntax.GotoStatement(kind, Syntax.Token(SyntaxKind.GotoKeyword), caseOrDefaultKeyword, expression, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new GotoStatementSyntax instance.</summary>
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, ExpressionSyntax expression = default(ExpressionSyntax))
    {
      return Syntax.GotoStatement(kind, Syntax.Token(SyntaxKind.GotoKeyword), default(SyntaxToken), expression, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new BreakStatementSyntax instance.</summary>
    public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
      switch (breakKeyword.Kind)
      {
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException("breakKeyword");
      }
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (BreakStatementSyntax)InternalSyntax.Syntax.BreakStatement(breakKeyword.Node, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new BreakStatementSyntax instance.</summary>
    public static BreakStatementSyntax BreakStatement()
    {
      return Syntax.BreakStatement(Syntax.Token(SyntaxKind.BreakKeyword), Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ContinueStatementSyntax instance.</summary>
    public static ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
      switch (continueKeyword.Kind)
      {
        case SyntaxKind.ContinueKeyword:
          break;
        default:
          throw new ArgumentException("continueKeyword");
      }
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ContinueStatementSyntax)InternalSyntax.Syntax.ContinueStatement(continueKeyword.Node, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new ContinueStatementSyntax instance.</summary>
    public static ContinueStatementSyntax ContinueStatement()
    {
      return Syntax.ContinueStatement(Syntax.Token(SyntaxKind.ContinueKeyword), Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ReturnStatementSyntax instance.</summary>
    public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (returnKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
          break;
        default:
          throw new ArgumentException("returnKeyword");
      }
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ReturnStatementSyntax)InternalSyntax.Syntax.ReturnStatement(returnKeyword.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new ReturnStatementSyntax instance.</summary>
    public static ReturnStatementSyntax ReturnStatement(ExpressionSyntax expression = default(ExpressionSyntax))
    {
      return Syntax.ReturnStatement(Syntax.Token(SyntaxKind.ReturnKeyword), expression, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ThrowStatementSyntax instance.</summary>
    public static ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (throwKeyword.Kind)
      {
        case SyntaxKind.ThrowKeyword:
          break;
        default:
          throw new ArgumentException("throwKeyword");
      }
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ThrowStatementSyntax)InternalSyntax.Syntax.ThrowStatement(throwKeyword.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new ThrowStatementSyntax instance.</summary>
    public static ThrowStatementSyntax ThrowStatement(ExpressionSyntax expression = default(ExpressionSyntax))
    {
      return Syntax.ThrowStatement(Syntax.Token(SyntaxKind.ThrowKeyword), expression, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new YieldStatementSyntax instance.</summary>
    public static YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.YieldReturnStatement:
        case SyntaxKind.YieldBreakStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (yieldKeyword.Kind)
      {
        case SyntaxKind.YieldKeyword:
          break;
        default:
          throw new ArgumentException("yieldKeyword");
      }
      switch (returnOrBreakKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException("returnOrBreakKeyword");
      }
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (YieldStatementSyntax)InternalSyntax.Syntax.YieldStatement(kind, yieldKeyword.Node, returnOrBreakKeyword.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new YieldStatementSyntax instance.</summary>
    public static YieldStatementSyntax YieldStatement(SyntaxKind kind, ExpressionSyntax expression = default(ExpressionSyntax))
    {
      return Syntax.YieldStatement(kind, Syntax.Token(SyntaxKind.YieldKeyword), Syntax.Token(GetYieldStatementReturnOrBreakKeywordKind(kind)), expression, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    private static SyntaxKind GetYieldStatementReturnOrBreakKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.YieldReturnStatement:
          return SyntaxKind.ReturnKeyword;
        case SyntaxKind.YieldBreakStatement:
          return SyntaxKind.BreakKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new WhileStatementSyntax instance.</summary>
    public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException("whileKeyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException("condition");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
      return (WhileStatementSyntax)InternalSyntax.Syntax.WhileStatement(whileKeyword.Node, openParenToken.Node, condition == null ? null : (InternalSyntax.ExpressionSyntax)condition.Green, closeParenToken.Node, statement == null ? null : (InternalSyntax.StatementSyntax)statement.Green).ToRed();
    }

    /// <summary>Creates a new WhileStatementSyntax instance.</summary>
    public static WhileStatementSyntax WhileStatement(ExpressionSyntax condition, StatementSyntax statement)
    {
      return Syntax.WhileStatement(Syntax.Token(SyntaxKind.WhileKeyword), Syntax.Token(SyntaxKind.OpenParenToken), condition, Syntax.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new DoStatementSyntax instance.</summary>
    public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
      switch (doKeyword.Kind)
      {
        case SyntaxKind.DoKeyword:
          break;
        default:
          throw new ArgumentException("doKeyword");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException("whileKeyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException("condition");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (DoStatementSyntax)InternalSyntax.Syntax.DoStatement(doKeyword.Node, statement == null ? null : (InternalSyntax.StatementSyntax)statement.Green, whileKeyword.Node, openParenToken.Node, condition == null ? null : (InternalSyntax.ExpressionSyntax)condition.Green, closeParenToken.Node, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new DoStatementSyntax instance.</summary>
    public static DoStatementSyntax DoStatement(StatementSyntax statement, ExpressionSyntax condition)
    {
      return Syntax.DoStatement(Syntax.Token(SyntaxKind.DoKeyword), statement, Syntax.Token(SyntaxKind.WhileKeyword), Syntax.Token(SyntaxKind.OpenParenToken), condition, Syntax.Token(SyntaxKind.CloseParenToken), Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ForStatementSyntax instance.</summary>
    public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (forKeyword.Kind)
      {
        case SyntaxKind.ForKeyword:
          break;
        default:
          throw new ArgumentException("forKeyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (firstSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("firstSemicolonToken");
      }
      switch (secondSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("secondSemicolonToken");
      }
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
      return (ForStatementSyntax)InternalSyntax.Syntax.ForStatement(forKeyword.Node, openParenToken.Node, declaration == null ? null : (InternalSyntax.VariableDeclarationSyntax)declaration.Green, initializers.Node.ToGreenSeparatedList<InternalSyntax.ExpressionSyntax>(), firstSemicolonToken.Node, condition == null ? null : (InternalSyntax.ExpressionSyntax)condition.Green, secondSemicolonToken.Node, incrementors.Node.ToGreenSeparatedList<InternalSyntax.ExpressionSyntax>(), closeParenToken.Node, statement == null ? null : (InternalSyntax.StatementSyntax)statement.Green).ToRed();
    }

    /// <summary>Creates a new ForStatementSyntax instance.</summary>
    public static ForStatementSyntax ForStatement(VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, ExpressionSyntax condition, SeparatedSyntaxList<ExpressionSyntax> incrementors, StatementSyntax statement)
    {
      return Syntax.ForStatement(Syntax.Token(SyntaxKind.ForKeyword), Syntax.Token(SyntaxKind.OpenParenToken), declaration, initializers, Syntax.Token(SyntaxKind.SemicolonToken), condition, Syntax.Token(SyntaxKind.SemicolonToken), incrementors, Syntax.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new ForStatementSyntax instance.</summary>
    public static ForStatementSyntax ForStatement(StatementSyntax statement)
    {
      return Syntax.ForStatement(Syntax.Token(SyntaxKind.ForKeyword), Syntax.Token(SyntaxKind.OpenParenToken), default(VariableDeclarationSyntax), default(SeparatedSyntaxList<ExpressionSyntax>), Syntax.Token(SyntaxKind.SemicolonToken), default(ExpressionSyntax), Syntax.Token(SyntaxKind.SemicolonToken), default(SeparatedSyntaxList<ExpressionSyntax>), Syntax.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new ForEachStatementSyntax instance.</summary>
    public static ForEachStatementSyntax ForEachStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (forEachKeyword.Kind)
      {
        case SyntaxKind.ForEachKeyword:
          break;
        default:
          throw new ArgumentException("forEachKeyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
      return (ForEachStatementSyntax)InternalSyntax.Syntax.ForEachStatement(forEachKeyword.Node, openParenToken.Node, type == null ? null : (InternalSyntax.TypeSyntax)type.Green, identifier.Node, inKeyword.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, closeParenToken.Node, statement == null ? null : (InternalSyntax.StatementSyntax)statement.Green).ToRed();
    }

    /// <summary>Creates a new ForEachStatementSyntax instance.</summary>
    public static ForEachStatementSyntax ForEachStatement(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax expression, StatementSyntax statement)
    {
      return Syntax.ForEachStatement(Syntax.Token(SyntaxKind.ForEachKeyword), Syntax.Token(SyntaxKind.OpenParenToken), type, identifier, Syntax.Token(SyntaxKind.InKeyword), expression, Syntax.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new ForEachStatementSyntax instance.</summary>
    public static ForEachStatementSyntax ForEachStatement(TypeSyntax type, string identifier, ExpressionSyntax expression, StatementSyntax statement)
    {
      return Syntax.ForEachStatement(Syntax.Token(SyntaxKind.ForEachKeyword), Syntax.Token(SyntaxKind.OpenParenToken), type, Syntax.Identifier(identifier), Syntax.Token(SyntaxKind.InKeyword), expression, Syntax.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new UsingStatementSyntax instance.</summary>
    public static UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException("usingKeyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
      return (UsingStatementSyntax)InternalSyntax.Syntax.UsingStatement(usingKeyword.Node, openParenToken.Node, declaration == null ? null : (InternalSyntax.VariableDeclarationSyntax)declaration.Green, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, closeParenToken.Node, statement == null ? null : (InternalSyntax.StatementSyntax)statement.Green).ToRed();
    }

    /// <summary>Creates a new UsingStatementSyntax instance.</summary>
    public static UsingStatementSyntax UsingStatement(VariableDeclarationSyntax declaration, ExpressionSyntax expression, StatementSyntax statement)
    {
      return Syntax.UsingStatement(Syntax.Token(SyntaxKind.UsingKeyword), Syntax.Token(SyntaxKind.OpenParenToken), declaration, expression, Syntax.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new UsingStatementSyntax instance.</summary>
    public static UsingStatementSyntax UsingStatement(StatementSyntax statement)
    {
      return Syntax.UsingStatement(Syntax.Token(SyntaxKind.UsingKeyword), Syntax.Token(SyntaxKind.OpenParenToken), default(VariableDeclarationSyntax), default(ExpressionSyntax), Syntax.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new FixedStatementSyntax instance.</summary>
    public static FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (fixedKeyword.Kind)
      {
        case SyntaxKind.FixedKeyword:
          break;
        default:
          throw new ArgumentException("fixedKeyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (declaration == null)
        throw new ArgumentNullException("declaration");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
      return (FixedStatementSyntax)InternalSyntax.Syntax.FixedStatement(fixedKeyword.Node, openParenToken.Node, declaration == null ? null : (InternalSyntax.VariableDeclarationSyntax)declaration.Green, closeParenToken.Node, statement == null ? null : (InternalSyntax.StatementSyntax)statement.Green).ToRed();
    }

    /// <summary>Creates a new FixedStatementSyntax instance.</summary>
    public static FixedStatementSyntax FixedStatement(VariableDeclarationSyntax declaration, StatementSyntax statement)
    {
      return Syntax.FixedStatement(Syntax.Token(SyntaxKind.FixedKeyword), Syntax.Token(SyntaxKind.OpenParenToken), declaration, Syntax.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new CheckedStatementSyntax instance.</summary>
    public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedStatement:
        case SyntaxKind.UncheckedStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (block == null)
        throw new ArgumentNullException("block");
      return (CheckedStatementSyntax)InternalSyntax.Syntax.CheckedStatement(kind, keyword.Node, block == null ? null : (InternalSyntax.BlockSyntax)block.Green).ToRed();
    }

    /// <summary>Creates a new CheckedStatementSyntax instance.</summary>
    public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, BlockSyntax block = default(BlockSyntax))
    {
      return Syntax.CheckedStatement(kind, Syntax.Token(GetCheckedStatementKeywordKind(kind)), block ?? Syntax.Block());
    }

    private static SyntaxKind GetCheckedStatementKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedStatement:
          return SyntaxKind.CheckedKeyword;
        case SyntaxKind.UncheckedStatement:
          return SyntaxKind.UncheckedKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new UnsafeStatementSyntax instance.</summary>
    public static UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
      switch (unsafeKeyword.Kind)
      {
        case SyntaxKind.UnsafeKeyword:
          break;
        default:
          throw new ArgumentException("unsafeKeyword");
      }
      if (block == null)
        throw new ArgumentNullException("block");
      return (UnsafeStatementSyntax)InternalSyntax.Syntax.UnsafeStatement(unsafeKeyword.Node, block == null ? null : (InternalSyntax.BlockSyntax)block.Green).ToRed();
    }

    /// <summary>Creates a new UnsafeStatementSyntax instance.</summary>
    public static UnsafeStatementSyntax UnsafeStatement(BlockSyntax block = default(BlockSyntax))
    {
      return Syntax.UnsafeStatement(Syntax.Token(SyntaxKind.UnsafeKeyword), block ?? Syntax.Block());
    }

    /// <summary>Creates a new LockStatementSyntax instance.</summary>
    public static LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (lockKeyword.Kind)
      {
        case SyntaxKind.LockKeyword:
          break;
        default:
          throw new ArgumentException("lockKeyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
      return (LockStatementSyntax)InternalSyntax.Syntax.LockStatement(lockKeyword.Node, openParenToken.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, closeParenToken.Node, statement == null ? null : (InternalSyntax.StatementSyntax)statement.Green).ToRed();
    }

    /// <summary>Creates a new LockStatementSyntax instance.</summary>
    public static LockStatementSyntax LockStatement(ExpressionSyntax expression, StatementSyntax statement)
    {
      return Syntax.LockStatement(Syntax.Token(SyntaxKind.LockKeyword), Syntax.Token(SyntaxKind.OpenParenToken), expression, Syntax.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new IfStatementSyntax instance.</summary>
    public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException("ifKeyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException("condition");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
      return (IfStatementSyntax)InternalSyntax.Syntax.IfStatement(ifKeyword.Node, openParenToken.Node, condition == null ? null : (InternalSyntax.ExpressionSyntax)condition.Green, closeParenToken.Node, statement == null ? null : (InternalSyntax.StatementSyntax)statement.Green, @else == null ? null : (InternalSyntax.ElseClauseSyntax)@else.Green).ToRed();
    }

    /// <summary>Creates a new IfStatementSyntax instance.</summary>
    public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementSyntax statement, ElseClauseSyntax @else)
    {
      return Syntax.IfStatement(Syntax.Token(SyntaxKind.IfKeyword), Syntax.Token(SyntaxKind.OpenParenToken), condition, Syntax.Token(SyntaxKind.CloseParenToken), statement, @else);
    }

    /// <summary>Creates a new IfStatementSyntax instance.</summary>
    public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementSyntax statement)
    {
      return Syntax.IfStatement(Syntax.Token(SyntaxKind.IfKeyword), Syntax.Token(SyntaxKind.OpenParenToken), condition, Syntax.Token(SyntaxKind.CloseParenToken), statement, default(ElseClauseSyntax));
    }

    /// <summary>Creates a new ElseClauseSyntax instance.</summary>
    public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)
    {
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException("elseKeyword");
      }
      if (statement == null)
        throw new ArgumentNullException("statement");
      return (ElseClauseSyntax)InternalSyntax.Syntax.ElseClause(elseKeyword.Node, statement == null ? null : (InternalSyntax.StatementSyntax)statement.Green).ToRed();
    }

    /// <summary>Creates a new ElseClauseSyntax instance.</summary>
    public static ElseClauseSyntax ElseClause(StatementSyntax statement)
    {
      return Syntax.ElseClause(Syntax.Token(SyntaxKind.ElseKeyword), statement);
    }

    /// <summary>Creates a new SwitchStatementSyntax instance.</summary>
    public static SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
      switch (switchKeyword.Kind)
      {
        case SyntaxKind.SwitchKeyword:
          break;
        default:
          throw new ArgumentException("switchKeyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException("expression");
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      return (SwitchStatementSyntax)InternalSyntax.Syntax.SwitchStatement(switchKeyword.Node, openParenToken.Node, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green, closeParenToken.Node, openBraceToken.Node, sections.Node.ToGreenList<InternalSyntax.SwitchSectionSyntax>(), closeBraceToken.Node).ToRed();
    }

    /// <summary>Creates a new SwitchStatementSyntax instance.</summary>
    public static SwitchStatementSyntax SwitchStatement(ExpressionSyntax expression, SyntaxList<SwitchSectionSyntax> sections)
    {
      return Syntax.SwitchStatement(Syntax.Token(SyntaxKind.SwitchKeyword), Syntax.Token(SyntaxKind.OpenParenToken), expression, Syntax.Token(SyntaxKind.CloseParenToken), Syntax.Token(SyntaxKind.OpenBraceToken), sections, Syntax.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new SwitchStatementSyntax instance.</summary>
    public static SwitchStatementSyntax SwitchStatement(ExpressionSyntax expression)
    {
      return Syntax.SwitchStatement(Syntax.Token(SyntaxKind.SwitchKeyword), Syntax.Token(SyntaxKind.OpenParenToken), expression, Syntax.Token(SyntaxKind.CloseParenToken), Syntax.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<SwitchSectionSyntax>), Syntax.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new SwitchSectionSyntax instance.</summary>
    public static SwitchSectionSyntax SwitchSection(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements)
    {
      return (SwitchSectionSyntax)InternalSyntax.Syntax.SwitchSection(labels.Node.ToGreenList<InternalSyntax.SwitchLabelSyntax>(), statements.Node.ToGreenList<InternalSyntax.StatementSyntax>()).ToRed();
    }

    /// <summary>Creates a new SwitchSectionSyntax instance.</summary>
    public static SwitchSectionSyntax SwitchSection()
    {
      return Syntax.SwitchSection(default(SyntaxList<SwitchLabelSyntax>), default(SyntaxList<StatementSyntax>));
    }

    /// <summary>Creates a new SwitchLabelSyntax instance.</summary>
    public static SwitchLabelSyntax SwitchLabel(SyntaxKind kind, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
      switch (kind)
      {
        case SyntaxKind.CaseSwitchLabel:
        case SyntaxKind.DefaultSwitchLabel:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (caseOrDefaultKeyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("caseOrDefaultKeyword");
      }
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      return (SwitchLabelSyntax)InternalSyntax.Syntax.SwitchLabel(kind, caseOrDefaultKeyword.Node, value == null ? null : (InternalSyntax.ExpressionSyntax)value.Green, colonToken.Node).ToRed();
    }

    /// <summary>Creates a new SwitchLabelSyntax instance.</summary>
    public static SwitchLabelSyntax SwitchLabel(SyntaxKind kind, ExpressionSyntax value = default(ExpressionSyntax))
    {
      return Syntax.SwitchLabel(kind, Syntax.Token(GetSwitchLabelCaseOrDefaultKeywordKind(kind)), value, Syntax.Token(SyntaxKind.ColonToken));
    }

    private static SyntaxKind GetSwitchLabelCaseOrDefaultKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.CaseSwitchLabel:
          return SyntaxKind.CaseKeyword;
        case SyntaxKind.DefaultSwitchLabel:
          return SyntaxKind.DefaultKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new TryStatementSyntax instance.</summary>
    public static TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
      switch (tryKeyword.Kind)
      {
        case SyntaxKind.TryKeyword:
          break;
        default:
          throw new ArgumentException("tryKeyword");
      }
      if (block == null)
        throw new ArgumentNullException("block");
      return (TryStatementSyntax)InternalSyntax.Syntax.TryStatement(tryKeyword.Node, block == null ? null : (InternalSyntax.BlockSyntax)block.Green, catches.Node.ToGreenList<InternalSyntax.CatchClauseSyntax>(), @finally == null ? null : (InternalSyntax.FinallyClauseSyntax)@finally.Green).ToRed();
    }

    /// <summary>Creates a new TryStatementSyntax instance.</summary>
    public static TryStatementSyntax TryStatement(BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
      return Syntax.TryStatement(Syntax.Token(SyntaxKind.TryKeyword), block, catches, @finally);
    }

    /// <summary>Creates a new TryStatementSyntax instance.</summary>
    public static TryStatementSyntax TryStatement(SyntaxList<CatchClauseSyntax> catches = default(SyntaxList<CatchClauseSyntax>))
    {
      return Syntax.TryStatement(Syntax.Token(SyntaxKind.TryKeyword), Syntax.Block(), catches, default(FinallyClauseSyntax));
    }

    /// <summary>Creates a new CatchClauseSyntax instance.</summary>
    public static CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, BlockSyntax block)
    {
      switch (catchKeyword.Kind)
      {
        case SyntaxKind.CatchKeyword:
          break;
        default:
          throw new ArgumentException("catchKeyword");
      }
      if (block == null)
        throw new ArgumentNullException("block");
      return (CatchClauseSyntax)InternalSyntax.Syntax.CatchClause(catchKeyword.Node, declaration == null ? null : (InternalSyntax.CatchDeclarationSyntax)declaration.Green, block == null ? null : (InternalSyntax.BlockSyntax)block.Green).ToRed();
    }

    /// <summary>Creates a new CatchClauseSyntax instance.</summary>
    public static CatchClauseSyntax CatchClause(CatchDeclarationSyntax declaration, BlockSyntax block)
    {
      return Syntax.CatchClause(Syntax.Token(SyntaxKind.CatchKeyword), declaration, block);
    }

    /// <summary>Creates a new CatchClauseSyntax instance.</summary>
    public static CatchClauseSyntax CatchClause()
    {
      return Syntax.CatchClause(Syntax.Token(SyntaxKind.CatchKeyword), default(CatchDeclarationSyntax), Syntax.Block());
    }

    /// <summary>Creates a new CatchDeclarationSyntax instance.</summary>
    public static CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (CatchDeclarationSyntax)InternalSyntax.Syntax.CatchDeclaration(openParenToken.Node, type == null ? null : (InternalSyntax.TypeSyntax)type.Green, identifier.Node, closeParenToken.Node).ToRed();
    }

    /// <summary>Creates a new CatchDeclarationSyntax instance.</summary>
    public static CatchDeclarationSyntax CatchDeclaration(TypeSyntax type, SyntaxToken identifier)
    {
      return Syntax.CatchDeclaration(Syntax.Token(SyntaxKind.OpenParenToken), type, identifier, Syntax.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new CatchDeclarationSyntax instance.</summary>
    public static CatchDeclarationSyntax CatchDeclaration(TypeSyntax type)
    {
      return Syntax.CatchDeclaration(Syntax.Token(SyntaxKind.OpenParenToken), type, default(SyntaxToken), Syntax.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new FinallyClauseSyntax instance.</summary>
    public static FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)
    {
      switch (finallyKeyword.Kind)
      {
        case SyntaxKind.FinallyKeyword:
          break;
        default:
          throw new ArgumentException("finallyKeyword");
      }
      if (block == null)
        throw new ArgumentNullException("block");
      return (FinallyClauseSyntax)InternalSyntax.Syntax.FinallyClause(finallyKeyword.Node, block == null ? null : (InternalSyntax.BlockSyntax)block.Green).ToRed();
    }

    /// <summary>Creates a new FinallyClauseSyntax instance.</summary>
    public static FinallyClauseSyntax FinallyClause(BlockSyntax block = default(BlockSyntax))
    {
      return Syntax.FinallyClause(Syntax.Token(SyntaxKind.FinallyKeyword), block ?? Syntax.Block());
    }

    /// <summary>Creates a new CompilationUnitSyntax instance.</summary>
    public static CompilationUnitSyntax CompilationUnit(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
      switch (endOfFileToken.Kind)
      {
        case SyntaxKind.EndOfFileToken:
          break;
        default:
          throw new ArgumentException("endOfFileToken");
      }
      return (CompilationUnitSyntax)InternalSyntax.Syntax.CompilationUnit(externs.Node.ToGreenList<InternalSyntax.ExternAliasDirectiveSyntax>(), usings.Node.ToGreenList<InternalSyntax.UsingDirectiveSyntax>(), attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), members.Node.ToGreenList<InternalSyntax.MemberDeclarationSyntax>(), endOfFileToken.Node).ToRed();
    }

    /// <summary>Creates a new CompilationUnitSyntax instance.</summary>
    public static CompilationUnitSyntax CompilationUnit(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxList<MemberDeclarationSyntax> members)
    {
      return Syntax.CompilationUnit(externs, usings, attributes, members, Syntax.Token(SyntaxKind.EndOfFileToken));
    }

    /// <summary>Creates a new CompilationUnitSyntax instance.</summary>
    public static CompilationUnitSyntax CompilationUnit()
    {
      return Syntax.CompilationUnit(default(SyntaxList<ExternAliasDirectiveSyntax>), default(SyntaxList<UsingDirectiveSyntax>), default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxList<MemberDeclarationSyntax>), Syntax.Token(SyntaxKind.EndOfFileToken));
    }

    /// <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
    public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
      switch (externKeyword.Kind)
      {
        case SyntaxKind.ExternKeyword:
          break;
        default:
          throw new ArgumentException("externKeyword");
      }
      switch (aliasKeyword.Kind)
      {
        case SyntaxKind.AliasKeyword:
          break;
        default:
          throw new ArgumentException("aliasKeyword");
      }
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ExternAliasDirectiveSyntax)InternalSyntax.Syntax.ExternAliasDirective(externKeyword.Node, aliasKeyword.Node, identifier.Node, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
    public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken identifier)
    {
      return Syntax.ExternAliasDirective(Syntax.Token(SyntaxKind.ExternKeyword), Syntax.Token(SyntaxKind.AliasKeyword), identifier, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
    public static ExternAliasDirectiveSyntax ExternAliasDirective(string identifier)
    {
      return Syntax.ExternAliasDirective(Syntax.Token(SyntaxKind.ExternKeyword), Syntax.Token(SyntaxKind.AliasKeyword), Syntax.Identifier(identifier), Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new UsingDirectiveSyntax instance.</summary>
    public static UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException("usingKeyword");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (UsingDirectiveSyntax)InternalSyntax.Syntax.UsingDirective(usingKeyword.Node, alias == null ? null : (InternalSyntax.NameEqualsSyntax)alias.Green, name == null ? null : (InternalSyntax.NameSyntax)name.Green, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new UsingDirectiveSyntax instance.</summary>
    public static UsingDirectiveSyntax UsingDirective(NameEqualsSyntax alias, NameSyntax name)
    {
      return Syntax.UsingDirective(Syntax.Token(SyntaxKind.UsingKeyword), alias, name, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new UsingDirectiveSyntax instance.</summary>
    public static UsingDirectiveSyntax UsingDirective(NameSyntax name)
    {
      return Syntax.UsingDirective(Syntax.Token(SyntaxKind.UsingKeyword), default(NameEqualsSyntax), name, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
    public static NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
      switch (namespaceKeyword.Kind)
      {
        case SyntaxKind.NamespaceKeyword:
          break;
        default:
          throw new ArgumentException("namespaceKeyword");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (NamespaceDeclarationSyntax)InternalSyntax.Syntax.NamespaceDeclaration(namespaceKeyword.Node, name == null ? null : (InternalSyntax.NameSyntax)name.Green, openBraceToken.Node, externs.Node.ToGreenList<InternalSyntax.ExternAliasDirectiveSyntax>(), usings.Node.ToGreenList<InternalSyntax.UsingDirectiveSyntax>(), members.Node.ToGreenList<InternalSyntax.MemberDeclarationSyntax>(), closeBraceToken.Node, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
    public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members)
    {
      return Syntax.NamespaceDeclaration(Syntax.Token(SyntaxKind.NamespaceKeyword), name, Syntax.Token(SyntaxKind.OpenBraceToken), externs, usings, members, Syntax.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
    public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name)
    {
      return Syntax.NamespaceDeclaration(Syntax.Token(SyntaxKind.NamespaceKeyword), name, Syntax.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<ExternAliasDirectiveSyntax>), default(SyntaxList<UsingDirectiveSyntax>), default(SyntaxList<MemberDeclarationSyntax>), Syntax.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new AttributeDeclarationSyntax instance.</summary>
    public static AttributeDeclarationSyntax AttributeDeclaration(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      return (AttributeDeclarationSyntax)InternalSyntax.Syntax.AttributeDeclaration(openBracketToken.Node, target == null ? null : (InternalSyntax.AttributeTargetSpecifierSyntax)target.Green, attributes.Node.ToGreenSeparatedList<InternalSyntax.AttributeSyntax>(), closeBracketToken.Node).ToRed();
    }

    /// <summary>Creates a new AttributeDeclarationSyntax instance.</summary>
    public static AttributeDeclarationSyntax AttributeDeclaration(AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes)
    {
      return Syntax.AttributeDeclaration(Syntax.Token(SyntaxKind.OpenBracketToken), target, attributes, Syntax.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new AttributeDeclarationSyntax instance.</summary>
    public static AttributeDeclarationSyntax AttributeDeclaration(SeparatedSyntaxList<AttributeSyntax> attributes = default(SeparatedSyntaxList<AttributeSyntax>))
    {
      return Syntax.AttributeDeclaration(Syntax.Token(SyntaxKind.OpenBracketToken), default(AttributeTargetSpecifierSyntax), attributes, Syntax.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new AttributeTargetSpecifierSyntax instance.</summary>
    public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)
    {
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      return (AttributeTargetSpecifierSyntax)InternalSyntax.Syntax.AttributeTargetSpecifier(identifier.Node, colonToken.Node).ToRed();
    }

    /// <summary>Creates a new AttributeTargetSpecifierSyntax instance.</summary>
    public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier)
    {
      return Syntax.AttributeTargetSpecifier(identifier, Syntax.Token(SyntaxKind.ColonToken));
    }

    /// <summary>Creates a new AttributeSyntax instance.</summary>
    public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
      if (name == null)
        throw new ArgumentNullException("name");
      return (AttributeSyntax)InternalSyntax.Syntax.Attribute(name == null ? null : (InternalSyntax.NameSyntax)name.Green, argumentList == null ? null : (InternalSyntax.AttributeArgumentListSyntax)argumentList.Green).ToRed();
    }

    /// <summary>Creates a new AttributeSyntax instance.</summary>
    public static AttributeSyntax Attribute(NameSyntax name)
    {
      return Syntax.Attribute(name, default(AttributeArgumentListSyntax));
    }

    /// <summary>Creates a new AttributeArgumentListSyntax instance.</summary>
    public static AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (AttributeArgumentListSyntax)InternalSyntax.Syntax.AttributeArgumentList(openParenToken.Node, arguments.Node.ToGreenSeparatedList<InternalSyntax.AttributeArgumentSyntax>(), closeParenToken.Node).ToRed();
    }

    /// <summary>Creates a new AttributeArgumentListSyntax instance.</summary>
    public static AttributeArgumentListSyntax AttributeArgumentList(SeparatedSyntaxList<AttributeArgumentSyntax> arguments = default(SeparatedSyntaxList<AttributeArgumentSyntax>))
    {
      return Syntax.AttributeArgumentList(Syntax.Token(SyntaxKind.OpenParenToken), arguments, Syntax.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new AttributeArgumentSyntax instance.</summary>
    public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
      if (expression == null)
        throw new ArgumentNullException("expression");
      return (AttributeArgumentSyntax)InternalSyntax.Syntax.AttributeArgument(nameEquals == null ? null : (InternalSyntax.NameEqualsSyntax)nameEquals.Green, nameColon == null ? null : (InternalSyntax.NameColonSyntax)nameColon.Green, expression == null ? null : (InternalSyntax.ExpressionSyntax)expression.Green).ToRed();
    }

    /// <summary>Creates a new AttributeArgumentSyntax instance.</summary>
    public static AttributeArgumentSyntax AttributeArgument(ExpressionSyntax expression)
    {
      return Syntax.AttributeArgument(default(NameEqualsSyntax), default(NameColonSyntax), expression);
    }

    /// <summary>Creates a new NameEqualsSyntax instance.</summary>
    public static NameEqualsSyntax NameEquals(IdentifierNameSyntax identifier, SyntaxToken equalsToken)
    {
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      return (NameEqualsSyntax)InternalSyntax.Syntax.NameEquals(identifier == null ? null : (InternalSyntax.IdentifierNameSyntax)identifier.Green, equalsToken.Node).ToRed();
    }

    /// <summary>Creates a new NameEqualsSyntax instance.</summary>
    public static NameEqualsSyntax NameEquals(IdentifierNameSyntax identifier)
    {
      return Syntax.NameEquals(identifier, Syntax.Token(SyntaxKind.EqualsToken));
    }

    /// <summary>Creates a new NameEqualsSyntax instance.</summary>
    public static NameEqualsSyntax NameEquals(string identifier)
    {
      return Syntax.NameEquals(Syntax.IdentifierName(identifier), Syntax.Token(SyntaxKind.EqualsToken));
    }

    /// <summary>Creates a new TypeParameterListSyntax instance.</summary>
    public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
      return (TypeParameterListSyntax)InternalSyntax.Syntax.TypeParameterList(lessThanToken.Node, parameters.Node.ToGreenSeparatedList<InternalSyntax.TypeParameterSyntax>(), greaterThanToken.Node).ToRed();
    }

    /// <summary>Creates a new TypeParameterListSyntax instance.</summary>
    public static TypeParameterListSyntax TypeParameterList(SeparatedSyntaxList<TypeParameterSyntax> parameters = default(SeparatedSyntaxList<TypeParameterSyntax>))
    {
      return Syntax.TypeParameterList(Syntax.Token(SyntaxKind.LessThanToken), parameters, Syntax.Token(SyntaxKind.GreaterThanToken));
    }

    /// <summary>Creates a new TypeParameterSyntax instance.</summary>
    public static TypeParameterSyntax TypeParameter(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
      switch (varianceKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("varianceKeyword");
      }
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      return (TypeParameterSyntax)InternalSyntax.Syntax.TypeParameter(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), varianceKeyword.Node, identifier.Node).ToRed();
    }

    /// <summary>Creates a new TypeParameterSyntax instance.</summary>
    public static TypeParameterSyntax TypeParameter(SyntaxToken identifier)
    {
      return Syntax.TypeParameter(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxToken), identifier);
    }

    /// <summary>Creates a new TypeParameterSyntax instance.</summary>
    public static TypeParameterSyntax TypeParameter(string identifier)
    {
      return Syntax.TypeParameter(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxToken), Syntax.Identifier(identifier));
    }

    /// <summary>Creates a new ClassDeclarationSyntax instance.</summary>
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
      switch (keyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ClassDeclarationSyntax)InternalSyntax.Syntax.ClassDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), keyword.Node, identifier.Node, typeParameterList == null ? null : (InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, baseList == null ? null : (InternalSyntax.BaseListSyntax)baseList.Green, constraintClauses.Node.ToGreenList<InternalSyntax.TypeParameterConstraintClauseSyntax>(), openBraceToken.Node, members.Node.ToGreenList<InternalSyntax.MemberDeclarationSyntax>(), closeBraceToken.Node, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new ClassDeclarationSyntax instance.</summary>
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<MemberDeclarationSyntax> members)
    {
      return Syntax.ClassDeclaration(attributes, modifiers, Syntax.Token(SyntaxKind.ClassKeyword), identifier, typeParameterList, baseList, constraintClauses, Syntax.Token(SyntaxKind.OpenBraceToken), members, Syntax.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new ClassDeclarationSyntax instance.</summary>
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxToken identifier)
    {
      return Syntax.ClassDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(SyntaxKind.ClassKeyword), identifier, default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), Syntax.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), Syntax.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new ClassDeclarationSyntax instance.</summary>
    public static ClassDeclarationSyntax ClassDeclaration(string identifier)
    {
      return Syntax.ClassDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(SyntaxKind.ClassKeyword), Syntax.Identifier(identifier), default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), Syntax.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), Syntax.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new StructDeclarationSyntax instance.</summary>
    public static StructDeclarationSyntax StructDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
      switch (keyword.Kind)
      {
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (StructDeclarationSyntax)InternalSyntax.Syntax.StructDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), keyword.Node, identifier.Node, typeParameterList == null ? null : (InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, baseList == null ? null : (InternalSyntax.BaseListSyntax)baseList.Green, constraintClauses.Node.ToGreenList<InternalSyntax.TypeParameterConstraintClauseSyntax>(), openBraceToken.Node, members.Node.ToGreenList<InternalSyntax.MemberDeclarationSyntax>(), closeBraceToken.Node, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new StructDeclarationSyntax instance.</summary>
    public static StructDeclarationSyntax StructDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<MemberDeclarationSyntax> members)
    {
      return Syntax.StructDeclaration(attributes, modifiers, Syntax.Token(SyntaxKind.StructKeyword), identifier, typeParameterList, baseList, constraintClauses, Syntax.Token(SyntaxKind.OpenBraceToken), members, Syntax.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new StructDeclarationSyntax instance.</summary>
    public static StructDeclarationSyntax StructDeclaration(SyntaxToken identifier)
    {
      return Syntax.StructDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(SyntaxKind.StructKeyword), identifier, default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), Syntax.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), Syntax.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new StructDeclarationSyntax instance.</summary>
    public static StructDeclarationSyntax StructDeclaration(string identifier)
    {
      return Syntax.StructDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(SyntaxKind.StructKeyword), Syntax.Identifier(identifier), default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), Syntax.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), Syntax.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
      switch (keyword.Kind)
      {
        case SyntaxKind.InterfaceKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (InterfaceDeclarationSyntax)InternalSyntax.Syntax.InterfaceDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), keyword.Node, identifier.Node, typeParameterList == null ? null : (InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, baseList == null ? null : (InternalSyntax.BaseListSyntax)baseList.Green, constraintClauses.Node.ToGreenList<InternalSyntax.TypeParameterConstraintClauseSyntax>(), openBraceToken.Node, members.Node.ToGreenList<InternalSyntax.MemberDeclarationSyntax>(), closeBraceToken.Node, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<MemberDeclarationSyntax> members)
    {
      return Syntax.InterfaceDeclaration(attributes, modifiers, Syntax.Token(SyntaxKind.InterfaceKeyword), identifier, typeParameterList, baseList, constraintClauses, Syntax.Token(SyntaxKind.OpenBraceToken), members, Syntax.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxToken identifier)
    {
      return Syntax.InterfaceDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(SyntaxKind.InterfaceKeyword), identifier, default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), Syntax.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), Syntax.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
    public static InterfaceDeclarationSyntax InterfaceDeclaration(string identifier)
    {
      return Syntax.InterfaceDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(SyntaxKind.InterfaceKeyword), Syntax.Identifier(identifier), default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), Syntax.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), Syntax.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new EnumDeclarationSyntax instance.</summary>
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
      switch (enumKeyword.Kind)
      {
        case SyntaxKind.EnumKeyword:
          break;
        default:
          throw new ArgumentException("enumKeyword");
      }
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (EnumDeclarationSyntax)InternalSyntax.Syntax.EnumDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), enumKeyword.Node, identifier.Node, baseList == null ? null : (InternalSyntax.BaseListSyntax)baseList.Green, openBraceToken.Node, members.Node.ToGreenSeparatedList<InternalSyntax.EnumMemberDeclarationSyntax>(), closeBraceToken.Node, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new EnumDeclarationSyntax instance.</summary>
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken identifier, BaseListSyntax baseList, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members)
    {
      return Syntax.EnumDeclaration(attributes, modifiers, Syntax.Token(SyntaxKind.EnumKeyword), identifier, baseList, Syntax.Token(SyntaxKind.OpenBraceToken), members, Syntax.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new EnumDeclarationSyntax instance.</summary>
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxToken identifier)
    {
      return Syntax.EnumDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(SyntaxKind.EnumKeyword), identifier, default(BaseListSyntax), Syntax.Token(SyntaxKind.OpenBraceToken), default(SeparatedSyntaxList<EnumMemberDeclarationSyntax>), Syntax.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new EnumDeclarationSyntax instance.</summary>
    public static EnumDeclarationSyntax EnumDeclaration(string identifier)
    {
      return Syntax.EnumDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(SyntaxKind.EnumKeyword), Syntax.Identifier(identifier), default(BaseListSyntax), Syntax.Token(SyntaxKind.OpenBraceToken), default(SeparatedSyntaxList<EnumMemberDeclarationSyntax>), Syntax.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException("delegateKeyword");
      }
      if (returnType == null)
        throw new ArgumentNullException("returnType");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (DelegateDeclarationSyntax)InternalSyntax.Syntax.DelegateDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), delegateKeyword.Node, returnType == null ? null : (InternalSyntax.TypeSyntax)returnType.Green, identifier.Node, typeParameterList == null ? null : (InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, parameterList == null ? null : (InternalSyntax.ParameterListSyntax)parameterList.Green, constraintClauses.Node.ToGreenList<InternalSyntax.TypeParameterConstraintClauseSyntax>(), semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
      return Syntax.DelegateDeclaration(attributes, modifiers, Syntax.Token(SyntaxKind.DelegateKeyword), returnType, identifier, typeParameterList, parameterList, constraintClauses, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
    public static DelegateDeclarationSyntax DelegateDeclaration(TypeSyntax returnType, SyntaxToken identifier)
    {
      return Syntax.DelegateDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(SyntaxKind.DelegateKeyword), returnType, identifier, default(TypeParameterListSyntax), Syntax.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
    public static DelegateDeclarationSyntax DelegateDeclaration(TypeSyntax returnType, string identifier)
    {
      return Syntax.DelegateDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(SyntaxKind.DelegateKeyword), returnType, Syntax.Identifier(identifier), default(TypeParameterListSyntax), Syntax.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      return (EnumMemberDeclarationSyntax)InternalSyntax.Syntax.EnumMemberDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), identifier.Node, equalsValue == null ? null : (InternalSyntax.EqualsValueClauseSyntax)equalsValue.Green).ToRed();
    }

    /// <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier)
    {
      return Syntax.EnumMemberDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), identifier, default(EqualsValueClauseSyntax));
    }

    /// <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string identifier)
    {
      return Syntax.EnumMemberDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), Syntax.Identifier(identifier), default(EqualsValueClauseSyntax));
    }

    /// <summary>Creates a new BaseListSyntax instance.</summary>
    public static BaseListSyntax BaseList(SyntaxToken colonToken, SeparatedSyntaxList<TypeSyntax> types)
    {
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      return (BaseListSyntax)InternalSyntax.Syntax.BaseList(colonToken.Node, types.Node.ToGreenSeparatedList<InternalSyntax.TypeSyntax>()).ToRed();
    }

    /// <summary>Creates a new BaseListSyntax instance.</summary>
    public static BaseListSyntax BaseList(SeparatedSyntaxList<TypeSyntax> types = default(SeparatedSyntaxList<TypeSyntax>))
    {
      return Syntax.BaseList(Syntax.Token(SyntaxKind.ColonToken), types);
    }

    /// <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax identifier, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException("whereKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException("identifier");
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      return (TypeParameterConstraintClauseSyntax)InternalSyntax.Syntax.TypeParameterConstraintClause(whereKeyword.Node, identifier == null ? null : (InternalSyntax.IdentifierNameSyntax)identifier.Green, colonToken.Node, constraints.Node.ToGreenSeparatedList<InternalSyntax.TypeParameterConstraintSyntax>()).ToRed();
    }

    /// <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax identifier, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
      return Syntax.TypeParameterConstraintClause(Syntax.Token(SyntaxKind.WhereKeyword), identifier, Syntax.Token(SyntaxKind.ColonToken), constraints);
    }

    /// <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax identifier)
    {
      return Syntax.TypeParameterConstraintClause(Syntax.Token(SyntaxKind.WhereKeyword), identifier, Syntax.Token(SyntaxKind.ColonToken), default(SeparatedSyntaxList<TypeParameterConstraintSyntax>));
    }

    /// <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string identifier)
    {
      return Syntax.TypeParameterConstraintClause(Syntax.Token(SyntaxKind.WhereKeyword), Syntax.IdentifierName(identifier), Syntax.Token(SyntaxKind.ColonToken), default(SeparatedSyntaxList<TypeParameterConstraintSyntax>));
    }

    /// <summary>Creates a new ConstructorConstraintSyntax instance.</summary>
    public static ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (ConstructorConstraintSyntax)InternalSyntax.Syntax.ConstructorConstraint(newKeyword.Node, openParenToken.Node, closeParenToken.Node).ToRed();
    }

    /// <summary>Creates a new ConstructorConstraintSyntax instance.</summary>
    public static ConstructorConstraintSyntax ConstructorConstraint()
    {
      return Syntax.ConstructorConstraint(Syntax.Token(SyntaxKind.NewKeyword), Syntax.Token(SyntaxKind.OpenParenToken), Syntax.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new ClassOrStructConstraintSyntax instance.</summary>
    public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.ClassConstraint:
        case SyntaxKind.StructConstraint:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (classOrStructKeyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException("classOrStructKeyword");
      }
      return (ClassOrStructConstraintSyntax)InternalSyntax.Syntax.ClassOrStructConstraint(kind, classOrStructKeyword.Node).ToRed();
    }

    /// <summary>Creates a new ClassOrStructConstraintSyntax instance.</summary>
    public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind)
    {
      return Syntax.ClassOrStructConstraint(kind, Syntax.Token(GetClassOrStructConstraintClassOrStructKeywordKind(kind)));
    }

    private static SyntaxKind GetClassOrStructConstraintClassOrStructKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.ClassConstraint:
          return SyntaxKind.ClassKeyword;
        case SyntaxKind.StructConstraint:
          return SyntaxKind.StructKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new TypeConstraintSyntax instance.</summary>
    public static TypeConstraintSyntax TypeConstraint(TypeSyntax type)
    {
      if (type == null)
        throw new ArgumentNullException("type");
      return (TypeConstraintSyntax)InternalSyntax.Syntax.TypeConstraint(type == null ? null : (InternalSyntax.TypeSyntax)type.Green).ToRed();
    }

    /// <summary>Creates a new FieldDeclarationSyntax instance.</summary>
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
      if (declaration == null)
        throw new ArgumentNullException("declaration");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (FieldDeclarationSyntax)InternalSyntax.Syntax.FieldDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), declaration == null ? null : (InternalSyntax.VariableDeclarationSyntax)declaration.Green, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new FieldDeclarationSyntax instance.</summary>
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration)
    {
      return Syntax.FieldDeclaration(attributes, modifiers, declaration, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new FieldDeclarationSyntax instance.</summary>
    public static FieldDeclarationSyntax FieldDeclaration(VariableDeclarationSyntax declaration)
    {
      return Syntax.FieldDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), declaration, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException("eventKeyword");
      }
      if (declaration == null)
        throw new ArgumentNullException("declaration");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (EventFieldDeclarationSyntax)InternalSyntax.Syntax.EventFieldDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), eventKeyword.Node, declaration == null ? null : (InternalSyntax.VariableDeclarationSyntax)declaration.Green, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration)
    {
      return Syntax.EventFieldDeclaration(attributes, modifiers, Syntax.Token(SyntaxKind.EventKeyword), declaration, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
    public static EventFieldDeclarationSyntax EventFieldDeclaration(VariableDeclarationSyntax declaration)
    {
      return Syntax.EventFieldDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(SyntaxKind.EventKeyword), declaration, Syntax.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ExplicitInterfaceSpecifierSyntax instance.</summary>
    public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)
    {
      if (name == null)
        throw new ArgumentNullException("name");
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      return (ExplicitInterfaceSpecifierSyntax)InternalSyntax.Syntax.ExplicitInterfaceSpecifier(name == null ? null : (InternalSyntax.NameSyntax)name.Green, dotToken.Node).ToRed();
    }

    /// <summary>Creates a new ExplicitInterfaceSpecifierSyntax instance.</summary>
    public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name)
    {
      return Syntax.ExplicitInterfaceSpecifier(name, Syntax.Token(SyntaxKind.DotToken));
    }

    /// <summary>Creates a new MethodDeclarationSyntax instance.</summary>
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, SyntaxToken semicolonToken)
    {
      if (returnType == null)
        throw new ArgumentNullException("returnType");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (MethodDeclarationSyntax)InternalSyntax.Syntax.MethodDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), returnType == null ? null : (InternalSyntax.TypeSyntax)returnType.Green, explicitInterfaceSpecifier == null ? null : (InternalSyntax.ExplicitInterfaceSpecifierSyntax)explicitInterfaceSpecifier.Green, identifier.Node, typeParameterList == null ? null : (InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, parameterList == null ? null : (InternalSyntax.ParameterListSyntax)parameterList.Green, constraintClauses.Node.ToGreenList<InternalSyntax.TypeParameterConstraintClauseSyntax>(), body == null ? null : (InternalSyntax.BlockSyntax)body.Green, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new MethodDeclarationSyntax instance.</summary>
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body)
    {
      return Syntax.MethodDeclaration(attributes, modifiers, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, default(SyntaxToken));
    }

    /// <summary>Creates a new MethodDeclarationSyntax instance.</summary>
    public static MethodDeclarationSyntax MethodDeclaration(TypeSyntax returnType, SyntaxToken identifier)
    {
      return Syntax.MethodDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), returnType, default(ExplicitInterfaceSpecifierSyntax), identifier, default(TypeParameterListSyntax), Syntax.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), default(BlockSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new MethodDeclarationSyntax instance.</summary>
    public static MethodDeclarationSyntax MethodDeclaration(TypeSyntax returnType, string identifier)
    {
      return Syntax.MethodDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), returnType, default(ExplicitInterfaceSpecifierSyntax), Syntax.Identifier(identifier), default(TypeParameterListSyntax), Syntax.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), default(BlockSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
      if (returnType == null)
        throw new ArgumentNullException("returnType");
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (OperatorDeclarationSyntax)InternalSyntax.Syntax.OperatorDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), returnType == null ? null : (InternalSyntax.TypeSyntax)returnType.Green, operatorKeyword.Node, operatorToken.Node, parameterList == null ? null : (InternalSyntax.ParameterListSyntax)parameterList.Green, body == null ? null : (InternalSyntax.BlockSyntax)body.Green, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body)
    {
      return Syntax.OperatorDeclaration(attributes, modifiers, returnType, Syntax.Token(SyntaxKind.OperatorKeyword), operatorToken, parameterList, body, default(SyntaxToken));
    }

    /// <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
    public static OperatorDeclarationSyntax OperatorDeclaration(TypeSyntax returnType, SyntaxToken operatorToken)
    {
      return Syntax.OperatorDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), returnType, Syntax.Token(SyntaxKind.OperatorKeyword), operatorToken, Syntax.ParameterList(), default(BlockSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
      switch (implicitOrExplicitKeyword.Kind)
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException("implicitOrExplicitKeyword");
      }
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ConversionOperatorDeclarationSyntax)InternalSyntax.Syntax.ConversionOperatorDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), implicitOrExplicitKeyword.Node, operatorKeyword.Node, type == null ? null : (InternalSyntax.TypeSyntax)type.Green, parameterList == null ? null : (InternalSyntax.ParameterListSyntax)parameterList.Green, body == null ? null : (InternalSyntax.BlockSyntax)body.Green, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body)
    {
      return Syntax.ConversionOperatorDeclaration(attributes, modifiers, implicitOrExplicitKeyword, Syntax.Token(SyntaxKind.OperatorKeyword), type, parameterList, body, default(SyntaxToken));
    }

    /// <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type)
    {
      return Syntax.ConversionOperatorDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), implicitOrExplicitKeyword, Syntax.Token(SyntaxKind.OperatorKeyword), type, Syntax.ParameterList(), default(BlockSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken)
    {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ConstructorDeclarationSyntax)InternalSyntax.Syntax.ConstructorDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), identifier.Node, parameterList == null ? null : (InternalSyntax.ParameterListSyntax)parameterList.Green, initializer == null ? null : (InternalSyntax.ConstructorInitializerSyntax)initializer.Green, body == null ? null : (InternalSyntax.BlockSyntax)body.Green, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body)
    {
      return Syntax.ConstructorDeclaration(attributes, modifiers, identifier, parameterList, initializer, body, default(SyntaxToken));
    }

    /// <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxToken identifier)
    {
      return Syntax.ConstructorDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), identifier, Syntax.ParameterList(), default(ConstructorInitializerSyntax), default(BlockSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
    public static ConstructorDeclarationSyntax ConstructorDeclaration(string identifier)
    {
      return Syntax.ConstructorDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Identifier(identifier), Syntax.ParameterList(), default(ConstructorInitializerSyntax), default(BlockSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new ConstructorInitializerSyntax instance.</summary>
    public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
      switch (kind)
      {
        case SyntaxKind.BaseConstructorInitializer:
        case SyntaxKind.ThisConstructorInitializer:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      switch (thisOrBaseKeyword.Kind)
      {
        case SyntaxKind.BaseKeyword:
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisOrBaseKeyword");
      }
      if (argumentList == null)
        throw new ArgumentNullException("argumentList");
      return (ConstructorInitializerSyntax)InternalSyntax.Syntax.ConstructorInitializer(kind, colonToken.Node, thisOrBaseKeyword.Node, argumentList == null ? null : (InternalSyntax.ArgumentListSyntax)argumentList.Green).ToRed();
    }

    /// <summary>Creates a new ConstructorInitializerSyntax instance.</summary>
    public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, ArgumentListSyntax argumentList = default(ArgumentListSyntax))
    {
      return Syntax.ConstructorInitializer(kind, Syntax.Token(SyntaxKind.ColonToken), Syntax.Token(GetConstructorInitializerThisOrBaseKeywordKind(kind)), argumentList ?? Syntax.ArgumentList());
    }

    private static SyntaxKind GetConstructorInitializerThisOrBaseKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.BaseConstructorInitializer:
          return SyntaxKind.BaseKeyword;
        case SyntaxKind.ThisConstructorInitializer:
          return SyntaxKind.ThisKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
      switch (tildeToken.Kind)
      {
        case SyntaxKind.TildeToken:
          break;
        default:
          throw new ArgumentException("tildeToken");
      }
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (DestructorDeclarationSyntax)InternalSyntax.Syntax.DestructorDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), tildeToken.Node, identifier.Node, parameterList == null ? null : (InternalSyntax.ParameterListSyntax)parameterList.Green, body == null ? null : (InternalSyntax.BlockSyntax)body.Green, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body)
    {
      return Syntax.DestructorDeclaration(attributes, modifiers, Syntax.Token(SyntaxKind.TildeToken), identifier, parameterList, body, default(SyntaxToken));
    }

    /// <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxToken identifier)
    {
      return Syntax.DestructorDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(SyntaxKind.TildeToken), identifier, Syntax.ParameterList(), default(BlockSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
    public static DestructorDeclarationSyntax DestructorDeclaration(string identifier)
    {
      return Syntax.DestructorDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(SyntaxKind.TildeToken), Syntax.Identifier(identifier), Syntax.ParameterList(), default(BlockSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
      if (type == null)
        throw new ArgumentNullException("type");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (accessorList == null)
        throw new ArgumentNullException("accessorList");
      return (PropertyDeclarationSyntax)InternalSyntax.Syntax.PropertyDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), type == null ? null : (InternalSyntax.TypeSyntax)type.Green, explicitInterfaceSpecifier == null ? null : (InternalSyntax.ExplicitInterfaceSpecifierSyntax)explicitInterfaceSpecifier.Green, identifier.Node, accessorList == null ? null : (InternalSyntax.AccessorListSyntax)accessorList.Green).ToRed();
    }

    /// <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
    public static PropertyDeclarationSyntax PropertyDeclaration(TypeSyntax type, SyntaxToken identifier)
    {
      return Syntax.PropertyDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), type, default(ExplicitInterfaceSpecifierSyntax), identifier, Syntax.AccessorList());
    }

    /// <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
    public static PropertyDeclarationSyntax PropertyDeclaration(TypeSyntax type, string identifier)
    {
      return Syntax.PropertyDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), type, default(ExplicitInterfaceSpecifierSyntax), Syntax.Identifier(identifier), Syntax.AccessorList());
    }

    /// <summary>Creates a new EventDeclarationSyntax instance.</summary>
    public static EventDeclarationSyntax EventDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException("eventKeyword");
      }
      if (type == null)
        throw new ArgumentNullException("type");
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (accessorList == null)
        throw new ArgumentNullException("accessorList");
      return (EventDeclarationSyntax)InternalSyntax.Syntax.EventDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), eventKeyword.Node, type == null ? null : (InternalSyntax.TypeSyntax)type.Green, explicitInterfaceSpecifier == null ? null : (InternalSyntax.ExplicitInterfaceSpecifierSyntax)explicitInterfaceSpecifier.Green, identifier.Node, accessorList == null ? null : (InternalSyntax.AccessorListSyntax)accessorList.Green).ToRed();
    }

    /// <summary>Creates a new EventDeclarationSyntax instance.</summary>
    public static EventDeclarationSyntax EventDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
      return Syntax.EventDeclaration(attributes, modifiers, Syntax.Token(SyntaxKind.EventKeyword), type, explicitInterfaceSpecifier, identifier, accessorList);
    }

    /// <summary>Creates a new EventDeclarationSyntax instance.</summary>
    public static EventDeclarationSyntax EventDeclaration(TypeSyntax type, SyntaxToken identifier)
    {
      return Syntax.EventDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(SyntaxKind.EventKeyword), type, default(ExplicitInterfaceSpecifierSyntax), identifier, Syntax.AccessorList());
    }

    /// <summary>Creates a new EventDeclarationSyntax instance.</summary>
    public static EventDeclarationSyntax EventDeclaration(TypeSyntax type, string identifier)
    {
      return Syntax.EventDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(SyntaxKind.EventKeyword), type, default(ExplicitInterfaceSpecifierSyntax), Syntax.Identifier(identifier), Syntax.AccessorList());
    }

    /// <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList)
    {
      if (type == null)
        throw new ArgumentNullException("type");
      switch (thisKeyword.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisKeyword");
      }
      if (parameterList == null)
        throw new ArgumentNullException("parameterList");
      if (accessorList == null)
        throw new ArgumentNullException("accessorList");
      return (IndexerDeclarationSyntax)InternalSyntax.Syntax.IndexerDeclaration(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), type == null ? null : (InternalSyntax.TypeSyntax)type.Green, explicitInterfaceSpecifier == null ? null : (InternalSyntax.ExplicitInterfaceSpecifierSyntax)explicitInterfaceSpecifier.Green, thisKeyword.Node, parameterList == null ? null : (InternalSyntax.BracketedParameterListSyntax)parameterList.Green, accessorList == null ? null : (InternalSyntax.AccessorListSyntax)accessorList.Green).ToRed();
    }

    /// <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList)
    {
      return Syntax.IndexerDeclaration(attributes, modifiers, type, explicitInterfaceSpecifier, Syntax.Token(SyntaxKind.ThisKeyword), parameterList, accessorList);
    }

    /// <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
    public static IndexerDeclarationSyntax IndexerDeclaration(TypeSyntax type)
    {
      return Syntax.IndexerDeclaration(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), type, default(ExplicitInterfaceSpecifierSyntax), Syntax.Token(SyntaxKind.ThisKeyword), Syntax.BracketedParameterList(), Syntax.AccessorList());
    }

    /// <summary>Creates a new AccessorListSyntax instance.</summary>
    public static AccessorListSyntax AccessorList(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      return (AccessorListSyntax)InternalSyntax.Syntax.AccessorList(openBraceToken.Node, accessors.Node.ToGreenList<InternalSyntax.AccessorDeclarationSyntax>(), closeBraceToken.Node).ToRed();
    }

    /// <summary>Creates a new AccessorListSyntax instance.</summary>
    public static AccessorListSyntax AccessorList(SyntaxList<AccessorDeclarationSyntax> accessors = default(SyntaxList<AccessorDeclarationSyntax>))
    {
      return Syntax.AccessorList(Syntax.Token(SyntaxKind.OpenBraceToken), accessors, Syntax.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GetAccessorDeclaration:
        case SyntaxKind.SetAccessorDeclaration:
        case SyntaxKind.AddAccessorDeclaration:
        case SyntaxKind.RemoveAccessorDeclaration:
        case SyntaxKind.UnknownAccessorDeclaration:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (keyword.Kind)
      {
        case SyntaxKind.GetKeyword:
        case SyntaxKind.SetKeyword:
        case SyntaxKind.AddKeyword:
        case SyntaxKind.RemoveKeyword:
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (AccessorDeclarationSyntax)InternalSyntax.Syntax.AccessorDeclaration(kind, attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), keyword.Node, body == null ? null : (InternalSyntax.BlockSyntax)body.Green, semicolonToken.Node).ToRed();
    }

    /// <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, BlockSyntax body)
    {
      return Syntax.AccessorDeclaration(kind, attributes, modifiers, Syntax.Token(GetAccessorDeclarationKeywordKind(kind)), body, default(SyntaxToken));
    }

    /// <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, BlockSyntax body = default(BlockSyntax))
    {
      return Syntax.AccessorDeclaration(kind, default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), Syntax.Token(GetAccessorDeclarationKeywordKind(kind)), body, default(SyntaxToken));
    }

    private static SyntaxKind GetAccessorDeclarationKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.GetAccessorDeclaration:
          return SyntaxKind.GetKeyword;
        case SyntaxKind.SetAccessorDeclaration:
          return SyntaxKind.SetKeyword;
        case SyntaxKind.AddAccessorDeclaration:
          return SyntaxKind.AddKeyword;
        case SyntaxKind.RemoveAccessorDeclaration:
          return SyntaxKind.RemoveKeyword;
        case SyntaxKind.UnknownAccessorDeclaration:
          return SyntaxKind.IdentifierToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new ParameterListSyntax instance.</summary>
    public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (ParameterListSyntax)InternalSyntax.Syntax.ParameterList(openParenToken.Node, parameters.Node.ToGreenSeparatedList<InternalSyntax.ParameterSyntax>(), closeParenToken.Node).ToRed();
    }

    /// <summary>Creates a new ParameterListSyntax instance.</summary>
    public static ParameterListSyntax ParameterList(SeparatedSyntaxList<ParameterSyntax> parameters = default(SeparatedSyntaxList<ParameterSyntax>))
    {
      return Syntax.ParameterList(Syntax.Token(SyntaxKind.OpenParenToken), parameters, Syntax.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new BracketedParameterListSyntax instance.</summary>
    public static BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      return (BracketedParameterListSyntax)InternalSyntax.Syntax.BracketedParameterList(openBracketToken.Node, parameters.Node.ToGreenSeparatedList<InternalSyntax.ParameterSyntax>(), closeBracketToken.Node).ToRed();
    }

    /// <summary>Creates a new BracketedParameterListSyntax instance.</summary>
    public static BracketedParameterListSyntax BracketedParameterList(SeparatedSyntaxList<ParameterSyntax> parameters = default(SeparatedSyntaxList<ParameterSyntax>))
    {
      return Syntax.BracketedParameterList(Syntax.Token(SyntaxKind.OpenBracketToken), parameters, Syntax.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new ParameterSyntax instance.</summary>
    public static ParameterSyntax Parameter(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.ArgListKeyword:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      return (ParameterSyntax)InternalSyntax.Syntax.Parameter(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), type == null ? null : (InternalSyntax.TypeSyntax)type.Green, identifier.Node, @default == null ? null : (InternalSyntax.EqualsValueClauseSyntax)@default.Green).ToRed();
    }

    /// <summary>Creates a new ParameterSyntax instance.</summary>
    public static ParameterSyntax Parameter(SyntaxToken identifier)
    {
      return Syntax.Parameter(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), default(TypeSyntax), identifier, default(EqualsValueClauseSyntax));
    }

    /// <summary>Creates a new IncompleteMemberSyntax instance.</summary>
    public static IncompleteMemberSyntax IncompleteMember(SyntaxList<AttributeDeclarationSyntax> attributes, SyntaxTokenList modifiers, TypeSyntax type)
    {
      return (IncompleteMemberSyntax)InternalSyntax.Syntax.IncompleteMember(attributes.Node.ToGreenList<InternalSyntax.AttributeDeclarationSyntax>(), modifiers.Node.ToGreenList<InternalSyntax.SyntaxNode>(), type == null ? null : (InternalSyntax.TypeSyntax)type.Green).ToRed();
    }

    /// <summary>Creates a new IncompleteMemberSyntax instance.</summary>
    public static IncompleteMemberSyntax IncompleteMember(TypeSyntax type = default(TypeSyntax))
    {
      return Syntax.IncompleteMember(default(SyntaxList<AttributeDeclarationSyntax>), default(SyntaxTokenList), type);
    }

    /// <summary>Creates a new SkippedTokensSyntax instance.</summary>
    public static SkippedTokensSyntax SkippedTokens(SyntaxTokenList tokens)
    {
      return (SkippedTokensSyntax)InternalSyntax.Syntax.SkippedTokens(tokens.Node.ToGreenList<InternalSyntax.SyntaxNode>()).ToRed();
    }

    /// <summary>Creates a new SkippedTokensSyntax instance.</summary>
    public static SkippedTokensSyntax SkippedTokens()
    {
      return Syntax.SkippedTokens(default(SyntaxTokenList));
    }

    /// <summary>Creates a new DocumentationCommentSyntax instance.</summary>
    public static DocumentationCommentSyntax DocumentationComment(SyntaxList<XmlNodeSyntax> nodes, SyntaxToken endOfComment)
    {
      switch (endOfComment.Kind)
      {
        case SyntaxKind.EndOfDocumentationCommentToken:
          break;
        default:
          throw new ArgumentException("endOfComment");
      }
      return (DocumentationCommentSyntax)InternalSyntax.Syntax.DocumentationComment(nodes.Node.ToGreenList<InternalSyntax.XmlNodeSyntax>(), endOfComment.Node).ToRed();
    }

    /// <summary>Creates a new DocumentationCommentSyntax instance.</summary>
    public static DocumentationCommentSyntax DocumentationComment(SyntaxList<XmlNodeSyntax> nodes = default(SyntaxList<XmlNodeSyntax>))
    {
      return Syntax.DocumentationComment(nodes, Syntax.Token(SyntaxKind.EndOfDocumentationCommentToken));
    }

    /// <summary>Creates a new XmlElementSyntax instance.</summary>
    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
      if (startTag == null)
        throw new ArgumentNullException("startTag");
      if (endTag == null)
        throw new ArgumentNullException("endTag");
      return (XmlElementSyntax)InternalSyntax.Syntax.XmlElement(startTag == null ? null : (InternalSyntax.XmlElementStartTagSyntax)startTag.Green, content.Node.ToGreenList<InternalSyntax.XmlNodeSyntax>(), endTag == null ? null : (InternalSyntax.XmlElementEndTagSyntax)endTag.Green).ToRed();
    }

    /// <summary>Creates a new XmlElementSyntax instance.</summary>
    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, XmlElementEndTagSyntax endTag)
    {
      return Syntax.XmlElement(startTag, default(SyntaxList<XmlNodeSyntax>), endTag);
    }

    /// <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
    public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
      return (XmlElementStartTagSyntax)InternalSyntax.Syntax.XmlElementStartTag(lessThanToken.Node, name == null ? null : (InternalSyntax.XmlNameSyntax)name.Green, attributes.Node.ToGreenList<InternalSyntax.XmlAttributeSyntax>(), greaterThanToken.Node).ToRed();
    }

    /// <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
    public static XmlElementStartTagSyntax XmlElementStartTag(XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes)
    {
      return Syntax.XmlElementStartTag(Syntax.Token(SyntaxKind.LessThanToken), name, attributes, Syntax.Token(SyntaxKind.GreaterThanToken));
    }

    /// <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
    public static XmlElementStartTagSyntax XmlElementStartTag(XmlNameSyntax name)
    {
      return Syntax.XmlElementStartTag(Syntax.Token(SyntaxKind.LessThanToken), name, default(SyntaxList<XmlAttributeSyntax>), Syntax.Token(SyntaxKind.GreaterThanToken));
    }

    /// <summary>Creates a new XmlElementEndTagSyntax instance.</summary>
    public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
      switch (lessThanSlashToken.Kind)
      {
        case SyntaxKind.LessThanSlashToken:
          break;
        default:
          throw new ArgumentException("lessThanSlashToken");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
      return (XmlElementEndTagSyntax)InternalSyntax.Syntax.XmlElementEndTag(lessThanSlashToken.Node, name == null ? null : (InternalSyntax.XmlNameSyntax)name.Green, greaterThanToken.Node).ToRed();
    }

    /// <summary>Creates a new XmlElementEndTagSyntax instance.</summary>
    public static XmlElementEndTagSyntax XmlElementEndTag(XmlNameSyntax name)
    {
      return Syntax.XmlElementEndTag(Syntax.Token(SyntaxKind.LessThanSlashToken), name, Syntax.Token(SyntaxKind.GreaterThanToken));
    }

    /// <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
    public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      switch (slashGreaterThanToken.Kind)
      {
        case SyntaxKind.SlashGreaterThanToken:
          break;
        default:
          throw new ArgumentException("slashGreaterThanToken");
      }
      return (XmlEmptyElementSyntax)InternalSyntax.Syntax.XmlEmptyElement(lessThanToken.Node, name == null ? null : (InternalSyntax.XmlNameSyntax)name.Green, attributes.Node.ToGreenList<InternalSyntax.XmlAttributeSyntax>(), slashGreaterThanToken.Node).ToRed();
    }

    /// <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
    public static XmlEmptyElementSyntax XmlEmptyElement(XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes)
    {
      return Syntax.XmlEmptyElement(Syntax.Token(SyntaxKind.LessThanToken), name, attributes, Syntax.Token(SyntaxKind.SlashGreaterThanToken));
    }

    /// <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
    public static XmlEmptyElementSyntax XmlEmptyElement(XmlNameSyntax name)
    {
      return Syntax.XmlEmptyElement(Syntax.Token(SyntaxKind.LessThanToken), name, default(SyntaxList<XmlAttributeSyntax>), Syntax.Token(SyntaxKind.SlashGreaterThanToken));
    }

    /// <summary>Creates a new XmlNameSyntax instance.</summary>
    public static XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
      switch (localName.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("localName");
      }
      return (XmlNameSyntax)InternalSyntax.Syntax.XmlName(prefix == null ? null : (InternalSyntax.XmlPrefixSyntax)prefix.Green, localName.Node).ToRed();
    }

    /// <summary>Creates a new XmlNameSyntax instance.</summary>
    public static XmlNameSyntax XmlName(SyntaxToken localName)
    {
      return Syntax.XmlName(default(XmlPrefixSyntax), localName);
    }

    /// <summary>Creates a new XmlNameSyntax instance.</summary>
    public static XmlNameSyntax XmlName(string localName)
    {
      return Syntax.XmlName(default(XmlPrefixSyntax), Syntax.Identifier(localName));
    }

    /// <summary>Creates a new XmlPrefixSyntax instance.</summary>
    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
    {
      switch (prefix.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("prefix");
      }
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      return (XmlPrefixSyntax)InternalSyntax.Syntax.XmlPrefix(prefix.Node, colonToken.Node).ToRed();
    }

    /// <summary>Creates a new XmlPrefixSyntax instance.</summary>
    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix)
    {
      return Syntax.XmlPrefix(prefix, Syntax.Token(SyntaxKind.ColonToken));
    }

    /// <summary>Creates a new XmlPrefixSyntax instance.</summary>
    public static XmlPrefixSyntax XmlPrefix(string prefix)
    {
      return Syntax.XmlPrefix(Syntax.Identifier(prefix), Syntax.Token(SyntaxKind.ColonToken));
    }

    /// <summary>Creates a new XmlAttributeSyntax instance.</summary>
    public static XmlAttributeSyntax XmlAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)
    {
      if (name == null)
        throw new ArgumentNullException("name");
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
      return (XmlAttributeSyntax)InternalSyntax.Syntax.XmlAttribute(name == null ? null : (InternalSyntax.XmlNameSyntax)name.Green, equalsToken.Node, startQuoteToken.Node, textTokens.Node.ToGreenList<InternalSyntax.SyntaxNode>(), endQuoteToken.Node).ToRed();
    }

    /// <summary>Creates a new XmlAttributeSyntax instance.</summary>
    public static XmlAttributeSyntax XmlAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)
    {
      return Syntax.XmlAttribute(name, Syntax.Token(SyntaxKind.EqualsToken), startQuoteToken, textTokens, endQuoteToken);
    }

    /// <summary>Creates a new XmlAttributeSyntax instance.</summary>
    public static XmlAttributeSyntax XmlAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxToken endQuoteToken)
    {
      return Syntax.XmlAttribute(name, Syntax.Token(SyntaxKind.EqualsToken), startQuoteToken, default(SyntaxTokenList), endQuoteToken);
    }

    /// <summary>Creates a new XmlTextSyntax instance.</summary>
    public static XmlTextSyntax XmlText(SyntaxTokenList textTokens)
    {
      return (XmlTextSyntax)InternalSyntax.Syntax.XmlText(textTokens.Node.ToGreenList<InternalSyntax.SyntaxNode>()).ToRed();
    }

    /// <summary>Creates a new XmlTextSyntax instance.</summary>
    public static XmlTextSyntax XmlText()
    {
      return Syntax.XmlText(default(SyntaxTokenList));
    }

    /// <summary>Creates a new XmlCDataSectionSyntax instance.</summary>
    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken)
    {
      switch (startCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataStartToken:
          break;
        default:
          throw new ArgumentException("startCDataToken");
      }
      switch (endCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataEndToken:
          break;
        default:
          throw new ArgumentException("endCDataToken");
      }
      return (XmlCDataSectionSyntax)InternalSyntax.Syntax.XmlCDataSection(startCDataToken.Node, textTokens.Node.ToGreenList<InternalSyntax.SyntaxNode>(), endCDataToken.Node).ToRed();
    }

    /// <summary>Creates a new XmlCDataSectionSyntax instance.</summary>
    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxTokenList textTokens = default(SyntaxTokenList))
    {
      return Syntax.XmlCDataSection(Syntax.Token(SyntaxKind.XmlCDataStartToken), textTokens, Syntax.Token(SyntaxKind.XmlCDataEndToken));
    }

    /// <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken)
    {
      switch (startProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionStartToken:
          break;
        default:
          throw new ArgumentException("startProcessingInstructionToken");
      }
      if (name == null)
        throw new ArgumentNullException("name");
      switch (endProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionEndToken:
          break;
        default:
          throw new ArgumentException("endProcessingInstructionToken");
      }
      return (XmlProcessingInstructionSyntax)InternalSyntax.Syntax.XmlProcessingInstruction(startProcessingInstructionToken.Node, name == null ? null : (InternalSyntax.XmlNameSyntax)name.Green, textTokens.Node.ToGreenList<InternalSyntax.SyntaxNode>(), endProcessingInstructionToken.Node).ToRed();
    }

    /// <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(XmlNameSyntax name, SyntaxTokenList textTokens)
    {
      return Syntax.XmlProcessingInstruction(Syntax.Token(SyntaxKind.XmlProcessingInstructionStartToken), name, textTokens, Syntax.Token(SyntaxKind.XmlProcessingInstructionEndToken));
    }

    /// <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(XmlNameSyntax name)
    {
      return Syntax.XmlProcessingInstruction(Syntax.Token(SyntaxKind.XmlProcessingInstructionStartToken), name, default(SyntaxTokenList), Syntax.Token(SyntaxKind.XmlProcessingInstructionEndToken));
    }

    /// <summary>Creates a new XmlCommentSyntax instance.</summary>
    public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
      switch (lessThanExclamationMinusMinusToken.Kind)
      {
        case SyntaxKind.XmlCommentStartToken:
          break;
        default:
          throw new ArgumentException("lessThanExclamationMinusMinusToken");
      }
      switch (minusMinusGreaterThanToken.Kind)
      {
        case SyntaxKind.XmlCommentEndToken:
          break;
        default:
          throw new ArgumentException("minusMinusGreaterThanToken");
      }
      return (XmlCommentSyntax)InternalSyntax.Syntax.XmlComment(lessThanExclamationMinusMinusToken.Node, textTokens.Node.ToGreenList<InternalSyntax.SyntaxNode>(), minusMinusGreaterThanToken.Node).ToRed();
    }

    /// <summary>Creates a new XmlCommentSyntax instance.</summary>
    public static XmlCommentSyntax XmlComment(SyntaxTokenList textTokens = default(SyntaxTokenList))
    {
      return Syntax.XmlComment(Syntax.Token(SyntaxKind.XmlCommentStartToken), textTokens, Syntax.Token(SyntaxKind.XmlCommentEndToken));
    }

    /// <summary>Creates a new IfDirectiveSyntax instance.</summary>
    public static IfDirectiveSyntax IfDirective(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException("ifKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException("condition");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (IfDirectiveSyntax)InternalSyntax.Syntax.IfDirective(hashToken.Node, ifKeyword.Node, condition == null ? null : (InternalSyntax.ExpressionSyntax)condition.Green, endOfDirectiveToken.Node, isActive, branchTaken, conditionValue).ToRed();
    }

    /// <summary>Creates a new IfDirectiveSyntax instance.</summary>
    public static IfDirectiveSyntax IfDirective(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue)
    {
      return Syntax.IfDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.IfKeyword), condition, Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive, branchTaken, conditionValue);
    }

    /// <summary>Creates a new ElifDirectiveSyntax instance.</summary>
    public static ElifDirectiveSyntax ElifDirective(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (elifKeyword.Kind)
      {
        case SyntaxKind.ElifKeyword:
          break;
        default:
          throw new ArgumentException("elifKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException("condition");
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (ElifDirectiveSyntax)InternalSyntax.Syntax.ElifDirective(hashToken.Node, elifKeyword.Node, condition == null ? null : (InternalSyntax.ExpressionSyntax)condition.Green, endOfDirectiveToken.Node, isActive, branchTaken, conditionValue).ToRed();
    }

    /// <summary>Creates a new ElifDirectiveSyntax instance.</summary>
    public static ElifDirectiveSyntax ElifDirective(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue)
    {
      return Syntax.ElifDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.ElifKeyword), condition, Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive, branchTaken, conditionValue);
    }

    /// <summary>Creates a new ElseDirectiveSyntax instance.</summary>
    public static ElseDirectiveSyntax ElseDirective(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException("elseKeyword");
      }
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (ElseDirectiveSyntax)InternalSyntax.Syntax.ElseDirective(hashToken.Node, elseKeyword.Node, endOfDirectiveToken.Node, isActive, branchTaken).ToRed();
    }

    /// <summary>Creates a new ElseDirectiveSyntax instance.</summary>
    public static ElseDirectiveSyntax ElseDirective(bool isActive, bool branchTaken)
    {
      return Syntax.ElseDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.ElseKeyword), Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive, branchTaken);
    }

    /// <summary>Creates a new EndIfDirectiveSyntax instance.</summary>
    public static EndIfDirectiveSyntax EndIfDirective(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (endIfKeyword.Kind)
      {
        case SyntaxKind.EndIfKeyword:
          break;
        default:
          throw new ArgumentException("endIfKeyword");
      }
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (EndIfDirectiveSyntax)InternalSyntax.Syntax.EndIfDirective(hashToken.Node, endIfKeyword.Node, endOfDirectiveToken.Node, isActive).ToRed();
    }

    /// <summary>Creates a new EndIfDirectiveSyntax instance.</summary>
    public static EndIfDirectiveSyntax EndIfDirective(bool isActive)
    {
      return Syntax.EndIfDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.EndIfKeyword), Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new RegionDirectiveSyntax instance.</summary>
    public static RegionDirectiveSyntax RegionDirective(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (regionKeyword.Kind)
      {
        case SyntaxKind.RegionKeyword:
          break;
        default:
          throw new ArgumentException("regionKeyword");
      }
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (RegionDirectiveSyntax)InternalSyntax.Syntax.RegionDirective(hashToken.Node, regionKeyword.Node, endOfDirectiveToken.Node, isActive).ToRed();
    }

    /// <summary>Creates a new RegionDirectiveSyntax instance.</summary>
    public static RegionDirectiveSyntax RegionDirective(bool isActive)
    {
      return Syntax.RegionDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.RegionKeyword), Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new EndRegionDirectiveSyntax instance.</summary>
    public static EndRegionDirectiveSyntax EndRegionDirective(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (endRegionKeyword.Kind)
      {
        case SyntaxKind.EndRegionKeyword:
          break;
        default:
          throw new ArgumentException("endRegionKeyword");
      }
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (EndRegionDirectiveSyntax)InternalSyntax.Syntax.EndRegionDirective(hashToken.Node, endRegionKeyword.Node, endOfDirectiveToken.Node, isActive).ToRed();
    }

    /// <summary>Creates a new EndRegionDirectiveSyntax instance.</summary>
    public static EndRegionDirectiveSyntax EndRegionDirective(bool isActive)
    {
      return Syntax.EndRegionDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.EndRegionKeyword), Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new ErrorDirectiveSyntax instance.</summary>
    public static ErrorDirectiveSyntax ErrorDirective(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (errorKeyword.Kind)
      {
        case SyntaxKind.ErrorKeyword:
          break;
        default:
          throw new ArgumentException("errorKeyword");
      }
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (ErrorDirectiveSyntax)InternalSyntax.Syntax.ErrorDirective(hashToken.Node, errorKeyword.Node, endOfDirectiveToken.Node, isActive).ToRed();
    }

    /// <summary>Creates a new ErrorDirectiveSyntax instance.</summary>
    public static ErrorDirectiveSyntax ErrorDirective(bool isActive)
    {
      return Syntax.ErrorDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.ErrorKeyword), Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new WarningDirectiveSyntax instance.</summary>
    public static WarningDirectiveSyntax WarningDirective(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException("warningKeyword");
      }
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (WarningDirectiveSyntax)InternalSyntax.Syntax.WarningDirective(hashToken.Node, warningKeyword.Node, endOfDirectiveToken.Node, isActive).ToRed();
    }

    /// <summary>Creates a new WarningDirectiveSyntax instance.</summary>
    public static WarningDirectiveSyntax WarningDirective(bool isActive)
    {
      return Syntax.WarningDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.WarningKeyword), Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new BadDirectiveSyntax instance.</summary>
    public static BadDirectiveSyntax BadDirective(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (BadDirectiveSyntax)InternalSyntax.Syntax.BadDirective(hashToken.Node, identifier.Node, endOfDirectiveToken.Node, isActive).ToRed();
    }

    /// <summary>Creates a new BadDirectiveSyntax instance.</summary>
    public static BadDirectiveSyntax BadDirective(SyntaxToken identifier, bool isActive)
    {
      return Syntax.BadDirective(Syntax.Token(SyntaxKind.HashToken), identifier, Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new DefineDirectiveSyntax instance.</summary>
    public static DefineDirectiveSyntax DefineDirective(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (defineKeyword.Kind)
      {
        case SyntaxKind.DefineKeyword:
          break;
        default:
          throw new ArgumentException("defineKeyword");
      }
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("name");
      }
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (DefineDirectiveSyntax)InternalSyntax.Syntax.DefineDirective(hashToken.Node, defineKeyword.Node, name.Node, endOfDirectiveToken.Node, isActive).ToRed();
    }

    /// <summary>Creates a new DefineDirectiveSyntax instance.</summary>
    public static DefineDirectiveSyntax DefineDirective(SyntaxToken name, bool isActive)
    {
      return Syntax.DefineDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.DefineKeyword), name, Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new DefineDirectiveSyntax instance.</summary>
    public static DefineDirectiveSyntax DefineDirective(string name, bool isActive)
    {
      return Syntax.DefineDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.DefineKeyword), Syntax.Identifier(name), Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new UndefDirectiveSyntax instance.</summary>
    public static UndefDirectiveSyntax UndefDirective(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (undefKeyword.Kind)
      {
        case SyntaxKind.UndefKeyword:
          break;
        default:
          throw new ArgumentException("undefKeyword");
      }
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("name");
      }
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (UndefDirectiveSyntax)InternalSyntax.Syntax.UndefDirective(hashToken.Node, undefKeyword.Node, name.Node, endOfDirectiveToken.Node, isActive).ToRed();
    }

    /// <summary>Creates a new UndefDirectiveSyntax instance.</summary>
    public static UndefDirectiveSyntax UndefDirective(SyntaxToken name, bool isActive)
    {
      return Syntax.UndefDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.UndefKeyword), name, Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new UndefDirectiveSyntax instance.</summary>
    public static UndefDirectiveSyntax UndefDirective(string name, bool isActive)
    {
      return Syntax.UndefDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.UndefKeyword), Syntax.Identifier(name), Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new LineDirectiveSyntax instance.</summary>
    public static LineDirectiveSyntax LineDirective(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (lineKeyword.Kind)
      {
        case SyntaxKind.LineKeyword:
          break;
        default:
          throw new ArgumentException("lineKeyword");
      }
      switch (line.Kind)
      {
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.HiddenKeyword:
          break;
        default:
          throw new ArgumentException("line");
      }
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("file");
      }
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (LineDirectiveSyntax)InternalSyntax.Syntax.LineDirective(hashToken.Node, lineKeyword.Node, line.Node, file.Node, endOfDirectiveToken.Node, isActive).ToRed();
    }

    /// <summary>Creates a new LineDirectiveSyntax instance.</summary>
    public static LineDirectiveSyntax LineDirective(SyntaxToken line, bool isActive)
    {
      return Syntax.LineDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.LineKeyword), line, default(SyntaxToken), Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new PragmaWarningDirectiveSyntax instance.</summary>
    public static PragmaWarningDirectiveSyntax PragmaWarningDirective(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException("pragmaKeyword");
      }
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException("warningKeyword");
      }
      switch (disableOrRestoreKeyword.Kind)
      {
        case SyntaxKind.DisableKeyword:
        case SyntaxKind.RestoreKeyword:
          break;
        default:
          throw new ArgumentException("disableOrRestoreKeyword");
      }
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (PragmaWarningDirectiveSyntax)InternalSyntax.Syntax.PragmaWarningDirective(hashToken.Node, pragmaKeyword.Node, warningKeyword.Node, disableOrRestoreKeyword.Node, errorCodes.Node.ToGreenSeparatedList<InternalSyntax.ExpressionSyntax>(), endOfDirectiveToken.Node, isActive).ToRed();
    }

    /// <summary>Creates a new PragmaWarningDirectiveSyntax instance.</summary>
    public static PragmaWarningDirectiveSyntax PragmaWarningDirective(SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, bool isActive)
    {
      return Syntax.PragmaWarningDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.PragmaKeyword), Syntax.Token(SyntaxKind.WarningKeyword), disableOrRestoreKeyword, errorCodes, Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new PragmaWarningDirectiveSyntax instance.</summary>
    public static PragmaWarningDirectiveSyntax PragmaWarningDirective(SyntaxToken disableOrRestoreKeyword, bool isActive)
    {
      return Syntax.PragmaWarningDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.PragmaKeyword), Syntax.Token(SyntaxKind.WarningKeyword), disableOrRestoreKeyword, default(SeparatedSyntaxList<ExpressionSyntax>), Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new PragmaChecksumDirectiveSyntax instance.</summary>
    public static PragmaChecksumDirectiveSyntax PragmaChecksumDirective(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException("pragmaKeyword");
      }
      switch (checksumKeyword.Kind)
      {
        case SyntaxKind.ChecksumKeyword:
          break;
        default:
          throw new ArgumentException("checksumKeyword");
      }
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      switch (guid.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("guid");
      }
      switch (bytes.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("bytes");
      }
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (PragmaChecksumDirectiveSyntax)InternalSyntax.Syntax.PragmaChecksumDirective(hashToken.Node, pragmaKeyword.Node, checksumKeyword.Node, file.Node, guid.Node, bytes.Node, endOfDirectiveToken.Node, isActive).ToRed();
    }

    /// <summary>Creates a new PragmaChecksumDirectiveSyntax instance.</summary>
    public static PragmaChecksumDirectiveSyntax PragmaChecksumDirective(bool isActive)
    {
      return Syntax.PragmaChecksumDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.PragmaKeyword), Syntax.Token(SyntaxKind.ChecksumKeyword), Syntax.Token(SyntaxKind.StringLiteralToken), Syntax.Token(SyntaxKind.StringLiteralToken), Syntax.Token(SyntaxKind.StringLiteralToken), Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new ReferenceDirectiveSyntax instance.</summary>
    public static ReferenceDirectiveSyntax ReferenceDirective(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (referenceKeyword.Kind)
      {
        case SyntaxKind.ReferenceKeyword:
          break;
        default:
          throw new ArgumentException("referenceKeyword");
      }
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (ReferenceDirectiveSyntax)InternalSyntax.Syntax.ReferenceDirective(hashToken.Node, referenceKeyword.Node, file.Node, endOfDirectiveToken.Node, isActive).ToRed();
    }

    /// <summary>Creates a new ReferenceDirectiveSyntax instance.</summary>
    public static ReferenceDirectiveSyntax ReferenceDirective(bool isActive)
    {
      return Syntax.ReferenceDirective(Syntax.Token(SyntaxKind.HashToken), Syntax.Token(SyntaxKind.ReferenceKeyword), Syntax.Token(SyntaxKind.StringLiteralToken), Syntax.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }
  }
}
