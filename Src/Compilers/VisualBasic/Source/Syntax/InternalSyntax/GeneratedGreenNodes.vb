' Definition of parse trees. Generated by a tool on 4/5/2012 12:49 PM DO NOT HAND EDIT

Imports Roslyn.Compilers.Internal
Imports System.Collections.Generic

Namespace Roslyn.Compilers.VisualBasic.InternalSyntax

    ''' <summary>
    ''' The base class for all nodes in the VB syntax tree.
    ''' </summary>
    Partial Friend MustInherit Class SyntaxNode


        Public Overridable Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitSyntaxNode(Me)
        End Function


    End Class

    ''' <summary>
    ''' The base class for all nodes that represent statements. This includes both
    ''' declaration statements, such as class declarations as well as executable
    ''' statements.
    ''' </summary>
    Friend MustInherit Class StatementSyntax
        Inherits SyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' The base class for all nodes that represent executable statements.
    ''' </summary>
    Friend MustInherit Class ExecutableStatementSyntax
        Inherits StatementSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' The base class for all nodes that represent statements that declare options,
    ''' imports, members, etc.
    ''' </summary>
    Friend MustInherit Class DeclarationStatementSyntax
        Inherits StatementSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' A class to represent an empty statement. This can occur when a colon is on a
    ''' line without anything else.
    ''' </summary>
    Friend NotInheritable Class EmptyStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _empty as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, empty As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(empty)
            Me._empty = empty

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), empty As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(empty)
            Me._empty = empty

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._empty = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._empty)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._empty)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.EmptyStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' An empty token because all non terminals must have a token.
        ''' </summary>
        Friend  ReadOnly Property Empty As InternalSyntax.PunctuationSyntax
            Get
                Return Me._empty
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._empty
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new EmptyStatementSyntax(kind, newErrors, GetAnnotations, _empty)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new EmptyStatementSyntax(kind, GetDiagnostics, annotations, _empty)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitEmptyStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an "End XXX" statement, where XXX is a single keyword.
    ''' </summary>
    Friend NotInheritable Class EndBlockStatementSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _endKeyword as KeywordSyntax
        Friend ReadOnly _blockKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, endKeyword As InternalSyntax.KeywordSyntax, blockKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(endKeyword)
            Me._endKeyword = endKeyword
            Init(blockKeyword)
            Me._blockKeyword = blockKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), endKeyword As InternalSyntax.KeywordSyntax, blockKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(endKeyword)
            Me._endKeyword = endKeyword
            Init(blockKeyword)
            Me._blockKeyword = blockKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._endKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._endKeyword)
          Me._blockKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._blockKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._endKeyword)
          writer.WriteValue(Me._blockKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.EndBlockStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "End" keyword
        ''' </summary>
        Friend  ReadOnly Property EndKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._endKeyword
            End Get
        End Property

        ''' <summary>
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </summary>
        Friend  ReadOnly Property BlockKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._blockKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._endKeyword
                Case 1
                    Return Me._blockKeyword
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new EndBlockStatementSyntax(kind, newErrors, GetAnnotations, _endKeyword, _blockKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new EndBlockStatementSyntax(kind, GetDiagnostics, annotations, _endKeyword, _blockKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitEndBlockStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an entire source file of VB code.
    ''' </summary>
    Partial Friend NotInheritable Class CompilationUnitSyntax
        Inherits SyntaxNode

        Friend ReadOnly _options as SyntaxNode
        Friend ReadOnly _imports as SyntaxNode
        Friend ReadOnly _attributes as SyntaxNode
        Friend ReadOnly _members as SyntaxNode
        Friend ReadOnly _endOfFileToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, options As InternalSyntax.SyntaxNode, [imports] As InternalSyntax.SyntaxNode, attributes As InternalSyntax.SyntaxNode, members As InternalSyntax.SyntaxNode, endOfFileToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            If options IsNot Nothing Then
                Init(options)
                Me._options = options
            End If
            If [imports] IsNot Nothing Then
                Init([imports])
                Me._imports = [imports]
            End If
            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            If members IsNot Nothing Then
                Init(members)
                Me._members = members
            End If
            Init(endOfFileToken)
            Me._endOfFileToken = endOfFileToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), options As InternalSyntax.SyntaxNode, [imports] As InternalSyntax.SyntaxNode, attributes As InternalSyntax.SyntaxNode, members As InternalSyntax.SyntaxNode, endOfFileToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            If options IsNot Nothing Then
                Init(options)
                Me._options = options
            End If
            If [imports] IsNot Nothing Then
                Init([imports])
                Me._imports = [imports]
            End If
            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            If members IsNot Nothing Then
                Init(members)
                Me._members = members
            End If
            Init(endOfFileToken)
            Me._endOfFileToken = endOfFileToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._options = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._options)
          Me._imports = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._imports)
          Me._attributes = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._attributes)
          Me._members = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._members)
          Me._endOfFileToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._endOfFileToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._options)
          writer.WriteValue(Me._imports)
          writer.WriteValue(Me._attributes)
          writer.WriteValue(Me._members)
          writer.WriteValue(Me._endOfFileToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.CompilationUnitSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' Represents the list of Option statements at the beginning of a source file.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Options As InternalSyntax.SeparatedSyntaxList(Of OptionStatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of OptionStatementSyntax)(New SyntaxList(of OptionStatementSyntax)(Me._options))
            End Get
        End Property

        ''' <summary>
        ''' Represents the list of Imports statements at the beginning of a source file.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property [Imports] As InternalSyntax.SeparatedSyntaxList(Of ImportsStatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of ImportsStatementSyntax)(New SyntaxList(of ImportsStatementSyntax)(Me._imports))
            End Get
        End Property

        ''' <summary>
        ''' Represents the list of AttributeStatements at the beginning of a source file
        ''' that contain the Assembly and Module attributes.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Attributes As InternalSyntax.SeparatedSyntaxList(Of AttributesStatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of AttributesStatementSyntax)(New SyntaxList(of AttributesStatementSyntax)(Me._attributes))
            End Get
        End Property

        ''' <summary>
        ''' Represents the members of the default namespace for this source file: all the
        ''' top-level type and namespace declarations in the file. May also contain
        ''' Statements that are not valid
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Members As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._members))
            End Get
        End Property

        ''' <summary>
        ''' Represents the end of the source file. This token may have trivia (whitespace,
        ''' comments, ...) attached to it.
        ''' </summary>
        Friend  ReadOnly Property EndOfFileToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._endOfFileToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._options
                Case 1
                    Return Me._imports
                Case 2
                    Return Me._attributes
                Case 3
                    Return Me._members
                Case 4
                    Return Me._endOfFileToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new CompilationUnitSyntax(kind, newErrors, GetAnnotations, _options, _imports, _attributes, _members, _endOfFileToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new CompilationUnitSyntax(kind, GetDiagnostics, annotations, _options, _imports, _attributes, _members, _endOfFileToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitCompilationUnit(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an Option statement, such as "Option Strict On".
    ''' </summary>
    Friend NotInheritable Class OptionStatementSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _optionKeyword as KeywordSyntax
        Friend ReadOnly _nameKeyword as KeywordSyntax
        Friend ReadOnly _valueKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, optionKeyword As InternalSyntax.KeywordSyntax, nameKeyword As InternalSyntax.KeywordSyntax, valueKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(optionKeyword)
            Me._optionKeyword = optionKeyword
            Init(nameKeyword)
            Me._nameKeyword = nameKeyword
            If valueKeyword IsNot Nothing Then
                Init(valueKeyword)
                Me._valueKeyword = valueKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), optionKeyword As InternalSyntax.KeywordSyntax, nameKeyword As InternalSyntax.KeywordSyntax, valueKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(optionKeyword)
            Me._optionKeyword = optionKeyword
            Init(nameKeyword)
            Me._nameKeyword = nameKeyword
            If valueKeyword IsNot Nothing Then
                Init(valueKeyword)
                Me._valueKeyword = valueKeyword
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._optionKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._optionKeyword)
          Me._nameKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._nameKeyword)
          Me._valueKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._valueKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._optionKeyword)
          writer.WriteValue(Me._nameKeyword)
          writer.WriteValue(Me._valueKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.OptionStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Option" keyword.
        ''' </summary>
        Friend  ReadOnly Property OptionKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._optionKeyword
            End Get
        End Property

        ''' <summary>
        ''' The keyword that identifies the option being set: Explicit, Strict, Compare or
        ''' Infer.
        ''' </summary>
        Friend  ReadOnly Property NameKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._nameKeyword
            End Get
        End Property

        ''' <summary>
        ''' The keyword that identifiers the value being set for the opition: On, Off, Text
        ''' or Binary.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ValueKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._valueKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._optionKeyword
                Case 1
                    Return Me._nameKeyword
                Case 2
                    Return Me._valueKeyword
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new OptionStatementSyntax(kind, newErrors, GetAnnotations, _optionKeyword, _nameKeyword, _valueKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new OptionStatementSyntax(kind, GetDiagnostics, annotations, _optionKeyword, _nameKeyword, _valueKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitOptionStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an Imports statement, which has one or more imports clauses.
    ''' </summary>
    Friend NotInheritable Class ImportsStatementSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _importsKeyword as KeywordSyntax
        Friend ReadOnly _importsClauses as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, importsKeyword As InternalSyntax.KeywordSyntax, importsClauses As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(importsKeyword)
            Me._importsKeyword = importsKeyword
            If importsClauses IsNot Nothing Then
                Init(importsClauses)
                Me._importsClauses = importsClauses
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), importsKeyword As InternalSyntax.KeywordSyntax, importsClauses As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(importsKeyword)
            Me._importsKeyword = importsKeyword
            If importsClauses IsNot Nothing Then
                Init(importsClauses)
                Me._importsClauses = importsClauses
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._importsKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._importsKeyword)
          Me._importsClauses = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._importsClauses)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._importsKeyword)
          writer.WriteValue(Me._importsClauses)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ImportsStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Imports" keyword.
        ''' </summary>
        Friend  ReadOnly Property ImportsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._importsKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of one or more import clauses. Each clause is either an alias, namespace
        ''' or XML namespace import.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property ImportsClauses As InternalSyntax.SeparatedSyntaxList(Of ImportsClauseSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of ImportsClauseSyntax)(New SyntaxList(of ImportsClauseSyntax)(Me._importsClauses))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._importsKeyword
                Case 1
                    Return Me._importsClauses
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ImportsStatementSyntax(kind, newErrors, GetAnnotations, _importsKeyword, _importsClauses)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ImportsStatementSyntax(kind, GetDiagnostics, annotations, _importsKeyword, _importsClauses)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitImportsStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' The base class for the possible clauses of an Imports statement.
    ''' </summary>
    Friend MustInherit Class ImportsClauseSyntax
        Inherits SyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' Represents the clause of an Imports statement that defines an alias for a
    ''' namespace or type.
    ''' </summary>
    Friend NotInheritable Class AliasImportsClauseSyntax
        Inherits ImportsClauseSyntax

        Friend ReadOnly _alias as IdentifierTokenSyntax
        Friend ReadOnly _equalsToken as PunctuationSyntax
        Friend ReadOnly _name as NameSyntax

        Friend Sub New(ByVal kind As SyntaxKind, [alias] As InternalSyntax.IdentifierTokenSyntax, equalsToken As InternalSyntax.PunctuationSyntax, name As NameSyntax)
            MyBase.New(kind)

            Init([alias])
            Me._alias = [alias]
            Init(equalsToken)
            Me._equalsToken = equalsToken
            Init(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), [alias] As InternalSyntax.IdentifierTokenSyntax, equalsToken As InternalSyntax.PunctuationSyntax, name As NameSyntax)
            MyBase.New(kind, errors, annotations)

            Init([alias])
            Me._alias = [alias]
            Init(equalsToken)
            Me._equalsToken = equalsToken
            Init(name)
            Me._name = name

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._alias = DirectCast(reader.ReadValue(), IdentifierTokenSyntax)
          Init(Me._alias)
          Me._equalsToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._equalsToken)
          Me._name = DirectCast(reader.ReadValue(), NameSyntax)
          Init(Me._name)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._alias)
          writer.WriteValue(Me._equalsToken)
          writer.WriteValue(Me._name)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.AliasImportsClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The identifier that the alias is being defined for.
        ''' </summary>
        Friend  ReadOnly Property [Alias] As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._alias
            End Get
        End Property

        ''' <summary>
        ''' The equals sign token.
        ''' </summary>
        Friend  ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        ''' <summary>
        ''' The namespace or type the alias refers to.
        ''' </summary>
        Friend  ReadOnly Property Name As InternalSyntax.NameSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._alias
                Case 1
                    Return Me._equalsToken
                Case 2
                    Return Me._name
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new AliasImportsClauseSyntax(kind, newErrors, GetAnnotations, _alias, _equalsToken, _name)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new AliasImportsClauseSyntax(kind, GetDiagnostics, annotations, _alias, _equalsToken, _name)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitAliasImportsClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the clause of an Imports statement that imports all members of a
    ''' namespace.
    ''' </summary>
    Friend NotInheritable Class MembersImportsClauseSyntax
        Inherits ImportsClauseSyntax

        Friend ReadOnly _name as NameSyntax

        Friend Sub New(ByVal kind As SyntaxKind, name As NameSyntax)
            MyBase.New(kind)

            Init(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), name As NameSyntax)
            MyBase.New(kind, errors, annotations)

            Init(name)
            Me._name = name

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._name = DirectCast(reader.ReadValue(), NameSyntax)
          Init(Me._name)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._name)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.MembersImportsClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The namespace or type being imported.
        ''' </summary>
        Friend  ReadOnly Property Name As InternalSyntax.NameSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._name
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new MembersImportsClauseSyntax(kind, newErrors, GetAnnotations, _name)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new MembersImportsClauseSyntax(kind, GetDiagnostics, annotations, _name)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitMembersImportsClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Defines a XML namespace for XML expressions.
    ''' </summary>
    Friend NotInheritable Class XmlNamespaceImportsClauseSyntax
        Inherits ImportsClauseSyntax

        Friend ReadOnly _lessThanToken as PunctuationSyntax
        Friend ReadOnly _xmlNamespace as XmlAttributeSyntax
        Friend ReadOnly _greaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanToken As InternalSyntax.PunctuationSyntax, xmlNamespace As XmlAttributeSyntax, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(lessThanToken)
            Me._lessThanToken = lessThanToken
            Init(xmlNamespace)
            Me._xmlNamespace = xmlNamespace
            Init(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanToken As InternalSyntax.PunctuationSyntax, xmlNamespace As XmlAttributeSyntax, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(lessThanToken)
            Me._lessThanToken = lessThanToken
            Init(xmlNamespace)
            Me._xmlNamespace = xmlNamespace
            Init(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._lessThanToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._lessThanToken)
          Me._xmlNamespace = DirectCast(reader.ReadValue(), XmlAttributeSyntax)
          Init(Me._xmlNamespace)
          Me._greaterThanToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._greaterThanToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._lessThanToken)
          writer.WriteValue(Me._xmlNamespace)
          writer.WriteValue(Me._greaterThanToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlNamespaceImportsClauseSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property LessThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanToken
            End Get
        End Property

        ''' <summary>
        ''' Identifies the XML namespace alias and URI.
        ''' </summary>
        Friend  ReadOnly Property XmlNamespace As InternalSyntax.XmlAttributeSyntax
            Get
                Return Me._xmlNamespace
            End Get
        End Property

        Friend  ReadOnly Property GreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._greaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._lessThanToken
                Case 1
                    Return Me._xmlNamespace
                Case 2
                    Return Me._greaterThanToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlNamespaceImportsClauseSyntax(kind, newErrors, GetAnnotations, _lessThanToken, _xmlNamespace, _greaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlNamespaceImportsClauseSyntax(kind, GetDiagnostics, annotations, _lessThanToken, _xmlNamespace, _greaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlNamespaceImportsClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Namespace statement, its contents and the End Namespace statement.
    ''' </summary>
    Friend NotInheritable Class NamespaceBlockSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _begin as NamespaceStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _members as SyntaxNode
        Friend ReadOnly _end as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, begin As NamespaceStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, members As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If members IsNot Nothing Then
                Init(members)
                Me._members = members
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As NamespaceStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, members As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If members IsNot Nothing Then
                Init(members)
                Me._members = members
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), NamespaceStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._members = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._members)
          Me._end = DirectCast(reader.ReadValue(), EndBlockStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._members)
          writer.WriteValue(Me._end)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.NamespaceBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The statement that begins the NamespaceBlock.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.NamespaceStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The declarations contained in the namespace statement.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Members As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._members))
            End Get
        End Property

        ''' <summary>
        ''' The End Namespace statement that ends the block.
        ''' </summary>
        Friend  ReadOnly Property [End] As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._members
                Case 3
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new NamespaceBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _members, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new NamespaceBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _members, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitNamespaceBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning statement of a namespace declaration. This node always
    ''' appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
    ''' </summary>
    Friend NotInheritable Class NamespaceStatementSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _namespaceKeyword as KeywordSyntax
        Friend ReadOnly _name as NameSyntax

        Friend Sub New(ByVal kind As SyntaxKind, namespaceKeyword As InternalSyntax.KeywordSyntax, name As NameSyntax)
            MyBase.New(kind)

            Init(namespaceKeyword)
            Me._namespaceKeyword = namespaceKeyword
            Init(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), namespaceKeyword As InternalSyntax.KeywordSyntax, name As NameSyntax)
            MyBase.New(kind, errors, annotations)

            Init(namespaceKeyword)
            Me._namespaceKeyword = namespaceKeyword
            Init(name)
            Me._name = name

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._namespaceKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._namespaceKeyword)
          Me._name = DirectCast(reader.ReadValue(), NameSyntax)
          Init(Me._name)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._namespaceKeyword)
          writer.WriteValue(Me._name)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.NamespaceStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Namespace" keyword.
        ''' </summary>
        Friend  ReadOnly Property NamespaceKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._namespaceKeyword
            End Get
        End Property

        ''' <summary>
        ''' A (possibly dotted) name denoting the namespace being declared.
        ''' </summary>
        Friend  ReadOnly Property Name As InternalSyntax.NameSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._namespaceKeyword
                Case 1
                    Return Me._name
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new NamespaceStatementSyntax(kind, newErrors, GetAnnotations, _namespaceKeyword, _name)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new NamespaceStatementSyntax(kind, GetDiagnostics, annotations, _namespaceKeyword, _name)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitNamespaceStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a declaration of a Class, Interface, Structure, Module, its contents
    ''' and the End statement that ends it.
    ''' </summary>
    Friend MustInherit Class TypeBlockSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _begin as TypeStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _inherits as SyntaxNode
        Friend ReadOnly _implements as SyntaxNode
        Friend ReadOnly _members as SyntaxNode
        Friend ReadOnly _end as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, begin As TypeStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, [inherits] As InternalSyntax.SyntaxNode, [implements] As InternalSyntax.SyntaxNode, members As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If [inherits] IsNot Nothing Then
                Init([inherits])
                Me._inherits = [inherits]
            End If
            If [implements] IsNot Nothing Then
                Init([implements])
                Me._implements = [implements]
            End If
            If members IsNot Nothing Then
                Init(members)
                Me._members = members
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As TypeStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, [inherits] As InternalSyntax.SyntaxNode, [implements] As InternalSyntax.SyntaxNode, members As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If [inherits] IsNot Nothing Then
                Init([inherits])
                Me._inherits = [inherits]
            End If
            If [implements] IsNot Nothing Then
                Init([implements])
                Me._implements = [implements]
            End If
            If members IsNot Nothing Then
                Init(members)
                Me._members = members
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), TypeStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._inherits = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._inherits)
          Me._implements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._implements)
          Me._members = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._members)
          Me._end = DirectCast(reader.ReadValue(), EndBlockStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._inherits)
          writer.WriteValue(Me._implements)
          writer.WriteValue(Me._members)
          writer.WriteValue(Me._end)
        End Sub

        ''' <summary>
        ''' The statement that begins the type or module.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.TypeStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' A list of the Inherits declarations for the type.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property [Inherits] As InternalSyntax.SeparatedSyntaxList(Of InheritsStatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of InheritsStatementSyntax)(New SyntaxList(of InheritsStatementSyntax)(Me._inherits))
            End Get
        End Property

        ''' <summary>
        ''' A list of the Implements declarations for the type.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property [Implements] As InternalSyntax.SeparatedSyntaxList(Of ImplementsStatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of ImplementsStatementSyntax)(New SyntaxList(of ImplementsStatementSyntax)(Me._implements))
            End Get
        End Property

        ''' <summary>
        ''' The declarations contained in the type or module.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Members As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._members))
            End Get
        End Property

        ''' <summary>
        ''' The End XXX statement that ends the block.
        ''' </summary>
        Friend  ReadOnly Property [End] As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents a declaration of Module, its contents and the End statement that
    ''' ends it.
    ''' </summary>
    Friend NotInheritable Class ModuleBlockSyntax
        Inherits TypeBlockSyntax


        Friend Sub New(ByVal kind As SyntaxKind, begin As TypeStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, [inherits] As InternalSyntax.SyntaxNode, [implements] As InternalSyntax.SyntaxNode, members As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, begin, beginTerminator, [inherits], [implements], members, [end])
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As TypeStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, [inherits] As InternalSyntax.SyntaxNode, [implements] As InternalSyntax.SyntaxNode, members As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations, begin, beginTerminator, [inherits], [implements], members, [end])
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ModuleBlockSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._inherits
                Case 3
                    Return Me._implements
                Case 4
                    Return Me._members
                Case 5
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 6
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ModuleBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _inherits, _implements, _members, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ModuleBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _inherits, _implements, _members, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitModuleBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a declaration of a Structure, its contents and the End statement
    ''' that ends it.
    ''' </summary>
    Friend NotInheritable Class StructureBlockSyntax
        Inherits TypeBlockSyntax


        Friend Sub New(ByVal kind As SyntaxKind, begin As TypeStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, [inherits] As InternalSyntax.SyntaxNode, [implements] As InternalSyntax.SyntaxNode, members As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, begin, beginTerminator, [inherits], [implements], members, [end])
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As TypeStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, [inherits] As InternalSyntax.SyntaxNode, [implements] As InternalSyntax.SyntaxNode, members As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations, begin, beginTerminator, [inherits], [implements], members, [end])
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.StructureBlockSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._inherits
                Case 3
                    Return Me._implements
                Case 4
                    Return Me._members
                Case 5
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 6
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new StructureBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _inherits, _implements, _members, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new StructureBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _inherits, _implements, _members, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitStructureBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a declaration of a Interface, its contents and the End statement
    ''' that ends it.
    ''' </summary>
    Friend NotInheritable Class InterfaceBlockSyntax
        Inherits TypeBlockSyntax


        Friend Sub New(ByVal kind As SyntaxKind, begin As TypeStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, [inherits] As InternalSyntax.SyntaxNode, [implements] As InternalSyntax.SyntaxNode, members As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, begin, beginTerminator, [inherits], [implements], members, [end])
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As TypeStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, [inherits] As InternalSyntax.SyntaxNode, [implements] As InternalSyntax.SyntaxNode, members As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations, begin, beginTerminator, [inherits], [implements], members, [end])
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.InterfaceBlockSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._inherits
                Case 3
                    Return Me._implements
                Case 4
                    Return Me._members
                Case 5
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 6
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new InterfaceBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _inherits, _implements, _members, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new InterfaceBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _inherits, _implements, _members, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitInterfaceBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a declaration of a Class its contents and the End statement that
    ''' ends it.
    ''' </summary>
    Friend NotInheritable Class ClassBlockSyntax
        Inherits TypeBlockSyntax


        Friend Sub New(ByVal kind As SyntaxKind, begin As TypeStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, [inherits] As InternalSyntax.SyntaxNode, [implements] As InternalSyntax.SyntaxNode, members As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, begin, beginTerminator, [inherits], [implements], members, [end])
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As TypeStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, [inherits] As InternalSyntax.SyntaxNode, [implements] As InternalSyntax.SyntaxNode, members As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations, begin, beginTerminator, [inherits], [implements], members, [end])
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ClassBlockSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._inherits
                Case 3
                    Return Me._implements
                Case 4
                    Return Me._members
                Case 5
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 6
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ClassBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _inherits, _implements, _members, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ClassBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _inherits, _implements, _members, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitClassBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a declaration of an Enum, its contents and the End Enum statement
    ''' that ends it.
    ''' </summary>
    Friend NotInheritable Class EnumBlockSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _begin as EnumStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _members as SyntaxNode
        Friend ReadOnly _end as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, begin As EnumStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, members As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If members IsNot Nothing Then
                Init(members)
                Me._members = members
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As EnumStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, members As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If members IsNot Nothing Then
                Init(members)
                Me._members = members
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), EnumStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._members = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._members)
          Me._end = DirectCast(reader.ReadValue(), EndBlockStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._members)
          writer.WriteValue(Me._end)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.EnumBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The statement that begins the type or module.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.EnumStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The declarations contained in the enumeration.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Members As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._members))
            End Get
        End Property

        ''' <summary>
        ''' The End XXX statement that ends the block.
        ''' </summary>
        Friend  ReadOnly Property [End] As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._members
                Case 3
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new EnumBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _members, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new EnumBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _members, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitEnumBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an Inherits or Implements statement in a Class, Structure or
    ''' Interface.
    ''' </summary>
    Friend MustInherit Class InheritsOrImplementsStatementSyntax
        Inherits DeclarationStatementSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' Represents an Inherits statement in a Class, Structure or Interface.
    ''' </summary>
    Friend NotInheritable Class InheritsStatementSyntax
        Inherits InheritsOrImplementsStatementSyntax

        Friend ReadOnly _inheritsKeyword as KeywordSyntax
        Friend ReadOnly _types as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, inheritsKeyword As InternalSyntax.KeywordSyntax, types As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(inheritsKeyword)
            Me._inheritsKeyword = inheritsKeyword
            If types IsNot Nothing Then
                Init(types)
                Me._types = types
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), inheritsKeyword As InternalSyntax.KeywordSyntax, types As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(inheritsKeyword)
            Me._inheritsKeyword = inheritsKeyword
            If types IsNot Nothing Then
                Init(types)
                Me._types = types
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._inheritsKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._inheritsKeyword)
          Me._types = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._types)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._inheritsKeyword)
          writer.WriteValue(Me._types)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.InheritsStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Inherits" keyword.
        ''' </summary>
        Friend  ReadOnly Property InheritsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._inheritsKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of the types being inherited.
        ''' </summary>
        Friend  ReadOnly Property Types As InternalSyntax.SeparatedSyntaxList(Of TypeSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of TypeSyntax)(New SyntaxList(of TypeSyntax)(Me._types))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._inheritsKeyword
                Case 1
                    Return Me._types
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new InheritsStatementSyntax(kind, newErrors, GetAnnotations, _inheritsKeyword, _types)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new InheritsStatementSyntax(kind, GetDiagnostics, annotations, _inheritsKeyword, _types)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitInheritsStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an Implements statement in a Class or Structure.
    ''' </summary>
    Friend NotInheritable Class ImplementsStatementSyntax
        Inherits InheritsOrImplementsStatementSyntax

        Friend ReadOnly _implementsKeyword as KeywordSyntax
        Friend ReadOnly _types as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, implementsKeyword As InternalSyntax.KeywordSyntax, types As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(implementsKeyword)
            Me._implementsKeyword = implementsKeyword
            If types IsNot Nothing Then
                Init(types)
                Me._types = types
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), implementsKeyword As InternalSyntax.KeywordSyntax, types As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(implementsKeyword)
            Me._implementsKeyword = implementsKeyword
            If types IsNot Nothing Then
                Init(types)
                Me._types = types
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._implementsKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._implementsKeyword)
          Me._types = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._types)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._implementsKeyword)
          writer.WriteValue(Me._types)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ImplementsStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Implements" keyword.
        ''' </summary>
        Friend  ReadOnly Property ImplementsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._implementsKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of the types being implemented.
        ''' </summary>
        Friend  ReadOnly Property Types As InternalSyntax.SeparatedSyntaxList(Of TypeSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of TypeSyntax)(New SyntaxList(of TypeSyntax)(Me._types))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._implementsKeyword
                Case 1
                    Return Me._types
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ImplementsStatementSyntax(kind, newErrors, GetAnnotations, _implementsKeyword, _types)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ImplementsStatementSyntax(kind, GetDiagnostics, annotations, _implementsKeyword, _types)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitImplementsStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Abstract class for the beginning statement of a Module, Class, Interface or
    ''' Structure declaration. This node always appears as the Begin of a TypeBlock
    ''' with Kind=ModuleDeclarationBlock, ClassDeclarationBlock,
    ''' InterfaceDeclarationBlock or StructureDeclarationBlock.
    ''' </summary>
    Friend MustInherit Class TypeStatementSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _attributes as SyntaxNode
        Friend ReadOnly _modifiers as SyntaxNode
        Friend ReadOnly _keyword as KeywordSyntax
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _typeParameterList as TypeParameterListSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            If modifiers IsNot Nothing Then
                Init(modifiers)
                Me._modifiers = modifiers
            End If
            Init(keyword)
            Me._keyword = keyword
            Init(identifier)
            Me._identifier = identifier
            If typeParameterList IsNot Nothing Then
                Init(typeParameterList)
                Me._typeParameterList = typeParameterList
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, errors, annotations)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            If modifiers IsNot Nothing Then
                Init(modifiers)
                Me._modifiers = modifiers
            End If
            Init(keyword)
            Me._keyword = keyword
            Init(identifier)
            Me._identifier = identifier
            If typeParameterList IsNot Nothing Then
                Init(typeParameterList)
                Me._typeParameterList = typeParameterList
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._attributes = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._attributes)
          Me._modifiers = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._modifiers)
          Me._keyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._keyword)
          Me._identifier = DirectCast(reader.ReadValue(), IdentifierTokenSyntax)
          Init(Me._identifier)
          Me._typeParameterList = DirectCast(reader.ReadValue(), TypeParameterListSyntax)
          Init(Me._typeParameterList)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._attributes)
          writer.WriteValue(Me._modifiers)
          writer.WriteValue(Me._keyword)
          writer.WriteValue(Me._identifier)
          writer.WriteValue(Me._typeParameterList)
        End Sub

        ''' <summary>
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Attributes As InternalSyntax.SyntaxList(Of AttributeBlockSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of AttributeBlockSyntax)(Me._attributes)
            End Get
        End Property

        ''' <summary>
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Modifiers As InternalSyntax.SyntaxList(Of KeywordSyntax)
            Get
                Return New InternalSyntax.SyntaxList(of KeywordSyntax)(Me._modifiers)
            End Get
        End Property

        ''' <summary>
        ''' The "Module", "Class", "Interface" or "Structure" keyword.
        ''' </summary>
        Friend  ReadOnly Property Keyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._keyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the type being declared.
        ''' </summary>
        Friend  ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' If present, a type parameter list with generic parameters for this type. If no
        ''' generic parameters were present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property TypeParameterList As InternalSyntax.TypeParameterListSyntax
            Get
                Return Me._typeParameterList
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents the beginning statement of a Module declaration. This node always
    ''' appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
    ''' </summary>
    Friend NotInheritable Class ModuleStatementSyntax
        Inherits TypeStatementSyntax


        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, attributes, modifiers, keyword, identifier, typeParameterList)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, errors, annotations, attributes, modifiers, keyword, identifier, typeParameterList)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ModuleStatementSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._keyword
                Case 3
                    Return Me._identifier
                Case 4
                    Return Me._typeParameterList
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ModuleStatementSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _keyword, _identifier, _typeParameterList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ModuleStatementSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _keyword, _identifier, _typeParameterList)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitModuleStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning statement of a Structure declaration. This node always
    ''' appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
    ''' </summary>
    Friend NotInheritable Class StructureStatementSyntax
        Inherits TypeStatementSyntax


        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, attributes, modifiers, keyword, identifier, typeParameterList)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, errors, annotations, attributes, modifiers, keyword, identifier, typeParameterList)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.StructureStatementSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._keyword
                Case 3
                    Return Me._identifier
                Case 4
                    Return Me._typeParameterList
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new StructureStatementSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _keyword, _identifier, _typeParameterList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new StructureStatementSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _keyword, _identifier, _typeParameterList)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitStructureStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning statement of a Interface declaration. This node always
    ''' appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
    ''' </summary>
    Friend NotInheritable Class InterfaceStatementSyntax
        Inherits TypeStatementSyntax


        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, attributes, modifiers, keyword, identifier, typeParameterList)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, errors, annotations, attributes, modifiers, keyword, identifier, typeParameterList)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.InterfaceStatementSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._keyword
                Case 3
                    Return Me._identifier
                Case 4
                    Return Me._typeParameterList
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new InterfaceStatementSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _keyword, _identifier, _typeParameterList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new InterfaceStatementSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _keyword, _identifier, _typeParameterList)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitInterfaceStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning statement of a Class declaration. This node always
    ''' appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
    ''' </summary>
    Friend NotInheritable Class ClassStatementSyntax
        Inherits TypeStatementSyntax


        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, attributes, modifiers, keyword, identifier, typeParameterList)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, errors, annotations, attributes, modifiers, keyword, identifier, typeParameterList)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ClassStatementSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._keyword
                Case 3
                    Return Me._identifier
                Case 4
                    Return Me._typeParameterList
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ClassStatementSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _keyword, _identifier, _typeParameterList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ClassStatementSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _keyword, _identifier, _typeParameterList)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitClassStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning statement of an Enum declaration. This node always
    ''' appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
    ''' </summary>
    Friend NotInheritable Class EnumStatementSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _attributes as SyntaxNode
        Friend ReadOnly _modifiers as SyntaxNode
        Friend ReadOnly _enumKeyword as KeywordSyntax
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _underlyingType as AsClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, enumKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, underlyingType As AsClauseSyntax)
            MyBase.New(kind)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            If modifiers IsNot Nothing Then
                Init(modifiers)
                Me._modifiers = modifiers
            End If
            Init(enumKeyword)
            Me._enumKeyword = enumKeyword
            Init(identifier)
            Me._identifier = identifier
            If underlyingType IsNot Nothing Then
                Init(underlyingType)
                Me._underlyingType = underlyingType
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, enumKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, underlyingType As AsClauseSyntax)
            MyBase.New(kind, errors, annotations)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            If modifiers IsNot Nothing Then
                Init(modifiers)
                Me._modifiers = modifiers
            End If
            Init(enumKeyword)
            Me._enumKeyword = enumKeyword
            Init(identifier)
            Me._identifier = identifier
            If underlyingType IsNot Nothing Then
                Init(underlyingType)
                Me._underlyingType = underlyingType
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._attributes = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._attributes)
          Me._modifiers = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._modifiers)
          Me._enumKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._enumKeyword)
          Me._identifier = DirectCast(reader.ReadValue(), IdentifierTokenSyntax)
          Init(Me._identifier)
          Me._underlyingType = DirectCast(reader.ReadValue(), AsClauseSyntax)
          Init(Me._underlyingType)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._attributes)
          writer.WriteValue(Me._modifiers)
          writer.WriteValue(Me._enumKeyword)
          writer.WriteValue(Me._identifier)
          writer.WriteValue(Me._underlyingType)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.EnumStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Attributes As InternalSyntax.SyntaxList(Of AttributeBlockSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of AttributeBlockSyntax)(Me._attributes)
            End Get
        End Property

        ''' <summary>
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Modifiers As InternalSyntax.SyntaxList(Of KeywordSyntax)
            Get
                Return New InternalSyntax.SyntaxList(of KeywordSyntax)(Me._modifiers)
            End Get
        End Property

        ''' <summary>
        ''' The "Enum" keyword.
        ''' </summary>
        Friend  ReadOnly Property EnumKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._enumKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the enum being declared.
        ''' </summary>
        Friend  ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' Optional "As XXX" clause describing the underlying type of the enumeration. If
        ''' no As clause was specified, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property UnderlyingType As InternalSyntax.AsClauseSyntax
            Get
                Return Me._underlyingType
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._enumKeyword
                Case 3
                    Return Me._identifier
                Case 4
                    Return Me._underlyingType
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new EnumStatementSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _enumKeyword, _identifier, _underlyingType)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new EnumStatementSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _enumKeyword, _identifier, _underlyingType)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitEnumStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the type parameter list in a declaration.
    ''' </summary>
    Friend NotInheritable Class TypeParameterListSyntax
        Inherits SyntaxNode

        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _ofKeyword as KeywordSyntax
        Friend ReadOnly _parameters as SyntaxNode
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, ofKeyword As InternalSyntax.KeywordSyntax, parameters As InternalSyntax.SyntaxNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(ofKeyword)
            Me._ofKeyword = ofKeyword
            If parameters IsNot Nothing Then
                Init(parameters)
                Me._parameters = parameters
            End If
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openParenToken As InternalSyntax.PunctuationSyntax, ofKeyword As InternalSyntax.KeywordSyntax, parameters As InternalSyntax.SyntaxNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(ofKeyword)
            Me._ofKeyword = ofKeyword
            If parameters IsNot Nothing Then
                Init(parameters)
                Me._parameters = parameters
            End If
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._openParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openParenToken)
          Me._ofKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._ofKeyword)
          Me._parameters = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._parameters)
          Me._closeParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeParenToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._openParenToken)
          writer.WriteValue(Me._ofKeyword)
          writer.WriteValue(Me._parameters)
          writer.WriteValue(Me._closeParenToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.TypeParameterListSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend  ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The "Of" keyword.
        ''' </summary>
        Friend  ReadOnly Property OfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ofKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of the type parameters. There must be at least one type parameter in the
        ''' list.
        ''' </summary>
        Friend  ReadOnly Property Parameters As InternalSyntax.SeparatedSyntaxList(Of TypeParameterSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of TypeParameterSyntax)(New SyntaxList(of TypeParameterSyntax)(Me._parameters))
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend  ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._openParenToken
                Case 1
                    Return Me._ofKeyword
                Case 2
                    Return Me._parameters
                Case 3
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new TypeParameterListSyntax(kind, newErrors, GetAnnotations, _openParenToken, _ofKeyword, _parameters, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new TypeParameterListSyntax(kind, GetDiagnostics, annotations, _openParenToken, _ofKeyword, _parameters, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitTypeParameterList(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a type parameter on a generic type declaration.
    ''' </summary>
    Friend NotInheritable Class TypeParameterSyntax
        Inherits SyntaxNode

        Friend ReadOnly _varianceKeyword as KeywordSyntax
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _typeParameterConstraintClause as TypeParameterConstraintClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, varianceKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterConstraintClause As TypeParameterConstraintClauseSyntax)
            MyBase.New(kind)

            If varianceKeyword IsNot Nothing Then
                Init(varianceKeyword)
                Me._varianceKeyword = varianceKeyword
            End If
            Init(identifier)
            Me._identifier = identifier
            If typeParameterConstraintClause IsNot Nothing Then
                Init(typeParameterConstraintClause)
                Me._typeParameterConstraintClause = typeParameterConstraintClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), varianceKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterConstraintClause As TypeParameterConstraintClauseSyntax)
            MyBase.New(kind, errors, annotations)

            If varianceKeyword IsNot Nothing Then
                Init(varianceKeyword)
                Me._varianceKeyword = varianceKeyword
            End If
            Init(identifier)
            Me._identifier = identifier
            If typeParameterConstraintClause IsNot Nothing Then
                Init(typeParameterConstraintClause)
                Me._typeParameterConstraintClause = typeParameterConstraintClause
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._varianceKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._varianceKeyword)
          Me._identifier = DirectCast(reader.ReadValue(), IdentifierTokenSyntax)
          Init(Me._identifier)
          Me._typeParameterConstraintClause = DirectCast(reader.ReadValue(), TypeParameterConstraintClauseSyntax)
          Init(Me._typeParameterConstraintClause)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._varianceKeyword)
          writer.WriteValue(Me._identifier)
          writer.WriteValue(Me._typeParameterConstraintClause)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.TypeParameterSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' Represents the "In" or "Out" variance keyword on a type parameter, if present.
        ''' If no variance modifier was present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property VarianceKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._varianceKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the type parameter
        ''' </summary>
        Friend  ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' The "As" keyword, if any type constraints were supplied. If no type constraints
        ''' were supplied, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property TypeParameterConstraintClause As InternalSyntax.TypeParameterConstraintClauseSyntax
            Get
                Return Me._typeParameterConstraintClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._varianceKeyword
                Case 1
                    Return Me._identifier
                Case 2
                    Return Me._typeParameterConstraintClause
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new TypeParameterSyntax(kind, newErrors, GetAnnotations, _varianceKeyword, _identifier, _typeParameterConstraintClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new TypeParameterSyntax(kind, GetDiagnostics, annotations, _varianceKeyword, _identifier, _typeParameterConstraintClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitTypeParameter(Me)
        End Function

    End Class

    ''' <summary>
    ''' An abstract node class that is the parent of classes that describe type
    ''' parameter constraint clauses.
    ''' </summary>
    Friend MustInherit Class TypeParameterConstraintClauseSyntax
        Inherits SyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' One of the type parameter constraints clauses. This represents a constraint
    ''' clause in the form of "As Constraint".
    ''' </summary>
    Friend NotInheritable Class TypeParameterSingleConstraintClauseSyntax
        Inherits TypeParameterConstraintClauseSyntax

        Friend ReadOnly _asKeyword as KeywordSyntax
        Friend ReadOnly _constraint as ConstraintSyntax

        Friend Sub New(ByVal kind As SyntaxKind, asKeyword As InternalSyntax.KeywordSyntax, constraint As ConstraintSyntax)
            MyBase.New(kind)

            Init(asKeyword)
            Me._asKeyword = asKeyword
            Init(constraint)
            Me._constraint = constraint

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), asKeyword As InternalSyntax.KeywordSyntax, constraint As ConstraintSyntax)
            MyBase.New(kind, errors, annotations)

            Init(asKeyword)
            Me._asKeyword = asKeyword
            Init(constraint)
            Me._constraint = constraint

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._asKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._asKeyword)
          Me._constraint = DirectCast(reader.ReadValue(), ConstraintSyntax)
          Init(Me._constraint)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._asKeyword)
          writer.WriteValue(Me._constraint)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.TypeParameterSingleConstraintClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "As" keyword, if any type constraints were supplied. If no type constraints
        ''' were supplied, Nothing is returned.
        ''' </summary>
        Friend  ReadOnly Property AsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._asKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of the supplied constraints. If no constraints were supplied, Nothing is
        ''' returned.
        ''' </summary>
        Friend  ReadOnly Property Constraint As InternalSyntax.ConstraintSyntax
            Get
                Return Me._constraint
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._asKeyword
                Case 1
                    Return Me._constraint
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new TypeParameterSingleConstraintClauseSyntax(kind, newErrors, GetAnnotations, _asKeyword, _constraint)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new TypeParameterSingleConstraintClauseSyntax(kind, GetDiagnostics, annotations, _asKeyword, _constraint)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitTypeParameterSingleConstraintClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' One of the type parameter constraints clauses. This represents a constraint
    ''' clause in the form of "As { Constraints }".
    ''' </summary>
    Friend NotInheritable Class TypeParameterMultipleConstraintClauseSyntax
        Inherits TypeParameterConstraintClauseSyntax

        Friend ReadOnly _asKeyword as KeywordSyntax
        Friend ReadOnly _openBraceToken as PunctuationSyntax
        Friend ReadOnly _constraints as SyntaxNode
        Friend ReadOnly _closeBraceToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, asKeyword As InternalSyntax.KeywordSyntax, openBraceToken As InternalSyntax.PunctuationSyntax, constraints As InternalSyntax.SyntaxNode, closeBraceToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(asKeyword)
            Me._asKeyword = asKeyword
            Init(openBraceToken)
            Me._openBraceToken = openBraceToken
            If constraints IsNot Nothing Then
                Init(constraints)
                Me._constraints = constraints
            End If
            Init(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), asKeyword As InternalSyntax.KeywordSyntax, openBraceToken As InternalSyntax.PunctuationSyntax, constraints As InternalSyntax.SyntaxNode, closeBraceToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(asKeyword)
            Me._asKeyword = asKeyword
            Init(openBraceToken)
            Me._openBraceToken = openBraceToken
            If constraints IsNot Nothing Then
                Init(constraints)
                Me._constraints = constraints
            End If
            Init(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._asKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._asKeyword)
          Me._openBraceToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openBraceToken)
          Me._constraints = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._constraints)
          Me._closeBraceToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeBraceToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._asKeyword)
          writer.WriteValue(Me._openBraceToken)
          writer.WriteValue(Me._constraints)
          writer.WriteValue(Me._closeBraceToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.TypeParameterMultipleConstraintClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "As" keyword.
        ''' </summary>
        Friend  ReadOnly Property AsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._asKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "{" token.
        ''' </summary>
        Friend  ReadOnly Property OpenBraceToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openBraceToken
            End Get
        End Property

        ''' <summary>
        ''' A list of the supplied constraints. If no constraints were supplied, an empty
        ''' list is returned.
        ''' </summary>
        Friend  ReadOnly Property Constraints As InternalSyntax.SeparatedSyntaxList(Of ConstraintSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of ConstraintSyntax)(New SyntaxList(of ConstraintSyntax)(Me._constraints))
            End Get
        End Property

        ''' <summary>
        ''' The "}" token.
        ''' </summary>
        Friend  ReadOnly Property CloseBraceToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeBraceToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._asKeyword
                Case 1
                    Return Me._openBraceToken
                Case 2
                    Return Me._constraints
                Case 3
                    Return Me._closeBraceToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new TypeParameterMultipleConstraintClauseSyntax(kind, newErrors, GetAnnotations, _asKeyword, _openBraceToken, _constraints, _closeBraceToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new TypeParameterMultipleConstraintClauseSyntax(kind, GetDiagnostics, annotations, _asKeyword, _openBraceToken, _constraints, _closeBraceToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitTypeParameterMultipleConstraintClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' An abstract node class that is the parent of classes that describe type
    ''' parameter constraints.
    ''' </summary>
    Friend MustInherit Class ConstraintSyntax
        Inherits SyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' One of the special type parameter constraints: New, Class or Structure. Which
    ''' kind of special constraint it is can be obtained from the Kind property and is
    ''' one of: NewConstraint, ReferenceConstraint or ValueConstraint.
    ''' </summary>
    Friend NotInheritable Class SpecialConstraintSyntax
        Inherits ConstraintSyntax

        Friend ReadOnly _constraintKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, constraintKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(constraintKeyword)
            Me._constraintKeyword = constraintKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), constraintKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(constraintKeyword)
            Me._constraintKeyword = constraintKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._constraintKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._constraintKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._constraintKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.SpecialConstraintSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "New", "Class" or "Structure" keyword that denotes the kind of special
        ''' constraint.
        ''' </summary>
        Friend  ReadOnly Property ConstraintKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._constraintKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._constraintKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new SpecialConstraintSyntax(kind, newErrors, GetAnnotations, _constraintKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new SpecialConstraintSyntax(kind, GetDiagnostics, annotations, _constraintKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitSpecialConstraint(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a type parameter constraint that is a type.
    ''' </summary>
    Friend NotInheritable Class TypeConstraintSyntax
        Inherits ConstraintSyntax

        Friend ReadOnly _type as TypeSyntax

        Friend Sub New(ByVal kind As SyntaxKind, type As TypeSyntax)
            MyBase.New(kind)

            Init(type)
            Me._type = type

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), type As TypeSyntax)
            MyBase.New(kind, errors, annotations)

            Init(type)
            Me._type = type

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._type = DirectCast(reader.ReadValue(), TypeSyntax)
          Init(Me._type)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._type)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.TypeConstraintSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The type describing the constraint.
        ''' </summary>
        Friend  ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._type
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new TypeConstraintSyntax(kind, newErrors, GetAnnotations, _type)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new TypeConstraintSyntax(kind, GetDiagnostics, annotations, _type)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitTypeConstraint(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a name and value in an EnumDeclarationBlock.
    ''' </summary>
    Friend NotInheritable Class EnumMemberDeclarationSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _attributes as SyntaxNode
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _initializer as EqualsValueSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, identifier As InternalSyntax.IdentifierTokenSyntax, initializer As EqualsValueSyntax)
            MyBase.New(kind)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            Init(identifier)
            Me._identifier = identifier
            If initializer IsNot Nothing Then
                Init(initializer)
                Me._initializer = initializer
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, identifier As InternalSyntax.IdentifierTokenSyntax, initializer As EqualsValueSyntax)
            MyBase.New(kind, errors, annotations)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            Init(identifier)
            Me._identifier = identifier
            If initializer IsNot Nothing Then
                Init(initializer)
                Me._initializer = initializer
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._attributes = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._attributes)
          Me._identifier = DirectCast(reader.ReadValue(), IdentifierTokenSyntax)
          Init(Me._identifier)
          Me._initializer = DirectCast(reader.ReadValue(), EqualsValueSyntax)
          Init(Me._initializer)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._attributes)
          writer.WriteValue(Me._identifier)
          writer.WriteValue(Me._initializer)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.EnumMemberDeclarationSyntax(Me, parent, startLocation)
        End Function

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Attributes As InternalSyntax.SyntaxList(Of AttributeBlockSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of AttributeBlockSyntax)(Me._attributes)
            End Get
        End Property

        Friend  ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' An optional value for the enum member.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Initializer As InternalSyntax.EqualsValueSyntax
            Get
                Return Me._initializer
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._identifier
                Case 2
                    Return Me._initializer
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new EnumMemberDeclarationSyntax(kind, newErrors, GetAnnotations, _attributes, _identifier, _initializer)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new EnumMemberDeclarationSyntax(kind, GetDiagnostics, annotations, _attributes, _identifier, _initializer)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitEnumMemberDeclaration(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a block member declaration: A declaration that has a beginning
    ''' declaration, a body of executable statements and an end statement. Examples
    ''' include methods, constructors, operators, property accessors and custom event
    ''' accessors.
    ''' </summary>
    Friend NotInheritable Class MethodBlockSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _begin as MethodBaseSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _statements as SyntaxNode
        Friend ReadOnly _end as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, begin As MethodBaseSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As MethodBaseSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), MethodBaseSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
          Me._end = DirectCast(reader.ReadValue(), EndBlockStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._statements)
          writer.WriteValue(Me._end)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.MethodBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The declaration that begins the block.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.MethodBaseSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        ''' <summary>
        ''' The End XXX statement that ends the block declaration.
        ''' </summary>
        Friend  ReadOnly Property [End] As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._statements
                Case 3
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new MethodBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new MethodBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitMethodBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a block property declaration: A declaration that has a beginning
    ''' declaration, some get or set accessor blocks and an end statement.
    ''' </summary>
    Friend NotInheritable Class PropertyBlockSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _begin as PropertyStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _accessors as SyntaxNode
        Friend ReadOnly _end as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, begin As PropertyStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, accessors As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If accessors IsNot Nothing Then
                Init(accessors)
                Me._accessors = accessors
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As PropertyStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, accessors As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If accessors IsNot Nothing Then
                Init(accessors)
                Me._accessors = accessors
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), PropertyStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._accessors = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._accessors)
          Me._end = DirectCast(reader.ReadValue(), EndBlockStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._accessors)
          writer.WriteValue(Me._end)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.PropertyBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The property declaration that begins the block.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.PropertyStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The accessor blocks contained in the property, between the Property and the End
        ''' Property statements.
        ''' </summary>
        Friend  ReadOnly Property Accessors As InternalSyntax.SeparatedSyntaxList(Of MethodBlockSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of MethodBlockSyntax)(New SyntaxList(of MethodBlockSyntax)(Me._accessors))
            End Get
        End Property

        ''' <summary>
        ''' The End Property statement that ends the block.
        ''' </summary>
        Friend  ReadOnly Property [End] As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._accessors
                Case 3
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new PropertyBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _accessors, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new PropertyBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _accessors, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitPropertyBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a custom event declaration: A declaration that has a beginning event
    ''' declaration, some accessor blocks and an end statement.
    ''' </summary>
    Friend NotInheritable Class EventBlockSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _begin as EventStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _accessors as SyntaxNode
        Friend ReadOnly _end as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, begin As EventStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, accessors As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If accessors IsNot Nothing Then
                Init(accessors)
                Me._accessors = accessors
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As EventStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, accessors As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If accessors IsNot Nothing Then
                Init(accessors)
                Me._accessors = accessors
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), EventStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._accessors = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._accessors)
          Me._end = DirectCast(reader.ReadValue(), EndBlockStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._accessors)
          writer.WriteValue(Me._end)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.EventBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The event declaration that begins the block.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.EventStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The accessor blocks contained in the custom event declaration, between the
        ''' Event statement and the End Event statement.
        ''' </summary>
        Friend  ReadOnly Property Accessors As InternalSyntax.SeparatedSyntaxList(Of MethodBlockSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of MethodBlockSyntax)(New SyntaxList(of MethodBlockSyntax)(Me._accessors))
            End Get
        End Property

        ''' <summary>
        ''' The End Event statement that ends the block.
        ''' </summary>
        Friend  ReadOnly Property [End] As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._accessors
                Case 3
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new EventBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _accessors, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new EventBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _accessors, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitEventBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' An abstract node class that is the parent for declarations that are
    ''' "method-like"; i.e., that have a parameter list and return type. This includes
    ''' methods, constructors, properties, events, operators, declares, delegates,
    ''' property accessors and custom event accessors.
    ''' </summary>
    Friend MustInherit Class MethodBaseSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _attributes as SyntaxNode
        Friend ReadOnly _modifiers as SyntaxNode
        Friend ReadOnly _keyword as KeywordSyntax
        Friend ReadOnly _parameterList as ParameterListSyntax
        Friend ReadOnly _asClause as AsClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax)
            MyBase.New(kind)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            If modifiers IsNot Nothing Then
                Init(modifiers)
                Me._modifiers = modifiers
            End If
            Init(keyword)
            Me._keyword = keyword
            If parameterList IsNot Nothing Then
                Init(parameterList)
                Me._parameterList = parameterList
            End If
            If asClause IsNot Nothing Then
                Init(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax)
            MyBase.New(kind, errors, annotations)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            If modifiers IsNot Nothing Then
                Init(modifiers)
                Me._modifiers = modifiers
            End If
            Init(keyword)
            Me._keyword = keyword
            If parameterList IsNot Nothing Then
                Init(parameterList)
                Me._parameterList = parameterList
            End If
            If asClause IsNot Nothing Then
                Init(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._attributes = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._attributes)
          Me._modifiers = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._modifiers)
          Me._keyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._keyword)
          Me._parameterList = DirectCast(reader.ReadValue(), ParameterListSyntax)
          Init(Me._parameterList)
          Me._asClause = DirectCast(reader.ReadValue(), AsClauseSyntax)
          Init(Me._asClause)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._attributes)
          writer.WriteValue(Me._modifiers)
          writer.WriteValue(Me._keyword)
          writer.WriteValue(Me._parameterList)
          writer.WriteValue(Me._asClause)
        End Sub

        ''' <summary>
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Attributes As InternalSyntax.SyntaxList(Of AttributeBlockSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of AttributeBlockSyntax)(Me._attributes)
            End Get
        End Property

        ''' <summary>
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Modifiers As InternalSyntax.SyntaxList(Of KeywordSyntax)
            Get
                Return New InternalSyntax.SyntaxList(of KeywordSyntax)(Me._modifiers)
            End Get
        End Property

        ''' <summary>
        ''' The keyword that introduces this method declaration. One of "Sub", "Function",
        ''' "Operator", "Event", "Property", "Get", "Set", "AddHandler", "RemoveHandler" or
        ''' "RaiseEvent".
        ''' </summary>
        Friend  ReadOnly Property Keyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._keyword
            End Get
        End Property

        ''' <summary>
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ParameterList As InternalSyntax.ParameterListSyntax
            Get
                Return Me._parameterList
            End Get
        End Property

        ''' <summary>
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property AsClause As InternalSyntax.AsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents the parameter list in a method declaration.
    ''' </summary>
    Friend NotInheritable Class ParameterListSyntax
        Inherits SyntaxNode

        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _parameters as SyntaxNode
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, parameters As InternalSyntax.SyntaxNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(openParenToken)
            Me._openParenToken = openParenToken
            If parameters IsNot Nothing Then
                Init(parameters)
                Me._parameters = parameters
            End If
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openParenToken As InternalSyntax.PunctuationSyntax, parameters As InternalSyntax.SyntaxNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(openParenToken)
            Me._openParenToken = openParenToken
            If parameters IsNot Nothing Then
                Init(parameters)
                Me._parameters = parameters
            End If
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._openParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openParenToken)
          Me._parameters = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._parameters)
          Me._closeParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeParenToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._openParenToken)
          writer.WriteValue(Me._parameters)
          writer.WriteValue(Me._closeParenToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ParameterListSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "(" token that introduces the parameter list. If no parameter list was
        ''' present, Nothing is returned.
        ''' </summary>
        Friend  ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The list of parameters. If no parameter list was present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Parameters As InternalSyntax.SeparatedSyntaxList(Of ParameterSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of ParameterSyntax)(New SyntaxList(of ParameterSyntax)(Me._parameters))
            End Get
        End Property

        ''' <summary>
        ''' The ")" token that concludes the parameter list. If no parameter list was
        ''' present, Nothing is returned.
        ''' </summary>
        Friend  ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._openParenToken
                Case 1
                    Return Me._parameters
                Case 2
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ParameterListSyntax(kind, newErrors, GetAnnotations, _openParenToken, _parameters, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ParameterListSyntax(kind, GetDiagnostics, annotations, _openParenToken, _parameters, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitParameterList(Me)
        End Function

    End Class

    ''' <summary>
    ''' The statement that declares a Sub or Function. If this method has a body, this
    ''' statement will be the Begin of a BlockStatement with
    ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
    ''' that BlockStatement.
    ''' </summary>
    Friend NotInheritable Class MethodStatementSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _typeParameterList as TypeParameterListSyntax
        Friend ReadOnly _handlesClause as HandlesClauseSyntax
        Friend ReadOnly _implementsClause as ImplementsClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, handlesClause As HandlesClauseSyntax, implementsClause As ImplementsClauseSyntax)
            MyBase.New(kind, attributes, modifiers, keyword, parameterList, asClause)

            Init(identifier)
            Me._identifier = identifier
            If typeParameterList IsNot Nothing Then
                Init(typeParameterList)
                Me._typeParameterList = typeParameterList
            End If
            If handlesClause IsNot Nothing Then
                Init(handlesClause)
                Me._handlesClause = handlesClause
            End If
            If implementsClause IsNot Nothing Then
                Init(implementsClause)
                Me._implementsClause = implementsClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, handlesClause As HandlesClauseSyntax, implementsClause As ImplementsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributes, modifiers, keyword, parameterList, asClause)

            Init(identifier)
            Me._identifier = identifier
            If typeParameterList IsNot Nothing Then
                Init(typeParameterList)
                Me._typeParameterList = typeParameterList
            End If
            If handlesClause IsNot Nothing Then
                Init(handlesClause)
                Me._handlesClause = handlesClause
            End If
            If implementsClause IsNot Nothing Then
                Init(implementsClause)
                Me._implementsClause = implementsClause
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._identifier = DirectCast(reader.ReadValue(), IdentifierTokenSyntax)
          Init(Me._identifier)
          Me._typeParameterList = DirectCast(reader.ReadValue(), TypeParameterListSyntax)
          Init(Me._typeParameterList)
          Me._handlesClause = DirectCast(reader.ReadValue(), HandlesClauseSyntax)
          Init(Me._handlesClause)
          Me._implementsClause = DirectCast(reader.ReadValue(), ImplementsClauseSyntax)
          Init(Me._implementsClause)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._identifier)
          writer.WriteValue(Me._typeParameterList)
          writer.WriteValue(Me._handlesClause)
          writer.WriteValue(Me._implementsClause)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.MethodStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The name of the method being declared.
        ''' </summary>
        Friend  ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' If present, a type parameter list with generic type parameters for this method.
        ''' If no generic type parameters were present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property TypeParameterList As InternalSyntax.TypeParameterListSyntax
            Get
                Return Me._typeParameterList
            End Get
        End Property

        ''' <summary>
        ''' If present, a Handles clause indicated the events that this method handles.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property HandlesClause As InternalSyntax.HandlesClauseSyntax
            Get
                Return Me._handlesClause
            End Get
        End Property

        ''' <summary>
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ImplementsClause As InternalSyntax.ImplementsClauseSyntax
            Get
                Return Me._implementsClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._keyword
                Case 3
                    Return Me._identifier
                Case 4
                    Return Me._typeParameterList
                Case 5
                    Return Me._parameterList
                Case 6
                    Return Me._asClause
                Case 7
                    Return Me._handlesClause
                Case 8
                    Return Me._implementsClause
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 9
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new MethodStatementSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _keyword, _identifier, _typeParameterList, _parameterList, _asClause, _handlesClause, _implementsClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new MethodStatementSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _keyword, _identifier, _typeParameterList, _parameterList, _asClause, _handlesClause, _implementsClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitMethodStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' A statement that declares a constructor. This statement will be the Begin of a
    ''' BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
    ''' will be the Body of that BlockStatement.
    ''' </summary>
    Friend NotInheritable Class ConstructorStatementSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _newKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, newKeyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax)
            MyBase.New(kind, attributes, modifiers, keyword, parameterList, asClause)

            Init(newKeyword)
            Me._newKeyword = newKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, newKeyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributes, modifiers, keyword, parameterList, asClause)

            Init(newKeyword)
            Me._newKeyword = newKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._newKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._newKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._newKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ConstructorStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "New" keyword in the constructor declaration.
        ''' </summary>
        Friend  ReadOnly Property NewKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._newKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._keyword
                Case 3
                    Return Me._newKeyword
                Case 4
                    Return Me._parameterList
                Case 5
                    Return Me._asClause
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 6
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ConstructorStatementSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _keyword, _newKeyword, _parameterList, _asClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ConstructorStatementSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _keyword, _newKeyword, _parameterList, _asClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitConstructorStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' A Declare statement that declares an external DLL method.
    ''' </summary>
    Friend NotInheritable Class DeclareStatementSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _declareKeyword as KeywordSyntax
        Friend ReadOnly _charsetKeyword as KeywordSyntax
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _libKeyword as KeywordSyntax
        Friend ReadOnly _libraryName as LiteralExpressionSyntax
        Friend ReadOnly _aliasKeyword as KeywordSyntax
        Friend ReadOnly _aliasName as LiteralExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, declareKeyword As InternalSyntax.KeywordSyntax, charsetKeyword As InternalSyntax.KeywordSyntax, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, libKeyword As InternalSyntax.KeywordSyntax, libraryName As LiteralExpressionSyntax, aliasKeyword As InternalSyntax.KeywordSyntax, aliasName As LiteralExpressionSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax)
            MyBase.New(kind, attributes, modifiers, keyword, parameterList, asClause)

            Init(declareKeyword)
            Me._declareKeyword = declareKeyword
            If charsetKeyword IsNot Nothing Then
                Init(charsetKeyword)
                Me._charsetKeyword = charsetKeyword
            End If
            Init(identifier)
            Me._identifier = identifier
            Init(libKeyword)
            Me._libKeyword = libKeyword
            Init(libraryName)
            Me._libraryName = libraryName
            If aliasKeyword IsNot Nothing Then
                Init(aliasKeyword)
                Me._aliasKeyword = aliasKeyword
            End If
            If aliasName IsNot Nothing Then
                Init(aliasName)
                Me._aliasName = aliasName
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, declareKeyword As InternalSyntax.KeywordSyntax, charsetKeyword As InternalSyntax.KeywordSyntax, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, libKeyword As InternalSyntax.KeywordSyntax, libraryName As LiteralExpressionSyntax, aliasKeyword As InternalSyntax.KeywordSyntax, aliasName As LiteralExpressionSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributes, modifiers, keyword, parameterList, asClause)

            Init(declareKeyword)
            Me._declareKeyword = declareKeyword
            If charsetKeyword IsNot Nothing Then
                Init(charsetKeyword)
                Me._charsetKeyword = charsetKeyword
            End If
            Init(identifier)
            Me._identifier = identifier
            Init(libKeyword)
            Me._libKeyword = libKeyword
            Init(libraryName)
            Me._libraryName = libraryName
            If aliasKeyword IsNot Nothing Then
                Init(aliasKeyword)
                Me._aliasKeyword = aliasKeyword
            End If
            If aliasName IsNot Nothing Then
                Init(aliasName)
                Me._aliasName = aliasName
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._declareKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._declareKeyword)
          Me._charsetKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._charsetKeyword)
          Me._identifier = DirectCast(reader.ReadValue(), IdentifierTokenSyntax)
          Init(Me._identifier)
          Me._libKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._libKeyword)
          Me._libraryName = DirectCast(reader.ReadValue(), LiteralExpressionSyntax)
          Init(Me._libraryName)
          Me._aliasKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._aliasKeyword)
          Me._aliasName = DirectCast(reader.ReadValue(), LiteralExpressionSyntax)
          Init(Me._aliasName)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._declareKeyword)
          writer.WriteValue(Me._charsetKeyword)
          writer.WriteValue(Me._identifier)
          writer.WriteValue(Me._libKeyword)
          writer.WriteValue(Me._libraryName)
          writer.WriteValue(Me._aliasKeyword)
          writer.WriteValue(Me._aliasName)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.DeclareStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Declare" keyword.
        ''' </summary>
        Friend  ReadOnly Property DeclareKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._declareKeyword
            End Get
        End Property

        ''' <summary>
        ''' If present, the keyword that defines the string translation semantics of the
        ''' external method.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property CharsetKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._charsetKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the method being declared.
        ''' </summary>
        Friend  ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' The "Lib" keyword.
        ''' </summary>
        Friend  ReadOnly Property LibKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._libKeyword
            End Get
        End Property

        ''' <summary>
        ''' The string literal with the library name.
        ''' </summary>
        Friend  ReadOnly Property LibraryName As InternalSyntax.LiteralExpressionSyntax
            Get
                Return Me._libraryName
            End Get
        End Property

        ''' <summary>
        ''' If present, the "Alias" keyword. If not present, returns Nothing.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property AliasKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._aliasKeyword
            End Get
        End Property

        ''' <summary>
        ''' The string literal with the alias. If not present, returns Nothing.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property AliasName As InternalSyntax.LiteralExpressionSyntax
            Get
                Return Me._aliasName
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._declareKeyword
                Case 3
                    Return Me._charsetKeyword
                Case 4
                    Return Me._keyword
                Case 5
                    Return Me._identifier
                Case 6
                    Return Me._libKeyword
                Case 7
                    Return Me._libraryName
                Case 8
                    Return Me._aliasKeyword
                Case 9
                    Return Me._aliasName
                Case 10
                    Return Me._parameterList
                Case 11
                    Return Me._asClause
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 12
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new DeclareStatementSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _declareKeyword, _charsetKeyword, _keyword, _identifier, _libKeyword, _libraryName, _aliasKeyword, _aliasName, _parameterList, _asClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new DeclareStatementSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _declareKeyword, _charsetKeyword, _keyword, _identifier, _libKeyword, _libraryName, _aliasKeyword, _aliasName, _parameterList, _asClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitDeclareStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' A statement that declares a delegate type.
    ''' </summary>
    Friend NotInheritable Class DelegateStatementSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _delegateKeyword as KeywordSyntax
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _typeParameterList as TypeParameterListSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, delegateKeyword As InternalSyntax.KeywordSyntax, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax)
            MyBase.New(kind, attributes, modifiers, keyword, parameterList, asClause)

            Init(delegateKeyword)
            Me._delegateKeyword = delegateKeyword
            Init(identifier)
            Me._identifier = identifier
            If typeParameterList IsNot Nothing Then
                Init(typeParameterList)
                Me._typeParameterList = typeParameterList
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, delegateKeyword As InternalSyntax.KeywordSyntax, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributes, modifiers, keyword, parameterList, asClause)

            Init(delegateKeyword)
            Me._delegateKeyword = delegateKeyword
            Init(identifier)
            Me._identifier = identifier
            If typeParameterList IsNot Nothing Then
                Init(typeParameterList)
                Me._typeParameterList = typeParameterList
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._delegateKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._delegateKeyword)
          Me._identifier = DirectCast(reader.ReadValue(), IdentifierTokenSyntax)
          Init(Me._identifier)
          Me._typeParameterList = DirectCast(reader.ReadValue(), TypeParameterListSyntax)
          Init(Me._typeParameterList)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._delegateKeyword)
          writer.WriteValue(Me._identifier)
          writer.WriteValue(Me._typeParameterList)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.DelegateStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Delegate" keyword.
        ''' </summary>
        Friend  ReadOnly Property DelegateKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._delegateKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the delegate being declared.
        ''' </summary>
        Friend  ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' If present, a type parameter list with generic type parameters for this
        ''' delegate. If no generic type parameters were present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property TypeParameterList As InternalSyntax.TypeParameterListSyntax
            Get
                Return Me._typeParameterList
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._delegateKeyword
                Case 3
                    Return Me._keyword
                Case 4
                    Return Me._identifier
                Case 5
                    Return Me._typeParameterList
                Case 6
                    Return Me._parameterList
                Case 7
                    Return Me._asClause
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 8
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new DelegateStatementSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _delegateKeyword, _keyword, _identifier, _typeParameterList, _parameterList, _asClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new DelegateStatementSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _delegateKeyword, _keyword, _identifier, _typeParameterList, _parameterList, _asClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitDelegateStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' A statement that declares an event. If the event being declared is a custom
    ''' event, this statement will be the Begin of a PropertyOrEventBlock, and the
    ''' accessors will be part of the Accessors of that node.
    ''' </summary>
    Friend NotInheritable Class EventStatementSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _customKeyword as KeywordSyntax
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _implementsClause as ImplementsClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, customKeyword As InternalSyntax.KeywordSyntax, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, implementsClause As ImplementsClauseSyntax)
            MyBase.New(kind, attributes, modifiers, keyword, parameterList, asClause)

            If customKeyword IsNot Nothing Then
                Init(customKeyword)
                Me._customKeyword = customKeyword
            End If
            Init(identifier)
            Me._identifier = identifier
            If implementsClause IsNot Nothing Then
                Init(implementsClause)
                Me._implementsClause = implementsClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, customKeyword As InternalSyntax.KeywordSyntax, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, implementsClause As ImplementsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributes, modifiers, keyword, parameterList, asClause)

            If customKeyword IsNot Nothing Then
                Init(customKeyword)
                Me._customKeyword = customKeyword
            End If
            Init(identifier)
            Me._identifier = identifier
            If implementsClause IsNot Nothing Then
                Init(implementsClause)
                Me._implementsClause = implementsClause
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._customKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._customKeyword)
          Me._identifier = DirectCast(reader.ReadValue(), IdentifierTokenSyntax)
          Init(Me._identifier)
          Me._implementsClause = DirectCast(reader.ReadValue(), ImplementsClauseSyntax)
          Init(Me._implementsClause)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._customKeyword)
          writer.WriteValue(Me._identifier)
          writer.WriteValue(Me._implementsClause)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.EventStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The optional Custom keyword for custom event declarations.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property CustomKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._customKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the event being declared.
        ''' </summary>
        Friend  ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' If present, an Implements clause indicates the interface methods that this
        ''' method implements.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ImplementsClause As InternalSyntax.ImplementsClauseSyntax
            Get
                Return Me._implementsClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._customKeyword
                Case 3
                    Return Me._keyword
                Case 4
                    Return Me._identifier
                Case 5
                    Return Me._parameterList
                Case 6
                    Return Me._asClause
                Case 7
                    Return Me._implementsClause
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 8
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new EventStatementSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _customKeyword, _keyword, _identifier, _parameterList, _asClause, _implementsClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new EventStatementSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _customKeyword, _keyword, _identifier, _parameterList, _asClause, _implementsClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitEventStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' A statement that declares an operator. If this operator has a body, this
    ''' statement will be the Begin of a BlockStatement with
    ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
    ''' that BlockStatement.
    ''' </summary>
    Friend NotInheritable Class OperatorStatementSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _operator as SyntaxToken

        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, [operator] As InternalSyntax.SyntaxToken, parameterList As ParameterListSyntax, asClause As AsClauseSyntax)
            MyBase.New(kind, attributes, modifiers, keyword, parameterList, asClause)

            Init([operator])
            Me._operator = [operator]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, [operator] As InternalSyntax.SyntaxToken, parameterList As ParameterListSyntax, asClause As AsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributes, modifiers, keyword, parameterList, asClause)

            Init([operator])
            Me._operator = [operator]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._operator = DirectCast(reader.ReadValue(), SyntaxToken)
          Init(Me._operator)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._operator)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.OperatorStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The operator being defined.
        ''' </summary>
        Friend  ReadOnly Property [Operator] As InternalSyntax.SyntaxToken
            Get
                Return Me._operator
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._keyword
                Case 3
                    Return Me._operator
                Case 4
                    Return Me._parameterList
                Case 5
                    Return Me._asClause
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 6
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new OperatorStatementSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _keyword, _operator, _parameterList, _asClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new OperatorStatementSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _keyword, _operator, _parameterList, _asClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitOperatorStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Statement that declares a property. If this property has accessors declared,
    ''' this statement will be the Begin of a BlockNode, and the accessors will be the
    ''' Body of that node. Auto properties are property declarations without a
    ''' PropertyBlock.
    ''' </summary>
    Friend NotInheritable Class PropertyStatementSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _initializer as EqualsValueSyntax
        Friend ReadOnly _implementsClause as ImplementsClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, initializer As EqualsValueSyntax, implementsClause As ImplementsClauseSyntax)
            MyBase.New(kind, attributes, modifiers, keyword, parameterList, asClause)

            Init(identifier)
            Me._identifier = identifier
            If initializer IsNot Nothing Then
                Init(initializer)
                Me._initializer = initializer
            End If
            If implementsClause IsNot Nothing Then
                Init(implementsClause)
                Me._implementsClause = implementsClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, initializer As EqualsValueSyntax, implementsClause As ImplementsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributes, modifiers, keyword, parameterList, asClause)

            Init(identifier)
            Me._identifier = identifier
            If initializer IsNot Nothing Then
                Init(initializer)
                Me._initializer = initializer
            End If
            If implementsClause IsNot Nothing Then
                Init(implementsClause)
                Me._implementsClause = implementsClause
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._identifier = DirectCast(reader.ReadValue(), IdentifierTokenSyntax)
          Init(Me._identifier)
          Me._initializer = DirectCast(reader.ReadValue(), EqualsValueSyntax)
          Init(Me._initializer)
          Me._implementsClause = DirectCast(reader.ReadValue(), ImplementsClauseSyntax)
          Init(Me._implementsClause)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._identifier)
          writer.WriteValue(Me._initializer)
          writer.WriteValue(Me._implementsClause)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.PropertyStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The name of the property being declared.
        ''' </summary>
        Friend  ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' If present, an "= initial-value" clause describing the initial value of the
        ''' property.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Initializer As InternalSyntax.EqualsValueSyntax
            Get
                Return Me._initializer
            End Get
        End Property

        ''' <summary>
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ImplementsClause As InternalSyntax.ImplementsClauseSyntax
            Get
                Return Me._implementsClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._keyword
                Case 3
                    Return Me._identifier
                Case 4
                    Return Me._parameterList
                Case 5
                    Return Me._asClause
                Case 6
                    Return Me._initializer
                Case 7
                    Return Me._implementsClause
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 8
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new PropertyStatementSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _keyword, _identifier, _parameterList, _asClause, _initializer, _implementsClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new PropertyStatementSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _keyword, _identifier, _parameterList, _asClause, _initializer, _implementsClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitPropertyStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
    ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
    ''' the node determines what kind of accessor this is. This statement is always the
    ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
    ''' </summary>
    Friend NotInheritable Class AccessorStatementSyntax
        Inherits MethodBaseSyntax


        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax)
            MyBase.New(kind, attributes, modifiers, keyword, parameterList, asClause)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributes, modifiers, keyword, parameterList, asClause)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.AccessorStatementSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._keyword
                Case 3
                    Return Me._parameterList
                Case 4
                    Return Me._asClause
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new AccessorStatementSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _keyword, _parameterList, _asClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new AccessorStatementSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _keyword, _parameterList, _asClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitAccessorStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Implements ..." clause on a type member, which describes which
    ''' interface members this member implements.
    ''' </summary>
    Friend NotInheritable Class ImplementsClauseSyntax
        Inherits SyntaxNode

        Friend ReadOnly _implementsKeyword as KeywordSyntax
        Friend ReadOnly _interfaceMembers as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, implementsKeyword As InternalSyntax.KeywordSyntax, interfaceMembers As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(implementsKeyword)
            Me._implementsKeyword = implementsKeyword
            If interfaceMembers IsNot Nothing Then
                Init(interfaceMembers)
                Me._interfaceMembers = interfaceMembers
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), implementsKeyword As InternalSyntax.KeywordSyntax, interfaceMembers As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(implementsKeyword)
            Me._implementsKeyword = implementsKeyword
            If interfaceMembers IsNot Nothing Then
                Init(interfaceMembers)
                Me._interfaceMembers = interfaceMembers
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._implementsKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._implementsKeyword)
          Me._interfaceMembers = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._interfaceMembers)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._implementsKeyword)
          writer.WriteValue(Me._interfaceMembers)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ImplementsClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Implements" keyword.
        ''' </summary>
        Friend  ReadOnly Property ImplementsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._implementsKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of interface members being implemented.
        ''' </summary>
        Friend  ReadOnly Property InterfaceMembers As InternalSyntax.SeparatedSyntaxList(Of QualifiedNameSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of QualifiedNameSyntax)(New SyntaxList(of QualifiedNameSyntax)(Me._interfaceMembers))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._implementsKeyword
                Case 1
                    Return Me._interfaceMembers
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ImplementsClauseSyntax(kind, newErrors, GetAnnotations, _implementsKeyword, _interfaceMembers)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ImplementsClauseSyntax(kind, GetDiagnostics, annotations, _implementsKeyword, _interfaceMembers)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitImplementsClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Handles ..." clause on a method declaration that describes
    ''' which events this method handles.
    ''' </summary>
    Friend NotInheritable Class HandlesClauseSyntax
        Inherits SyntaxNode

        Friend ReadOnly _handlesKeyword as KeywordSyntax
        Friend ReadOnly _events as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, handlesKeyword As InternalSyntax.KeywordSyntax, events As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(handlesKeyword)
            Me._handlesKeyword = handlesKeyword
            If events IsNot Nothing Then
                Init(events)
                Me._events = events
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), handlesKeyword As InternalSyntax.KeywordSyntax, events As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(handlesKeyword)
            Me._handlesKeyword = handlesKeyword
            If events IsNot Nothing Then
                Init(events)
                Me._events = events
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._handlesKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._handlesKeyword)
          Me._events = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._events)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._handlesKeyword)
          writer.WriteValue(Me._events)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.HandlesClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Handles" keyword.
        ''' </summary>
        Friend  ReadOnly Property HandlesKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._handlesKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of event members being handled.
        ''' </summary>
        Friend  ReadOnly Property Events As InternalSyntax.SeparatedSyntaxList(Of HandlesClauseItemSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of HandlesClauseItemSyntax)(New SyntaxList(of HandlesClauseItemSyntax)(Me._events))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._handlesKeyword
                Case 1
                    Return Me._events
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new HandlesClauseSyntax(kind, newErrors, GetAnnotations, _handlesKeyword, _events)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new HandlesClauseSyntax(kind, GetDiagnostics, annotations, _handlesKeyword, _events)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitHandlesClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single handled event in a "Handles ..." clause.
    ''' </summary>
    Friend NotInheritable Class HandlesClauseItemSyntax
        Inherits SyntaxNode

        Friend ReadOnly _eventContainer as SyntaxToken
        Friend ReadOnly _dotToken as PunctuationSyntax
        Friend ReadOnly _eventMember as IdentifierNameSyntax

        Friend Sub New(ByVal kind As SyntaxKind, eventContainer As InternalSyntax.SyntaxToken, dotToken As InternalSyntax.PunctuationSyntax, eventMember As IdentifierNameSyntax)
            MyBase.New(kind)

            Init(eventContainer)
            Me._eventContainer = eventContainer
            Init(dotToken)
            Me._dotToken = dotToken
            Init(eventMember)
            Me._eventMember = eventMember

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), eventContainer As InternalSyntax.SyntaxToken, dotToken As InternalSyntax.PunctuationSyntax, eventMember As IdentifierNameSyntax)
            MyBase.New(kind, errors, annotations)

            Init(eventContainer)
            Me._eventContainer = eventContainer
            Init(dotToken)
            Me._dotToken = dotToken
            Init(eventMember)
            Me._eventMember = eventMember

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._eventContainer = DirectCast(reader.ReadValue(), SyntaxToken)
          Init(Me._eventContainer)
          Me._dotToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._dotToken)
          Me._eventMember = DirectCast(reader.ReadValue(), IdentifierNameSyntax)
          Init(Me._eventMember)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._eventContainer)
          writer.WriteValue(Me._dotToken)
          writer.WriteValue(Me._eventMember)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.HandlesClauseItemSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The container of the event. This can either be an simple identifier
        ''' (identifying a members of the containing type) or one of the special keywords
        ''' "Me", "MyBase" or "MyClass".
        ''' </summary>
        Friend  ReadOnly Property EventContainer As InternalSyntax.SyntaxToken
            Get
                Return Me._eventContainer
            End Get
        End Property

        ''' <summary>
        ''' The "." token.
        ''' </summary>
        Friend  ReadOnly Property DotToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._dotToken
            End Get
        End Property

        ''' <summary>
        ''' The event being handled. This must be a simple identifier.
        ''' </summary>
        Friend  ReadOnly Property EventMember As InternalSyntax.IdentifierNameSyntax
            Get
                Return Me._eventMember
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._eventContainer
                Case 1
                    Return Me._dotToken
                Case 2
                    Return Me._eventMember
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new HandlesClauseItemSyntax(kind, newErrors, GetAnnotations, _eventContainer, _dotToken, _eventMember)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new HandlesClauseItemSyntax(kind, GetDiagnostics, annotations, _eventContainer, _dotToken, _eventMember)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitHandlesClauseItem(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning of a declaration. However, not enough syntax is
    ''' detected to classify this as a field, method, property or event. This is node
    ''' always represents a syntax error.
    ''' </summary>
    Friend NotInheritable Class IncompleteMemberSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _attributes as SyntaxNode
        Friend ReadOnly _modifiers as SyntaxNode
        Friend ReadOnly _missingIdentifier as IdentifierTokenSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, missingIdentifier As InternalSyntax.IdentifierTokenSyntax)
            MyBase.New(kind)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            If modifiers IsNot Nothing Then
                Init(modifiers)
                Me._modifiers = modifiers
            End If
            If missingIdentifier IsNot Nothing Then
                Init(missingIdentifier)
                Me._missingIdentifier = missingIdentifier
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, missingIdentifier As InternalSyntax.IdentifierTokenSyntax)
            MyBase.New(kind, errors, annotations)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            If modifiers IsNot Nothing Then
                Init(modifiers)
                Me._modifiers = modifiers
            End If
            If missingIdentifier IsNot Nothing Then
                Init(missingIdentifier)
                Me._missingIdentifier = missingIdentifier
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._attributes = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._attributes)
          Me._modifiers = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._modifiers)
          Me._missingIdentifier = DirectCast(reader.ReadValue(), IdentifierTokenSyntax)
          Init(Me._missingIdentifier)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._attributes)
          writer.WriteValue(Me._modifiers)
          writer.WriteValue(Me._missingIdentifier)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.IncompleteMemberSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Attributes As InternalSyntax.SyntaxList(Of AttributeBlockSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of AttributeBlockSyntax)(Me._attributes)
            End Get
        End Property

        ''' <summary>
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Modifiers As InternalSyntax.SyntaxList(Of KeywordSyntax)
            Get
                Return New InternalSyntax.SyntaxList(of KeywordSyntax)(Me._modifiers)
            End Get
        End Property

        ''' <summary>
        ''' The missing identifier token for this incomplete member. Should only be used to
        ''' have a location for error reporting.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property MissingIdentifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._missingIdentifier
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._missingIdentifier
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new IncompleteMemberSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _missingIdentifier)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new IncompleteMemberSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _missingIdentifier)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitIncompleteMember(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the declaration of one or more variables or constants, either as
    ''' local variables or as class/structure members. In the case of a constant, it is
    ''' represented by having "Const" in the Modifiers (although technically "Const" is
    ''' not a modifier, it is represented as one in the parse trees.)
    ''' </summary>
    Friend NotInheritable Class FieldDeclarationSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _attributes as SyntaxNode
        Friend ReadOnly _modifiers as SyntaxNode
        Friend ReadOnly _declarators as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, declarators As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            If modifiers IsNot Nothing Then
                Init(modifiers)
                Me._modifiers = modifiers
            End If
            If declarators IsNot Nothing Then
                Init(declarators)
                Me._declarators = declarators
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, declarators As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            If modifiers IsNot Nothing Then
                Init(modifiers)
                Me._modifiers = modifiers
            End If
            If declarators IsNot Nothing Then
                Init(declarators)
                Me._declarators = declarators
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._attributes = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._attributes)
          Me._modifiers = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._modifiers)
          Me._declarators = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._declarators)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._attributes)
          writer.WriteValue(Me._modifiers)
          writer.WriteValue(Me._declarators)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.FieldDeclarationSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' A list of all attribute blocks on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Attributes As InternalSyntax.SyntaxList(Of AttributeBlockSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of AttributeBlockSyntax)(Me._attributes)
            End Get
        End Property

        ''' <summary>
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Modifiers As InternalSyntax.SyntaxList(Of KeywordSyntax)
            Get
                Return New InternalSyntax.SyntaxList(of KeywordSyntax)(Me._modifiers)
            End Get
        End Property

        ''' <summary>
        ''' The list of variable declarator. Each declarator specifies one or more variable
        ''' names along with a type and/or initializer.
        ''' </summary>
        Friend  ReadOnly Property Declarators As InternalSyntax.SeparatedSyntaxList(Of VariableDeclaratorSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of VariableDeclaratorSyntax)(New SyntaxList(of VariableDeclaratorSyntax)(Me._declarators))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._declarators
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new FieldDeclarationSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _declarators)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new FieldDeclarationSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _declarators)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitFieldDeclaration(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the part of a variable or constant declaration statement that
    ''' associated one or more variable names with a type.
    ''' </summary>
    Friend NotInheritable Class VariableDeclaratorSyntax
        Inherits SyntaxNode

        Friend ReadOnly _names as SyntaxNode
        Friend ReadOnly _asClause as AsClauseSyntax
        Friend ReadOnly _initializer as EqualsValueSyntax

        Friend Sub New(ByVal kind As SyntaxKind, names As InternalSyntax.SyntaxNode, asClause As AsClauseSyntax, initializer As EqualsValueSyntax)
            MyBase.New(kind)

            If names IsNot Nothing Then
                Init(names)
                Me._names = names
            End If
            If asClause IsNot Nothing Then
                Init(asClause)
                Me._asClause = asClause
            End If
            If initializer IsNot Nothing Then
                Init(initializer)
                Me._initializer = initializer
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), names As InternalSyntax.SyntaxNode, asClause As AsClauseSyntax, initializer As EqualsValueSyntax)
            MyBase.New(kind, errors, annotations)

            If names IsNot Nothing Then
                Init(names)
                Me._names = names
            End If
            If asClause IsNot Nothing Then
                Init(asClause)
                Me._asClause = asClause
            End If
            If initializer IsNot Nothing Then
                Init(initializer)
                Me._initializer = initializer
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._names = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._names)
          Me._asClause = DirectCast(reader.ReadValue(), AsClauseSyntax)
          Init(Me._asClause)
          Me._initializer = DirectCast(reader.ReadValue(), EqualsValueSyntax)
          Init(Me._initializer)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._names)
          writer.WriteValue(Me._asClause)
          writer.WriteValue(Me._initializer)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.VariableDeclaratorSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The names of the variables being declared. Each name might have a "?" or "()"
        ''' modifier(s) attached.
        ''' </summary>
        Friend  ReadOnly Property Names As InternalSyntax.SeparatedSyntaxList(Of ModifiedIdentifierSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of ModifiedIdentifierSyntax)(New SyntaxList(of ModifiedIdentifierSyntax)(Me._names))
            End Get
        End Property

        ''' <summary>
        ''' The "As" clause that describes the return type, and possibly includes "New",
        ''' "With" or "From". If no As clause was present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property AsClause As InternalSyntax.AsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        ''' <summary>
        ''' If present, an "= initial-value" clause describing the initial value of the
        ''' variable or the value of the constant.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Initializer As InternalSyntax.EqualsValueSyntax
            Get
                Return Me._initializer
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._names
                Case 1
                    Return Me._asClause
                Case 2
                    Return Me._initializer
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new VariableDeclaratorSyntax(kind, newErrors, GetAnnotations, _names, _asClause, _initializer)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new VariableDeclaratorSyntax(kind, GetDiagnostics, annotations, _names, _asClause, _initializer)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitVariableDeclarator(Me)
        End Function

    End Class

    ''' <summary>
    ''' Abstract node class that represents the different kinds of "As {type-name}"
    ''' clauses in a declaration: simple "As" clauses and "As New" clauses. The type
    ''' has optional attributes associated with it, although attributes are not
    ''' permitted in all possible places where this node occurs.
    ''' </summary>
    Friend MustInherit Class AsClauseSyntax
        Inherits SyntaxNode

        Friend ReadOnly _asKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, asKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(asKeyword)
            Me._asKeyword = asKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), asKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(asKeyword)
            Me._asKeyword = asKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._asKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._asKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._asKeyword)
        End Sub

        ''' <summary>
        ''' The "As" keyword.
        ''' </summary>
        Friend  ReadOnly Property AsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._asKeyword
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents an "As {type-name}" clause that does not have an initializer or
    ''' "New". The type has optional attributes associated with it, although attributes
    ''' are not permitted in all possible places where this node occurs.
    ''' </summary>
    Friend NotInheritable Class SimpleAsClauseSyntax
        Inherits AsClauseSyntax

        Friend ReadOnly _attributes as SyntaxNode
        Friend ReadOnly _type as TypeSyntax

        Friend Sub New(ByVal kind As SyntaxKind, asKeyword As InternalSyntax.KeywordSyntax, attributes As InternalSyntax.SyntaxNode, type As TypeSyntax)
            MyBase.New(kind, asKeyword)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            Init(type)
            Me._type = type

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), asKeyword As InternalSyntax.KeywordSyntax, attributes As InternalSyntax.SyntaxNode, type As TypeSyntax)
            MyBase.New(kind, errors, annotations, asKeyword)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            Init(type)
            Me._type = type

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._attributes = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._attributes)
          Me._type = DirectCast(reader.ReadValue(), TypeSyntax)
          Init(Me._type)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._attributes)
          writer.WriteValue(Me._type)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.SimpleAsClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' A list of all attribute blocks on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Attributes As InternalSyntax.SyntaxList(Of AttributeBlockSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of AttributeBlockSyntax)(Me._attributes)
            End Get
        End Property

        ''' <summary>
        ''' The type-name part of the As clause.
        ''' </summary>
        Friend  ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._asKeyword
                Case 1
                    Return Me._attributes
                Case 2
                    Return Me._type
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new SimpleAsClauseSyntax(kind, newErrors, GetAnnotations, _asKeyword, _attributes, _type)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new SimpleAsClauseSyntax(kind, GetDiagnostics, annotations, _asKeyword, _attributes, _type)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitSimpleAsClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an "As New {type-name} [arguments] [initializers]" clause in a
    ''' declaration. The type has optional attributes associated with it, although
    ''' attributes are not permitted in many places where this node occurs (they are
    ''' permitted, for example, on automatically implemented properties.)
    ''' </summary>
    Friend NotInheritable Class AsNewClauseSyntax
        Inherits AsClauseSyntax

        Friend ReadOnly _newExpression as NewExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, asKeyword As InternalSyntax.KeywordSyntax, newExpression As NewExpressionSyntax)
            MyBase.New(kind, asKeyword)

            Init(newExpression)
            Me._newExpression = newExpression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), asKeyword As InternalSyntax.KeywordSyntax, newExpression As NewExpressionSyntax)
            MyBase.New(kind, errors, annotations, asKeyword)

            Init(newExpression)
            Me._newExpression = newExpression

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._newExpression = DirectCast(reader.ReadValue(), NewExpressionSyntax)
          Init(Me._newExpression)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._newExpression)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.AsNewClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The New expression
        ''' </summary>
        Friend  ReadOnly Property NewExpression As InternalSyntax.NewExpressionSyntax
            Get
                Return Me._newExpression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._asKeyword
                Case 1
                    Return Me._newExpression
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new AsNewClauseSyntax(kind, newErrors, GetAnnotations, _asKeyword, _newExpression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new AsNewClauseSyntax(kind, GetDiagnostics, annotations, _asKeyword, _newExpression)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitAsNewClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' An abstract node class that represents a "With" or "From" clause used to
    ''' initializer an new object.
    ''' </summary>
    Friend MustInherit Class ObjectCreationInitializerSyntax
        Inherits SyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' Represents a "With {...} clause used to initialize a new object's members.
    ''' </summary>
    Friend NotInheritable Class ObjectMemberInitializerSyntax
        Inherits ObjectCreationInitializerSyntax

        Friend ReadOnly _withKeyword as KeywordSyntax
        Friend ReadOnly _openBraceToken as PunctuationSyntax
        Friend ReadOnly _initializers as SyntaxNode
        Friend ReadOnly _closeBraceToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, withKeyword As InternalSyntax.KeywordSyntax, openBraceToken As InternalSyntax.PunctuationSyntax, initializers As InternalSyntax.SyntaxNode, closeBraceToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(withKeyword)
            Me._withKeyword = withKeyword
            Init(openBraceToken)
            Me._openBraceToken = openBraceToken
            If initializers IsNot Nothing Then
                Init(initializers)
                Me._initializers = initializers
            End If
            Init(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), withKeyword As InternalSyntax.KeywordSyntax, openBraceToken As InternalSyntax.PunctuationSyntax, initializers As InternalSyntax.SyntaxNode, closeBraceToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(withKeyword)
            Me._withKeyword = withKeyword
            Init(openBraceToken)
            Me._openBraceToken = openBraceToken
            If initializers IsNot Nothing Then
                Init(initializers)
                Me._initializers = initializers
            End If
            Init(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._withKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._withKeyword)
          Me._openBraceToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openBraceToken)
          Me._initializers = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._initializers)
          Me._closeBraceToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeBraceToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._withKeyword)
          writer.WriteValue(Me._openBraceToken)
          writer.WriteValue(Me._initializers)
          writer.WriteValue(Me._closeBraceToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ObjectMemberInitializerSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "With" keyword.
        ''' </summary>
        Friend  ReadOnly Property WithKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._withKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "{" token.
        ''' </summary>
        Friend  ReadOnly Property OpenBraceToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openBraceToken
            End Get
        End Property

        ''' <summary>
        ''' The comma-separated list of field initializers.
        ''' </summary>
        Friend  ReadOnly Property Initializers As InternalSyntax.SeparatedSyntaxList(Of FieldInitializerSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of FieldInitializerSyntax)(New SyntaxList(of FieldInitializerSyntax)(Me._initializers))
            End Get
        End Property

        ''' <summary>
        ''' The "}" token.
        ''' </summary>
        Friend  ReadOnly Property CloseBraceToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeBraceToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._withKeyword
                Case 1
                    Return Me._openBraceToken
                Case 2
                    Return Me._initializers
                Case 3
                    Return Me._closeBraceToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ObjectMemberInitializerSyntax(kind, newErrors, GetAnnotations, _withKeyword, _openBraceToken, _initializers, _closeBraceToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ObjectMemberInitializerSyntax(kind, GetDiagnostics, annotations, _withKeyword, _openBraceToken, _initializers, _closeBraceToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitObjectMemberInitializer(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "From {...} clause used to initialize a new collection object's
    ''' elements.
    ''' </summary>
    Friend NotInheritable Class ObjectCollectionInitializerSyntax
        Inherits ObjectCreationInitializerSyntax

        Friend ReadOnly _fromKeyword as KeywordSyntax
        Friend ReadOnly _initializer as CollectionInitializerSyntax

        Friend Sub New(ByVal kind As SyntaxKind, fromKeyword As InternalSyntax.KeywordSyntax, initializer As CollectionInitializerSyntax)
            MyBase.New(kind)

            Init(fromKeyword)
            Me._fromKeyword = fromKeyword
            Init(initializer)
            Me._initializer = initializer

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), fromKeyword As InternalSyntax.KeywordSyntax, initializer As CollectionInitializerSyntax)
            MyBase.New(kind, errors, annotations)

            Init(fromKeyword)
            Me._fromKeyword = fromKeyword
            Init(initializer)
            Me._initializer = initializer

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._fromKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._fromKeyword)
          Me._initializer = DirectCast(reader.ReadValue(), CollectionInitializerSyntax)
          Init(Me._initializer)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._fromKeyword)
          writer.WriteValue(Me._initializer)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ObjectCollectionInitializerSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "From" keyword.
        ''' </summary>
        Friend  ReadOnly Property FromKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._fromKeyword
            End Get
        End Property

        ''' <summary>
        ''' The initializer including the braces.
        ''' </summary>
        Friend  ReadOnly Property Initializer As InternalSyntax.CollectionInitializerSyntax
            Get
                Return Me._initializer
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._fromKeyword
                Case 1
                    Return Me._initializer
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ObjectCollectionInitializerSyntax(kind, newErrors, GetAnnotations, _fromKeyword, _initializer)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ObjectCollectionInitializerSyntax(kind, GetDiagnostics, annotations, _fromKeyword, _initializer)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitObjectCollectionInitializer(Me)
        End Function

    End Class

    ''' <summary>
    ''' Abstract class that represent a single field initializer used in a "With {...}"
    ''' field initializer list.
    ''' </summary>
    Friend MustInherit Class FieldInitializerSyntax
        Inherits SyntaxNode

        Friend ReadOnly _keyKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, keyKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            If keyKeyword IsNot Nothing Then
                Init(keyKeyword)
                Me._keyKeyword = keyKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            If keyKeyword IsNot Nothing Then
                Init(keyKeyword)
                Me._keyKeyword = keyKeyword
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._keyKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._keyKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._keyKeyword)
        End Sub

        ''' <summary>
        ''' The optional "Key" keyword.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property KeyKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._keyKeyword
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represent a field initializer in a With {...} initializer where the field name
    ''' is inferred from the initializer expression.
    ''' </summary>
    Friend NotInheritable Class InferredFieldInitializerSyntax
        Inherits FieldInitializerSyntax

        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, keyKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, keyKeyword)

            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations, keyKeyword)

            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._expression)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.InferredFieldInitializerSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The value being assigned.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._keyKeyword
                Case 1
                    Return Me._expression
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new InferredFieldInitializerSyntax(kind, newErrors, GetAnnotations, _keyKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new InferredFieldInitializerSyntax(kind, GetDiagnostics, annotations, _keyKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitInferredFieldInitializer(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represent a named field initializer in a With {...} initializer, such as ".x =
    ''' expr".
    ''' </summary>
    Friend NotInheritable Class NamedFieldInitializerSyntax
        Inherits FieldInitializerSyntax

        Friend ReadOnly _dotToken as PunctuationSyntax
        Friend ReadOnly _identifier as IdentifierNameSyntax
        Friend ReadOnly _equalsToken as PunctuationSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, keyKeyword As InternalSyntax.KeywordSyntax, dotToken As InternalSyntax.PunctuationSyntax, identifier As IdentifierNameSyntax, equalsToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, keyKeyword)

            Init(dotToken)
            Me._dotToken = dotToken
            Init(identifier)
            Me._identifier = identifier
            Init(equalsToken)
            Me._equalsToken = equalsToken
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyKeyword As InternalSyntax.KeywordSyntax, dotToken As InternalSyntax.PunctuationSyntax, identifier As IdentifierNameSyntax, equalsToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations, keyKeyword)

            Init(dotToken)
            Me._dotToken = dotToken
            Init(identifier)
            Me._identifier = identifier
            Init(equalsToken)
            Me._equalsToken = equalsToken
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._dotToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._dotToken)
          Me._identifier = DirectCast(reader.ReadValue(), IdentifierNameSyntax)
          Init(Me._identifier)
          Me._equalsToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._equalsToken)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._dotToken)
          writer.WriteValue(Me._identifier)
          writer.WriteValue(Me._equalsToken)
          writer.WriteValue(Me._expression)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.NamedFieldInitializerSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "." token.
        ''' </summary>
        Friend  ReadOnly Property DotToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._dotToken
            End Get
        End Property

        ''' <summary>
        ''' The name of the field being initialized.
        ''' </summary>
        Friend  ReadOnly Property Identifier As InternalSyntax.IdentifierNameSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' The "=" token.
        ''' </summary>
        Friend  ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        ''' <summary>
        ''' The value being assigned to the field.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._keyKeyword
                Case 1
                    Return Me._dotToken
                Case 2
                    Return Me._identifier
                Case 3
                    Return Me._equalsToken
                Case 4
                    Return Me._expression
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new NamedFieldInitializerSyntax(kind, newErrors, GetAnnotations, _keyKeyword, _dotToken, _identifier, _equalsToken, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new NamedFieldInitializerSyntax(kind, GetDiagnostics, annotations, _keyKeyword, _dotToken, _identifier, _equalsToken, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitNamedFieldInitializer(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an "= initializer" clause in a declaration for a variable,
    ''' pararameter or automatic property.
    ''' </summary>
    Friend NotInheritable Class EqualsValueSyntax
        Inherits SyntaxNode

        Friend ReadOnly _equalsToken as PunctuationSyntax
        Friend ReadOnly _value as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, equalsToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax)
            MyBase.New(kind)

            Init(equalsToken)
            Me._equalsToken = equalsToken
            Init(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), equalsToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(equalsToken)
            Me._equalsToken = equalsToken
            Init(value)
            Me._value = value

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._equalsToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._equalsToken)
          Me._value = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._value)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._equalsToken)
          writer.WriteValue(Me._value)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.EqualsValueSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "=" token.
        ''' </summary>
        Friend  ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        ''' <summary>
        ''' The expression used as the initial value.
        ''' </summary>
        Friend  ReadOnly Property Value As InternalSyntax.ExpressionSyntax
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._equalsToken
                Case 1
                    Return Me._value
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new EqualsValueSyntax(kind, newErrors, GetAnnotations, _equalsToken, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new EqualsValueSyntax(kind, GetDiagnostics, annotations, _equalsToken, _value)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitEqualsValue(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represent a parameter to a method, property, constructor, etc.
    ''' </summary>
    Friend NotInheritable Class ParameterSyntax
        Inherits SyntaxNode

        Friend ReadOnly _attributes as SyntaxNode
        Friend ReadOnly _modifiers as SyntaxNode
        Friend ReadOnly _identifier as ModifiedIdentifierSyntax
        Friend ReadOnly _asClause as SimpleAsClauseSyntax
        Friend ReadOnly _default as EqualsValueSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, [default] As EqualsValueSyntax)
            MyBase.New(kind)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            If modifiers IsNot Nothing Then
                Init(modifiers)
                Me._modifiers = modifiers
            End If
            Init(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                Init(asClause)
                Me._asClause = asClause
            End If
            If [default] IsNot Nothing Then
                Init([default])
                Me._default = [default]
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, [default] As EqualsValueSyntax)
            MyBase.New(kind, errors, annotations)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            If modifiers IsNot Nothing Then
                Init(modifiers)
                Me._modifiers = modifiers
            End If
            Init(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                Init(asClause)
                Me._asClause = asClause
            End If
            If [default] IsNot Nothing Then
                Init([default])
                Me._default = [default]
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._attributes = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._attributes)
          Me._modifiers = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._modifiers)
          Me._identifier = DirectCast(reader.ReadValue(), ModifiedIdentifierSyntax)
          Init(Me._identifier)
          Me._asClause = DirectCast(reader.ReadValue(), SimpleAsClauseSyntax)
          Init(Me._asClause)
          Me._default = DirectCast(reader.ReadValue(), EqualsValueSyntax)
          Init(Me._default)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._attributes)
          writer.WriteValue(Me._modifiers)
          writer.WriteValue(Me._identifier)
          writer.WriteValue(Me._asClause)
          writer.WriteValue(Me._default)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ParameterSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' A list of all attribute blocks on this parameter. If no attributes were
        ''' specified, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Attributes As InternalSyntax.SyntaxList(Of AttributeBlockSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of AttributeBlockSyntax)(Me._attributes)
            End Get
        End Property

        ''' <summary>
        ''' A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
        ''' modify this parameter.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Modifiers As InternalSyntax.SyntaxList(Of KeywordSyntax)
            Get
                Return New InternalSyntax.SyntaxList(of KeywordSyntax)(Me._modifiers)
            End Get
        End Property

        ''' <summary>
        ''' The name of the parameter, including any "?" or "()" modifiers.
        ''' </summary>
        Friend  ReadOnly Property Identifier As InternalSyntax.ModifiedIdentifierSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' If present, the "As type-name" clause describing the type of the parameter. If
        ''' no As clause is present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        ''' <summary>
        ''' If present, an initializer with the default value of the parameter. If no
        ''' default value is present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property [Default] As InternalSyntax.EqualsValueSyntax
            Get
                Return Me._default
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._identifier
                Case 3
                    Return Me._asClause
                Case 4
                    Return Me._default
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ParameterSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _identifier, _asClause, _default)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ParameterSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _identifier, _asClause, _default)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitParameter(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
    ''' used in parameter declarations and variable declarations.
    ''' </summary>
    Friend NotInheritable Class ModifiedIdentifierSyntax
        Inherits SyntaxNode

        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _nullable as PunctuationSyntax
        Friend ReadOnly _arrayBounds as ArgumentListSyntax
        Friend ReadOnly _arrayRankSpecifiers as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax, nullable As InternalSyntax.PunctuationSyntax, arrayBounds As ArgumentListSyntax, arrayRankSpecifiers As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(identifier)
            Me._identifier = identifier
            If nullable IsNot Nothing Then
                Init(nullable)
                Me._nullable = nullable
            End If
            If arrayBounds IsNot Nothing Then
                Init(arrayBounds)
                Me._arrayBounds = arrayBounds
            End If
            If arrayRankSpecifiers IsNot Nothing Then
                Init(arrayRankSpecifiers)
                Me._arrayRankSpecifiers = arrayRankSpecifiers
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifier As InternalSyntax.IdentifierTokenSyntax, nullable As InternalSyntax.PunctuationSyntax, arrayBounds As ArgumentListSyntax, arrayRankSpecifiers As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(identifier)
            Me._identifier = identifier
            If nullable IsNot Nothing Then
                Init(nullable)
                Me._nullable = nullable
            End If
            If arrayBounds IsNot Nothing Then
                Init(arrayBounds)
                Me._arrayBounds = arrayBounds
            End If
            If arrayRankSpecifiers IsNot Nothing Then
                Init(arrayRankSpecifiers)
                Me._arrayRankSpecifiers = arrayRankSpecifiers
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._identifier = DirectCast(reader.ReadValue(), IdentifierTokenSyntax)
          Init(Me._identifier)
          Me._nullable = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._nullable)
          Me._arrayBounds = DirectCast(reader.ReadValue(), ArgumentListSyntax)
          Init(Me._arrayBounds)
          Me._arrayRankSpecifiers = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._arrayRankSpecifiers)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._identifier)
          writer.WriteValue(Me._nullable)
          writer.WriteValue(Me._arrayBounds)
          writer.WriteValue(Me._arrayRankSpecifiers)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ModifiedIdentifierSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The identifier that names the item being declared.
        ''' </summary>
        Friend  ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' The "?" token that indicates a nullable type.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Nullable As InternalSyntax.PunctuationSyntax
            Get
                Return Me._nullable
            End Get
        End Property

        ''' <summary>
        ''' The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ArrayBounds As InternalSyntax.ArgumentListSyntax
            Get
                Return Me._arrayBounds
            End Get
        End Property

        ''' <summary>
        ''' A list of array modifiers for the type. If no array modifiers were present, an
        ''' empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property ArrayRankSpecifiers As InternalSyntax.SyntaxList(Of ArrayRankSpecifierSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of ArrayRankSpecifierSyntax)(Me._arrayRankSpecifiers)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._identifier
                Case 1
                    Return Me._nullable
                Case 2
                    Return Me._arrayBounds
                Case 3
                    Return Me._arrayRankSpecifiers
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ModifiedIdentifierSyntax(kind, newErrors, GetAnnotations, _identifier, _nullable, _arrayBounds, _arrayRankSpecifiers)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ModifiedIdentifierSyntax(kind, GetDiagnostics, annotations, _identifier, _nullable, _arrayBounds, _arrayRankSpecifiers)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitModifiedIdentifier(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a modifier that describes an array type, without bounds, such as
    ''' "()" or "(,)".
    ''' </summary>
    Friend NotInheritable Class ArrayRankSpecifierSyntax
        Inherits SyntaxNode

        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _commaTokens as SyntaxNode
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, commaTokens As InternalSyntax.SyntaxNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(openParenToken)
            Me._openParenToken = openParenToken
            If commaTokens IsNot Nothing Then
                Init(commaTokens)
                Me._commaTokens = commaTokens
            End If
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openParenToken As InternalSyntax.PunctuationSyntax, commaTokens As InternalSyntax.SyntaxNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(openParenToken)
            Me._openParenToken = openParenToken
            If commaTokens IsNot Nothing Then
                Init(commaTokens)
                Me._commaTokens = commaTokens
            End If
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._openParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openParenToken)
          Me._commaTokens = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._commaTokens)
          Me._closeParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeParenToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._openParenToken)
          writer.WriteValue(Me._commaTokens)
          writer.WriteValue(Me._closeParenToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ArrayRankSpecifierSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend  ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The comma tokens in the array type. There is one less comma than the rank.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property CommaTokens As InternalSyntax.SyntaxList(Of PunctuationSyntax)
            Get
                Return New InternalSyntax.SyntaxList(of PunctuationSyntax)(Me._commaTokens)
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend  ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._openParenToken
                Case 1
                    Return Me._commaTokens
                Case 2
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ArrayRankSpecifierSyntax(kind, newErrors, GetAnnotations, _openParenToken, _commaTokens, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ArrayRankSpecifierSyntax(kind, GetDiagnostics, annotations, _openParenToken, _commaTokens, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitArrayRankSpecifier(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a group of attributes within "&lt;" and "&gt;" brackets.
    ''' </summary>
    Friend NotInheritable Class AttributeBlockSyntax
        Inherits SyntaxNode

        Friend ReadOnly _lessThanToken as PunctuationSyntax
        Friend ReadOnly _attributes as SyntaxNode
        Friend ReadOnly _greaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanToken As InternalSyntax.PunctuationSyntax, attributes As InternalSyntax.SyntaxNode, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(lessThanToken)
            Me._lessThanToken = lessThanToken
            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            Init(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanToken As InternalSyntax.PunctuationSyntax, attributes As InternalSyntax.SyntaxNode, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(lessThanToken)
            Me._lessThanToken = lessThanToken
            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            Init(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._lessThanToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._lessThanToken)
          Me._attributes = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._attributes)
          Me._greaterThanToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._greaterThanToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._lessThanToken)
          writer.WriteValue(Me._attributes)
          writer.WriteValue(Me._greaterThanToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.AttributeBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "&lt;" token.
        ''' </summary>
        Friend  ReadOnly Property LessThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanToken
            End Get
        End Property

        ''' <summary>
        ''' A comma separated list of attribute declarations in this attribute block.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Attributes As InternalSyntax.SeparatedSyntaxList(Of AttributeSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of AttributeSyntax)(New SyntaxList(of AttributeSyntax)(Me._attributes))
            End Get
        End Property

        ''' <summary>
        ''' The "&gt;" token.
        ''' </summary>
        Friend  ReadOnly Property GreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._greaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._lessThanToken
                Case 1
                    Return Me._attributes
                Case 2
                    Return Me._greaterThanToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new AttributeBlockSyntax(kind, newErrors, GetAnnotations, _lessThanToken, _attributes, _greaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new AttributeBlockSyntax(kind, GetDiagnostics, annotations, _lessThanToken, _attributes, _greaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitAttributeBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single attribute declaration within an attribute block.
    ''' </summary>
    Friend NotInheritable Class AttributeSyntax
        Inherits SyntaxNode

        Friend ReadOnly _target as AttributeTargetSyntax
        Friend ReadOnly _name as TypeSyntax
        Friend ReadOnly _argumentList as ArgumentListSyntax

        Friend Sub New(ByVal kind As SyntaxKind, target As AttributeTargetSyntax, name As TypeSyntax, argumentList As ArgumentListSyntax)
            MyBase.New(kind)

            If target IsNot Nothing Then
                Init(target)
                Me._target = target
            End If
            Init(name)
            Me._name = name
            If argumentList IsNot Nothing Then
                Init(argumentList)
                Me._argumentList = argumentList
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), target As AttributeTargetSyntax, name As TypeSyntax, argumentList As ArgumentListSyntax)
            MyBase.New(kind, errors, annotations)

            If target IsNot Nothing Then
                Init(target)
                Me._target = target
            End If
            Init(name)
            Me._name = name
            If argumentList IsNot Nothing Then
                Init(argumentList)
                Me._argumentList = argumentList
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._target = DirectCast(reader.ReadValue(), AttributeTargetSyntax)
          Init(Me._target)
          Me._name = DirectCast(reader.ReadValue(), TypeSyntax)
          Init(Me._name)
          Me._argumentList = DirectCast(reader.ReadValue(), ArgumentListSyntax)
          Init(Me._argumentList)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._target)
          writer.WriteValue(Me._name)
          writer.WriteValue(Me._argumentList)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.AttributeSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' Optional attribute target. Assembly|Module :
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Target As InternalSyntax.AttributeTargetSyntax
            Get
                Return Me._target
            End Get
        End Property

        ''' <summary>
        ''' The name of the attribute.
        ''' </summary>
        Friend  ReadOnly Property Name As InternalSyntax.TypeSyntax
            Get
                Return Me._name
            End Get
        End Property

        ''' <summary>
        ''' The argument list, if present. If no argument list was supplied, Nothing is
        ''' returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ArgumentList As InternalSyntax.ArgumentListSyntax
            Get
                Return Me._argumentList
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._target
                Case 1
                    Return Me._name
                Case 2
                    Return Me._argumentList
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new AttributeSyntax(kind, newErrors, GetAnnotations, _target, _name, _argumentList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new AttributeSyntax(kind, GetDiagnostics, annotations, _target, _name, _argumentList)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitAttribute(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single attribute declaration within an attribute block.
    ''' </summary>
    Friend NotInheritable Class AttributeTargetSyntax
        Inherits SyntaxNode

        Friend ReadOnly _attributeModifier as KeywordSyntax
        Friend ReadOnly _colonToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeModifier As InternalSyntax.KeywordSyntax, colonToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(attributeModifier)
            Me._attributeModifier = attributeModifier
            Init(colonToken)
            Me._colonToken = colonToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeModifier As InternalSyntax.KeywordSyntax, colonToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(attributeModifier)
            Me._attributeModifier = attributeModifier
            Init(colonToken)
            Me._colonToken = colonToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._attributeModifier = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._attributeModifier)
          Me._colonToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._colonToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._attributeModifier)
          writer.WriteValue(Me._colonToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.AttributeTargetSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Assembly" or "Module" attribute modifier, is present. If no attribute
        ''' modifier is present, Nothing is returned.
        ''' </summary>
        Friend  ReadOnly Property AttributeModifier As InternalSyntax.KeywordSyntax
            Get
                Return Me._attributeModifier
            End Get
        End Property

        ''' <summary>
        ''' The ":" token, if an attribute modifier is present. If no attribute modifier is
        ''' present, Nothing is returned.
        ''' </summary>
        Friend  ReadOnly Property ColonToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._colonToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributeModifier
                Case 1
                    Return Me._colonToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new AttributeTargetSyntax(kind, newErrors, GetAnnotations, _attributeModifier, _colonToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new AttributeTargetSyntax(kind, GetDiagnostics, annotations, _attributeModifier, _colonToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitAttributeTarget(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a file-level attribute, in which the attributes have no other
    ''' syntactic element they are attached to.
    ''' </summary>
    Friend NotInheritable Class AttributesStatementSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _attributes as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._attributes = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._attributes)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._attributes)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.AttributesStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The list of attribute blocks.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Attributes As InternalSyntax.SyntaxList(Of AttributeBlockSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of AttributeBlockSyntax)(Me._attributes)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._attributes
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new AttributesStatementSyntax(kind, newErrors, GetAnnotations, _attributes)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new AttributesStatementSyntax(kind, GetDiagnostics, annotations, _attributes)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitAttributesStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represent an expression in a statement context.
    ''' </summary>
    Friend NotInheritable Class ExpressionStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _questionToken as PunctuationSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, questionToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)

            If questionToken IsNot Nothing Then
                Init(questionToken)
                Me._questionToken = questionToken
            End If
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), questionToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            If questionToken IsNot Nothing Then
                Init(questionToken)
                Me._questionToken = questionToken
            End If
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._questionToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._questionToken)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._questionToken)
          writer.WriteValue(Me._expression)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ExpressionStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' "?" token, if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property QuestionToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._questionToken
            End Get
        End Property

        ''' <summary>
        ''' The expression.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._questionToken
                Case 1
                    Return Me._expression
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ExpressionStatementSyntax(kind, newErrors, GetAnnotations, _questionToken, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ExpressionStatementSyntax(kind, GetDiagnostics, annotations, _questionToken, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitExpressionStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a While...End While statement, including the While, body and End
    ''' While.
    ''' </summary>
    Friend NotInheritable Class WhileBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _begin as WhileStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _statements as SyntaxNode
        Friend ReadOnly _end as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, begin As WhileStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As WhileStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), WhileStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
          Me._end = DirectCast(reader.ReadValue(), EndBlockStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._statements)
          writer.WriteValue(Me._end)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.WhileBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The While statement that begins the block.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.WhileStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The statements contained in the While...End While. This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        ''' <summary>
        ''' The End While statement that ends the block.
        ''' </summary>
        Friend  ReadOnly Property [End] As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._statements
                Case 3
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new WhileBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new WhileBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitWhileBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an entire Using...End Using statement, including the Using, body and
    ''' End Using statements.
    ''' </summary>
    Friend NotInheritable Class UsingBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _begin as UsingStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _statements as SyntaxNode
        Friend ReadOnly _end as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, begin As UsingStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As UsingStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), UsingStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
          Me._end = DirectCast(reader.ReadValue(), EndBlockStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._statements)
          writer.WriteValue(Me._end)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.UsingBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The UsingStatement that begins the Using...End Using block.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.UsingStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The statements contained in the Using...End Using block. This might be an empty
        ''' list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        ''' <summary>
        ''' The End Using statement that ends the block.
        ''' </summary>
        Friend  ReadOnly Property [End] As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._statements
                Case 3
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new UsingBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new UsingBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitUsingBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a entire SyncLock...End SyncLock block, including the SyncLock
    ''' statement, the enclosed statements, and the End SyncLock statment.
    ''' </summary>
    Friend NotInheritable Class SyncLockBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _begin as SyncLockStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _statements as SyntaxNode
        Friend ReadOnly _end as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, begin As SyncLockStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As SyncLockStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), SyncLockStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
          Me._end = DirectCast(reader.ReadValue(), EndBlockStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._statements)
          writer.WriteValue(Me._end)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.SyncLockBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The SyncLock statement that begins the block.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.SyncLockStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The statements contained in the SyncLock...End SyncLock statement. This might
        ''' be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        ''' <summary>
        ''' The End SyncLock statement that ends the block.
        ''' </summary>
        Friend  ReadOnly Property [End] As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._statements
                Case 3
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new SyncLockBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new SyncLockBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitSyncLockBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a With...End With block, include the With statement, the body of the
    ''' block and the End With statement.
    ''' </summary>
    Friend NotInheritable Class WithBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _begin as WithStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _statements as SyntaxNode
        Friend ReadOnly _end as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, begin As WithStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As WithStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), WithStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
          Me._end = DirectCast(reader.ReadValue(), EndBlockStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._statements)
          writer.WriteValue(Me._end)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.WithBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The WithStatement that begins the With...End With block.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.WithStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The statements contained in the With...End With block. This might be an empty
        ''' list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        ''' <summary>
        ''' The End With statement that ends the block.
        ''' </summary>
        Friend  ReadOnly Property [End] As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._statements
                Case 3
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new WithBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new WithBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitWithBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the declaration of one or more local variables or constants.
    ''' </summary>
    Friend NotInheritable Class LocalDeclarationSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _modifiers as SyntaxNode
        Friend ReadOnly _declarators as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, modifiers As InternalSyntax.SyntaxNode, declarators As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            If modifiers IsNot Nothing Then
                Init(modifiers)
                Me._modifiers = modifiers
            End If
            If declarators IsNot Nothing Then
                Init(declarators)
                Me._declarators = declarators
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), modifiers As InternalSyntax.SyntaxNode, declarators As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            If modifiers IsNot Nothing Then
                Init(modifiers)
                Me._modifiers = modifiers
            End If
            If declarators IsNot Nothing Then
                Init(declarators)
                Me._declarators = declarators
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._modifiers = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._modifiers)
          Me._declarators = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._declarators)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._modifiers)
          writer.WriteValue(Me._declarators)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.LocalDeclarationSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The modifier token (Static, Dim or Const) that introduces this local variable
        ''' declaration.
        ''' </summary>
        Friend  ReadOnly Property Modifiers As InternalSyntax.SyntaxList(Of KeywordSyntax)
            Get
                Return New InternalSyntax.SyntaxList(of KeywordSyntax)(Me._modifiers)
            End Get
        End Property

        ''' <summary>
        ''' The list of variable declarator. Each declarator specifies one or more variable
        ''' names along with a type and/or initializer.
        ''' </summary>
        Friend  ReadOnly Property Declarators As InternalSyntax.SeparatedSyntaxList(Of VariableDeclaratorSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of VariableDeclaratorSyntax)(New SyntaxList(of VariableDeclaratorSyntax)(Me._declarators))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._modifiers
                Case 1
                    Return Me._declarators
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new LocalDeclarationSyntax(kind, newErrors, GetAnnotations, _modifiers, _declarators)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new LocalDeclarationSyntax(kind, GetDiagnostics, annotations, _modifiers, _declarators)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitLocalDeclaration(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a label statement.
    ''' </summary>
    Friend NotInheritable Class LabelStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _labelToken as SyntaxToken

        Friend Sub New(ByVal kind As SyntaxKind, labelToken As InternalSyntax.SyntaxToken)
            MyBase.New(kind)

            Init(labelToken)
            Me._labelToken = labelToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), labelToken As InternalSyntax.SyntaxToken)
            MyBase.New(kind, errors, annotations)

            Init(labelToken)
            Me._labelToken = labelToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._labelToken = DirectCast(reader.ReadValue(), SyntaxToken)
          Init(Me._labelToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._labelToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.LabelStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The name of the label. If the label is a line number, returns an IntegerLiteral
        ''' that is the line number, otherwise, returns an Identifier.
        ''' </summary>
        Friend  ReadOnly Property LabelToken As InternalSyntax.SyntaxToken
            Get
                Return Me._labelToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._labelToken
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new LabelStatementSyntax(kind, newErrors, GetAnnotations, _labelToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new LabelStatementSyntax(kind, GetDiagnostics, annotations, _labelToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitLabelStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "GoTo" statement.
    ''' </summary>
    Friend NotInheritable Class GoToStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _goToKeyword as KeywordSyntax
        Friend ReadOnly _label as LabelSyntax

        Friend Sub New(ByVal kind As SyntaxKind, goToKeyword As InternalSyntax.KeywordSyntax, label As LabelSyntax)
            MyBase.New(kind)

            Init(goToKeyword)
            Me._goToKeyword = goToKeyword
            Init(label)
            Me._label = label

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), goToKeyword As InternalSyntax.KeywordSyntax, label As LabelSyntax)
            MyBase.New(kind, errors, annotations)

            Init(goToKeyword)
            Me._goToKeyword = goToKeyword
            Init(label)
            Me._label = label

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._goToKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._goToKeyword)
          Me._label = DirectCast(reader.ReadValue(), LabelSyntax)
          Init(Me._label)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._goToKeyword)
          writer.WriteValue(Me._label)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.GoToStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "GoTo" keyword.
        ''' </summary>
        Friend  ReadOnly Property GoToKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._goToKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the label. If the label is a line number, wraps an IntegerLiteral
        ''' that is the line number, otherwise, wraps an Identifier.
        ''' </summary>
        Friend  ReadOnly Property Label As InternalSyntax.LabelSyntax
            Get
                Return Me._label
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._goToKeyword
                Case 1
                    Return Me._label
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new GoToStatementSyntax(kind, newErrors, GetAnnotations, _goToKeyword, _label)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new GoToStatementSyntax(kind, GetDiagnostics, annotations, _goToKeyword, _label)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitGoToStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' A label for a GoTo, Resume, or On Error statement. An identifier, line number,
    ''' or next keyword.
    ''' </summary>
    Friend NotInheritable Class LabelSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _labelToken as SyntaxToken

        Friend Sub New(ByVal kind As SyntaxKind, labelToken As InternalSyntax.SyntaxToken)
            MyBase.New(kind)

            Init(labelToken)
            Me._labelToken = labelToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), labelToken As InternalSyntax.SyntaxToken)
            MyBase.New(kind, errors, annotations)

            Init(labelToken)
            Me._labelToken = labelToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._labelToken = DirectCast(reader.ReadValue(), SyntaxToken)
          Init(Me._labelToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._labelToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.LabelSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The label name (identifier), line number (integer literal), or next keyword
        ''' token.
        ''' </summary>
        Friend  ReadOnly Property LabelToken As InternalSyntax.SyntaxToken
            Get
                Return Me._labelToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._labelToken
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new LabelSyntax(kind, newErrors, GetAnnotations, _labelToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new LabelSyntax(kind, GetDiagnostics, annotations, _labelToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitLabel(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Stop" or "End" statement. The Kind can be used to determine which
    ''' kind of statement this is.
    ''' </summary>
    Friend NotInheritable Class StopOrEndStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _stopOrEndKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, stopOrEndKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(stopOrEndKeyword)
            Me._stopOrEndKeyword = stopOrEndKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), stopOrEndKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(stopOrEndKeyword)
            Me._stopOrEndKeyword = stopOrEndKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._stopOrEndKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._stopOrEndKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._stopOrEndKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.StopOrEndStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Stop" or "End" keyword.
        ''' </summary>
        Friend  ReadOnly Property StopOrEndKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._stopOrEndKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._stopOrEndKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new StopOrEndStatementSyntax(kind, newErrors, GetAnnotations, _stopOrEndKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new StopOrEndStatementSyntax(kind, GetDiagnostics, annotations, _stopOrEndKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitStopOrEndStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' An exit statement. The kind of block being exited can be found by examining the
    ''' Kind.
    ''' </summary>
    Friend NotInheritable Class ExitStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _exitKeyword as KeywordSyntax
        Friend ReadOnly _blockKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, exitKeyword As InternalSyntax.KeywordSyntax, blockKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(exitKeyword)
            Me._exitKeyword = exitKeyword
            Init(blockKeyword)
            Me._blockKeyword = blockKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), exitKeyword As InternalSyntax.KeywordSyntax, blockKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(exitKeyword)
            Me._exitKeyword = exitKeyword
            Init(blockKeyword)
            Me._blockKeyword = blockKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._exitKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._exitKeyword)
          Me._blockKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._blockKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._exitKeyword)
          writer.WriteValue(Me._blockKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ExitStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Exit" keyword.
        ''' </summary>
        Friend  ReadOnly Property ExitKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._exitKeyword
            End Get
        End Property

        ''' <summary>
        ''' The keyword describing the block to exit.
        ''' </summary>
        Friend  ReadOnly Property BlockKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._blockKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._exitKeyword
                Case 1
                    Return Me._blockKeyword
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ExitStatementSyntax(kind, newErrors, GetAnnotations, _exitKeyword, _blockKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ExitStatementSyntax(kind, GetDiagnostics, annotations, _exitKeyword, _blockKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitExitStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Continue (block)" statement. THe kind of block referenced can be
    ''' determined by examining the Kind.
    ''' </summary>
    Friend NotInheritable Class ContinueStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _continueKeyword as KeywordSyntax
        Friend ReadOnly _blockKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, continueKeyword As InternalSyntax.KeywordSyntax, blockKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(continueKeyword)
            Me._continueKeyword = continueKeyword
            Init(blockKeyword)
            Me._blockKeyword = blockKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), continueKeyword As InternalSyntax.KeywordSyntax, blockKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(continueKeyword)
            Me._continueKeyword = continueKeyword
            Init(blockKeyword)
            Me._blockKeyword = blockKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._continueKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._continueKeyword)
          Me._blockKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._blockKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._continueKeyword)
          writer.WriteValue(Me._blockKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ContinueStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Continue" keyword.
        ''' </summary>
        Friend  ReadOnly Property ContinueKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._continueKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Do", "For" or "While" keyword that identifies the kind of loop being
        ''' continued.
        ''' </summary>
        Friend  ReadOnly Property BlockKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._blockKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._continueKeyword
                Case 1
                    Return Me._blockKeyword
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ContinueStatementSyntax(kind, newErrors, GetAnnotations, _continueKeyword, _blockKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ContinueStatementSyntax(kind, GetDiagnostics, annotations, _continueKeyword, _blockKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitContinueStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Return" statement.
    ''' </summary>
    Friend NotInheritable Class ReturnStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _returnKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, returnKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)

            Init(returnKeyword)
            Me._returnKeyword = returnKeyword
            If expression IsNot Nothing Then
                Init(expression)
                Me._expression = expression
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), returnKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(returnKeyword)
            Me._returnKeyword = returnKeyword
            If expression IsNot Nothing Then
                Init(expression)
                Me._expression = expression
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._returnKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._returnKeyword)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._returnKeyword)
          writer.WriteValue(Me._expression)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ReturnStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Return" keyword.
        ''' </summary>
        Friend  ReadOnly Property ReturnKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._returnKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression being returned, if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._returnKeyword
                Case 1
                    Return Me._expression
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ReturnStatementSyntax(kind, newErrors, GetAnnotations, _returnKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ReturnStatementSyntax(kind, GetDiagnostics, annotations, _returnKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitReturnStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a line If-Then-Else statement.
    ''' </summary>
    Friend NotInheritable Class SingleLineIfStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _ifPart as SingleLineIfPartSyntax
        Friend ReadOnly _elsePart as SingleLineElsePartSyntax

        Friend Sub New(ByVal kind As SyntaxKind, ifPart As SingleLineIfPartSyntax, elsePart As SingleLineElsePartSyntax)
            MyBase.New(kind)

            Init(ifPart)
            Me._ifPart = ifPart
            If elsePart IsNot Nothing Then
                Init(elsePart)
                Me._elsePart = elsePart
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), ifPart As SingleLineIfPartSyntax, elsePart As SingleLineElsePartSyntax)
            MyBase.New(kind, errors, annotations)

            Init(ifPart)
            Me._ifPart = ifPart
            If elsePart IsNot Nothing Then
                Init(elsePart)
                Me._elsePart = elsePart
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._ifPart = DirectCast(reader.ReadValue(), SingleLineIfPartSyntax)
          Init(Me._ifPart)
          Me._elsePart = DirectCast(reader.ReadValue(), SingleLineElsePartSyntax)
          Init(Me._elsePart)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._ifPart)
          writer.WriteValue(Me._elsePart)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.SingleLineIfStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The If part of the statement.
        ''' </summary>
        Friend  ReadOnly Property IfPart As InternalSyntax.SingleLineIfPartSyntax
            Get
                Return Me._ifPart
            End Get
        End Property

        ''' <summary>
        ''' The Else part of the statement. If there is no Else part, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ElsePart As InternalSyntax.SingleLineElsePartSyntax
            Get
                Return Me._elsePart
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._ifPart
                Case 1
                    Return Me._elsePart
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new SingleLineIfStatementSyntax(kind, newErrors, GetAnnotations, _ifPart, _elsePart)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new SingleLineIfStatementSyntax(kind, GetDiagnostics, annotations, _ifPart, _elsePart)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitSingleLineIfStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents part of a single line If statement, consisting of a beginning
    ''' if-statement, followed by a body of statement controlled by that beginning
    ''' statement. The Kind property returns if this is an SingleLineIf.
    ''' </summary>
    Friend NotInheritable Class SingleLineIfPartSyntax
        Inherits SyntaxNode

        Friend ReadOnly _begin as IfStatementSyntax
        Friend ReadOnly _statements as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, begin As IfStatementSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As IfStatementSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), IfStatementSyntax)
          Init(Me._begin)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._statements)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.SingleLineIfPartSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The statement that introduces this part of the If...Then...Else...End If. This
        ''' must be an IfStatement.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.IfStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statements controlled by this If or Else If. This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._statements
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new SingleLineIfPartSyntax(kind, newErrors, GetAnnotations, _begin, _statements)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new SingleLineIfPartSyntax(kind, GetDiagnostics, annotations, _begin, _statements)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitSingleLineIfPart(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the Else part of an If statement, consisting of a Else statement,
    ''' followed by a body of statement controlled by that Else.
    ''' </summary>
    Friend NotInheritable Class SingleLineElsePartSyntax
        Inherits SyntaxNode

        Friend ReadOnly _begin as ElseStatementSyntax
        Friend ReadOnly _statements as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, begin As ElseStatementSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As ElseStatementSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), ElseStatementSyntax)
          Init(Me._begin)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._statements)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.SingleLineElsePartSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The Else statement that introduces this part.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.ElseStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statements controlled by the Else.This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._statements
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new SingleLineElsePartSyntax(kind, newErrors, GetAnnotations, _begin, _statements)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new SingleLineElsePartSyntax(kind, GetDiagnostics, annotations, _begin, _statements)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitSingleLineElsePart(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a block If...Then...Else...EndIf Statement. The Kind property can be
    ''' used to determine if it is a block or line If.
    ''' </summary>
    Friend NotInheritable Class MultiLineIfBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _ifPart as IfPartSyntax
        Friend ReadOnly _elseIfParts as SyntaxNode
        Friend ReadOnly _elsePart as ElsePartSyntax
        Friend ReadOnly _end as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, ifPart As IfPartSyntax, elseIfParts As InternalSyntax.SyntaxNode, elsePart As ElsePartSyntax, [end] As EndBlockStatementSyntax)
            MyBase.New(kind)

            Init(ifPart)
            Me._ifPart = ifPart
            If elseIfParts IsNot Nothing Then
                Init(elseIfParts)
                Me._elseIfParts = elseIfParts
            End If
            If elsePart IsNot Nothing Then
                Init(elsePart)
                Me._elsePart = elsePart
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), ifPart As IfPartSyntax, elseIfParts As InternalSyntax.SyntaxNode, elsePart As ElsePartSyntax, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)

            Init(ifPart)
            Me._ifPart = ifPart
            If elseIfParts IsNot Nothing Then
                Init(elseIfParts)
                Me._elseIfParts = elseIfParts
            End If
            If elsePart IsNot Nothing Then
                Init(elsePart)
                Me._elsePart = elsePart
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._ifPart = DirectCast(reader.ReadValue(), IfPartSyntax)
          Init(Me._ifPart)
          Me._elseIfParts = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._elseIfParts)
          Me._elsePart = DirectCast(reader.ReadValue(), ElsePartSyntax)
          Init(Me._elsePart)
          Me._end = DirectCast(reader.ReadValue(), EndBlockStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._ifPart)
          writer.WriteValue(Me._elseIfParts)
          writer.WriteValue(Me._elsePart)
          writer.WriteValue(Me._end)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.MultiLineIfBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The If part of the statement.
        ''' </summary>
        Friend  ReadOnly Property IfPart As InternalSyntax.IfPartSyntax
            Get
                Return Me._ifPart
            End Get
        End Property

        ''' <summary>
        ''' A list of the "ElseIf" parts of the statement. If there are no ElseIf parts,
        ''' then an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property ElseIfParts As InternalSyntax.SyntaxList(Of IfPartSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of IfPartSyntax)(Me._elseIfParts)
            End Get
        End Property

        ''' <summary>
        ''' The Else part of the statement. If there is no Else part, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ElsePart As InternalSyntax.ElsePartSyntax
            Get
                Return Me._elsePart
            End Get
        End Property

        ''' <summary>
        ''' If this is a block if, returns the "End If" statement.
        ''' </summary>
        Friend  ReadOnly Property [End] As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._ifPart
                Case 1
                    Return Me._elseIfParts
                Case 2
                    Return Me._elsePart
                Case 3
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new MultiLineIfBlockSyntax(kind, newErrors, GetAnnotations, _ifPart, _elseIfParts, _elsePart, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new MultiLineIfBlockSyntax(kind, GetDiagnostics, annotations, _ifPart, _elseIfParts, _elsePart, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitMultiLineIfBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents part of an If statement, consisting of a beginning statement (If or
    ''' ElseIf), followed by a body of statement controlled by that beginning
    ''' statement. The Kind property returns if this is an If or ElseIf.
    ''' </summary>
    Friend NotInheritable Class IfPartSyntax
        Inherits SyntaxNode

        Friend ReadOnly _begin as IfStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _statements as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, begin As IfStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As IfStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), IfStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._statements)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.IfPartSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The statement that introduces this part of the If...Then...Else...End If. This
        ''' must be an IfStatement.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.IfStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The statements controlled by this If or Else If. This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._statements
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new IfPartSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _statements)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new IfPartSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _statements)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitIfPart(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the Else part of an If statement, consisting of a Else statement,
    ''' followed by a body of statement controlled by that Else.
    ''' </summary>
    Friend NotInheritable Class ElsePartSyntax
        Inherits SyntaxNode

        Friend ReadOnly _begin as ElseStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _statements as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, begin As ElseStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As ElseStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), ElseStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._statements)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ElsePartSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The Else statement that introduces this part.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.ElseStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The statements controlled by the Else. This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._statements
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ElsePartSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _statements)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ElsePartSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _statements)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitElsePart(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the If part or ElseIf part of a If...End If block (or line If). This
    ''' statement is always the Begin of a IfPart. The Kind can be examined to
    ''' determine if this is an If or an ElseIf statement.
    ''' </summary>
    Friend NotInheritable Class IfStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _elseKeyword as KeywordSyntax
        Friend ReadOnly _ifOrElseIfKeyword as KeywordSyntax
        Friend ReadOnly _condition as ExpressionSyntax
        Friend ReadOnly _thenKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, elseKeyword As InternalSyntax.KeywordSyntax, ifOrElseIfKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            If elseKeyword IsNot Nothing Then
                Init(elseKeyword)
                Me._elseKeyword = elseKeyword
            End If
            Init(ifOrElseIfKeyword)
            Me._ifOrElseIfKeyword = ifOrElseIfKeyword
            Init(condition)
            Me._condition = condition
            If thenKeyword IsNot Nothing Then
                Init(thenKeyword)
                Me._thenKeyword = thenKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), elseKeyword As InternalSyntax.KeywordSyntax, ifOrElseIfKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            If elseKeyword IsNot Nothing Then
                Init(elseKeyword)
                Me._elseKeyword = elseKeyword
            End If
            Init(ifOrElseIfKeyword)
            Me._ifOrElseIfKeyword = ifOrElseIfKeyword
            Init(condition)
            Me._condition = condition
            If thenKeyword IsNot Nothing Then
                Init(thenKeyword)
                Me._thenKeyword = thenKeyword
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._elseKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._elseKeyword)
          Me._ifOrElseIfKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._ifOrElseIfKeyword)
          Me._condition = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._condition)
          Me._thenKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._thenKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._elseKeyword)
          writer.WriteValue(Me._ifOrElseIfKeyword)
          writer.WriteValue(Me._condition)
          writer.WriteValue(Me._thenKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.IfStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' If this ElseIf was written as "Else If", contains the "Else" keyword. Otherwise
        ''' returns Nothing.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ElseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._elseKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "If" or "ElseIf" keyword.
        ''' </summary>
        Friend  ReadOnly Property IfOrElseIfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ifOrElseIfKeyword
            End Get
        End Property

        ''' <summary>
        ''' The boolean expression that is being tested.
        ''' </summary>
        Friend  ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        ''' <summary>
        ''' The "Then" keyword.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ThenKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._thenKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._elseKeyword
                Case 1
                    Return Me._ifOrElseIfKeyword
                Case 2
                    Return Me._condition
                Case 3
                    Return Me._thenKeyword
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new IfStatementSyntax(kind, newErrors, GetAnnotations, _elseKeyword, _ifOrElseIfKeyword, _condition, _thenKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new IfStatementSyntax(kind, GetDiagnostics, annotations, _elseKeyword, _ifOrElseIfKeyword, _condition, _thenKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitIfStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the Else part of a If...End If block (or line If). This statement is
    ''' always the Begin of a ElsePart.
    ''' </summary>
    Friend NotInheritable Class ElseStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _elseKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, elseKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(elseKeyword)
            Me._elseKeyword = elseKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), elseKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(elseKeyword)
            Me._elseKeyword = elseKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._elseKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._elseKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._elseKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ElseStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Else" keyword
        ''' </summary>
        Friend  ReadOnly Property ElseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._elseKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._elseKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ElseStatementSyntax(kind, newErrors, GetAnnotations, _elseKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ElseStatementSyntax(kind, GetDiagnostics, annotations, _elseKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitElseStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an entire Try...Catch...Finally...End Try statement.
    ''' </summary>
    Friend NotInheritable Class TryBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _tryPart as TryPartSyntax
        Friend ReadOnly _catchParts as SyntaxNode
        Friend ReadOnly _finallyPart as FinallyPartSyntax
        Friend ReadOnly _end as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, tryPart As TryPartSyntax, catchParts As InternalSyntax.SyntaxNode, finallyPart As FinallyPartSyntax, [end] As EndBlockStatementSyntax)
            MyBase.New(kind)

            Init(tryPart)
            Me._tryPart = tryPart
            If catchParts IsNot Nothing Then
                Init(catchParts)
                Me._catchParts = catchParts
            End If
            If finallyPart IsNot Nothing Then
                Init(finallyPart)
                Me._finallyPart = finallyPart
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), tryPart As TryPartSyntax, catchParts As InternalSyntax.SyntaxNode, finallyPart As FinallyPartSyntax, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)

            Init(tryPart)
            Me._tryPart = tryPart
            If catchParts IsNot Nothing Then
                Init(catchParts)
                Me._catchParts = catchParts
            End If
            If finallyPart IsNot Nothing Then
                Init(finallyPart)
                Me._finallyPart = finallyPart
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._tryPart = DirectCast(reader.ReadValue(), TryPartSyntax)
          Init(Me._tryPart)
          Me._catchParts = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._catchParts)
          Me._finallyPart = DirectCast(reader.ReadValue(), FinallyPartSyntax)
          Init(Me._finallyPart)
          Me._end = DirectCast(reader.ReadValue(), EndBlockStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._tryPart)
          writer.WriteValue(Me._catchParts)
          writer.WriteValue(Me._finallyPart)
          writer.WriteValue(Me._end)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.TryBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The Try part of the statement.
        ''' </summary>
        Friend  ReadOnly Property TryPart As InternalSyntax.TryPartSyntax
            Get
                Return Me._tryPart
            End Get
        End Property

        ''' <summary>
        ''' A list of the Catch parts of the statement. If there are no Catch parts, then
        ''' an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property CatchParts As InternalSyntax.SyntaxList(Of CatchPartSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of CatchPartSyntax)(Me._catchParts)
            End Get
        End Property

        ''' <summary>
        ''' The Finally part of the statement, if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property FinallyPart As InternalSyntax.FinallyPartSyntax
            Get
                Return Me._finallyPart
            End Get
        End Property

        ''' <summary>
        ''' The "End Try" statement.
        ''' </summary>
        Friend  ReadOnly Property [End] As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._tryPart
                Case 1
                    Return Me._catchParts
                Case 2
                    Return Me._finallyPart
                Case 3
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new TryBlockSyntax(kind, newErrors, GetAnnotations, _tryPart, _catchParts, _finallyPart, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new TryBlockSyntax(kind, GetDiagnostics, annotations, _tryPart, _catchParts, _finallyPart, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitTryBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents part of an Try...Catch...Finally...End Try statement, consisting of
    ''' a beginning statement (Try, Catch or Finally), followed by a body of statements
    ''' controlled by that beginning statement. The Kind property returns which kind of
    ''' part this is.
    ''' </summary>
    Friend NotInheritable Class TryPartSyntax
        Inherits SyntaxNode

        Friend ReadOnly _begin as TryStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _statements as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, begin As TryStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As TryStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), TryStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._statements)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.TryPartSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The TryStatement that introduces this part of the Try...Catch...Finally...End
        ''' Try.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.TryStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The statements inside the Try part of the Try...Catch...Finally...End Try. This
        ''' might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._statements
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new TryPartSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _statements)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new TryPartSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _statements)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitTryPart(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Catch part of an Try...Catch...Finally...End Try statement,
    ''' consisting of a Catch statement, followed by a body of statements controlled by
    ''' that Catch statement. The Kind property returns which kind of part this is.
    ''' </summary>
    Friend NotInheritable Class CatchPartSyntax
        Inherits SyntaxNode

        Friend ReadOnly _begin as CatchStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _statements as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, begin As CatchStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As CatchStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), CatchStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._statements)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.CatchPartSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The CatchStatement that introduces this part.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.CatchStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The statements controlled by the Catch statement. This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._statements
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new CatchPartSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _statements)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new CatchPartSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _statements)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitCatchPart(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the Finally part of an Try...Catch...Finally...End Try statement,
    ''' consisting of a Finally statement, followed by a body of statements controlled
    ''' by the Finally.
    ''' </summary>
    Friend NotInheritable Class FinallyPartSyntax
        Inherits SyntaxNode

        Friend ReadOnly _begin as FinallyStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _statements as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, begin As FinallyStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As FinallyStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), FinallyStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._statements)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.FinallyPartSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The FinallyStatement that introduces the Finally part of a Try.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.FinallyStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The statements inside the Finally part of the Try...Catch...Finally...End Try.
        ''' This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._statements
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new FinallyPartSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _statements)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new FinallyPartSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _statements)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitFinallyPart(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the Try part part of a Try...Catch...Finally...End Try. This
    ''' statement is always the Begin of a TryPart.
    ''' </summary>
    Friend NotInheritable Class TryStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _tryKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, tryKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(tryKeyword)
            Me._tryKeyword = tryKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), tryKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(tryKeyword)
            Me._tryKeyword = tryKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._tryKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._tryKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._tryKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.TryStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Try" keyword
        ''' </summary>
        Friend  ReadOnly Property TryKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._tryKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._tryKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new TryStatementSyntax(kind, newErrors, GetAnnotations, _tryKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new TryStatementSyntax(kind, GetDiagnostics, annotations, _tryKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitTryStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the Catch part part of a Try...Catch...Finally...End Try. This
    ''' statement is always the Begin of a CatchPart.
    ''' </summary>
    Friend NotInheritable Class CatchStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _catchKeyword as KeywordSyntax
        Friend ReadOnly _identifierName as IdentifierNameSyntax
        Friend ReadOnly _asClause as SimpleAsClauseSyntax
        Friend ReadOnly _whenClause as CatchFilterClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, catchKeyword As InternalSyntax.KeywordSyntax, identifierName As IdentifierNameSyntax, asClause As SimpleAsClauseSyntax, whenClause As CatchFilterClauseSyntax)
            MyBase.New(kind)

            Init(catchKeyword)
            Me._catchKeyword = catchKeyword
            If identifierName IsNot Nothing Then
                Init(identifierName)
                Me._identifierName = identifierName
            End If
            If asClause IsNot Nothing Then
                Init(asClause)
                Me._asClause = asClause
            End If
            If whenClause IsNot Nothing Then
                Init(whenClause)
                Me._whenClause = whenClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), catchKeyword As InternalSyntax.KeywordSyntax, identifierName As IdentifierNameSyntax, asClause As SimpleAsClauseSyntax, whenClause As CatchFilterClauseSyntax)
            MyBase.New(kind, errors, annotations)

            Init(catchKeyword)
            Me._catchKeyword = catchKeyword
            If identifierName IsNot Nothing Then
                Init(identifierName)
                Me._identifierName = identifierName
            End If
            If asClause IsNot Nothing Then
                Init(asClause)
                Me._asClause = asClause
            End If
            If whenClause IsNot Nothing Then
                Init(whenClause)
                Me._whenClause = whenClause
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._catchKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._catchKeyword)
          Me._identifierName = DirectCast(reader.ReadValue(), IdentifierNameSyntax)
          Init(Me._identifierName)
          Me._asClause = DirectCast(reader.ReadValue(), SimpleAsClauseSyntax)
          Init(Me._asClause)
          Me._whenClause = DirectCast(reader.ReadValue(), CatchFilterClauseSyntax)
          Init(Me._whenClause)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._catchKeyword)
          writer.WriteValue(Me._identifierName)
          writer.WriteValue(Me._asClause)
          writer.WriteValue(Me._whenClause)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.CatchStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Catch" keyword.
        ''' </summary>
        Friend  ReadOnly Property CatchKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._catchKeyword
            End Get
        End Property

        ''' <summary>
        ''' The identifier representing the exception that was caught, if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property IdentifierName As InternalSyntax.IdentifierNameSyntax
            Get
                Return Me._identifierName
            End Get
        End Property

        ''' <summary>
        ''' The As clause that defines the type of exception being caught.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        ''' <summary>
        ''' The "When" clause, if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property WhenClause As InternalSyntax.CatchFilterClauseSyntax
            Get
                Return Me._whenClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._catchKeyword
                Case 1
                    Return Me._identifierName
                Case 2
                    Return Me._asClause
                Case 3
                    Return Me._whenClause
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new CatchStatementSyntax(kind, newErrors, GetAnnotations, _catchKeyword, _identifierName, _asClause, _whenClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new CatchStatementSyntax(kind, GetDiagnostics, annotations, _catchKeyword, _identifierName, _asClause, _whenClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitCatchStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the When/Filter clause of a Catch statement
    ''' </summary>
    Friend NotInheritable Class CatchFilterClauseSyntax
        Inherits SyntaxNode

        Friend ReadOnly _whenKeyword as KeywordSyntax
        Friend ReadOnly _filter as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, whenKeyword As InternalSyntax.KeywordSyntax, filter As ExpressionSyntax)
            MyBase.New(kind)

            Init(whenKeyword)
            Me._whenKeyword = whenKeyword
            Init(filter)
            Me._filter = filter

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), whenKeyword As InternalSyntax.KeywordSyntax, filter As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(whenKeyword)
            Me._whenKeyword = whenKeyword
            Init(filter)
            Me._filter = filter

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._whenKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._whenKeyword)
          Me._filter = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._filter)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._whenKeyword)
          writer.WriteValue(Me._filter)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.CatchFilterClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "When" keyword
        ''' </summary>
        Friend  ReadOnly Property WhenKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._whenKeyword
            End Get
        End Property

        ''' <summary>
        ''' The filter expression
        ''' </summary>
        Friend  ReadOnly Property Filter As InternalSyntax.ExpressionSyntax
            Get
                Return Me._filter
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._whenKeyword
                Case 1
                    Return Me._filter
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new CatchFilterClauseSyntax(kind, newErrors, GetAnnotations, _whenKeyword, _filter)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new CatchFilterClauseSyntax(kind, GetDiagnostics, annotations, _whenKeyword, _filter)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitCatchFilterClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the Finally part part of a Try...Catch...Finally...End Try. This
    ''' statement is always the Begin of a FinallyPart.
    ''' </summary>
    Friend NotInheritable Class FinallyStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _finallyKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, finallyKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(finallyKeyword)
            Me._finallyKeyword = finallyKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), finallyKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(finallyKeyword)
            Me._finallyKeyword = finallyKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._finallyKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._finallyKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._finallyKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.FinallyStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Finally" keyword.
        ''' </summary>
        Friend  ReadOnly Property FinallyKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._finallyKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._finallyKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new FinallyStatementSyntax(kind, newErrors, GetAnnotations, _finallyKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new FinallyStatementSyntax(kind, GetDiagnostics, annotations, _finallyKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitFinallyStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Error" statement.
    ''' </summary>
    Friend NotInheritable Class ErrorStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _errorKeyword as KeywordSyntax
        Friend ReadOnly _errorNumber as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, errorKeyword As InternalSyntax.KeywordSyntax, errorNumber As ExpressionSyntax)
            MyBase.New(kind)

            Init(errorKeyword)
            Me._errorKeyword = errorKeyword
            Init(errorNumber)
            Me._errorNumber = errorNumber

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), errorKeyword As InternalSyntax.KeywordSyntax, errorNumber As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(errorKeyword)
            Me._errorKeyword = errorKeyword
            Init(errorNumber)
            Me._errorNumber = errorNumber

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._errorKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._errorKeyword)
          Me._errorNumber = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._errorNumber)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._errorKeyword)
          writer.WriteValue(Me._errorNumber)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ErrorStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Error" keyword.
        ''' </summary>
        Friend  ReadOnly Property ErrorKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._errorKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression that represents the error number.
        ''' </summary>
        Friend  ReadOnly Property ErrorNumber As InternalSyntax.ExpressionSyntax
            Get
                Return Me._errorNumber
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._errorKeyword
                Case 1
                    Return Me._errorNumber
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ErrorStatementSyntax(kind, newErrors, GetAnnotations, _errorKeyword, _errorNumber)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ErrorStatementSyntax(kind, GetDiagnostics, annotations, _errorKeyword, _errorNumber)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitErrorStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an OnError Goto statement.
    ''' </summary>
    Friend NotInheritable Class OnErrorGoToStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _onKeyword as KeywordSyntax
        Friend ReadOnly _errorKeyword as KeywordSyntax
        Friend ReadOnly _goToKeyword as KeywordSyntax
        Friend ReadOnly _minus as PunctuationSyntax
        Friend ReadOnly _label as LabelSyntax

        Friend Sub New(ByVal kind As SyntaxKind, onKeyword As InternalSyntax.KeywordSyntax, errorKeyword As InternalSyntax.KeywordSyntax, goToKeyword As InternalSyntax.KeywordSyntax, minus As InternalSyntax.PunctuationSyntax, label As LabelSyntax)
            MyBase.New(kind)

            Init(onKeyword)
            Me._onKeyword = onKeyword
            Init(errorKeyword)
            Me._errorKeyword = errorKeyword
            Init(goToKeyword)
            Me._goToKeyword = goToKeyword
            If minus IsNot Nothing Then
                Init(minus)
                Me._minus = minus
            End If
            Init(label)
            Me._label = label

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), onKeyword As InternalSyntax.KeywordSyntax, errorKeyword As InternalSyntax.KeywordSyntax, goToKeyword As InternalSyntax.KeywordSyntax, minus As InternalSyntax.PunctuationSyntax, label As LabelSyntax)
            MyBase.New(kind, errors, annotations)

            Init(onKeyword)
            Me._onKeyword = onKeyword
            Init(errorKeyword)
            Me._errorKeyword = errorKeyword
            Init(goToKeyword)
            Me._goToKeyword = goToKeyword
            If minus IsNot Nothing Then
                Init(minus)
                Me._minus = minus
            End If
            Init(label)
            Me._label = label

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._onKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._onKeyword)
          Me._errorKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._errorKeyword)
          Me._goToKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._goToKeyword)
          Me._minus = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._minus)
          Me._label = DirectCast(reader.ReadValue(), LabelSyntax)
          Init(Me._label)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._onKeyword)
          writer.WriteValue(Me._errorKeyword)
          writer.WriteValue(Me._goToKeyword)
          writer.WriteValue(Me._minus)
          writer.WriteValue(Me._label)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.OnErrorGoToStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "On" keyword
        ''' </summary>
        Friend  ReadOnly Property OnKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._onKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Error" keyword.
        ''' </summary>
        Friend  ReadOnly Property ErrorKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._errorKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "GoTo" keyword
        ''' </summary>
        Friend  ReadOnly Property GoToKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._goToKeyword
            End Get
        End Property

        ''' <summary>
        ''' An optional minus for On Error Goto -1
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Minus As InternalSyntax.PunctuationSyntax
            Get
                Return Me._minus
            End Get
        End Property

        ''' <summary>
        ''' The name of the label. If the label is a line number, 0 or -1, wraps an
        ''' IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
        ''' </summary>
        Friend  ReadOnly Property Label As InternalSyntax.LabelSyntax
            Get
                Return Me._label
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._onKeyword
                Case 1
                    Return Me._errorKeyword
                Case 2
                    Return Me._goToKeyword
                Case 3
                    Return Me._minus
                Case 4
                    Return Me._label
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new OnErrorGoToStatementSyntax(kind, newErrors, GetAnnotations, _onKeyword, _errorKeyword, _goToKeyword, _minus, _label)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new OnErrorGoToStatementSyntax(kind, GetDiagnostics, annotations, _onKeyword, _errorKeyword, _goToKeyword, _minus, _label)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitOnErrorGoToStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an OnError Resume Next statement.
    ''' </summary>
    Friend NotInheritable Class OnErrorResumeNextStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _onKeyword as KeywordSyntax
        Friend ReadOnly _errorKeyword as KeywordSyntax
        Friend ReadOnly _resumeKeyword as KeywordSyntax
        Friend ReadOnly _nextKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, onKeyword As InternalSyntax.KeywordSyntax, errorKeyword As InternalSyntax.KeywordSyntax, resumeKeyword As InternalSyntax.KeywordSyntax, nextKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(onKeyword)
            Me._onKeyword = onKeyword
            Init(errorKeyword)
            Me._errorKeyword = errorKeyword
            Init(resumeKeyword)
            Me._resumeKeyword = resumeKeyword
            Init(nextKeyword)
            Me._nextKeyword = nextKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), onKeyword As InternalSyntax.KeywordSyntax, errorKeyword As InternalSyntax.KeywordSyntax, resumeKeyword As InternalSyntax.KeywordSyntax, nextKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(onKeyword)
            Me._onKeyword = onKeyword
            Init(errorKeyword)
            Me._errorKeyword = errorKeyword
            Init(resumeKeyword)
            Me._resumeKeyword = resumeKeyword
            Init(nextKeyword)
            Me._nextKeyword = nextKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._onKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._onKeyword)
          Me._errorKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._errorKeyword)
          Me._resumeKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._resumeKeyword)
          Me._nextKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._nextKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._onKeyword)
          writer.WriteValue(Me._errorKeyword)
          writer.WriteValue(Me._resumeKeyword)
          writer.WriteValue(Me._nextKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.OnErrorResumeNextStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "On" keyword
        ''' </summary>
        Friend  ReadOnly Property OnKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._onKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Error" keyword.
        ''' </summary>
        Friend  ReadOnly Property ErrorKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._errorKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Resume" keyword.
        ''' </summary>
        Friend  ReadOnly Property ResumeKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._resumeKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Next"
        ''' </summary>
        Friend  ReadOnly Property NextKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._nextKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._onKeyword
                Case 1
                    Return Me._errorKeyword
                Case 2
                    Return Me._resumeKeyword
                Case 3
                    Return Me._nextKeyword
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new OnErrorResumeNextStatementSyntax(kind, newErrors, GetAnnotations, _onKeyword, _errorKeyword, _resumeKeyword, _nextKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new OnErrorResumeNextStatementSyntax(kind, GetDiagnostics, annotations, _onKeyword, _errorKeyword, _resumeKeyword, _nextKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitOnErrorResumeNextStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Resume" statement. The Kind property can be used to determine if
    ''' this is a "Resume", "Resume Next" or "Resume label" statement.
    ''' </summary>
    Friend NotInheritable Class ResumeStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _resumeKeyword as KeywordSyntax
        Friend ReadOnly _label as LabelSyntax

        Friend Sub New(ByVal kind As SyntaxKind, resumeKeyword As InternalSyntax.KeywordSyntax, label As LabelSyntax)
            MyBase.New(kind)

            Init(resumeKeyword)
            Me._resumeKeyword = resumeKeyword
            If label IsNot Nothing Then
                Init(label)
                Me._label = label
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), resumeKeyword As InternalSyntax.KeywordSyntax, label As LabelSyntax)
            MyBase.New(kind, errors, annotations)

            Init(resumeKeyword)
            Me._resumeKeyword = resumeKeyword
            If label IsNot Nothing Then
                Init(label)
                Me._label = label
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._resumeKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._resumeKeyword)
          Me._label = DirectCast(reader.ReadValue(), LabelSyntax)
          Init(Me._label)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._resumeKeyword)
          writer.WriteValue(Me._label)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ResumeStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Resume" keyword.
        ''' </summary>
        Friend  ReadOnly Property ResumeKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._resumeKeyword
            End Get
        End Property

        ''' <summary>
        ''' The label. The value of this depends on the Kind. If Kind=Resume, returns
        ''' Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
        ''' wraps an Identifier or IntegerLiteralToken with the label or line number.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Label As InternalSyntax.LabelSyntax
            Get
                Return Me._label
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._resumeKeyword
                Case 1
                    Return Me._label
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ResumeStatementSyntax(kind, newErrors, GetAnnotations, _resumeKeyword, _label)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ResumeStatementSyntax(kind, GetDiagnostics, annotations, _resumeKeyword, _label)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitResumeStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Select Case block, including the Select Case that begins it, the
    ''' contains Case blocks and the End Select.
    ''' </summary>
    Friend NotInheritable Class SelectBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _begin as SelectStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _caseBlocks as SyntaxNode
        Friend ReadOnly _end as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, begin As SelectStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, caseBlocks As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If caseBlocks IsNot Nothing Then
                Init(caseBlocks)
                Me._caseBlocks = caseBlocks
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As SelectStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, caseBlocks As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If caseBlocks IsNot Nothing Then
                Init(caseBlocks)
                Me._caseBlocks = caseBlocks
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), SelectStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._caseBlocks = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._caseBlocks)
          Me._end = DirectCast(reader.ReadValue(), EndBlockStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._caseBlocks)
          writer.WriteValue(Me._end)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.SelectBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The Select Case statement that begins the block.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.SelectStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' A list of the contained Case blocks.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property CaseBlocks As InternalSyntax.SyntaxList(Of CaseBlockSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of CaseBlockSyntax)(Me._caseBlocks)
            End Get
        End Property

        ''' <summary>
        ''' The End Select statement that ends the block.
        ''' </summary>
        Friend  ReadOnly Property [End] As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._caseBlocks
                Case 3
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new SelectBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _caseBlocks, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new SelectBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _caseBlocks, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitSelectBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Select Case statement. This statement always occurs as the Begin
    ''' of a SelectBlock.
    ''' </summary>
    Friend NotInheritable Class SelectStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _selectKeyword as KeywordSyntax
        Friend ReadOnly _caseKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, selectKeyword As InternalSyntax.KeywordSyntax, caseKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)

            Init(selectKeyword)
            Me._selectKeyword = selectKeyword
            If caseKeyword IsNot Nothing Then
                Init(caseKeyword)
                Me._caseKeyword = caseKeyword
            End If
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), selectKeyword As InternalSyntax.KeywordSyntax, caseKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(selectKeyword)
            Me._selectKeyword = selectKeyword
            If caseKeyword IsNot Nothing Then
                Init(caseKeyword)
                Me._caseKeyword = caseKeyword
            End If
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._selectKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._selectKeyword)
          Me._caseKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._caseKeyword)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._selectKeyword)
          writer.WriteValue(Me._caseKeyword)
          writer.WriteValue(Me._expression)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.SelectStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Select" keyword.
        ''' </summary>
        Friend  ReadOnly Property SelectKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._selectKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Case" keyword, if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property CaseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._caseKeyword
            End Get
        End Property

        ''' <summary>
        ''' The value that branching is based on.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._selectKeyword
                Case 1
                    Return Me._caseKeyword
                Case 2
                    Return Me._expression
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new SelectStatementSyntax(kind, newErrors, GetAnnotations, _selectKeyword, _caseKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new SelectStatementSyntax(kind, GetDiagnostics, annotations, _selectKeyword, _caseKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitSelectStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a case statement and its subsequent block.
    ''' </summary>
    Friend NotInheritable Class CaseBlockSyntax
        Inherits SyntaxNode

        Friend ReadOnly _begin as CaseStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _statements as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, begin As CaseStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As CaseStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), CaseStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._statements)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.CaseBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The statement that begins the case block.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.CaseStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The statements contained in the case block. This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._statements
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new CaseBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _statements)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new CaseBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _statements)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitCaseBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Case or Case Else statement. This statement is always the Begin of
    ''' a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
    ''' Kind=Case.
    ''' </summary>
    Friend NotInheritable Class CaseStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _caseKeyword as KeywordSyntax
        Friend ReadOnly _cases as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, caseKeyword As InternalSyntax.KeywordSyntax, cases As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(caseKeyword)
            Me._caseKeyword = caseKeyword
            If cases IsNot Nothing Then
                Init(cases)
                Me._cases = cases
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), caseKeyword As InternalSyntax.KeywordSyntax, cases As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(caseKeyword)
            Me._caseKeyword = caseKeyword
            If cases IsNot Nothing Then
                Init(cases)
                Me._cases = cases
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._caseKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._caseKeyword)
          Me._cases = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._cases)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._caseKeyword)
          writer.WriteValue(Me._cases)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.CaseStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Case" keyword
        ''' </summary>
        Friend  ReadOnly Property CaseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._caseKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of clauses associated with this Case. If Kind=CaseElse, then this list
        ''' has exactly one child, which is a CaseElseClause.
        ''' </summary>
        Friend  ReadOnly Property Cases As InternalSyntax.SeparatedSyntaxList(Of CaseClauseSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of CaseClauseSyntax)(New SyntaxList(of CaseClauseSyntax)(Me._cases))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._caseKeyword
                Case 1
                    Return Me._cases
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new CaseStatementSyntax(kind, newErrors, GetAnnotations, _caseKeyword, _cases)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new CaseStatementSyntax(kind, GetDiagnostics, annotations, _caseKeyword, _cases)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitCaseStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single clause in a case statement. An abstract node that is the
    ''' parent of different kinds of Case clauses.
    ''' </summary>
    Friend MustInherit Class CaseClauseSyntax
        Inherits SyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' The "Else" part in a Case Else statement.
    ''' </summary>
    Friend NotInheritable Class CaseElseClauseSyntax
        Inherits CaseClauseSyntax

        Friend ReadOnly _elseKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, elseKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(elseKeyword)
            Me._elseKeyword = elseKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), elseKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(elseKeyword)
            Me._elseKeyword = elseKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._elseKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._elseKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._elseKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.CaseElseClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Else" keyword.
        ''' </summary>
        Friend  ReadOnly Property ElseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._elseKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._elseKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new CaseElseClauseSyntax(kind, newErrors, GetAnnotations, _elseKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new CaseElseClauseSyntax(kind, GetDiagnostics, annotations, _elseKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitCaseElseClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single value in a Case.
    ''' </summary>
    Friend NotInheritable Class CaseValueClauseSyntax
        Inherits CaseClauseSyntax

        Friend ReadOnly _value as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, value As ExpressionSyntax)
            MyBase.New(kind)

            Init(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), value As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(value)
            Me._value = value

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._value = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._value)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._value)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.CaseValueClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The expression that denotes the value being tested against.
        ''' </summary>
        Friend  ReadOnly Property Value As InternalSyntax.ExpressionSyntax
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._value
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new CaseValueClauseSyntax(kind, newErrors, GetAnnotations, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new CaseValueClauseSyntax(kind, GetDiagnostics, annotations, _value)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitCaseValueClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a range "expression To expression" in a Case.
    ''' </summary>
    Friend NotInheritable Class CaseRangeClauseSyntax
        Inherits CaseClauseSyntax

        Friend ReadOnly _lowerBound as ExpressionSyntax
        Friend ReadOnly _toKeyword as KeywordSyntax
        Friend ReadOnly _upperBound as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lowerBound As ExpressionSyntax, toKeyword As InternalSyntax.KeywordSyntax, upperBound As ExpressionSyntax)
            MyBase.New(kind)

            Init(lowerBound)
            Me._lowerBound = lowerBound
            Init(toKeyword)
            Me._toKeyword = toKeyword
            Init(upperBound)
            Me._upperBound = upperBound

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lowerBound As ExpressionSyntax, toKeyword As InternalSyntax.KeywordSyntax, upperBound As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(lowerBound)
            Me._lowerBound = lowerBound
            Init(toKeyword)
            Me._toKeyword = toKeyword
            Init(upperBound)
            Me._upperBound = upperBound

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._lowerBound = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._lowerBound)
          Me._toKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._toKeyword)
          Me._upperBound = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._upperBound)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._lowerBound)
          writer.WriteValue(Me._toKeyword)
          writer.WriteValue(Me._upperBound)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.CaseRangeClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The lower bound of the range.
        ''' </summary>
        Friend  ReadOnly Property LowerBound As InternalSyntax.ExpressionSyntax
            Get
                Return Me._lowerBound
            End Get
        End Property

        ''' <summary>
        ''' The "To" keyword
        ''' </summary>
        Friend  ReadOnly Property ToKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._toKeyword
            End Get
        End Property

        ''' <summary>
        ''' The upper bound of the range.
        ''' </summary>
        Friend  ReadOnly Property UpperBound As InternalSyntax.ExpressionSyntax
            Get
                Return Me._upperBound
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._lowerBound
                Case 1
                    Return Me._toKeyword
                Case 2
                    Return Me._upperBound
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new CaseRangeClauseSyntax(kind, newErrors, GetAnnotations, _lowerBound, _toKeyword, _upperBound)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new CaseRangeClauseSyntax(kind, GetDiagnostics, annotations, _lowerBound, _toKeyword, _upperBound)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitCaseRangeClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
    ''' </summary>
    Friend NotInheritable Class CaseRelationalClauseSyntax
        Inherits CaseClauseSyntax

        Friend ReadOnly _isKeyword as KeywordSyntax
        Friend ReadOnly _operatorToken as PunctuationSyntax
        Friend ReadOnly _value as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, isKeyword As InternalSyntax.KeywordSyntax, operatorToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax)
            MyBase.New(kind)

            If isKeyword IsNot Nothing Then
                Init(isKeyword)
                Me._isKeyword = isKeyword
            End If
            Init(operatorToken)
            Me._operatorToken = operatorToken
            Init(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), isKeyword As InternalSyntax.KeywordSyntax, operatorToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            If isKeyword IsNot Nothing Then
                Init(isKeyword)
                Me._isKeyword = isKeyword
            End If
            Init(operatorToken)
            Me._operatorToken = operatorToken
            Init(value)
            Me._value = value

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._isKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._isKeyword)
          Me._operatorToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._operatorToken)
          Me._value = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._value)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._isKeyword)
          writer.WriteValue(Me._operatorToken)
          writer.WriteValue(Me._value)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.CaseRelationalClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Is" keyword, if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property IsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._isKeyword
            End Get
        End Property

        ''' <summary>
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </summary>
        Friend  ReadOnly Property OperatorToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._operatorToken
            End Get
        End Property

        ''' <summary>
        ''' The expression that denotes the value being tested against.
        ''' </summary>
        Friend  ReadOnly Property Value As InternalSyntax.ExpressionSyntax
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._isKeyword
                Case 1
                    Return Me._operatorToken
                Case 2
                    Return Me._value
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new CaseRelationalClauseSyntax(kind, newErrors, GetAnnotations, _isKeyword, _operatorToken, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new CaseRelationalClauseSyntax(kind, GetDiagnostics, annotations, _isKeyword, _operatorToken, _value)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitCaseRelationalClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "SyncLock" statement. This statement always occurs as the Begin
    ''' of a SyncLockBlock.
    ''' </summary>
    Friend NotInheritable Class SyncLockStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _syncLockKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, syncLockKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)

            Init(syncLockKeyword)
            Me._syncLockKeyword = syncLockKeyword
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), syncLockKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(syncLockKeyword)
            Me._syncLockKeyword = syncLockKeyword
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._syncLockKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._syncLockKeyword)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._syncLockKeyword)
          writer.WriteValue(Me._expression)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.SyncLockStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "SyncLock" keyword.
        ''' </summary>
        Friend  ReadOnly Property SyncLockKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._syncLockKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression being synchronized on.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._syncLockKeyword
                Case 1
                    Return Me._expression
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new SyncLockStatementSyntax(kind, newErrors, GetAnnotations, _syncLockKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new SyncLockStatementSyntax(kind, GetDiagnostics, annotations, _syncLockKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitSyncLockStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Do-Loop block. The Kind property can be used to determine if this
    ''' is a top-test, bottom-test or infinite loop.
    ''' </summary>
    Friend NotInheritable Class DoLoopBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _begin as DoStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _statements as SyntaxNode
        Friend ReadOnly _end as LoopStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, begin As DoStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As LoopStatementSyntax)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As DoStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As LoopStatementSyntax)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), DoStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
          Me._end = DirectCast(reader.ReadValue(), LoopStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._statements)
          writer.WriteValue(Me._end)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.DoLoopBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The Do statement that begins the block.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.DoStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        ''' <summary>
        ''' The Loop statement that ends the block.
        ''' </summary>
        Friend  ReadOnly Property [End] As InternalSyntax.LoopStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._statements
                Case 3
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new DoLoopBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new DoLoopBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitDoLoopBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' The Do statement that begins a Do-Loop block. This statement always occurs as
    ''' the Begin of a DoLoopBlock.
    ''' </summary>
    Friend NotInheritable Class DoStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _doKeyword as KeywordSyntax
        Friend ReadOnly _whileUntilClause as WhileUntilClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, doKeyword As InternalSyntax.KeywordSyntax, whileUntilClause As WhileUntilClauseSyntax)
            MyBase.New(kind)

            Init(doKeyword)
            Me._doKeyword = doKeyword
            If whileUntilClause IsNot Nothing Then
                Init(whileUntilClause)
                Me._whileUntilClause = whileUntilClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), doKeyword As InternalSyntax.KeywordSyntax, whileUntilClause As WhileUntilClauseSyntax)
            MyBase.New(kind, errors, annotations)

            Init(doKeyword)
            Me._doKeyword = doKeyword
            If whileUntilClause IsNot Nothing Then
                Init(whileUntilClause)
                Me._whileUntilClause = whileUntilClause
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._doKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._doKeyword)
          Me._whileUntilClause = DirectCast(reader.ReadValue(), WhileUntilClauseSyntax)
          Init(Me._whileUntilClause)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._doKeyword)
          writer.WriteValue(Me._whileUntilClause)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.DoStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Do" keyword.
        ''' </summary>
        Friend  ReadOnly Property DoKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._doKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "While expression" or "Until expression" part of the Do statement, if
        ''' present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property WhileUntilClause As InternalSyntax.WhileUntilClauseSyntax
            Get
                Return Me._whileUntilClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._doKeyword
                Case 1
                    Return Me._whileUntilClause
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new DoStatementSyntax(kind, newErrors, GetAnnotations, _doKeyword, _whileUntilClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new DoStatementSyntax(kind, GetDiagnostics, annotations, _doKeyword, _whileUntilClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitDoStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' The Loop statement that ends a Do-Loop block. This statement always occurs as
    ''' the End of a DoLoopBlock.
    ''' </summary>
    Friend NotInheritable Class LoopStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _loopKeyword as KeywordSyntax
        Friend ReadOnly _whileUntilClause as WhileUntilClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, loopKeyword As InternalSyntax.KeywordSyntax, whileUntilClause As WhileUntilClauseSyntax)
            MyBase.New(kind)

            Init(loopKeyword)
            Me._loopKeyword = loopKeyword
            If whileUntilClause IsNot Nothing Then
                Init(whileUntilClause)
                Me._whileUntilClause = whileUntilClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), loopKeyword As InternalSyntax.KeywordSyntax, whileUntilClause As WhileUntilClauseSyntax)
            MyBase.New(kind, errors, annotations)

            Init(loopKeyword)
            Me._loopKeyword = loopKeyword
            If whileUntilClause IsNot Nothing Then
                Init(whileUntilClause)
                Me._whileUntilClause = whileUntilClause
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._loopKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._loopKeyword)
          Me._whileUntilClause = DirectCast(reader.ReadValue(), WhileUntilClauseSyntax)
          Init(Me._whileUntilClause)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._loopKeyword)
          writer.WriteValue(Me._whileUntilClause)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.LoopStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Loop" keyword.
        ''' </summary>
        Friend  ReadOnly Property LoopKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._loopKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "While expression" or "Until expression" part of the Loop statement, if
        ''' present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property WhileUntilClause As InternalSyntax.WhileUntilClauseSyntax
            Get
                Return Me._whileUntilClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._loopKeyword
                Case 1
                    Return Me._whileUntilClause
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new LoopStatementSyntax(kind, newErrors, GetAnnotations, _loopKeyword, _whileUntilClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new LoopStatementSyntax(kind, GetDiagnostics, annotations, _loopKeyword, _whileUntilClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitLoopStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "While expression" or "Until expression" in a Do or Loop
    ''' statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
    ''' indicate which kind of clause.
    ''' </summary>
    Friend NotInheritable Class WhileUntilClauseSyntax
        Inherits SyntaxNode

        Friend ReadOnly _whileOrUntilKeyword as KeywordSyntax
        Friend ReadOnly _condition as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, whileOrUntilKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind)

            Init(whileOrUntilKeyword)
            Me._whileOrUntilKeyword = whileOrUntilKeyword
            Init(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), whileOrUntilKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(whileOrUntilKeyword)
            Me._whileOrUntilKeyword = whileOrUntilKeyword
            Init(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._whileOrUntilKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._whileOrUntilKeyword)
          Me._condition = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._condition)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._whileOrUntilKeyword)
          writer.WriteValue(Me._condition)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.WhileUntilClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "While" or "Until" keyword.
        ''' </summary>
        Friend  ReadOnly Property WhileOrUntilKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._whileOrUntilKeyword
            End Get
        End Property

        ''' <summary>
        ''' The boolean expression after the While or Until.
        ''' </summary>
        Friend  ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._whileOrUntilKeyword
                Case 1
                    Return Me._condition
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new WhileUntilClauseSyntax(kind, newErrors, GetAnnotations, _whileOrUntilKeyword, _condition)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new WhileUntilClauseSyntax(kind, GetDiagnostics, annotations, _whileOrUntilKeyword, _condition)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitWhileUntilClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' The While statement that begins a While...End While block. This statement
    ''' always occurs as the Begin of a WhileBlock.
    ''' </summary>
    Friend NotInheritable Class WhileStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _whileKeyword as KeywordSyntax
        Friend ReadOnly _condition as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, whileKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind)

            Init(whileKeyword)
            Me._whileKeyword = whileKeyword
            Init(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), whileKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(whileKeyword)
            Me._whileKeyword = whileKeyword
            Init(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._whileKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._whileKeyword)
          Me._condition = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._condition)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._whileKeyword)
          writer.WriteValue(Me._condition)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.WhileStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "While" keyword.
        ''' </summary>
        Friend  ReadOnly Property WhileKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._whileKeyword
            End Get
        End Property

        ''' <summary>
        ''' The boolean expression that controls the While loop.
        ''' </summary>
        Friend  ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._whileKeyword
                Case 1
                    Return Me._condition
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new WhileStatementSyntax(kind, newErrors, GetAnnotations, _whileKeyword, _condition)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new WhileStatementSyntax(kind, GetDiagnostics, annotations, _whileKeyword, _condition)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitWhileStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a For or For Each block, including the introducting statement, the
    ''' body and the "Next" (which can be omitted if a containing For has a Next with
    ''' multiple variables).
    ''' </summary>
    Friend NotInheritable Class ForBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _begin as ExecutableStatementSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax
        Friend ReadOnly _statements as SyntaxNode
        Friend ReadOnly _end as NextStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, begin As ExecutableStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As NextStatementSyntax)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            If [end] IsNot Nothing Then
                Init([end])
                Me._end = [end]
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As ExecutableStatementSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As NextStatementSyntax)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            Init(beginTerminator)
            Me._beginTerminator = beginTerminator
            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            If [end] IsNot Nothing Then
                Init([end])
                Me._end = [end]
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), ExecutableStatementSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
          Me._end = DirectCast(reader.ReadValue(), NextStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
          writer.WriteValue(Me._statements)
          writer.WriteValue(Me._end)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ForBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The For or For Each statement that begins the block.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.ExecutableStatementSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement.
        ''' </summary>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

        ''' <summary>
        ''' The statements contained in the For or For Each loop. This might be an empty
        ''' list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        ''' <summary>
        ''' The Next statement that ends the block. If two For statements are ended by a
        ''' single Next statement, the inner For will not have an EndStatment.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property [End] As InternalSyntax.NextStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._statements
                Case 3
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ForBlockSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ForBlockSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitForBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' The For statement that begins a For-Next block. This statement always occurs as
    ''' the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
    ''' corresponding Next statement. However, multiple nested For statements are ended
    ''' by a single Next statement with multiple variables, then the inner For
    ''' statements will have End set to Nothing, and the Next statement is the End of
    ''' the outermost For statement that is being ended.
    ''' </summary>
    Friend NotInheritable Class ForStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _forKeyword as KeywordSyntax
        Friend ReadOnly _controlVariable as SyntaxNode
        Friend ReadOnly _equalsToken as PunctuationSyntax
        Friend ReadOnly _fromValue as ExpressionSyntax
        Friend ReadOnly _toKeyword as KeywordSyntax
        Friend ReadOnly _toValue as ExpressionSyntax
        Friend ReadOnly _stepClause as ForStepClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, forKeyword As InternalSyntax.KeywordSyntax, controlVariable As SyntaxNode, equalsToken As InternalSyntax.PunctuationSyntax, fromValue As ExpressionSyntax, toKeyword As InternalSyntax.KeywordSyntax, toValue As ExpressionSyntax, stepClause As ForStepClauseSyntax)
            MyBase.New(kind)

            Init(forKeyword)
            Me._forKeyword = forKeyword
            Init(controlVariable)
            Me._controlVariable = controlVariable
            Init(equalsToken)
            Me._equalsToken = equalsToken
            Init(fromValue)
            Me._fromValue = fromValue
            Init(toKeyword)
            Me._toKeyword = toKeyword
            Init(toValue)
            Me._toValue = toValue
            If stepClause IsNot Nothing Then
                Init(stepClause)
                Me._stepClause = stepClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), forKeyword As InternalSyntax.KeywordSyntax, controlVariable As SyntaxNode, equalsToken As InternalSyntax.PunctuationSyntax, fromValue As ExpressionSyntax, toKeyword As InternalSyntax.KeywordSyntax, toValue As ExpressionSyntax, stepClause As ForStepClauseSyntax)
            MyBase.New(kind, errors, annotations)

            Init(forKeyword)
            Me._forKeyword = forKeyword
            Init(controlVariable)
            Me._controlVariable = controlVariable
            Init(equalsToken)
            Me._equalsToken = equalsToken
            Init(fromValue)
            Me._fromValue = fromValue
            Init(toKeyword)
            Me._toKeyword = toKeyword
            Init(toValue)
            Me._toValue = toValue
            If stepClause IsNot Nothing Then
                Init(stepClause)
                Me._stepClause = stepClause
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._forKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._forKeyword)
          Me._controlVariable = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._controlVariable)
          Me._equalsToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._equalsToken)
          Me._fromValue = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._fromValue)
          Me._toKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._toKeyword)
          Me._toValue = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._toValue)
          Me._stepClause = DirectCast(reader.ReadValue(), ForStepClauseSyntax)
          Init(Me._stepClause)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._forKeyword)
          writer.WriteValue(Me._controlVariable)
          writer.WriteValue(Me._equalsToken)
          writer.WriteValue(Me._fromValue)
          writer.WriteValue(Me._toKeyword)
          writer.WriteValue(Me._toValue)
          writer.WriteValue(Me._stepClause)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ForStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "For" keyword.
        ''' </summary>
        Friend  ReadOnly Property ForKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._forKeyword
            End Get
        End Property

        ''' <summary>
        ''' If the For or For Each statement is of a form that does not declare a new loop
        ''' control variable, this is the expression that denotes the loop control
        ''' variable. If this loop is of a form that does declare a new control variable,
        ''' this is a VariableDeclarator that has the variable being declared.
        ''' </summary>
        Friend  ReadOnly Property ControlVariable As InternalSyntax.SyntaxNode
            Get
                Return Me._controlVariable
            End Get
        End Property

        ''' <summary>
        ''' The "=" token.
        ''' </summary>
        Friend  ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        ''' <summary>
        ''' The expression denoting the initial value of the iteration.
        ''' </summary>
        Friend  ReadOnly Property FromValue As InternalSyntax.ExpressionSyntax
            Get
                Return Me._fromValue
            End Get
        End Property

        ''' <summary>
        ''' The "To" keyword.
        ''' </summary>
        Friend  ReadOnly Property ToKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._toKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression denoting the final value of the iteration.
        ''' </summary>
        Friend  ReadOnly Property ToValue As InternalSyntax.ExpressionSyntax
            Get
                Return Me._toValue
            End Get
        End Property

        ''' <summary>
        ''' The optional Step clause.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property StepClause As InternalSyntax.ForStepClauseSyntax
            Get
                Return Me._stepClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._forKeyword
                Case 1
                    Return Me._controlVariable
                Case 2
                    Return Me._equalsToken
                Case 3
                    Return Me._fromValue
                Case 4
                    Return Me._toKeyword
                Case 5
                    Return Me._toValue
                Case 6
                    Return Me._stepClause
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 7
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ForStatementSyntax(kind, newErrors, GetAnnotations, _forKeyword, _controlVariable, _equalsToken, _fromValue, _toKeyword, _toValue, _stepClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ForStatementSyntax(kind, GetDiagnostics, annotations, _forKeyword, _controlVariable, _equalsToken, _fromValue, _toKeyword, _toValue, _stepClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitForStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' The Step clause in a For Statement.
    ''' </summary>
    Friend NotInheritable Class ForStepClauseSyntax
        Inherits SyntaxNode

        Friend ReadOnly _stepKeyword as KeywordSyntax
        Friend ReadOnly _stepValue as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, stepKeyword As InternalSyntax.KeywordSyntax, stepValue As ExpressionSyntax)
            MyBase.New(kind)

            Init(stepKeyword)
            Me._stepKeyword = stepKeyword
            Init(stepValue)
            Me._stepValue = stepValue

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), stepKeyword As InternalSyntax.KeywordSyntax, stepValue As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(stepKeyword)
            Me._stepKeyword = stepKeyword
            Init(stepValue)
            Me._stepValue = stepValue

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._stepKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._stepKeyword)
          Me._stepValue = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._stepValue)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._stepKeyword)
          writer.WriteValue(Me._stepValue)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ForStepClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Step" keyword.
        ''' </summary>
        Friend  ReadOnly Property StepKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._stepKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression denoting the step increment.
        ''' </summary>
        Friend  ReadOnly Property StepValue As InternalSyntax.ExpressionSyntax
            Get
                Return Me._stepValue
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._stepKeyword
                Case 1
                    Return Me._stepValue
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ForStepClauseSyntax(kind, newErrors, GetAnnotations, _stepKeyword, _stepValue)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ForStepClauseSyntax(kind, GetDiagnostics, annotations, _stepKeyword, _stepValue)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitForStepClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' The For Each statement that begins a For Each-Next block. This statement always
    ''' occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
    ''' Body of that ForBlock. Most of the time, the End of that ForBlock is the
    ''' corresponding Next statement. However, multiple nested For statements are ended
    ''' by a single Next statement with multiple variables, then the inner For
    ''' statements will have End set to Nothing, and the Next statement is the End of
    ''' the outermost For statement that is being ended.
    ''' </summary>
    Friend NotInheritable Class ForEachStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _forKeyword as KeywordSyntax
        Friend ReadOnly _eachKeyword as KeywordSyntax
        Friend ReadOnly _controlVariable as SyntaxNode
        Friend ReadOnly _inKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, forKeyword As InternalSyntax.KeywordSyntax, eachKeyword As InternalSyntax.KeywordSyntax, controlVariable As SyntaxNode, inKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)

            Init(forKeyword)
            Me._forKeyword = forKeyword
            Init(eachKeyword)
            Me._eachKeyword = eachKeyword
            Init(controlVariable)
            Me._controlVariable = controlVariable
            Init(inKeyword)
            Me._inKeyword = inKeyword
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), forKeyword As InternalSyntax.KeywordSyntax, eachKeyword As InternalSyntax.KeywordSyntax, controlVariable As SyntaxNode, inKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(forKeyword)
            Me._forKeyword = forKeyword
            Init(eachKeyword)
            Me._eachKeyword = eachKeyword
            Init(controlVariable)
            Me._controlVariable = controlVariable
            Init(inKeyword)
            Me._inKeyword = inKeyword
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._forKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._forKeyword)
          Me._eachKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._eachKeyword)
          Me._controlVariable = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._controlVariable)
          Me._inKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._inKeyword)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._forKeyword)
          writer.WriteValue(Me._eachKeyword)
          writer.WriteValue(Me._controlVariable)
          writer.WriteValue(Me._inKeyword)
          writer.WriteValue(Me._expression)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ForEachStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "For" keyword.
        ''' </summary>
        Friend  ReadOnly Property ForKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._forKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Each" keyword.
        ''' </summary>
        Friend  ReadOnly Property EachKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._eachKeyword
            End Get
        End Property

        ''' <summary>
        ''' If the For or For Each statement is of a form that does not declare a new loop
        ''' control variable, this is the expression that denotes the loop control
        ''' variable. If this loop is of a form that does declare a new control variable,
        ''' this is a VariableDeclarator that has the variable being declared.
        ''' </summary>
        Friend  ReadOnly Property ControlVariable As InternalSyntax.SyntaxNode
            Get
                Return Me._controlVariable
            End Get
        End Property

        ''' <summary>
        ''' The "In" keyword.
        ''' </summary>
        Friend  ReadOnly Property InKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._inKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression denoting the collection to iterate over.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._forKeyword
                Case 1
                    Return Me._eachKeyword
                Case 2
                    Return Me._controlVariable
                Case 3
                    Return Me._inKeyword
                Case 4
                    Return Me._expression
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ForEachStatementSyntax(kind, newErrors, GetAnnotations, _forKeyword, _eachKeyword, _controlVariable, _inKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ForEachStatementSyntax(kind, GetDiagnostics, annotations, _forKeyword, _eachKeyword, _controlVariable, _inKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitForEachStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' The Next statement that ends a For-Next or For Each-Next block. This statement
    ''' always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
    ''' and the body of the For-Next is the Body of that ForBlock. The Begin of that
    ''' ForBlock has the corresponding For or For Each statement.
    ''' </summary>
    Friend NotInheritable Class NextStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _nextKeyword as KeywordSyntax
        Friend ReadOnly _controlVariables as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, nextKeyword As InternalSyntax.KeywordSyntax, controlVariables As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(nextKeyword)
            Me._nextKeyword = nextKeyword
            If controlVariables IsNot Nothing Then
                Init(controlVariables)
                Me._controlVariables = controlVariables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), nextKeyword As InternalSyntax.KeywordSyntax, controlVariables As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(nextKeyword)
            Me._nextKeyword = nextKeyword
            If controlVariables IsNot Nothing Then
                Init(controlVariables)
                Me._controlVariables = controlVariables
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._nextKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._nextKeyword)
          Me._controlVariables = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._controlVariables)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._nextKeyword)
          writer.WriteValue(Me._controlVariables)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.NextStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Next" keyword.
        ''' </summary>
        Friend  ReadOnly Property NextKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._nextKeyword
            End Get
        End Property

        ''' <summary>
        ''' The variables in the Next statement, if present
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property ControlVariables As InternalSyntax.SeparatedSyntaxList(Of ExpressionSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of ExpressionSyntax)(New SyntaxList(of ExpressionSyntax)(Me._controlVariables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._nextKeyword
                Case 1
                    Return Me._controlVariables
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new NextStatementSyntax(kind, newErrors, GetAnnotations, _nextKeyword, _controlVariables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new NextStatementSyntax(kind, GetDiagnostics, annotations, _nextKeyword, _controlVariables)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitNextStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' The Using statement that begins a Using block. This statement always occurs as
    ''' the Begin of a UsingBlock, and the body of the Using is the Body of that
    ''' UsingBlock.
    ''' </summary>
    Friend NotInheritable Class UsingStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _usingKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _variables as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, usingKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, variables As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(usingKeyword)
            Me._usingKeyword = usingKeyword
            If expression IsNot Nothing Then
                Init(expression)
                Me._expression = expression
            End If
            If variables IsNot Nothing Then
                Init(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), usingKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, variables As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(usingKeyword)
            Me._usingKeyword = usingKeyword
            If expression IsNot Nothing Then
                Init(expression)
                Me._expression = expression
            End If
            If variables IsNot Nothing Then
                Init(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._usingKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._usingKeyword)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
          Me._variables = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._variables)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._usingKeyword)
          writer.WriteValue(Me._expression)
          writer.WriteValue(Me._variables)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.UsingStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Using" keyword.
        ''' </summary>
        Friend  ReadOnly Property UsingKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._usingKeyword
            End Get
        End Property

        ''' <summary>
        ''' If the Using statement is of a form that does not declare a new variable, this
        ''' is the expression used in the using. Otherwise, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' If the Using statement is of a form that declares one or more new variables,
        ''' this is the list of variable declarations. Otherwise, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Variables As InternalSyntax.SeparatedSyntaxList(Of VariableDeclaratorSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of VariableDeclaratorSyntax)(New SyntaxList(of VariableDeclaratorSyntax)(Me._variables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._usingKeyword
                Case 1
                    Return Me._expression
                Case 2
                    Return Me._variables
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new UsingStatementSyntax(kind, newErrors, GetAnnotations, _usingKeyword, _expression, _variables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new UsingStatementSyntax(kind, GetDiagnostics, annotations, _usingKeyword, _expression, _variables)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitUsingStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Throw statement.
    ''' </summary>
    Friend NotInheritable Class ThrowStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _throwKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, throwKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)

            Init(throwKeyword)
            Me._throwKeyword = throwKeyword
            If expression IsNot Nothing Then
                Init(expression)
                Me._expression = expression
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), throwKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(throwKeyword)
            Me._throwKeyword = throwKeyword
            If expression IsNot Nothing Then
                Init(expression)
                Me._expression = expression
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._throwKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._throwKeyword)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._throwKeyword)
          writer.WriteValue(Me._expression)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ThrowStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Throw" keyword
        ''' </summary>
        Friend  ReadOnly Property ThrowKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._throwKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression denoting the value being thrown.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._throwKeyword
                Case 1
                    Return Me._expression
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ThrowStatementSyntax(kind, newErrors, GetAnnotations, _throwKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ThrowStatementSyntax(kind, GetDiagnostics, annotations, _throwKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitThrowStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an assignment or compound assignment statement. Which one can be
    ''' determined by checking the Kind.
    ''' </summary>
    Friend NotInheritable Class AssignmentStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _left as ExpressionSyntax
        Friend ReadOnly _operatorToken as PunctuationSyntax
        Friend ReadOnly _right as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, left As ExpressionSyntax, operatorToken As InternalSyntax.PunctuationSyntax, right As ExpressionSyntax)
            MyBase.New(kind)

            Init(left)
            Me._left = left
            Init(operatorToken)
            Me._operatorToken = operatorToken
            Init(right)
            Me._right = right

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), left As ExpressionSyntax, operatorToken As InternalSyntax.PunctuationSyntax, right As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(left)
            Me._left = left
            Init(operatorToken)
            Me._operatorToken = operatorToken
            Init(right)
            Me._right = right

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._left = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._left)
          Me._operatorToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._operatorToken)
          Me._right = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._right)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._left)
          writer.WriteValue(Me._operatorToken)
          writer.WriteValue(Me._right)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.AssignmentStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The target (left hand side) of the assignment.
        ''' </summary>
        Friend  ReadOnly Property Left As InternalSyntax.ExpressionSyntax
            Get
                Return Me._left
            End Get
        End Property

        ''' <summary>
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </summary>
        Friend  ReadOnly Property OperatorToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._operatorToken
            End Get
        End Property

        ''' <summary>
        ''' The source (right hand side) of the assignment.
        ''' </summary>
        Friend  ReadOnly Property Right As InternalSyntax.ExpressionSyntax
            Get
                Return Me._right
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._left
                Case 1
                    Return Me._operatorToken
                Case 2
                    Return Me._right
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new AssignmentStatementSyntax(kind, newErrors, GetAnnotations, _left, _operatorToken, _right)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new AssignmentStatementSyntax(kind, GetDiagnostics, annotations, _left, _operatorToken, _right)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitAssignmentStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represent an call statement (also known as a invocation statement).
    ''' </summary>
    Friend NotInheritable Class CallStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _callKeyword as KeywordSyntax
        Friend ReadOnly _invocation as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, callKeyword As InternalSyntax.KeywordSyntax, invocation As ExpressionSyntax)
            MyBase.New(kind)

            If callKeyword IsNot Nothing Then
                Init(callKeyword)
                Me._callKeyword = callKeyword
            End If
            Init(invocation)
            Me._invocation = invocation

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), callKeyword As InternalSyntax.KeywordSyntax, invocation As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            If callKeyword IsNot Nothing Then
                Init(callKeyword)
                Me._callKeyword = callKeyword
            End If
            Init(invocation)
            Me._invocation = invocation

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._callKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._callKeyword)
          Me._invocation = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._invocation)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._callKeyword)
          writer.WriteValue(Me._invocation)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.CallStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Call" keyword, if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property CallKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._callKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression denoting the call. This could be an Invocation or a MemberAccess
        ''' (in the case where no parentheses were supplied.)
        ''' </summary>
        Friend  ReadOnly Property Invocation As InternalSyntax.ExpressionSyntax
            Get
                Return Me._invocation
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._callKeyword
                Case 1
                    Return Me._invocation
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new CallStatementSyntax(kind, newErrors, GetAnnotations, _callKeyword, _invocation)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new CallStatementSyntax(kind, GetDiagnostics, annotations, _callKeyword, _invocation)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitCallStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an AddHandler or RemoveHandler statement. The Kind property
    ''' determines which one.
    ''' </summary>
    Friend NotInheritable Class AddRemoveHandlerStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _addHandlerOrRemoveHandlerKeyword as KeywordSyntax
        Friend ReadOnly _eventExpression as ExpressionSyntax
        Friend ReadOnly _commaToken as PunctuationSyntax
        Friend ReadOnly _delegateExpression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, addHandlerOrRemoveHandlerKeyword As InternalSyntax.KeywordSyntax, eventExpression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, delegateExpression As ExpressionSyntax)
            MyBase.New(kind)

            Init(addHandlerOrRemoveHandlerKeyword)
            Me._addHandlerOrRemoveHandlerKeyword = addHandlerOrRemoveHandlerKeyword
            Init(eventExpression)
            Me._eventExpression = eventExpression
            Init(commaToken)
            Me._commaToken = commaToken
            Init(delegateExpression)
            Me._delegateExpression = delegateExpression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), addHandlerOrRemoveHandlerKeyword As InternalSyntax.KeywordSyntax, eventExpression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, delegateExpression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(addHandlerOrRemoveHandlerKeyword)
            Me._addHandlerOrRemoveHandlerKeyword = addHandlerOrRemoveHandlerKeyword
            Init(eventExpression)
            Me._eventExpression = eventExpression
            Init(commaToken)
            Me._commaToken = commaToken
            Init(delegateExpression)
            Me._delegateExpression = delegateExpression

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._addHandlerOrRemoveHandlerKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._addHandlerOrRemoveHandlerKeyword)
          Me._eventExpression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._eventExpression)
          Me._commaToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._commaToken)
          Me._delegateExpression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._delegateExpression)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._addHandlerOrRemoveHandlerKeyword)
          writer.WriteValue(Me._eventExpression)
          writer.WriteValue(Me._commaToken)
          writer.WriteValue(Me._delegateExpression)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.AddRemoveHandlerStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "AddHandler" or "RemoveHandler" keyword.
        ''' </summary>
        Friend  ReadOnly Property AddHandlerOrRemoveHandlerKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._addHandlerOrRemoveHandlerKeyword
            End Get
        End Property

        ''' <summary>
        ''' The event being accessed.
        ''' </summary>
        Friend  ReadOnly Property EventExpression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._eventExpression
            End Get
        End Property

        ''' <summary>
        ''' The "," token.
        ''' </summary>
        Friend  ReadOnly Property CommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._commaToken
            End Get
        End Property

        ''' <summary>
        ''' The delegate being added or removed.
        ''' </summary>
        Friend  ReadOnly Property DelegateExpression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._delegateExpression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._addHandlerOrRemoveHandlerKeyword
                Case 1
                    Return Me._eventExpression
                Case 2
                    Return Me._commaToken
                Case 3
                    Return Me._delegateExpression
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new AddRemoveHandlerStatementSyntax(kind, newErrors, GetAnnotations, _addHandlerOrRemoveHandlerKeyword, _eventExpression, _commaToken, _delegateExpression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new AddRemoveHandlerStatementSyntax(kind, GetDiagnostics, annotations, _addHandlerOrRemoveHandlerKeyword, _eventExpression, _commaToken, _delegateExpression)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitAddRemoveHandlerStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represent a RaiseEvent statement.
    ''' </summary>
    Friend NotInheritable Class RaiseEventStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _raiseEventKeyword as KeywordSyntax
        Friend ReadOnly _identifier as IdentifierNameSyntax
        Friend ReadOnly _argumentList as ArgumentListSyntax

        Friend Sub New(ByVal kind As SyntaxKind, raiseEventKeyword As InternalSyntax.KeywordSyntax, identifier As IdentifierNameSyntax, argumentList As ArgumentListSyntax)
            MyBase.New(kind)

            Init(raiseEventKeyword)
            Me._raiseEventKeyword = raiseEventKeyword
            Init(identifier)
            Me._identifier = identifier
            If argumentList IsNot Nothing Then
                Init(argumentList)
                Me._argumentList = argumentList
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), raiseEventKeyword As InternalSyntax.KeywordSyntax, identifier As IdentifierNameSyntax, argumentList As ArgumentListSyntax)
            MyBase.New(kind, errors, annotations)

            Init(raiseEventKeyword)
            Me._raiseEventKeyword = raiseEventKeyword
            Init(identifier)
            Me._identifier = identifier
            If argumentList IsNot Nothing Then
                Init(argumentList)
                Me._argumentList = argumentList
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._raiseEventKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._raiseEventKeyword)
          Me._identifier = DirectCast(reader.ReadValue(), IdentifierNameSyntax)
          Init(Me._identifier)
          Me._argumentList = DirectCast(reader.ReadValue(), ArgumentListSyntax)
          Init(Me._argumentList)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._raiseEventKeyword)
          writer.WriteValue(Me._identifier)
          writer.WriteValue(Me._argumentList)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.RaiseEventStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "RaiseEvent" keyword
        ''' </summary>
        Friend  ReadOnly Property RaiseEventKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._raiseEventKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the event being raised.
        ''' </summary>
        Friend  ReadOnly Property Identifier As InternalSyntax.IdentifierNameSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' The argument list, if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ArgumentList As InternalSyntax.ArgumentListSyntax
            Get
                Return Me._argumentList
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._raiseEventKeyword
                Case 1
                    Return Me._identifier
                Case 2
                    Return Me._argumentList
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new RaiseEventStatementSyntax(kind, newErrors, GetAnnotations, _raiseEventKeyword, _identifier, _argumentList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new RaiseEventStatementSyntax(kind, GetDiagnostics, annotations, _raiseEventKeyword, _identifier, _argumentList)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitRaiseEventStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "With" statement. This statement always occurs as the
    ''' BeginStatement of a WithBlock, and the body of the With is the Body of that
    ''' WithBlock.
    ''' </summary>
    Friend NotInheritable Class WithStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _withKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, withKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)

            Init(withKeyword)
            Me._withKeyword = withKeyword
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), withKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(withKeyword)
            Me._withKeyword = withKeyword
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._withKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._withKeyword)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._withKeyword)
          writer.WriteValue(Me._expression)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.WithStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "With" keyword.
        ''' </summary>
        Friend  ReadOnly Property WithKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._withKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression that is the operand of the With statement.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._withKeyword
                Case 1
                    Return Me._expression
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new WithStatementSyntax(kind, newErrors, GetAnnotations, _withKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new WithStatementSyntax(kind, GetDiagnostics, annotations, _withKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitWithStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a ReDim statement.
    ''' </summary>
    Friend NotInheritable Class ReDimStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _reDimKeyword as KeywordSyntax
        Friend ReadOnly _preserveKeyword as KeywordSyntax
        Friend ReadOnly _clauses as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, reDimKeyword As InternalSyntax.KeywordSyntax, preserveKeyword As InternalSyntax.KeywordSyntax, clauses As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(reDimKeyword)
            Me._reDimKeyword = reDimKeyword
            If preserveKeyword IsNot Nothing Then
                Init(preserveKeyword)
                Me._preserveKeyword = preserveKeyword
            End If
            If clauses IsNot Nothing Then
                Init(clauses)
                Me._clauses = clauses
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), reDimKeyword As InternalSyntax.KeywordSyntax, preserveKeyword As InternalSyntax.KeywordSyntax, clauses As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(reDimKeyword)
            Me._reDimKeyword = reDimKeyword
            If preserveKeyword IsNot Nothing Then
                Init(preserveKeyword)
                Me._preserveKeyword = preserveKeyword
            End If
            If clauses IsNot Nothing Then
                Init(clauses)
                Me._clauses = clauses
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._reDimKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._reDimKeyword)
          Me._preserveKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._preserveKeyword)
          Me._clauses = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._clauses)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._reDimKeyword)
          writer.WriteValue(Me._preserveKeyword)
          writer.WriteValue(Me._clauses)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ReDimStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "ReDim" keyword.
        ''' </summary>
        Friend  ReadOnly Property ReDimKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._reDimKeyword
            End Get
        End Property

        ''' <summary>
        ''' Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
        ''' Kind=RedimPreserve.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property PreserveKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._preserveKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of ReDim clauses. Each clause is a Invocation node with an argument
        ''' list denoting the new bounds for the array.
        ''' </summary>
        Friend  ReadOnly Property Clauses As InternalSyntax.SeparatedSyntaxList(Of InvocationExpressionSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of InvocationExpressionSyntax)(New SyntaxList(of InvocationExpressionSyntax)(Me._clauses))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._reDimKeyword
                Case 1
                    Return Me._preserveKeyword
                Case 2
                    Return Me._clauses
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ReDimStatementSyntax(kind, newErrors, GetAnnotations, _reDimKeyword, _preserveKeyword, _clauses)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ReDimStatementSyntax(kind, GetDiagnostics, annotations, _reDimKeyword, _preserveKeyword, _clauses)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitReDimStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an "Erase" statement.
    ''' </summary>
    Friend NotInheritable Class EraseStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _eraseKeyword as KeywordSyntax
        Friend ReadOnly _expressions as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, eraseKeyword As InternalSyntax.KeywordSyntax, expressions As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(eraseKeyword)
            Me._eraseKeyword = eraseKeyword
            If expressions IsNot Nothing Then
                Init(expressions)
                Me._expressions = expressions
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), eraseKeyword As InternalSyntax.KeywordSyntax, expressions As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(eraseKeyword)
            Me._eraseKeyword = eraseKeyword
            If expressions IsNot Nothing Then
                Init(expressions)
                Me._expressions = expressions
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._eraseKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._eraseKeyword)
          Me._expressions = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._expressions)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._eraseKeyword)
          writer.WriteValue(Me._expressions)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.EraseStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Erase" keyword.
        ''' </summary>
        Friend  ReadOnly Property EraseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._eraseKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of expressions denoting the arrays to erase.
        ''' </summary>
        Friend  ReadOnly Property Expressions As InternalSyntax.SeparatedSyntaxList(Of ExpressionSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of ExpressionSyntax)(New SyntaxList(of ExpressionSyntax)(Me._expressions))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._eraseKeyword
                Case 1
                    Return Me._expressions
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new EraseStatementSyntax(kind, newErrors, GetAnnotations, _eraseKeyword, _expressions)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new EraseStatementSyntax(kind, GetDiagnostics, annotations, _eraseKeyword, _expressions)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitEraseStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' An abstract base class for all node classes that define expressions.
    ''' </summary>
    Friend MustInherit Class ExpressionSyntax
        Inherits SyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' Represents a literal. The kind of literal is determined by the Kind property:
    ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
    ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
    ''' determined by casting the associated Token to the correct type and getting the
    ''' value from the token.
    ''' </summary>
    Friend NotInheritable Class LiteralExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _token as SyntaxToken

        Friend Sub New(ByVal kind As SyntaxKind, token As InternalSyntax.SyntaxToken)
            MyBase.New(kind)

            Init(token)
            Me._token = token

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), token As InternalSyntax.SyntaxToken)
            MyBase.New(kind, errors, annotations)

            Init(token)
            Me._token = token

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._token = DirectCast(reader.ReadValue(), SyntaxToken)
          Init(Me._token)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._token)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.LiteralExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </summary>
        Friend  ReadOnly Property Token As InternalSyntax.SyntaxToken
            Get
                Return Me._token
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._token
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new LiteralExpressionSyntax(kind, newErrors, GetAnnotations, _token)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new LiteralExpressionSyntax(kind, GetDiagnostics, annotations, _token)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitLiteralExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a parenthesized expression.
    ''' </summary>
    Friend NotInheritable Class ParenthesizedExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(expression)
            Me._expression = expression
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(expression)
            Me._expression = expression
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._openParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openParenToken)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
          Me._closeParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeParenToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._openParenToken)
          writer.WriteValue(Me._expression)
          writer.WriteValue(Me._closeParenToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ParenthesizedExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "(" token
        ''' </summary>
        Friend  ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The expression inside the parentheses.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' The ")" token
        ''' </summary>
        Friend  ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._openParenToken
                Case 1
                    Return Me._expression
                Case 2
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ParenthesizedExpressionSyntax(kind, newErrors, GetAnnotations, _openParenToken, _expression, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ParenthesizedExpressionSyntax(kind, GetDiagnostics, annotations, _openParenToken, _expression, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitParenthesizedExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Identifies one of the special instances "Me", "MyClass" or "MyBase". The Kind
    ''' property identifies which.
    ''' </summary>
    Friend MustInherit Class InstanceExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _keyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(keyword)
            Me._keyword = keyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(keyword)
            Me._keyword = keyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._keyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._keyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._keyword)
        End Sub

        ''' <summary>
        ''' The "Me", "MyClass" or "MyBase" keyword.
        ''' </summary>
        Friend  ReadOnly Property Keyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._keyword
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Identifies the special instance "Me"
    ''' </summary>
    Friend NotInheritable Class MeExpressionSyntax
        Inherits InstanceExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, keyword)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, keyword)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.MeExpressionSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._keyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new MeExpressionSyntax(kind, newErrors, GetAnnotations, _keyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new MeExpressionSyntax(kind, GetDiagnostics, annotations, _keyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitMeExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Identifies the special instance "MyBase"
    ''' </summary>
    Friend NotInheritable Class MyBaseExpressionSyntax
        Inherits InstanceExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, keyword)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, keyword)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.MyBaseExpressionSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._keyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new MyBaseExpressionSyntax(kind, newErrors, GetAnnotations, _keyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new MyBaseExpressionSyntax(kind, GetDiagnostics, annotations, _keyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitMyBaseExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Identifies the special instance "MyClass"
    ''' </summary>
    Friend NotInheritable Class MyClassExpressionSyntax
        Inherits InstanceExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, keyword)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, keyword)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.MyClassExpressionSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._keyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new MyClassExpressionSyntax(kind, newErrors, GetAnnotations, _keyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new MyClassExpressionSyntax(kind, GetDiagnostics, annotations, _keyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitMyClassExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a GetType expression.
    ''' </summary>
    Friend NotInheritable Class GetTypeExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _getTypeKeyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _type as TypeSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, getTypeKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(getTypeKeyword)
            Me._getTypeKeyword = getTypeKeyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(type)
            Me._type = type
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), getTypeKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(getTypeKeyword)
            Me._getTypeKeyword = getTypeKeyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(type)
            Me._type = type
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._getTypeKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._getTypeKeyword)
          Me._openParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openParenToken)
          Me._type = DirectCast(reader.ReadValue(), TypeSyntax)
          Init(Me._type)
          Me._closeParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeParenToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._getTypeKeyword)
          writer.WriteValue(Me._openParenToken)
          writer.WriteValue(Me._type)
          writer.WriteValue(Me._closeParenToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.GetTypeExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "GetType" keyword.
        ''' </summary>
        Friend  ReadOnly Property GetTypeKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._getTypeKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend  ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The type to get the Type object for. This can be an open generic type.
        ''' </summary>
        Friend  ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend  ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._getTypeKeyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._type
                Case 3
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new GetTypeExpressionSyntax(kind, newErrors, GetAnnotations, _getTypeKeyword, _openParenToken, _type, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new GetTypeExpressionSyntax(kind, GetDiagnostics, annotations, _getTypeKeyword, _openParenToken, _type, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitGetTypeExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a TypeOf...Is or IsNot expression.
    ''' </summary>
    Friend NotInheritable Class TypeOfExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _typeOfKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _operatorToken as KeywordSyntax
        Friend ReadOnly _type as TypeSyntax

        Friend Sub New(ByVal kind As SyntaxKind, typeOfKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, operatorToken As InternalSyntax.KeywordSyntax, type As TypeSyntax)
            MyBase.New(kind)

            Init(typeOfKeyword)
            Me._typeOfKeyword = typeOfKeyword
            Init(expression)
            Me._expression = expression
            Init(operatorToken)
            Me._operatorToken = operatorToken
            Init(type)
            Me._type = type

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), typeOfKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, operatorToken As InternalSyntax.KeywordSyntax, type As TypeSyntax)
            MyBase.New(kind, errors, annotations)

            Init(typeOfKeyword)
            Me._typeOfKeyword = typeOfKeyword
            Init(expression)
            Me._expression = expression
            Init(operatorToken)
            Me._operatorToken = operatorToken
            Init(type)
            Me._type = type

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._typeOfKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._typeOfKeyword)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
          Me._operatorToken = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._operatorToken)
          Me._type = DirectCast(reader.ReadValue(), TypeSyntax)
          Init(Me._type)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._typeOfKeyword)
          writer.WriteValue(Me._expression)
          writer.WriteValue(Me._operatorToken)
          writer.WriteValue(Me._type)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.TypeOfExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "TypeOf" keyword.
        ''' </summary>
        Friend  ReadOnly Property TypeOfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._typeOfKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression being tested.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' The "Is" or "IsNot" keyword.
        ''' </summary>
        Friend  ReadOnly Property OperatorToken As InternalSyntax.KeywordSyntax
            Get
                Return Me._operatorToken
            End Get
        End Property

        ''' <summary>
        ''' The name of the type being tested against.
        ''' </summary>
        Friend  ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._typeOfKeyword
                Case 1
                    Return Me._expression
                Case 2
                    Return Me._operatorToken
                Case 3
                    Return Me._type
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new TypeOfExpressionSyntax(kind, newErrors, GetAnnotations, _typeOfKeyword, _expression, _operatorToken, _type)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new TypeOfExpressionSyntax(kind, GetDiagnostics, annotations, _typeOfKeyword, _expression, _operatorToken, _type)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitTypeOfExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a GetXmlNamespace expression.
    ''' </summary>
    Friend NotInheritable Class GetXmlNamespaceExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _getXmlNamespaceKeyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _name as XmlNameTokenSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, getXmlNamespaceKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, name As InternalSyntax.XmlNameTokenSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(getXmlNamespaceKeyword)
            Me._getXmlNamespaceKeyword = getXmlNamespaceKeyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            If name IsNot Nothing Then
                Init(name)
                Me._name = name
            End If
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), getXmlNamespaceKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, name As InternalSyntax.XmlNameTokenSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(getXmlNamespaceKeyword)
            Me._getXmlNamespaceKeyword = getXmlNamespaceKeyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            If name IsNot Nothing Then
                Init(name)
                Me._name = name
            End If
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._getXmlNamespaceKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._getXmlNamespaceKeyword)
          Me._openParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openParenToken)
          Me._name = DirectCast(reader.ReadValue(), XmlNameTokenSyntax)
          Init(Me._name)
          Me._closeParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeParenToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._getXmlNamespaceKeyword)
          writer.WriteValue(Me._openParenToken)
          writer.WriteValue(Me._name)
          writer.WriteValue(Me._closeParenToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.GetXmlNamespaceExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "GetXmlNamespace" keyword.
        ''' </summary>
        Friend  ReadOnly Property GetXmlNamespaceKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._getXmlNamespaceKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend  ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The Xml namespace name being referenced.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Name As InternalSyntax.XmlNameTokenSyntax
            Get
                Return Me._name
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend  ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._getXmlNamespaceKeyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._name
                Case 3
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new GetXmlNamespaceExpressionSyntax(kind, newErrors, GetAnnotations, _getXmlNamespaceKeyword, _openParenToken, _name, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new GetXmlNamespaceExpressionSyntax(kind, GetDiagnostics, annotations, _getXmlNamespaceKeyword, _openParenToken, _name, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitGetXmlNamespaceExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents member access (.name) or dictionary access (!name). The Kind
    ''' property determines which kind of access.
    ''' </summary>
    Friend NotInheritable Class MemberAccessExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _operatorToken as PunctuationSyntax
        Friend ReadOnly _name as SimpleNameSyntax

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax, operatorToken As InternalSyntax.PunctuationSyntax, name As SimpleNameSyntax)
            MyBase.New(kind)

            If expression IsNot Nothing Then
                Init(expression)
                Me._expression = expression
            End If
            Init(operatorToken)
            Me._operatorToken = operatorToken
            Init(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), expression As ExpressionSyntax, operatorToken As InternalSyntax.PunctuationSyntax, name As SimpleNameSyntax)
            MyBase.New(kind, errors, annotations)

            If expression IsNot Nothing Then
                Init(expression)
                Me._expression = expression
            End If
            Init(operatorToken)
            Me._operatorToken = operatorToken
            Init(name)
            Me._name = name

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
          Me._operatorToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._operatorToken)
          Me._name = DirectCast(reader.ReadValue(), SimpleNameSyntax)
          Init(Me._name)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._expression)
          writer.WriteValue(Me._operatorToken)
          writer.WriteValue(Me._name)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.MemberAccessExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The expression on the left-hand-side of the "." or "!" token.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' The "." or "!" token.
        ''' </summary>
        Friend  ReadOnly Property OperatorToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._operatorToken
            End Get
        End Property

        ''' <summary>
        ''' The identifier after the "." or "!" token.
        ''' </summary>
        Friend  ReadOnly Property Name As InternalSyntax.SimpleNameSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._expression
                Case 1
                    Return Me._operatorToken
                Case 2
                    Return Me._name
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new MemberAccessExpressionSyntax(kind, newErrors, GetAnnotations, _expression, _operatorToken, _name)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new MemberAccessExpressionSyntax(kind, GetDiagnostics, annotations, _expression, _operatorToken, _name)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitMemberAccessExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML member element access (node.&lt;Element&gt;), attribute
    ''' access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
    ''' Kind property determines which kind of access.
    ''' </summary>
    Friend NotInheritable Class XmlMemberAccessExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _base as ExpressionSyntax
        Friend ReadOnly _token1 as PunctuationSyntax
        Friend ReadOnly _token2 as PunctuationSyntax
        Friend ReadOnly _token3 as PunctuationSyntax
        Friend ReadOnly _name as XmlNodeSyntax

        Friend Sub New(ByVal kind As SyntaxKind, base As ExpressionSyntax, token1 As InternalSyntax.PunctuationSyntax, token2 As InternalSyntax.PunctuationSyntax, token3 As InternalSyntax.PunctuationSyntax, name As XmlNodeSyntax)
            MyBase.New(kind)

            If base IsNot Nothing Then
                Init(base)
                Me._base = base
            End If
            Init(token1)
            Me._token1 = token1
            If token2 IsNot Nothing Then
                Init(token2)
                Me._token2 = token2
            End If
            If token3 IsNot Nothing Then
                Init(token3)
                Me._token3 = token3
            End If
            Init(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), base As ExpressionSyntax, token1 As InternalSyntax.PunctuationSyntax, token2 As InternalSyntax.PunctuationSyntax, token3 As InternalSyntax.PunctuationSyntax, name As XmlNodeSyntax)
            MyBase.New(kind, errors, annotations)

            If base IsNot Nothing Then
                Init(base)
                Me._base = base
            End If
            Init(token1)
            Me._token1 = token1
            If token2 IsNot Nothing Then
                Init(token2)
                Me._token2 = token2
            End If
            If token3 IsNot Nothing Then
                Init(token3)
                Me._token3 = token3
            End If
            Init(name)
            Me._name = name

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._base = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._base)
          Me._token1 = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._token1)
          Me._token2 = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._token2)
          Me._token3 = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._token3)
          Me._name = DirectCast(reader.ReadValue(), XmlNodeSyntax)
          Init(Me._name)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._base)
          writer.WriteValue(Me._token1)
          writer.WriteValue(Me._token2)
          writer.WriteValue(Me._token3)
          writer.WriteValue(Me._name)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlMemberAccessExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The expression on the left-hand-side of the ".", ".@" or "..." .
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Base As InternalSyntax.ExpressionSyntax
            Get
                Return Me._base
            End Get
        End Property

        ''' <summary>
        ''' The initial dot "." part of the separator.
        ''' </summary>
        Friend  ReadOnly Property Token1 As InternalSyntax.PunctuationSyntax
            Get
                Return Me._token1
            End Get
        End Property

        ''' <summary>
        ''' The "@" part of .@ or the second "." of "...".
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Token2 As InternalSyntax.PunctuationSyntax
            Get
                Return Me._token2
            End Get
        End Property

        ''' <summary>
        ''' The third "." in a "..." separator.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Token3 As InternalSyntax.PunctuationSyntax
            Get
                Return Me._token3
            End Get
        End Property

        ''' <summary>
        ''' The identifier after the ".", ".@" or "..."
        ''' </summary>
        Friend  ReadOnly Property Name As InternalSyntax.XmlNodeSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._base
                Case 1
                    Return Me._token1
                Case 2
                    Return Me._token2
                Case 3
                    Return Me._token3
                Case 4
                    Return Me._name
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlMemberAccessExpressionSyntax(kind, newErrors, GetAnnotations, _base, _token1, _token2, _token3, _name)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlMemberAccessExpressionSyntax(kind, GetDiagnostics, annotations, _base, _token1, _token2, _token3, _name)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlMemberAccessExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an invocation expression consisting of an invocation target and an
    ''' optional argument list or an array, parameterized property or object default
    ''' property index.
    ''' </summary>
    Friend NotInheritable Class InvocationExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _argumentList as ArgumentListSyntax

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax, argumentList As ArgumentListSyntax)
            MyBase.New(kind)

            Init(expression)
            Me._expression = expression
            If argumentList IsNot Nothing Then
                Init(argumentList)
                Me._argumentList = argumentList
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), expression As ExpressionSyntax, argumentList As ArgumentListSyntax)
            MyBase.New(kind, errors, annotations)

            Init(expression)
            Me._expression = expression
            If argumentList IsNot Nothing Then
                Init(argumentList)
                Me._argumentList = argumentList
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
          Me._argumentList = DirectCast(reader.ReadValue(), ArgumentListSyntax)
          Init(Me._argumentList)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._expression)
          writer.WriteValue(Me._argumentList)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.InvocationExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The target of the call or index expression.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' The argument list.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ArgumentList As InternalSyntax.ArgumentListSyntax
            Get
                Return Me._argumentList
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._expression
                Case 1
                    Return Me._argumentList
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new InvocationExpressionSyntax(kind, newErrors, GetAnnotations, _expression, _argumentList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new InvocationExpressionSyntax(kind, GetDiagnostics, annotations, _expression, _argumentList)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitInvocationExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Base class for object, array and anonymous object creation expressions
    ''' </summary>
    Partial Friend MustInherit Class NewExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _newKeyword as KeywordSyntax
        Friend ReadOnly _attributes as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, newKeyword As InternalSyntax.KeywordSyntax, attributes As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(newKeyword)
            Me._newKeyword = newKeyword
            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), newKeyword As InternalSyntax.KeywordSyntax, attributes As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(newKeyword)
            Me._newKeyword = newKeyword
            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._newKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._newKeyword)
          Me._attributes = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._attributes)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._newKeyword)
          writer.WriteValue(Me._attributes)
        End Sub

        ''' <summary>
        ''' The "New" keyword.
        ''' </summary>
        Friend  ReadOnly Property NewKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._newKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of all attribute blocks on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Attributes As InternalSyntax.SyntaxList(Of AttributeBlockSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of AttributeBlockSyntax)(Me._attributes)
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents a New expression that creates a new non-array object, possibly with
    ''' a "With" or "From" clause.
    ''' </summary>
    Friend NotInheritable Class ObjectCreationExpressionSyntax
        Inherits NewExpressionSyntax

        Friend ReadOnly _type as TypeSyntax
        Friend ReadOnly _argumentList as ArgumentListSyntax
        Friend ReadOnly _initializer as ObjectCreationInitializerSyntax

        Friend Sub New(ByVal kind As SyntaxKind, newKeyword As InternalSyntax.KeywordSyntax, attributes As InternalSyntax.SyntaxNode, type As TypeSyntax, argumentList As ArgumentListSyntax, initializer As ObjectCreationInitializerSyntax)
            MyBase.New(kind, newKeyword, attributes)

            Init(type)
            Me._type = type
            If argumentList IsNot Nothing Then
                Init(argumentList)
                Me._argumentList = argumentList
            End If
            If initializer IsNot Nothing Then
                Init(initializer)
                Me._initializer = initializer
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), newKeyword As InternalSyntax.KeywordSyntax, attributes As InternalSyntax.SyntaxNode, type As TypeSyntax, argumentList As ArgumentListSyntax, initializer As ObjectCreationInitializerSyntax)
            MyBase.New(kind, errors, annotations, newKeyword, attributes)

            Init(type)
            Me._type = type
            If argumentList IsNot Nothing Then
                Init(argumentList)
                Me._argumentList = argumentList
            End If
            If initializer IsNot Nothing Then
                Init(initializer)
                Me._initializer = initializer
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._type = DirectCast(reader.ReadValue(), TypeSyntax)
          Init(Me._type)
          Me._argumentList = DirectCast(reader.ReadValue(), ArgumentListSyntax)
          Init(Me._argumentList)
          Me._initializer = DirectCast(reader.ReadValue(), ObjectCreationInitializerSyntax)
          Init(Me._initializer)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._type)
          writer.WriteValue(Me._argumentList)
          writer.WriteValue(Me._initializer)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ObjectCreationExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The type of the object being initialized.
        ''' </summary>
        Friend  ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        ''' <summary>
        ''' The argument list, if present. If no argument list was supplied, Nothing is
        ''' returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ArgumentList As InternalSyntax.ArgumentListSyntax
            Get
                Return Me._argumentList
            End Get
        End Property

        ''' <summary>
        ''' An optional From or With clause to initialize the new object.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Initializer As InternalSyntax.ObjectCreationInitializerSyntax
            Get
                Return Me._initializer
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._newKeyword
                Case 1
                    Return Me._attributes
                Case 2
                    Return Me._type
                Case 3
                    Return Me._argumentList
                Case 4
                    Return Me._initializer
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ObjectCreationExpressionSyntax(kind, newErrors, GetAnnotations, _newKeyword, _attributes, _type, _argumentList, _initializer)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ObjectCreationExpressionSyntax(kind, GetDiagnostics, annotations, _newKeyword, _attributes, _type, _argumentList, _initializer)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitObjectCreationExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a New expression that create an object of anonymous type.
    ''' </summary>
    Friend NotInheritable Class AnonymousObjectCreationExpressionSyntax
        Inherits NewExpressionSyntax

        Friend ReadOnly _initializer as ObjectMemberInitializerSyntax

        Friend Sub New(ByVal kind As SyntaxKind, newKeyword As InternalSyntax.KeywordSyntax, attributes As InternalSyntax.SyntaxNode, initializer As ObjectMemberInitializerSyntax)
            MyBase.New(kind, newKeyword, attributes)

            Init(initializer)
            Me._initializer = initializer

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), newKeyword As InternalSyntax.KeywordSyntax, attributes As InternalSyntax.SyntaxNode, initializer As ObjectMemberInitializerSyntax)
            MyBase.New(kind, errors, annotations, newKeyword, attributes)

            Init(initializer)
            Me._initializer = initializer

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._initializer = DirectCast(reader.ReadValue(), ObjectMemberInitializerSyntax)
          Init(Me._initializer)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._initializer)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.AnonymousObjectCreationExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The With clause to initialize the new object.
        ''' </summary>
        Friend  ReadOnly Property Initializer As InternalSyntax.ObjectMemberInitializerSyntax
            Get
                Return Me._initializer
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._newKeyword
                Case 1
                    Return Me._attributes
                Case 2
                    Return Me._initializer
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new AnonymousObjectCreationExpressionSyntax(kind, newErrors, GetAnnotations, _newKeyword, _attributes, _initializer)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new AnonymousObjectCreationExpressionSyntax(kind, GetDiagnostics, annotations, _newKeyword, _attributes, _initializer)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitAnonymousObjectCreationExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an expression that creates a new array.
    ''' </summary>
    Friend NotInheritable Class ArrayCreationExpressionSyntax
        Inherits NewExpressionSyntax

        Friend ReadOnly _type as TypeSyntax
        Friend ReadOnly _arrayBounds as ArgumentListSyntax
        Friend ReadOnly _rankSpecifiers as SyntaxNode
        Friend ReadOnly _initializer as CollectionInitializerSyntax

        Friend Sub New(ByVal kind As SyntaxKind, newKeyword As InternalSyntax.KeywordSyntax, attributes As InternalSyntax.SyntaxNode, type As TypeSyntax, arrayBounds As ArgumentListSyntax, rankSpecifiers As InternalSyntax.SyntaxNode, initializer As CollectionInitializerSyntax)
            MyBase.New(kind, newKeyword, attributes)

            Init(type)
            Me._type = type
            If arrayBounds IsNot Nothing Then
                Init(arrayBounds)
                Me._arrayBounds = arrayBounds
            End If
            If rankSpecifiers IsNot Nothing Then
                Init(rankSpecifiers)
                Me._rankSpecifiers = rankSpecifiers
            End If
            Init(initializer)
            Me._initializer = initializer

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), newKeyword As InternalSyntax.KeywordSyntax, attributes As InternalSyntax.SyntaxNode, type As TypeSyntax, arrayBounds As ArgumentListSyntax, rankSpecifiers As InternalSyntax.SyntaxNode, initializer As CollectionInitializerSyntax)
            MyBase.New(kind, errors, annotations, newKeyword, attributes)

            Init(type)
            Me._type = type
            If arrayBounds IsNot Nothing Then
                Init(arrayBounds)
                Me._arrayBounds = arrayBounds
            End If
            If rankSpecifiers IsNot Nothing Then
                Init(rankSpecifiers)
                Me._rankSpecifiers = rankSpecifiers
            End If
            Init(initializer)
            Me._initializer = initializer

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._type = DirectCast(reader.ReadValue(), TypeSyntax)
          Init(Me._type)
          Me._arrayBounds = DirectCast(reader.ReadValue(), ArgumentListSyntax)
          Init(Me._arrayBounds)
          Me._rankSpecifiers = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._rankSpecifiers)
          Me._initializer = DirectCast(reader.ReadValue(), CollectionInitializerSyntax)
          Init(Me._initializer)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._type)
          writer.WriteValue(Me._arrayBounds)
          writer.WriteValue(Me._rankSpecifiers)
          writer.WriteValue(Me._initializer)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ArrayCreationExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The element type of the array being created.
        ''' </summary>
        Friend  ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        ''' <summary>
        ''' The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ArrayBounds As InternalSyntax.ArgumentListSyntax
            Get
                Return Me._arrayBounds
            End Get
        End Property

        ''' <summary>
        ''' A list of array modifiers such as "()" or "(,)". If no array modifiers were
        ''' present, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property RankSpecifiers As InternalSyntax.SyntaxList(Of ArrayRankSpecifierSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of ArrayRankSpecifierSyntax)(Me._rankSpecifiers)
            End Get
        End Property

        ''' <summary>
        ''' The initializer including the braces.
        ''' </summary>
        Friend  ReadOnly Property Initializer As InternalSyntax.CollectionInitializerSyntax
            Get
                Return Me._initializer
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._newKeyword
                Case 1
                    Return Me._attributes
                Case 2
                    Return Me._type
                Case 3
                    Return Me._arrayBounds
                Case 4
                    Return Me._rankSpecifiers
                Case 5
                    Return Me._initializer
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 6
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ArrayCreationExpressionSyntax(kind, newErrors, GetAnnotations, _newKeyword, _attributes, _type, _arrayBounds, _rankSpecifiers, _initializer)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ArrayCreationExpressionSyntax(kind, GetDiagnostics, annotations, _newKeyword, _attributes, _type, _arrayBounds, _rankSpecifiers, _initializer)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitArrayCreationExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an expression that creates a new array wihout naming the element
    ''' type.
    ''' </summary>
    Friend NotInheritable Class CollectionInitializerSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _openBraceToken as PunctuationSyntax
        Friend ReadOnly _initializers as SyntaxNode
        Friend ReadOnly _closeBraceToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openBraceToken As InternalSyntax.PunctuationSyntax, initializers As InternalSyntax.SyntaxNode, closeBraceToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(openBraceToken)
            Me._openBraceToken = openBraceToken
            If initializers IsNot Nothing Then
                Init(initializers)
                Me._initializers = initializers
            End If
            Init(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openBraceToken As InternalSyntax.PunctuationSyntax, initializers As InternalSyntax.SyntaxNode, closeBraceToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(openBraceToken)
            Me._openBraceToken = openBraceToken
            If initializers IsNot Nothing Then
                Init(initializers)
                Me._initializers = initializers
            End If
            Init(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._openBraceToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openBraceToken)
          Me._initializers = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._initializers)
          Me._closeBraceToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeBraceToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._openBraceToken)
          writer.WriteValue(Me._initializers)
          writer.WriteValue(Me._closeBraceToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.CollectionInitializerSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "{" token.
        ''' </summary>
        Friend  ReadOnly Property OpenBraceToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openBraceToken
            End Get
        End Property

        ''' <summary>
        ''' The list of initializers between the braces.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Initializers As InternalSyntax.SeparatedSyntaxList(Of ExpressionSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of ExpressionSyntax)(New SyntaxList(of ExpressionSyntax)(Me._initializers))
            End Get
        End Property

        ''' <summary>
        ''' The "}" token.
        ''' </summary>
        Friend  ReadOnly Property CloseBraceToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeBraceToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._openBraceToken
                Case 1
                    Return Me._initializers
                Case 2
                    Return Me._closeBraceToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new CollectionInitializerSyntax(kind, newErrors, GetAnnotations, _openBraceToken, _initializers, _closeBraceToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new CollectionInitializerSyntax(kind, GetDiagnostics, annotations, _openBraceToken, _initializers, _closeBraceToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitCollectionInitializer(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a CType, DirectCast or TryCast conversion expression. The Kind
    ''' property determines which kind of cast it is.
    ''' </summary>
    Friend MustInherit Class CastExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _keyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _commaToken as PunctuationSyntax
        Friend ReadOnly _type as TypeSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(keyword)
            Me._keyword = keyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(expression)
            Me._expression = expression
            Init(commaToken)
            Me._commaToken = commaToken
            Init(type)
            Me._type = type
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(keyword)
            Me._keyword = keyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(expression)
            Me._expression = expression
            Init(commaToken)
            Me._commaToken = commaToken
            Init(type)
            Me._type = type
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._keyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._keyword)
          Me._openParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openParenToken)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
          Me._commaToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._commaToken)
          Me._type = DirectCast(reader.ReadValue(), TypeSyntax)
          Init(Me._type)
          Me._closeParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeParenToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._keyword)
          writer.WriteValue(Me._openParenToken)
          writer.WriteValue(Me._expression)
          writer.WriteValue(Me._commaToken)
          writer.WriteValue(Me._type)
          writer.WriteValue(Me._closeParenToken)
        End Sub

        ''' <summary>
        ''' The "CType", "DirectCast" or "TryCast" keyword.
        ''' </summary>
        Friend  ReadOnly Property Keyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._keyword
            End Get
        End Property

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend  ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The expression being cast.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' The "," token.
        ''' </summary>
        Friend  ReadOnly Property CommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._commaToken
            End Get
        End Property

        ''' <summary>
        ''' The type the expression is being cast to.
        ''' </summary>
        Friend  ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend  ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

    End Class

    Friend NotInheritable Class CTypeExpressionSyntax
        Inherits CastExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, keyword, openParenToken, expression, commaToken, type, closeParenToken)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations, keyword, openParenToken, expression, commaToken, type, closeParenToken)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.CTypeExpressionSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._keyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._expression
                Case 3
                    Return Me._commaToken
                Case 4
                    Return Me._type
                Case 5
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 6
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new CTypeExpressionSyntax(kind, newErrors, GetAnnotations, _keyword, _openParenToken, _expression, _commaToken, _type, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new CTypeExpressionSyntax(kind, GetDiagnostics, annotations, _keyword, _openParenToken, _expression, _commaToken, _type, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitCTypeExpression(Me)
        End Function

    End Class

    Friend NotInheritable Class DirectCastExpressionSyntax
        Inherits CastExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, keyword, openParenToken, expression, commaToken, type, closeParenToken)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations, keyword, openParenToken, expression, commaToken, type, closeParenToken)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.DirectCastExpressionSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._keyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._expression
                Case 3
                    Return Me._commaToken
                Case 4
                    Return Me._type
                Case 5
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 6
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new DirectCastExpressionSyntax(kind, newErrors, GetAnnotations, _keyword, _openParenToken, _expression, _commaToken, _type, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new DirectCastExpressionSyntax(kind, GetDiagnostics, annotations, _keyword, _openParenToken, _expression, _commaToken, _type, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitDirectCastExpression(Me)
        End Function

    End Class

    Friend NotInheritable Class TryCastExpressionSyntax
        Inherits CastExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, keyword, openParenToken, expression, commaToken, type, closeParenToken)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations, keyword, openParenToken, expression, commaToken, type, closeParenToken)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.TryCastExpressionSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._keyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._expression
                Case 3
                    Return Me._commaToken
                Case 4
                    Return Me._type
                Case 5
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 6
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new TryCastExpressionSyntax(kind, newErrors, GetAnnotations, _keyword, _openParenToken, _expression, _commaToken, _type, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new TryCastExpressionSyntax(kind, GetDiagnostics, annotations, _keyword, _openParenToken, _expression, _commaToken, _type, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitTryCastExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a cast to a pre-defined type using a pre-defined cast expression,
    ''' such as CInt or CLng.
    ''' </summary>
    Friend NotInheritable Class PredefinedCastExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _keyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(keyword)
            Me._keyword = keyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(expression)
            Me._expression = expression
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(keyword)
            Me._keyword = keyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(expression)
            Me._expression = expression
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._keyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._keyword)
          Me._openParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openParenToken)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
          Me._closeParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeParenToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._keyword)
          writer.WriteValue(Me._openParenToken)
          writer.WriteValue(Me._expression)
          writer.WriteValue(Me._closeParenToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.PredefinedCastExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The keyword that was used in the cast operation.
        ''' </summary>
        Friend  ReadOnly Property Keyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._keyword
            End Get
        End Property

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend  ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The expression being cast.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend  ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._keyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._expression
                Case 3
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new PredefinedCastExpressionSyntax(kind, newErrors, GetAnnotations, _keyword, _openParenToken, _expression, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new PredefinedCastExpressionSyntax(kind, GetDiagnostics, annotations, _keyword, _openParenToken, _expression, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitPredefinedCastExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a binary operator. The Kind property classifies the operators into
    ''' similar kind of operators (arithmetic, relational, logical or string); the
    ''' exact operation being performed is determined by the Operator property.
    ''' </summary>
    Friend NotInheritable Class BinaryExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _left as ExpressionSyntax
        Friend ReadOnly _operatorToken as SyntaxToken
        Friend ReadOnly _right as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, left As ExpressionSyntax, operatorToken As InternalSyntax.SyntaxToken, right As ExpressionSyntax)
            MyBase.New(kind)

            Init(left)
            Me._left = left
            Init(operatorToken)
            Me._operatorToken = operatorToken
            Init(right)
            Me._right = right

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), left As ExpressionSyntax, operatorToken As InternalSyntax.SyntaxToken, right As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(left)
            Me._left = left
            Init(operatorToken)
            Me._operatorToken = operatorToken
            Init(right)
            Me._right = right

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._left = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._left)
          Me._operatorToken = DirectCast(reader.ReadValue(), SyntaxToken)
          Init(Me._operatorToken)
          Me._right = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._right)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._left)
          writer.WriteValue(Me._operatorToken)
          writer.WriteValue(Me._right)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.BinaryExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The left operand.
        ''' </summary>
        Friend  ReadOnly Property Left As InternalSyntax.ExpressionSyntax
            Get
                Return Me._left
            End Get
        End Property

        Friend  ReadOnly Property OperatorToken As InternalSyntax.SyntaxToken
            Get
                Return Me._operatorToken
            End Get
        End Property

        ''' <summary>
        ''' The right operand.
        ''' </summary>
        Friend  ReadOnly Property Right As InternalSyntax.ExpressionSyntax
            Get
                Return Me._right
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._left
                Case 1
                    Return Me._operatorToken
                Case 2
                    Return Me._right
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new BinaryExpressionSyntax(kind, newErrors, GetAnnotations, _left, _operatorToken, _right)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new BinaryExpressionSyntax(kind, GetDiagnostics, annotations, _left, _operatorToken, _right)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitBinaryExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
    ''' </summary>
    Friend NotInheritable Class UnaryExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _operatorToken as SyntaxToken
        Friend ReadOnly _operand as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, operatorToken As InternalSyntax.SyntaxToken, operand As ExpressionSyntax)
            MyBase.New(kind)

            Init(operatorToken)
            Me._operatorToken = operatorToken
            Init(operand)
            Me._operand = operand

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), operatorToken As InternalSyntax.SyntaxToken, operand As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(operatorToken)
            Me._operatorToken = operatorToken
            Init(operand)
            Me._operand = operand

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._operatorToken = DirectCast(reader.ReadValue(), SyntaxToken)
          Init(Me._operatorToken)
          Me._operand = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._operand)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._operatorToken)
          writer.WriteValue(Me._operand)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.UnaryExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The token that is the operator.
        ''' </summary>
        Friend  ReadOnly Property OperatorToken As InternalSyntax.SyntaxToken
            Get
                Return Me._operatorToken
            End Get
        End Property

        ''' <summary>
        ''' The expression being operated on.
        ''' </summary>
        Friend  ReadOnly Property Operand As InternalSyntax.ExpressionSyntax
            Get
                Return Me._operand
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._operatorToken
                Case 1
                    Return Me._operand
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new UnaryExpressionSyntax(kind, newErrors, GetAnnotations, _operatorToken, _operand)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new UnaryExpressionSyntax(kind, GetDiagnostics, annotations, _operatorToken, _operand)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitUnaryExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a conditional expression, If(condition, true-expr, false-expr) or
    ''' If(expr, nothing-expr).
    ''' </summary>
    Friend NotInheritable Class BinaryConditionalExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _ifKeyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _firstExpression as ExpressionSyntax
        Friend ReadOnly _commaToken as PunctuationSyntax
        Friend ReadOnly _secondExpression as ExpressionSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, ifKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, firstExpression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, secondExpression As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(ifKeyword)
            Me._ifKeyword = ifKeyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(firstExpression)
            Me._firstExpression = firstExpression
            Init(commaToken)
            Me._commaToken = commaToken
            Init(secondExpression)
            Me._secondExpression = secondExpression
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), ifKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, firstExpression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, secondExpression As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(ifKeyword)
            Me._ifKeyword = ifKeyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(firstExpression)
            Me._firstExpression = firstExpression
            Init(commaToken)
            Me._commaToken = commaToken
            Init(secondExpression)
            Me._secondExpression = secondExpression
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._ifKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._ifKeyword)
          Me._openParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openParenToken)
          Me._firstExpression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._firstExpression)
          Me._commaToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._commaToken)
          Me._secondExpression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._secondExpression)
          Me._closeParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeParenToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._ifKeyword)
          writer.WriteValue(Me._openParenToken)
          writer.WriteValue(Me._firstExpression)
          writer.WriteValue(Me._commaToken)
          writer.WriteValue(Me._secondExpression)
          writer.WriteValue(Me._closeParenToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.BinaryConditionalExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "If" keyword
        ''' </summary>
        Friend  ReadOnly Property IfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ifKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "(" token
        ''' </summary>
        Friend  ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The first expression inside the parentheses.
        ''' </summary>
        Friend  ReadOnly Property FirstExpression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._firstExpression
            End Get
        End Property

        ''' <summary>
        ''' The "," token.
        ''' </summary>
        Friend  ReadOnly Property CommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._commaToken
            End Get
        End Property

        ''' <summary>
        ''' The second expression inside the parentheses.
        ''' </summary>
        Friend  ReadOnly Property SecondExpression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._secondExpression
            End Get
        End Property

        ''' <summary>
        ''' The ")" token
        ''' </summary>
        Friend  ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._ifKeyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._firstExpression
                Case 3
                    Return Me._commaToken
                Case 4
                    Return Me._secondExpression
                Case 5
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 6
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new BinaryConditionalExpressionSyntax(kind, newErrors, GetAnnotations, _ifKeyword, _openParenToken, _firstExpression, _commaToken, _secondExpression, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new BinaryConditionalExpressionSyntax(kind, GetDiagnostics, annotations, _ifKeyword, _openParenToken, _firstExpression, _commaToken, _secondExpression, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitBinaryConditionalExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a conditional expression, If(condition, true-expr, false-expr) or
    ''' If(expr, nothing-expr).
    ''' </summary>
    Friend NotInheritable Class TernaryConditionalExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _ifKeyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _condition as ExpressionSyntax
        Friend ReadOnly _firstCommaToken as PunctuationSyntax
        Friend ReadOnly _whenTrue as ExpressionSyntax
        Friend ReadOnly _secondCommaToken as PunctuationSyntax
        Friend ReadOnly _whenFalse as ExpressionSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, ifKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, condition As ExpressionSyntax, firstCommaToken As InternalSyntax.PunctuationSyntax, whenTrue As ExpressionSyntax, secondCommaToken As InternalSyntax.PunctuationSyntax, whenFalse As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(ifKeyword)
            Me._ifKeyword = ifKeyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(condition)
            Me._condition = condition
            Init(firstCommaToken)
            Me._firstCommaToken = firstCommaToken
            Init(whenTrue)
            Me._whenTrue = whenTrue
            Init(secondCommaToken)
            Me._secondCommaToken = secondCommaToken
            Init(whenFalse)
            Me._whenFalse = whenFalse
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), ifKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, condition As ExpressionSyntax, firstCommaToken As InternalSyntax.PunctuationSyntax, whenTrue As ExpressionSyntax, secondCommaToken As InternalSyntax.PunctuationSyntax, whenFalse As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(ifKeyword)
            Me._ifKeyword = ifKeyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(condition)
            Me._condition = condition
            Init(firstCommaToken)
            Me._firstCommaToken = firstCommaToken
            Init(whenTrue)
            Me._whenTrue = whenTrue
            Init(secondCommaToken)
            Me._secondCommaToken = secondCommaToken
            Init(whenFalse)
            Me._whenFalse = whenFalse
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._ifKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._ifKeyword)
          Me._openParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openParenToken)
          Me._condition = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._condition)
          Me._firstCommaToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._firstCommaToken)
          Me._whenTrue = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._whenTrue)
          Me._secondCommaToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._secondCommaToken)
          Me._whenFalse = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._whenFalse)
          Me._closeParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeParenToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._ifKeyword)
          writer.WriteValue(Me._openParenToken)
          writer.WriteValue(Me._condition)
          writer.WriteValue(Me._firstCommaToken)
          writer.WriteValue(Me._whenTrue)
          writer.WriteValue(Me._secondCommaToken)
          writer.WriteValue(Me._whenFalse)
          writer.WriteValue(Me._closeParenToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.TernaryConditionalExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "If" keyword
        ''' </summary>
        Friend  ReadOnly Property IfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ifKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "(" token
        ''' </summary>
        Friend  ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The first expression inside the parentheses.
        ''' </summary>
        Friend  ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        ''' <summary>
        ''' The "," token.
        ''' </summary>
        Friend  ReadOnly Property FirstCommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._firstCommaToken
            End Get
        End Property

        ''' <summary>
        ''' The second expression inside the parentheses.
        ''' </summary>
        Friend  ReadOnly Property WhenTrue As InternalSyntax.ExpressionSyntax
            Get
                Return Me._whenTrue
            End Get
        End Property

        ''' <summary>
        ''' The "," token.
        ''' </summary>
        Friend  ReadOnly Property SecondCommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._secondCommaToken
            End Get
        End Property

        ''' <summary>
        ''' The second expression inside the parentheses.
        ''' </summary>
        Friend  ReadOnly Property WhenFalse As InternalSyntax.ExpressionSyntax
            Get
                Return Me._whenFalse
            End Get
        End Property

        ''' <summary>
        ''' The ")" token
        ''' </summary>
        Friend  ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._ifKeyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._condition
                Case 3
                    Return Me._firstCommaToken
                Case 4
                    Return Me._whenTrue
                Case 5
                    Return Me._secondCommaToken
                Case 6
                    Return Me._whenFalse
                Case 7
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 8
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new TernaryConditionalExpressionSyntax(kind, newErrors, GetAnnotations, _ifKeyword, _openParenToken, _condition, _firstCommaToken, _whenTrue, _secondCommaToken, _whenFalse, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new TernaryConditionalExpressionSyntax(kind, GetDiagnostics, annotations, _ifKeyword, _openParenToken, _condition, _firstCommaToken, _whenTrue, _secondCommaToken, _whenFalse, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitTernaryConditionalExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a lambda expression, either single line or multi-line.
    ''' </summary>
    Friend MustInherit Class LambdaExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _begin as LambdaHeaderSyntax
        Friend ReadOnly _beginTerminator as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, begin As LambdaHeaderSyntax, beginTerminator As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(begin)
            Me._begin = begin
            If beginTerminator IsNot Nothing Then
                Init(beginTerminator)
                Me._beginTerminator = beginTerminator
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As LambdaHeaderSyntax, beginTerminator As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(begin)
            Me._begin = begin
            If beginTerminator IsNot Nothing Then
                Init(beginTerminator)
                Me._beginTerminator = beginTerminator
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._begin = DirectCast(reader.ReadValue(), LambdaHeaderSyntax)
          Init(Me._begin)
          Me._beginTerminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginTerminator)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._begin)
          writer.WriteValue(Me._beginTerminator)
        End Sub

        ''' <summary>
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </summary>
        Friend  ReadOnly Property Begin As InternalSyntax.LambdaHeaderSyntax
            Get
                Return Me._begin
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Begin statement. Optional only
        ''' for single line lambdas.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property BeginTerminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginTerminator
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents a single line lambda expression.
    ''' </summary>
    Friend NotInheritable Class SingleLineLambdaExpressionSyntax
        Inherits LambdaExpressionSyntax

        Friend ReadOnly _body as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, begin As LambdaHeaderSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, body As SyntaxNode)
            MyBase.New(kind, begin, beginTerminator)

            Init(body)
            Me._body = body

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As LambdaHeaderSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, body As SyntaxNode)
            MyBase.New(kind, errors, annotations, begin, beginTerminator)

            Init(body)
            Me._body = body

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._body = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._body)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._body)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.SingleLineLambdaExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' Statement (single-line Sub lambda) or Expression (single-line Function).
        ''' </summary>
        Friend  ReadOnly Property Body As InternalSyntax.SyntaxNode
            Get
                Return Me._body
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._body
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new SingleLineLambdaExpressionSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _body)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new SingleLineLambdaExpressionSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _body)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitSingleLineLambdaExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a multi-line lambda expression.
    ''' </summary>
    Friend NotInheritable Class MultiLineLambdaExpressionSyntax
        Inherits LambdaExpressionSyntax

        Friend ReadOnly _statements as SyntaxNode
        Friend ReadOnly _end as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, begin As LambdaHeaderSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, begin, beginTerminator)

            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), begin As LambdaHeaderSyntax, beginTerminator As InternalSyntax.PunctuationSyntax, statements As InternalSyntax.SyntaxNode, [end] As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations, begin, beginTerminator)

            If statements IsNot Nothing Then
                Init(statements)
                Me._statements = statements
            End If
            Init([end])
            Me._end = [end]

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._statements = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._statements)
          Me._end = DirectCast(reader.ReadValue(), EndBlockStatementSyntax)
          Init(Me._end)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._statements)
          writer.WriteValue(Me._end)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.MultiLineLambdaExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
        ''' Expression (single-line Function). This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Statements As InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of StatementSyntax)(New SyntaxList(of StatementSyntax)(Me._statements))
            End Get
        End Property

        ''' <summary>
        ''' Returns the "End Sub" or "End Function" statement if this is a multi-line
        ''' lambda.
        ''' </summary>
        Friend  ReadOnly Property [End] As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._end
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._begin
                Case 1
                    Return Me._beginTerminator
                Case 2
                    Return Me._statements
                Case 3
                    Return Me._end
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new MultiLineLambdaExpressionSyntax(kind, newErrors, GetAnnotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new MultiLineLambdaExpressionSyntax(kind, GetDiagnostics, annotations, _begin, _beginTerminator, _statements, _end)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitMultiLineLambdaExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the header part of a lambda expression
    ''' </summary>
    Friend NotInheritable Class LambdaHeaderSyntax
        Inherits MethodBaseSyntax


        Friend Sub New(ByVal kind As SyntaxKind, attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax)
            MyBase.New(kind, attributes, modifiers, keyword, parameterList, asClause)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributes As InternalSyntax.SyntaxNode, modifiers As InternalSyntax.SyntaxNode, keyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributes, modifiers, keyword, parameterList, asClause)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.LambdaHeaderSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._attributes
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._keyword
                Case 3
                    Return Me._parameterList
                Case 4
                    Return Me._asClause
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new LambdaHeaderSyntax(kind, newErrors, GetAnnotations, _attributes, _modifiers, _keyword, _parameterList, _asClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new LambdaHeaderSyntax(kind, GetDiagnostics, annotations, _attributes, _modifiers, _keyword, _parameterList, _asClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitLambdaHeader(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a parenthesized argument list.
    ''' </summary>
    Friend NotInheritable Class ArgumentListSyntax
        Inherits SyntaxNode

        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _arguments as SyntaxNode
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, arguments As InternalSyntax.SyntaxNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(openParenToken)
            Me._openParenToken = openParenToken
            If arguments IsNot Nothing Then
                Init(arguments)
                Me._arguments = arguments
            End If
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openParenToken As InternalSyntax.PunctuationSyntax, arguments As InternalSyntax.SyntaxNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(openParenToken)
            Me._openParenToken = openParenToken
            If arguments IsNot Nothing Then
                Init(arguments)
                Me._arguments = arguments
            End If
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._openParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openParenToken)
          Me._arguments = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._arguments)
          Me._closeParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeParenToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._openParenToken)
          writer.WriteValue(Me._arguments)
          writer.WriteValue(Me._closeParenToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ArgumentListSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend  ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The list of arguments. This may be empty. Ommitted argument are represented by
        ''' an OmittedArgumentSyntax node.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Arguments As InternalSyntax.SeparatedSyntaxList(Of ArgumentSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of ArgumentSyntax)(New SyntaxList(of ArgumentSyntax)(Me._arguments))
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend  ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._openParenToken
                Case 1
                    Return Me._arguments
                Case 2
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ArgumentListSyntax(kind, newErrors, GetAnnotations, _openParenToken, _arguments, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ArgumentListSyntax(kind, GetDiagnostics, annotations, _openParenToken, _arguments, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitArgumentList(Me)
        End Function

    End Class

    ''' <summary>
    ''' Base class for the possible kinds of arguments that can appear in an argument
    ''' list.
    ''' </summary>
    Friend MustInherit Class ArgumentSyntax
        Inherits SyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' Represents an omitted argument in an argument list. An omitted argument is not
    ''' considered a syntax error but a valid case when no argument is required.
    ''' </summary>
    Friend NotInheritable Class OmittedArgumentSyntax
        Inherits ArgumentSyntax

        Friend ReadOnly _empty as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, empty As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(empty)
            Me._empty = empty

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), empty As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(empty)
            Me._empty = empty

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._empty = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._empty)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._empty)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.OmittedArgumentSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' An empty token because all non terminals must have a token.
        ''' </summary>
        Friend  ReadOnly Property Empty As InternalSyntax.PunctuationSyntax
            Get
                Return Me._empty
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._empty
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new OmittedArgumentSyntax(kind, newErrors, GetAnnotations, _empty)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new OmittedArgumentSyntax(kind, GetDiagnostics, annotations, _empty)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitOmittedArgument(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a simple argument that is just an expression.
    ''' </summary>
    Friend NotInheritable Class SimpleArgumentSyntax
        Inherits ArgumentSyntax

        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax)
            MyBase.New(kind)

            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._expression)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.SimpleArgumentSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The expression that is the argument.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._expression
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new SimpleArgumentSyntax(kind, newErrors, GetAnnotations, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new SimpleArgumentSyntax(kind, GetDiagnostics, annotations, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitSimpleArgument(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a named argument, such as "Value:=7".
    ''' </summary>
    Friend NotInheritable Class NamedArgumentSyntax
        Inherits ArgumentSyntax

        Friend ReadOnly _identifierName as IdentifierNameSyntax
        Friend ReadOnly _colonEqualsToken as PunctuationSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, identifierName As IdentifierNameSyntax, colonEqualsToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)

            Init(identifierName)
            Me._identifierName = identifierName
            Init(colonEqualsToken)
            Me._colonEqualsToken = colonEqualsToken
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifierName As IdentifierNameSyntax, colonEqualsToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(identifierName)
            Me._identifierName = identifierName
            Init(colonEqualsToken)
            Me._colonEqualsToken = colonEqualsToken
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._identifierName = DirectCast(reader.ReadValue(), IdentifierNameSyntax)
          Init(Me._identifierName)
          Me._colonEqualsToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._colonEqualsToken)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._identifierName)
          writer.WriteValue(Me._colonEqualsToken)
          writer.WriteValue(Me._expression)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.NamedArgumentSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The name used to identify the named argument.
        ''' </summary>
        Friend  ReadOnly Property IdentifierName As InternalSyntax.IdentifierNameSyntax
            Get
                Return Me._identifierName
            End Get
        End Property

        ''' <summary>
        ''' The ":=" token.
        ''' </summary>
        Friend  ReadOnly Property ColonEqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._colonEqualsToken
            End Get
        End Property

        ''' <summary>
        ''' The expression that is the named argument.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._identifierName
                Case 1
                    Return Me._colonEqualsToken
                Case 2
                    Return Me._expression
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new NamedArgumentSyntax(kind, newErrors, GetAnnotations, _identifierName, _colonEqualsToken, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new NamedArgumentSyntax(kind, GetDiagnostics, annotations, _identifierName, _colonEqualsToken, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitNamedArgument(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a range argument, such as "0 to 5", used in array bounds. The
    ''' "Value" property represents the upper bound of the range.
    ''' </summary>
    Friend NotInheritable Class RangeArgumentSyntax
        Inherits ArgumentSyntax

        Friend ReadOnly _lowerBound as ExpressionSyntax
        Friend ReadOnly _toKeyword as KeywordSyntax
        Friend ReadOnly _upperBound as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lowerBound As ExpressionSyntax, toKeyword As InternalSyntax.KeywordSyntax, upperBound As ExpressionSyntax)
            MyBase.New(kind)

            Init(lowerBound)
            Me._lowerBound = lowerBound
            Init(toKeyword)
            Me._toKeyword = toKeyword
            Init(upperBound)
            Me._upperBound = upperBound

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lowerBound As ExpressionSyntax, toKeyword As InternalSyntax.KeywordSyntax, upperBound As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(lowerBound)
            Me._lowerBound = lowerBound
            Init(toKeyword)
            Me._toKeyword = toKeyword
            Init(upperBound)
            Me._upperBound = upperBound

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._lowerBound = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._lowerBound)
          Me._toKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._toKeyword)
          Me._upperBound = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._upperBound)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._lowerBound)
          writer.WriteValue(Me._toKeyword)
          writer.WriteValue(Me._upperBound)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.RangeArgumentSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The lower bound of the range. This is typically the integer constant zero.
        ''' </summary>
        Friend  ReadOnly Property LowerBound As InternalSyntax.ExpressionSyntax
            Get
                Return Me._lowerBound
            End Get
        End Property

        ''' <summary>
        ''' The "To" keyword.
        ''' </summary>
        Friend  ReadOnly Property ToKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._toKeyword
            End Get
        End Property

        ''' <summary>
        ''' The upper bound of the range.
        ''' </summary>
        Friend  ReadOnly Property UpperBound As InternalSyntax.ExpressionSyntax
            Get
                Return Me._upperBound
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._lowerBound
                Case 1
                    Return Me._toKeyword
                Case 2
                    Return Me._upperBound
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new RangeArgumentSyntax(kind, newErrors, GetAnnotations, _lowerBound, _toKeyword, _upperBound)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new RangeArgumentSyntax(kind, GetDiagnostics, annotations, _lowerBound, _toKeyword, _upperBound)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitRangeArgument(Me)
        End Function

    End Class

    ''' <summary>
    ''' This class represents a query expression. A query expression is composed of one
    ''' or more query operators in a row. The first query operator must be a From or
    ''' Aggregate.
    ''' </summary>
    Friend NotInheritable Class QueryExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _clauses as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, clauses As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            If clauses IsNot Nothing Then
                Init(clauses)
                Me._clauses = clauses
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), clauses As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            If clauses IsNot Nothing Then
                Init(clauses)
                Me._clauses = clauses
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._clauses = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._clauses)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._clauses)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.QueryExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' A list of all the query operators in this query expression. This list always
        ''' contains at least one operator.
        ''' </summary>
        Friend  ReadOnly Property Clauses As InternalSyntax.SyntaxList(Of QueryClauseSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of QueryClauseSyntax)(Me._clauses)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._clauses
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new QueryExpressionSyntax(kind, newErrors, GetAnnotations, _clauses)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new QueryExpressionSyntax(kind, GetDiagnostics, annotations, _clauses)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitQueryExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' This is a base class for all query operators.
    ''' </summary>
    Friend MustInherit Class QueryClauseSyntax
        Inherits SyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' Describes a single variable of the form "x [As Type] In expression" for use in
    ''' query expressions.
    ''' </summary>
    Friend NotInheritable Class CollectionRangeVariableSyntax
        Inherits SyntaxNode

        Friend ReadOnly _identifier as ModifiedIdentifierSyntax
        Friend ReadOnly _asClause as SimpleAsClauseSyntax
        Friend ReadOnly _inKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, inKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)

            Init(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                Init(asClause)
                Me._asClause = asClause
            End If
            Init(inKeyword)
            Me._inKeyword = inKeyword
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, inKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                Init(asClause)
                Me._asClause = asClause
            End If
            Init(inKeyword)
            Me._inKeyword = inKeyword
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._identifier = DirectCast(reader.ReadValue(), ModifiedIdentifierSyntax)
          Init(Me._identifier)
          Me._asClause = DirectCast(reader.ReadValue(), SimpleAsClauseSyntax)
          Init(Me._asClause)
          Me._inKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._inKeyword)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._identifier)
          writer.WriteValue(Me._asClause)
          writer.WriteValue(Me._inKeyword)
          writer.WriteValue(Me._expression)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.CollectionRangeVariableSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The name of the range variable being defined.
        ''' </summary>
        Friend  ReadOnly Property Identifier As InternalSyntax.ModifiedIdentifierSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' Describes the type of the variable being defined.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        ''' <summary>
        ''' The "In" keyword.
        ''' </summary>
        Friend  ReadOnly Property InKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._inKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression that serves as the source of items for the range variable.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._identifier
                Case 1
                    Return Me._asClause
                Case 2
                    Return Me._inKeyword
                Case 3
                    Return Me._expression
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new CollectionRangeVariableSyntax(kind, newErrors, GetAnnotations, _identifier, _asClause, _inKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new CollectionRangeVariableSyntax(kind, GetDiagnostics, annotations, _identifier, _asClause, _inKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitCollectionRangeVariable(Me)
        End Function

    End Class

    ''' <summary>
    ''' Describes a single variable of the form "[x [As Type] =] expression" for use in
    ''' query expressions.
    ''' </summary>
    Friend NotInheritable Class ExpressionRangeVariableSyntax
        Inherits SyntaxNode

        Friend ReadOnly _nameEquals as VariableNameEqualsSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, nameEquals As VariableNameEqualsSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)

            If nameEquals IsNot Nothing Then
                Init(nameEquals)
                Me._nameEquals = nameEquals
            End If
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), nameEquals As VariableNameEqualsSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            If nameEquals IsNot Nothing Then
                Init(nameEquals)
                Me._nameEquals = nameEquals
            End If
            Init(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._nameEquals = DirectCast(reader.ReadValue(), VariableNameEqualsSyntax)
          Init(Me._nameEquals)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._nameEquals)
          writer.WriteValue(Me._expression)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ExpressionRangeVariableSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The optional name and type of the expression range variable. If ommitted, the
        ''' name of the expression range variable is inferred from the expression.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property NameEquals As InternalSyntax.VariableNameEqualsSyntax
            Get
                Return Me._nameEquals
            End Get
        End Property

        ''' <summary>
        ''' The expression used to initialize the expression variable.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._nameEquals
                Case 1
                    Return Me._expression
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ExpressionRangeVariableSyntax(kind, newErrors, GetAnnotations, _nameEquals, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ExpressionRangeVariableSyntax(kind, GetDiagnostics, annotations, _nameEquals, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitExpressionRangeVariable(Me)
        End Function

    End Class

    ''' <summary>
    ''' Describes a single variable of the form "[x [As Type] =] aggregation-function"
    ''' for use in the Into clause of Aggregate or Group By or Group Join query
    ''' operators.
    ''' </summary>
    Friend NotInheritable Class AggregationRangeVariableSyntax
        Inherits SyntaxNode

        Friend ReadOnly _nameEquals as VariableNameEqualsSyntax
        Friend ReadOnly _aggregation as AggregationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, nameEquals As VariableNameEqualsSyntax, aggregation As AggregationSyntax)
            MyBase.New(kind)

            If nameEquals IsNot Nothing Then
                Init(nameEquals)
                Me._nameEquals = nameEquals
            End If
            Init(aggregation)
            Me._aggregation = aggregation

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), nameEquals As VariableNameEqualsSyntax, aggregation As AggregationSyntax)
            MyBase.New(kind, errors, annotations)

            If nameEquals IsNot Nothing Then
                Init(nameEquals)
                Me._nameEquals = nameEquals
            End If
            Init(aggregation)
            Me._aggregation = aggregation

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._nameEquals = DirectCast(reader.ReadValue(), VariableNameEqualsSyntax)
          Init(Me._nameEquals)
          Me._aggregation = DirectCast(reader.ReadValue(), AggregationSyntax)
          Init(Me._aggregation)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._nameEquals)
          writer.WriteValue(Me._aggregation)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.AggregationRangeVariableSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The optional name and type of the expression range variable. If ommitted, the
        ''' name of the expression range variable is inferred from the aggregation
        ''' expression.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property NameEquals As InternalSyntax.VariableNameEqualsSyntax
            Get
                Return Me._nameEquals
            End Get
        End Property

        ''' <summary>
        ''' The name of the aggregation function. The "Group" aggregation function is
        ''' represented by the identifier "Group".
        ''' </summary>
        Friend  ReadOnly Property Aggregation As InternalSyntax.AggregationSyntax
            Get
                Return Me._aggregation
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._nameEquals
                Case 1
                    Return Me._aggregation
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new AggregationRangeVariableSyntax(kind, newErrors, GetAnnotations, _nameEquals, _aggregation)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new AggregationRangeVariableSyntax(kind, GetDiagnostics, annotations, _nameEquals, _aggregation)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitAggregationRangeVariable(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the name and optional type of an expression range variable.
    ''' </summary>
    Friend NotInheritable Class VariableNameEqualsSyntax
        Inherits SyntaxNode

        Friend ReadOnly _identifier as ModifiedIdentifierSyntax
        Friend ReadOnly _asClause as SimpleAsClauseSyntax
        Friend ReadOnly _equalsToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, equalsToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                Init(asClause)
                Me._asClause = asClause
            End If
            Init(equalsToken)
            Me._equalsToken = equalsToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, equalsToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                Init(asClause)
                Me._asClause = asClause
            End If
            Init(equalsToken)
            Me._equalsToken = equalsToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._identifier = DirectCast(reader.ReadValue(), ModifiedIdentifierSyntax)
          Init(Me._identifier)
          Me._asClause = DirectCast(reader.ReadValue(), SimpleAsClauseSyntax)
          Init(Me._asClause)
          Me._equalsToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._equalsToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._identifier)
          writer.WriteValue(Me._asClause)
          writer.WriteValue(Me._equalsToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.VariableNameEqualsSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The name of the variable being defined.
        ''' </summary>
        Friend  ReadOnly Property Identifier As InternalSyntax.ModifiedIdentifierSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' Describes the type of the variable being defined.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        ''' <summary>
        ''' The "=" token.
        ''' </summary>
        Friend  ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._identifier
                Case 1
                    Return Me._asClause
                Case 2
                    Return Me._equalsToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new VariableNameEqualsSyntax(kind, newErrors, GetAnnotations, _identifier, _asClause, _equalsToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new VariableNameEqualsSyntax(kind, GetDiagnostics, annotations, _identifier, _asClause, _equalsToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitVariableNameEquals(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents aggregation in aggregation range variable declaration of a Group By,
    ''' Group Join or Aggregate query operator.
    ''' </summary>
    Friend MustInherit Class AggregationSyntax
        Inherits ExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' Represents an invocation of an Aggregation function in the aggregation range
    ''' variable declaration of a Group By, Group Join or Aggregate query operator.
    ''' </summary>
    Friend NotInheritable Class FunctionAggregationSyntax
        Inherits AggregationSyntax

        Friend ReadOnly _functionName as IdentifierTokenSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _argument as ExpressionSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, functionName As InternalSyntax.IdentifierTokenSyntax, openParenToken As InternalSyntax.PunctuationSyntax, argument As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(functionName)
            Me._functionName = functionName
            If openParenToken IsNot Nothing Then
                Init(openParenToken)
                Me._openParenToken = openParenToken
            End If
            If argument IsNot Nothing Then
                Init(argument)
                Me._argument = argument
            End If
            If closeParenToken IsNot Nothing Then
                Init(closeParenToken)
                Me._closeParenToken = closeParenToken
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), functionName As InternalSyntax.IdentifierTokenSyntax, openParenToken As InternalSyntax.PunctuationSyntax, argument As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(functionName)
            Me._functionName = functionName
            If openParenToken IsNot Nothing Then
                Init(openParenToken)
                Me._openParenToken = openParenToken
            End If
            If argument IsNot Nothing Then
                Init(argument)
                Me._argument = argument
            End If
            If closeParenToken IsNot Nothing Then
                Init(closeParenToken)
                Me._closeParenToken = closeParenToken
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._functionName = DirectCast(reader.ReadValue(), IdentifierTokenSyntax)
          Init(Me._functionName)
          Me._openParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openParenToken)
          Me._argument = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._argument)
          Me._closeParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeParenToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._functionName)
          writer.WriteValue(Me._openParenToken)
          writer.WriteValue(Me._argument)
          writer.WriteValue(Me._closeParenToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.FunctionAggregationSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The name of the aggregation function.
        ''' </summary>
        Friend  ReadOnly Property FunctionName As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._functionName
            End Get
        End Property

        ''' <summary>
        ''' The "(" token if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The argument to the aggregation function.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Argument As InternalSyntax.ExpressionSyntax
            Get
                Return Me._argument
            End Get
        End Property

        ''' <summary>
        ''' The ")" token, if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._functionName
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._argument
                Case 3
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new FunctionAggregationSyntax(kind, newErrors, GetAnnotations, _functionName, _openParenToken, _argument, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new FunctionAggregationSyntax(kind, GetDiagnostics, annotations, _functionName, _openParenToken, _argument, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitFunctionAggregation(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the use of "Group" as the aggregation function in the in the
    ''' aggregation range variable declaration of a Group By or Group Join query
    ''' operator.
    ''' </summary>
    Friend NotInheritable Class GroupAggregationSyntax
        Inherits AggregationSyntax

        Friend ReadOnly _groupKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, groupKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(groupKeyword)
            Me._groupKeyword = groupKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), groupKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(groupKeyword)
            Me._groupKeyword = groupKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._groupKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._groupKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._groupKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.GroupAggregationSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Group" keyword.
        ''' </summary>
        Friend  ReadOnly Property GroupKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._groupKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._groupKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new GroupAggregationSyntax(kind, newErrors, GetAnnotations, _groupKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new GroupAggregationSyntax(kind, GetDiagnostics, annotations, _groupKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitGroupAggregation(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "From" query operator. If this is the beginning of a query, the
    ''' Source will be Nothing. Otherwise, the Source will be the part of the query to
    ''' the left of the From.
    ''' </summary>
    Friend NotInheritable Class FromClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _fromKeyword as KeywordSyntax
        Friend ReadOnly _variables as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, fromKeyword As InternalSyntax.KeywordSyntax, variables As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(fromKeyword)
            Me._fromKeyword = fromKeyword
            If variables IsNot Nothing Then
                Init(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), fromKeyword As InternalSyntax.KeywordSyntax, variables As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(fromKeyword)
            Me._fromKeyword = fromKeyword
            If variables IsNot Nothing Then
                Init(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._fromKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._fromKeyword)
          Me._variables = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._variables)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._fromKeyword)
          writer.WriteValue(Me._variables)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.FromClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "From" keyword.
        ''' </summary>
        Friend  ReadOnly Property FromKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._fromKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of collection variables declared by this From operator.
        ''' </summary>
        Friend  ReadOnly Property Variables As InternalSyntax.SeparatedSyntaxList(Of CollectionRangeVariableSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of CollectionRangeVariableSyntax)(New SyntaxList(of CollectionRangeVariableSyntax)(Me._variables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._fromKeyword
                Case 1
                    Return Me._variables
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new FromClauseSyntax(kind, newErrors, GetAnnotations, _fromKeyword, _variables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new FromClauseSyntax(kind, GetDiagnostics, annotations, _fromKeyword, _variables)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitFromClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Let" query operator.
    ''' </summary>
    Friend NotInheritable Class LetClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _letKeyword as KeywordSyntax
        Friend ReadOnly _variables as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, letKeyword As InternalSyntax.KeywordSyntax, variables As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(letKeyword)
            Me._letKeyword = letKeyword
            If variables IsNot Nothing Then
                Init(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), letKeyword As InternalSyntax.KeywordSyntax, variables As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(letKeyword)
            Me._letKeyword = letKeyword
            If variables IsNot Nothing Then
                Init(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._letKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._letKeyword)
          Me._variables = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._variables)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._letKeyword)
          writer.WriteValue(Me._variables)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.LetClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Let" keyword.
        ''' </summary>
        Friend  ReadOnly Property LetKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._letKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of expression range variable being defined by the Let operator.
        ''' </summary>
        Friend  ReadOnly Property Variables As InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)(New SyntaxList(of ExpressionRangeVariableSyntax)(Me._variables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._letKeyword
                Case 1
                    Return Me._variables
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new LetClauseSyntax(kind, newErrors, GetAnnotations, _letKeyword, _variables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new LetClauseSyntax(kind, GetDiagnostics, annotations, _letKeyword, _variables)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitLetClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an Aggregate query operator.
    ''' </summary>
    Friend NotInheritable Class AggregateClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _aggregateKeyword as KeywordSyntax
        Friend ReadOnly _variables as SyntaxNode
        Friend ReadOnly _additionalQueryOperators as SyntaxNode
        Friend ReadOnly _intoKeyword as KeywordSyntax
        Friend ReadOnly _aggregationVariables as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, aggregateKeyword As InternalSyntax.KeywordSyntax, variables As InternalSyntax.SyntaxNode, additionalQueryOperators As InternalSyntax.SyntaxNode, intoKeyword As InternalSyntax.KeywordSyntax, aggregationVariables As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(aggregateKeyword)
            Me._aggregateKeyword = aggregateKeyword
            If variables IsNot Nothing Then
                Init(variables)
                Me._variables = variables
            End If
            If additionalQueryOperators IsNot Nothing Then
                Init(additionalQueryOperators)
                Me._additionalQueryOperators = additionalQueryOperators
            End If
            Init(intoKeyword)
            Me._intoKeyword = intoKeyword
            If aggregationVariables IsNot Nothing Then
                Init(aggregationVariables)
                Me._aggregationVariables = aggregationVariables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), aggregateKeyword As InternalSyntax.KeywordSyntax, variables As InternalSyntax.SyntaxNode, additionalQueryOperators As InternalSyntax.SyntaxNode, intoKeyword As InternalSyntax.KeywordSyntax, aggregationVariables As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(aggregateKeyword)
            Me._aggregateKeyword = aggregateKeyword
            If variables IsNot Nothing Then
                Init(variables)
                Me._variables = variables
            End If
            If additionalQueryOperators IsNot Nothing Then
                Init(additionalQueryOperators)
                Me._additionalQueryOperators = additionalQueryOperators
            End If
            Init(intoKeyword)
            Me._intoKeyword = intoKeyword
            If aggregationVariables IsNot Nothing Then
                Init(aggregationVariables)
                Me._aggregationVariables = aggregationVariables
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._aggregateKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._aggregateKeyword)
          Me._variables = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._variables)
          Me._additionalQueryOperators = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._additionalQueryOperators)
          Me._intoKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._intoKeyword)
          Me._aggregationVariables = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._aggregationVariables)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._aggregateKeyword)
          writer.WriteValue(Me._variables)
          writer.WriteValue(Me._additionalQueryOperators)
          writer.WriteValue(Me._intoKeyword)
          writer.WriteValue(Me._aggregationVariables)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.AggregateClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Aggregate" keyword.
        ''' </summary>
        Friend  ReadOnly Property AggregateKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._aggregateKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of collection range variables declared by this Aggregate operator.
        ''' </summary>
        Friend  ReadOnly Property Variables As InternalSyntax.SeparatedSyntaxList(Of CollectionRangeVariableSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of CollectionRangeVariableSyntax)(New SyntaxList(of CollectionRangeVariableSyntax)(Me._variables))
            End Get
        End Property

        ''' <summary>
        ''' A list of additional query operators. It may be empty.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property AdditionalQueryOperators As InternalSyntax.SyntaxList(Of QueryClauseSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of QueryClauseSyntax)(Me._additionalQueryOperators)
            End Get
        End Property

        ''' <summary>
        ''' The "Into" keyword.
        ''' </summary>
        Friend  ReadOnly Property IntoKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._intoKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of new variables being defined by the aggregation.
        ''' </summary>
        Friend  ReadOnly Property AggregationVariables As InternalSyntax.SeparatedSyntaxList(Of AggregationRangeVariableSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of AggregationRangeVariableSyntax)(New SyntaxList(of AggregationRangeVariableSyntax)(Me._aggregationVariables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._aggregateKeyword
                Case 1
                    Return Me._variables
                Case 2
                    Return Me._additionalQueryOperators
                Case 3
                    Return Me._intoKeyword
                Case 4
                    Return Me._aggregationVariables
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new AggregateClauseSyntax(kind, newErrors, GetAnnotations, _aggregateKeyword, _variables, _additionalQueryOperators, _intoKeyword, _aggregationVariables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new AggregateClauseSyntax(kind, GetDiagnostics, annotations, _aggregateKeyword, _variables, _additionalQueryOperators, _intoKeyword, _aggregationVariables)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitAggregateClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Distinct" query operator.
    ''' </summary>
    Friend NotInheritable Class DistinctClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _distinctKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, distinctKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(distinctKeyword)
            Me._distinctKeyword = distinctKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), distinctKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(distinctKeyword)
            Me._distinctKeyword = distinctKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._distinctKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._distinctKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._distinctKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.DistinctClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Distinct" keyword.
        ''' </summary>
        Friend  ReadOnly Property DistinctKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._distinctKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._distinctKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new DistinctClauseSyntax(kind, newErrors, GetAnnotations, _distinctKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new DistinctClauseSyntax(kind, GetDiagnostics, annotations, _distinctKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitDistinctClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Where" query operator.
    ''' </summary>
    Friend NotInheritable Class WhereClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _whereKeyword as KeywordSyntax
        Friend ReadOnly _condition as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, whereKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind)

            Init(whereKeyword)
            Me._whereKeyword = whereKeyword
            Init(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), whereKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(whereKeyword)
            Me._whereKeyword = whereKeyword
            Init(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._whereKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._whereKeyword)
          Me._condition = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._condition)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._whereKeyword)
          writer.WriteValue(Me._condition)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.WhereClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Where" keyword.
        ''' </summary>
        Friend  ReadOnly Property WhereKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._whereKeyword
            End Get
        End Property

        ''' <summary>
        ''' The boolean expression used for filtering.
        ''' </summary>
        Friend  ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._whereKeyword
                Case 1
                    Return Me._condition
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new WhereClauseSyntax(kind, newErrors, GetAnnotations, _whereKeyword, _condition)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new WhereClauseSyntax(kind, GetDiagnostics, annotations, _whereKeyword, _condition)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitWhereClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Skip While" or "Take While" query operator. The Kind property
    ''' tells which.
    ''' </summary>
    Friend NotInheritable Class PartitionWhileClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _skipOrTakeKeyword as KeywordSyntax
        Friend ReadOnly _whileKeyword as KeywordSyntax
        Friend ReadOnly _condition as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, skipOrTakeKeyword As InternalSyntax.KeywordSyntax, whileKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind)

            Init(skipOrTakeKeyword)
            Me._skipOrTakeKeyword = skipOrTakeKeyword
            Init(whileKeyword)
            Me._whileKeyword = whileKeyword
            Init(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), skipOrTakeKeyword As InternalSyntax.KeywordSyntax, whileKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(skipOrTakeKeyword)
            Me._skipOrTakeKeyword = skipOrTakeKeyword
            Init(whileKeyword)
            Me._whileKeyword = whileKeyword
            Init(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._skipOrTakeKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._skipOrTakeKeyword)
          Me._whileKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._whileKeyword)
          Me._condition = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._condition)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._skipOrTakeKeyword)
          writer.WriteValue(Me._whileKeyword)
          writer.WriteValue(Me._condition)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.PartitionWhileClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Skip" or "Take" keyword.
        ''' </summary>
        Friend  ReadOnly Property SkipOrTakeKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._skipOrTakeKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "While" keyword.
        ''' </summary>
        Friend  ReadOnly Property WhileKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._whileKeyword
            End Get
        End Property

        ''' <summary>
        ''' The boolean expression used for partitioning.
        ''' </summary>
        Friend  ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._skipOrTakeKeyword
                Case 1
                    Return Me._whileKeyword
                Case 2
                    Return Me._condition
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new PartitionWhileClauseSyntax(kind, newErrors, GetAnnotations, _skipOrTakeKeyword, _whileKeyword, _condition)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new PartitionWhileClauseSyntax(kind, GetDiagnostics, annotations, _skipOrTakeKeyword, _whileKeyword, _condition)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitPartitionWhileClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Skip" or "Take" query operator. The Kind property tells which.
    ''' </summary>
    Friend NotInheritable Class PartitionClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _skipOrTakeKeyword as KeywordSyntax
        Friend ReadOnly _count as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, skipOrTakeKeyword As InternalSyntax.KeywordSyntax, count As ExpressionSyntax)
            MyBase.New(kind)

            Init(skipOrTakeKeyword)
            Me._skipOrTakeKeyword = skipOrTakeKeyword
            Init(count)
            Me._count = count

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), skipOrTakeKeyword As InternalSyntax.KeywordSyntax, count As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(skipOrTakeKeyword)
            Me._skipOrTakeKeyword = skipOrTakeKeyword
            Init(count)
            Me._count = count

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._skipOrTakeKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._skipOrTakeKeyword)
          Me._count = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._count)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._skipOrTakeKeyword)
          writer.WriteValue(Me._count)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.PartitionClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Skip" or "Take" keyword.
        ''' </summary>
        Friend  ReadOnly Property SkipOrTakeKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._skipOrTakeKeyword
            End Get
        End Property

        ''' <summary>
        ''' Represents the expression with the number of items to take or skip.
        ''' </summary>
        Friend  ReadOnly Property Count As InternalSyntax.ExpressionSyntax
            Get
                Return Me._count
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._skipOrTakeKeyword
                Case 1
                    Return Me._count
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new PartitionClauseSyntax(kind, newErrors, GetAnnotations, _skipOrTakeKeyword, _count)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new PartitionClauseSyntax(kind, GetDiagnostics, annotations, _skipOrTakeKeyword, _count)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitPartitionClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Group By" query operator.
    ''' </summary>
    Friend NotInheritable Class GroupByClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _groupKeyword as KeywordSyntax
        Friend ReadOnly _items as SyntaxNode
        Friend ReadOnly _byKeyword as KeywordSyntax
        Friend ReadOnly _keys as SyntaxNode
        Friend ReadOnly _intoKeyword as KeywordSyntax
        Friend ReadOnly _aggregationVariables as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, groupKeyword As InternalSyntax.KeywordSyntax, items As InternalSyntax.SyntaxNode, byKeyword As InternalSyntax.KeywordSyntax, keys As InternalSyntax.SyntaxNode, intoKeyword As InternalSyntax.KeywordSyntax, aggregationVariables As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(groupKeyword)
            Me._groupKeyword = groupKeyword
            If items IsNot Nothing Then
                Init(items)
                Me._items = items
            End If
            Init(byKeyword)
            Me._byKeyword = byKeyword
            If keys IsNot Nothing Then
                Init(keys)
                Me._keys = keys
            End If
            Init(intoKeyword)
            Me._intoKeyword = intoKeyword
            If aggregationVariables IsNot Nothing Then
                Init(aggregationVariables)
                Me._aggregationVariables = aggregationVariables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), groupKeyword As InternalSyntax.KeywordSyntax, items As InternalSyntax.SyntaxNode, byKeyword As InternalSyntax.KeywordSyntax, keys As InternalSyntax.SyntaxNode, intoKeyword As InternalSyntax.KeywordSyntax, aggregationVariables As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(groupKeyword)
            Me._groupKeyword = groupKeyword
            If items IsNot Nothing Then
                Init(items)
                Me._items = items
            End If
            Init(byKeyword)
            Me._byKeyword = byKeyword
            If keys IsNot Nothing Then
                Init(keys)
                Me._keys = keys
            End If
            Init(intoKeyword)
            Me._intoKeyword = intoKeyword
            If aggregationVariables IsNot Nothing Then
                Init(aggregationVariables)
                Me._aggregationVariables = aggregationVariables
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._groupKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._groupKeyword)
          Me._items = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._items)
          Me._byKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._byKeyword)
          Me._keys = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._keys)
          Me._intoKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._intoKeyword)
          Me._aggregationVariables = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._aggregationVariables)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._groupKeyword)
          writer.WriteValue(Me._items)
          writer.WriteValue(Me._byKeyword)
          writer.WriteValue(Me._keys)
          writer.WriteValue(Me._intoKeyword)
          writer.WriteValue(Me._aggregationVariables)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.GroupByClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Group" keyword.
        ''' </summary>
        Friend  ReadOnly Property GroupKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._groupKeyword
            End Get
        End Property

        ''' <summary>
        ''' The optional list of variables being grouped; the contents of the Group clause.
        ''' If none were specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Items As InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)(New SyntaxList(of ExpressionRangeVariableSyntax)(Me._items))
            End Get
        End Property

        ''' <summary>
        ''' The "By" keyword.
        ''' </summary>
        Friend  ReadOnly Property ByKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._byKeyword
            End Get
        End Property

        ''' <summary>
        ''' The key values being used for grouping.
        ''' </summary>
        Friend  ReadOnly Property Keys As InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)(New SyntaxList(of ExpressionRangeVariableSyntax)(Me._keys))
            End Get
        End Property

        Friend  ReadOnly Property IntoKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._intoKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of new variables that calculate aggregations.
        ''' </summary>
        Friend  ReadOnly Property AggregationVariables As InternalSyntax.SeparatedSyntaxList(Of AggregationRangeVariableSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of AggregationRangeVariableSyntax)(New SyntaxList(of AggregationRangeVariableSyntax)(Me._aggregationVariables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._groupKeyword
                Case 1
                    Return Me._items
                Case 2
                    Return Me._byKeyword
                Case 3
                    Return Me._keys
                Case 4
                    Return Me._intoKeyword
                Case 5
                    Return Me._aggregationVariables
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 6
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new GroupByClauseSyntax(kind, newErrors, GetAnnotations, _groupKeyword, _items, _byKeyword, _keys, _intoKeyword, _aggregationVariables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new GroupByClauseSyntax(kind, GetDiagnostics, annotations, _groupKeyword, _items, _byKeyword, _keys, _intoKeyword, _aggregationVariables)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitGroupByClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Join query operator.
    ''' </summary>
    Friend Class JoinClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _joinKeyword as KeywordSyntax
        Friend ReadOnly _joinedVariables as SyntaxNode
        Friend ReadOnly _additionalJoins as SyntaxNode
        Friend ReadOnly _onKeyword as KeywordSyntax
        Friend ReadOnly _joinConditions as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, joinKeyword As InternalSyntax.KeywordSyntax, joinedVariables As InternalSyntax.SyntaxNode, additionalJoins As InternalSyntax.SyntaxNode, onKeyword As InternalSyntax.KeywordSyntax, joinConditions As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(joinKeyword)
            Me._joinKeyword = joinKeyword
            If joinedVariables IsNot Nothing Then
                Init(joinedVariables)
                Me._joinedVariables = joinedVariables
            End If
            If additionalJoins IsNot Nothing Then
                Init(additionalJoins)
                Me._additionalJoins = additionalJoins
            End If
            Init(onKeyword)
            Me._onKeyword = onKeyword
            If joinConditions IsNot Nothing Then
                Init(joinConditions)
                Me._joinConditions = joinConditions
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), joinKeyword As InternalSyntax.KeywordSyntax, joinedVariables As InternalSyntax.SyntaxNode, additionalJoins As InternalSyntax.SyntaxNode, onKeyword As InternalSyntax.KeywordSyntax, joinConditions As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(joinKeyword)
            Me._joinKeyword = joinKeyword
            If joinedVariables IsNot Nothing Then
                Init(joinedVariables)
                Me._joinedVariables = joinedVariables
            End If
            If additionalJoins IsNot Nothing Then
                Init(additionalJoins)
                Me._additionalJoins = additionalJoins
            End If
            Init(onKeyword)
            Me._onKeyword = onKeyword
            If joinConditions IsNot Nothing Then
                Init(joinConditions)
                Me._joinConditions = joinConditions
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._joinKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._joinKeyword)
          Me._joinedVariables = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._joinedVariables)
          Me._additionalJoins = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._additionalJoins)
          Me._onKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._onKeyword)
          Me._joinConditions = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._joinConditions)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._joinKeyword)
          writer.WriteValue(Me._joinedVariables)
          writer.WriteValue(Me._additionalJoins)
          writer.WriteValue(Me._onKeyword)
          writer.WriteValue(Me._joinConditions)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.JoinClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Join" keyword.
        ''' </summary>
        Friend  ReadOnly Property JoinKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._joinKeyword
            End Get
        End Property

        ''' <summary>
        ''' Defines the collection range variables being joined to.
        ''' </summary>
        Friend  ReadOnly Property JoinedVariables As InternalSyntax.SeparatedSyntaxList(Of CollectionRangeVariableSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of CollectionRangeVariableSyntax)(New SyntaxList(of CollectionRangeVariableSyntax)(Me._joinedVariables))
            End Get
        End Property

        ''' <summary>
        ''' An additional Join or Group Join query operator.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property AdditionalJoins As InternalSyntax.SyntaxList(Of JoinClauseSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of JoinClauseSyntax)(Me._additionalJoins)
            End Get
        End Property

        ''' <summary>
        ''' The "On" keyword.
        ''' </summary>
        Friend  ReadOnly Property OnKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._onKeyword
            End Get
        End Property

        ''' <summary>
        ''' The conditions indicating what expressions to compare during the join. Each
        ''' condition is a JoinCondition, and the separators are "And" keywords.
        ''' </summary>
        Friend  ReadOnly Property JoinConditions As InternalSyntax.SeparatedSyntaxList(Of JoinConditionSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of JoinConditionSyntax)(New SyntaxList(of JoinConditionSyntax)(Me._joinConditions))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._joinKeyword
                Case 1
                    Return Me._joinedVariables
                Case 2
                    Return Me._additionalJoins
                Case 3
                    Return Me._onKeyword
                Case 4
                    Return Me._joinConditions
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new JoinClauseSyntax(kind, newErrors, GetAnnotations, _joinKeyword, _joinedVariables, _additionalJoins, _onKeyword, _joinConditions)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new JoinClauseSyntax(kind, GetDiagnostics, annotations, _joinKeyword, _joinedVariables, _additionalJoins, _onKeyword, _joinConditions)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitJoinClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "expression Equals expression" condition in a Join.
    ''' </summary>
    Friend NotInheritable Class JoinConditionSyntax
        Inherits SyntaxNode

        Friend ReadOnly _left as ExpressionSyntax
        Friend ReadOnly _equalsKeyword as KeywordSyntax
        Friend ReadOnly _right as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, left As ExpressionSyntax, equalsKeyword As InternalSyntax.KeywordSyntax, right As ExpressionSyntax)
            MyBase.New(kind)

            Init(left)
            Me._left = left
            Init(equalsKeyword)
            Me._equalsKeyword = equalsKeyword
            Init(right)
            Me._right = right

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), left As ExpressionSyntax, equalsKeyword As InternalSyntax.KeywordSyntax, right As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)

            Init(left)
            Me._left = left
            Init(equalsKeyword)
            Me._equalsKeyword = equalsKeyword
            Init(right)
            Me._right = right

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._left = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._left)
          Me._equalsKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._equalsKeyword)
          Me._right = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._right)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._left)
          writer.WriteValue(Me._equalsKeyword)
          writer.WriteValue(Me._right)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.JoinConditionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The left expression in the Join condition.
        ''' </summary>
        Friend  ReadOnly Property Left As InternalSyntax.ExpressionSyntax
            Get
                Return Me._left
            End Get
        End Property

        ''' <summary>
        ''' The "Equals" keyword.
        ''' </summary>
        Friend  ReadOnly Property EqualsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._equalsKeyword
            End Get
        End Property

        ''' <summary>
        ''' The right expression in the Join condition.
        ''' </summary>
        Friend  ReadOnly Property Right As InternalSyntax.ExpressionSyntax
            Get
                Return Me._right
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._left
                Case 1
                    Return Me._equalsKeyword
                Case 2
                    Return Me._right
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new JoinConditionSyntax(kind, newErrors, GetAnnotations, _left, _equalsKeyword, _right)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new JoinConditionSyntax(kind, GetDiagnostics, annotations, _left, _equalsKeyword, _right)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitJoinCondition(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Group Join" query operator.
    ''' </summary>
    Friend NotInheritable Class GroupJoinClauseSyntax
        Inherits JoinClauseSyntax

        Friend ReadOnly _groupKeyword as KeywordSyntax
        Friend ReadOnly _intoKeyword as KeywordSyntax
        Friend ReadOnly _aggregationVariables as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, groupKeyword As InternalSyntax.KeywordSyntax, joinKeyword As InternalSyntax.KeywordSyntax, joinedVariables As InternalSyntax.SyntaxNode, additionalJoins As InternalSyntax.SyntaxNode, onKeyword As InternalSyntax.KeywordSyntax, joinConditions As InternalSyntax.SyntaxNode, intoKeyword As InternalSyntax.KeywordSyntax, aggregationVariables As InternalSyntax.SyntaxNode)
            MyBase.New(kind, joinKeyword, joinedVariables, additionalJoins, onKeyword, joinConditions)

            Init(groupKeyword)
            Me._groupKeyword = groupKeyword
            Init(intoKeyword)
            Me._intoKeyword = intoKeyword
            If aggregationVariables IsNot Nothing Then
                Init(aggregationVariables)
                Me._aggregationVariables = aggregationVariables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), groupKeyword As InternalSyntax.KeywordSyntax, joinKeyword As InternalSyntax.KeywordSyntax, joinedVariables As InternalSyntax.SyntaxNode, additionalJoins As InternalSyntax.SyntaxNode, onKeyword As InternalSyntax.KeywordSyntax, joinConditions As InternalSyntax.SyntaxNode, intoKeyword As InternalSyntax.KeywordSyntax, aggregationVariables As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations, joinKeyword, joinedVariables, additionalJoins, onKeyword, joinConditions)

            Init(groupKeyword)
            Me._groupKeyword = groupKeyword
            Init(intoKeyword)
            Me._intoKeyword = intoKeyword
            If aggregationVariables IsNot Nothing Then
                Init(aggregationVariables)
                Me._aggregationVariables = aggregationVariables
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._groupKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._groupKeyword)
          Me._intoKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._intoKeyword)
          Me._aggregationVariables = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._aggregationVariables)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._groupKeyword)
          writer.WriteValue(Me._intoKeyword)
          writer.WriteValue(Me._aggregationVariables)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.GroupJoinClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Group" keyword.
        ''' </summary>
        Friend  ReadOnly Property GroupKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._groupKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Into" keyword.
        ''' </summary>
        Friend  ReadOnly Property IntoKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._intoKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of new variables that calculate aggregations.
        ''' </summary>
        Friend  ReadOnly Property AggregationVariables As InternalSyntax.SeparatedSyntaxList(Of AggregationRangeVariableSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of AggregationRangeVariableSyntax)(New SyntaxList(of AggregationRangeVariableSyntax)(Me._aggregationVariables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._groupKeyword
                Case 1
                    Return Me._joinKeyword
                Case 2
                    Return Me._joinedVariables
                Case 3
                    Return Me._additionalJoins
                Case 4
                    Return Me._onKeyword
                Case 5
                    Return Me._joinConditions
                Case 6
                    Return Me._intoKeyword
                Case 7
                    Return Me._aggregationVariables
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 8
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new GroupJoinClauseSyntax(kind, newErrors, GetAnnotations, _groupKeyword, _joinKeyword, _joinedVariables, _additionalJoins, _onKeyword, _joinConditions, _intoKeyword, _aggregationVariables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new GroupJoinClauseSyntax(kind, GetDiagnostics, annotations, _groupKeyword, _joinKeyword, _joinedVariables, _additionalJoins, _onKeyword, _joinConditions, _intoKeyword, _aggregationVariables)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitGroupJoinClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Order By" query operator.
    ''' </summary>
    Friend NotInheritable Class OrderByClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _orderKeyword as KeywordSyntax
        Friend ReadOnly _byKeyword as KeywordSyntax
        Friend ReadOnly _orderings as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, orderKeyword As InternalSyntax.KeywordSyntax, byKeyword As InternalSyntax.KeywordSyntax, orderings As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(orderKeyword)
            Me._orderKeyword = orderKeyword
            Init(byKeyword)
            Me._byKeyword = byKeyword
            If orderings IsNot Nothing Then
                Init(orderings)
                Me._orderings = orderings
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), orderKeyword As InternalSyntax.KeywordSyntax, byKeyword As InternalSyntax.KeywordSyntax, orderings As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(orderKeyword)
            Me._orderKeyword = orderKeyword
            Init(byKeyword)
            Me._byKeyword = byKeyword
            If orderings IsNot Nothing Then
                Init(orderings)
                Me._orderings = orderings
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._orderKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._orderKeyword)
          Me._byKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._byKeyword)
          Me._orderings = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._orderings)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._orderKeyword)
          writer.WriteValue(Me._byKeyword)
          writer.WriteValue(Me._orderings)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.OrderByClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Order" keyword
        ''' </summary>
        Friend  ReadOnly Property OrderKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._orderKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "By" keyword.
        ''' </summary>
        Friend  ReadOnly Property ByKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._byKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of OrderExpression's to sort by.
        ''' </summary>
        Friend  ReadOnly Property Orderings As InternalSyntax.SeparatedSyntaxList(Of OrderingSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of OrderingSyntax)(New SyntaxList(of OrderingSyntax)(Me._orderings))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._orderKeyword
                Case 1
                    Return Me._byKeyword
                Case 2
                    Return Me._orderings
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new OrderByClauseSyntax(kind, newErrors, GetAnnotations, _orderKeyword, _byKeyword, _orderings)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new OrderByClauseSyntax(kind, GetDiagnostics, annotations, _orderKeyword, _byKeyword, _orderings)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitOrderByClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' An expression to order by, plus an optional ordering. The Kind indicates
    ''' whether to order in ascending or descending order.
    ''' </summary>
    Friend NotInheritable Class OrderingSyntax
        Inherits SyntaxNode

        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _ascendingOrDescendingKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax, ascendingOrDescendingKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(expression)
            Me._expression = expression
            If ascendingOrDescendingKeyword IsNot Nothing Then
                Init(ascendingOrDescendingKeyword)
                Me._ascendingOrDescendingKeyword = ascendingOrDescendingKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), expression As ExpressionSyntax, ascendingOrDescendingKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(expression)
            Me._expression = expression
            If ascendingOrDescendingKeyword IsNot Nothing Then
                Init(ascendingOrDescendingKeyword)
                Me._ascendingOrDescendingKeyword = ascendingOrDescendingKeyword
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
          Me._ascendingOrDescendingKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._ascendingOrDescendingKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._expression)
          writer.WriteValue(Me._ascendingOrDescendingKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.OrderingSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The expression to sort by.
        ''' </summary>
        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' The "Ascending" or "Descending" keyword, if present. To determine whether to
        ''' sort in ascending or descending order, checking the Kind property is easier.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property AscendingOrDescendingKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ascendingOrDescendingKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._expression
                Case 1
                    Return Me._ascendingOrDescendingKeyword
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new OrderingSyntax(kind, newErrors, GetAnnotations, _expression, _ascendingOrDescendingKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new OrderingSyntax(kind, GetDiagnostics, annotations, _expression, _ascendingOrDescendingKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitOrdering(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Select" query operator.
    ''' </summary>
    Friend NotInheritable Class SelectClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _selectKeyword as KeywordSyntax
        Friend ReadOnly _variables as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, selectKeyword As InternalSyntax.KeywordSyntax, variables As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(selectKeyword)
            Me._selectKeyword = selectKeyword
            If variables IsNot Nothing Then
                Init(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), selectKeyword As InternalSyntax.KeywordSyntax, variables As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(selectKeyword)
            Me._selectKeyword = selectKeyword
            If variables IsNot Nothing Then
                Init(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._selectKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._selectKeyword)
          Me._variables = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._variables)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._selectKeyword)
          writer.WriteValue(Me._variables)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.SelectClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Select" keyword.
        ''' </summary>
        Friend  ReadOnly Property SelectKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._selectKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of expression range variables being defined by the Select query
        ''' operator.
        ''' </summary>
        Friend  ReadOnly Property Variables As InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)(New SyntaxList(of ExpressionRangeVariableSyntax)(Me._variables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._selectKeyword
                Case 1
                    Return Me._variables
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new SelectClauseSyntax(kind, newErrors, GetAnnotations, _selectKeyword, _variables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new SelectClauseSyntax(kind, GetDiagnostics, annotations, _selectKeyword, _variables)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitSelectClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' This is the base class for all XML expression syntax nodes (XmlDocument and
    ''' XmlElement).
    ''' </summary>
    Friend MustInherit Class XmlNodeSyntax
        Inherits ExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' Represents and XML Document literal expression.
    ''' </summary>
    Friend NotInheritable Class XmlDocumentSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _declaration as XmlDeclarationSyntax
        Friend ReadOnly _precedingMisc as SyntaxNode
        Friend ReadOnly _root as XmlNodeSyntax
        Friend ReadOnly _followingMisc as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, declaration As XmlDeclarationSyntax, precedingMisc As InternalSyntax.SyntaxNode, root As XmlNodeSyntax, followingMisc As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(declaration)
            Me._declaration = declaration
            If precedingMisc IsNot Nothing Then
                Init(precedingMisc)
                Me._precedingMisc = precedingMisc
            End If
            Init(root)
            Me._root = root
            If followingMisc IsNot Nothing Then
                Init(followingMisc)
                Me._followingMisc = followingMisc
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), declaration As XmlDeclarationSyntax, precedingMisc As InternalSyntax.SyntaxNode, root As XmlNodeSyntax, followingMisc As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(declaration)
            Me._declaration = declaration
            If precedingMisc IsNot Nothing Then
                Init(precedingMisc)
                Me._precedingMisc = precedingMisc
            End If
            Init(root)
            Me._root = root
            If followingMisc IsNot Nothing Then
                Init(followingMisc)
                Me._followingMisc = followingMisc
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._declaration = DirectCast(reader.ReadValue(), XmlDeclarationSyntax)
          Init(Me._declaration)
          Me._precedingMisc = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._precedingMisc)
          Me._root = DirectCast(reader.ReadValue(), XmlNodeSyntax)
          Init(Me._root)
          Me._followingMisc = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._followingMisc)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._declaration)
          writer.WriteValue(Me._precedingMisc)
          writer.WriteValue(Me._root)
          writer.WriteValue(Me._followingMisc)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlDocumentSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property Declaration As InternalSyntax.XmlDeclarationSyntax
            Get
                Return Me._declaration
            End Get
        End Property

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property PrecedingMisc As InternalSyntax.SyntaxList(Of XmlNodeSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of XmlNodeSyntax)(Me._precedingMisc)
            End Get
        End Property

        Friend  ReadOnly Property Root As InternalSyntax.XmlNodeSyntax
            Get
                Return Me._root
            End Get
        End Property

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property FollowingMisc As InternalSyntax.SyntaxList(Of XmlNodeSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of XmlNodeSyntax)(Me._followingMisc)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._declaration
                Case 1
                    Return Me._precedingMisc
                Case 2
                    Return Me._root
                Case 3
                    Return Me._followingMisc
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlDocumentSyntax(kind, newErrors, GetAnnotations, _declaration, _precedingMisc, _root, _followingMisc)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlDocumentSyntax(kind, GetDiagnostics, annotations, _declaration, _precedingMisc, _root, _followingMisc)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlDocument(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the XML declaration prologue in an XML literal expression.
    ''' </summary>
    Friend NotInheritable Class XmlDeclarationSyntax
        Inherits SyntaxNode

        Friend ReadOnly _lessThanQuestionToken as PunctuationSyntax
        Friend ReadOnly _xmlKeyword as KeywordSyntax
        Friend ReadOnly _version as XmlDeclarationOptionSyntax
        Friend ReadOnly _encoding as XmlDeclarationOptionSyntax
        Friend ReadOnly _standalone as XmlDeclarationOptionSyntax
        Friend ReadOnly _questionGreaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanQuestionToken As InternalSyntax.PunctuationSyntax, xmlKeyword As InternalSyntax.KeywordSyntax, version As XmlDeclarationOptionSyntax, encoding As XmlDeclarationOptionSyntax, standalone As XmlDeclarationOptionSyntax, questionGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(lessThanQuestionToken)
            Me._lessThanQuestionToken = lessThanQuestionToken
            Init(xmlKeyword)
            Me._xmlKeyword = xmlKeyword
            Init(version)
            Me._version = version
            If encoding IsNot Nothing Then
                Init(encoding)
                Me._encoding = encoding
            End If
            If standalone IsNot Nothing Then
                Init(standalone)
                Me._standalone = standalone
            End If
            Init(questionGreaterThanToken)
            Me._questionGreaterThanToken = questionGreaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanQuestionToken As InternalSyntax.PunctuationSyntax, xmlKeyword As InternalSyntax.KeywordSyntax, version As XmlDeclarationOptionSyntax, encoding As XmlDeclarationOptionSyntax, standalone As XmlDeclarationOptionSyntax, questionGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(lessThanQuestionToken)
            Me._lessThanQuestionToken = lessThanQuestionToken
            Init(xmlKeyword)
            Me._xmlKeyword = xmlKeyword
            Init(version)
            Me._version = version
            If encoding IsNot Nothing Then
                Init(encoding)
                Me._encoding = encoding
            End If
            If standalone IsNot Nothing Then
                Init(standalone)
                Me._standalone = standalone
            End If
            Init(questionGreaterThanToken)
            Me._questionGreaterThanToken = questionGreaterThanToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._lessThanQuestionToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._lessThanQuestionToken)
          Me._xmlKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._xmlKeyword)
          Me._version = DirectCast(reader.ReadValue(), XmlDeclarationOptionSyntax)
          Init(Me._version)
          Me._encoding = DirectCast(reader.ReadValue(), XmlDeclarationOptionSyntax)
          Init(Me._encoding)
          Me._standalone = DirectCast(reader.ReadValue(), XmlDeclarationOptionSyntax)
          Init(Me._standalone)
          Me._questionGreaterThanToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._questionGreaterThanToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._lessThanQuestionToken)
          writer.WriteValue(Me._xmlKeyword)
          writer.WriteValue(Me._version)
          writer.WriteValue(Me._encoding)
          writer.WriteValue(Me._standalone)
          writer.WriteValue(Me._questionGreaterThanToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlDeclarationSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property LessThanQuestionToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanQuestionToken
            End Get
        End Property

        Friend  ReadOnly Property XmlKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._xmlKeyword
            End Get
        End Property

        Friend  ReadOnly Property Version As InternalSyntax.XmlDeclarationOptionSyntax
            Get
                Return Me._version
            End Get
        End Property

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Encoding As InternalSyntax.XmlDeclarationOptionSyntax
            Get
                Return Me._encoding
            End Get
        End Property

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Standalone As InternalSyntax.XmlDeclarationOptionSyntax
            Get
                Return Me._standalone
            End Get
        End Property

        Friend  ReadOnly Property QuestionGreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._questionGreaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._lessThanQuestionToken
                Case 1
                    Return Me._xmlKeyword
                Case 2
                    Return Me._version
                Case 3
                    Return Me._encoding
                Case 4
                    Return Me._standalone
                Case 5
                    Return Me._questionGreaterThanToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 6
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlDeclarationSyntax(kind, newErrors, GetAnnotations, _lessThanQuestionToken, _xmlKeyword, _version, _encoding, _standalone, _questionGreaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlDeclarationSyntax(kind, GetDiagnostics, annotations, _lessThanQuestionToken, _xmlKeyword, _version, _encoding, _standalone, _questionGreaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlDeclaration(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML document prologue option - version, encoding, standalone or
    ''' whitespace in an XML literal expression.
    ''' </summary>
    Friend NotInheritable Class XmlDeclarationOptionSyntax
        Inherits SyntaxNode

        Friend ReadOnly _name as XmlNameTokenSyntax
        Friend ReadOnly _equals as PunctuationSyntax
        Friend ReadOnly _value as XmlStringSyntax

        Friend Sub New(ByVal kind As SyntaxKind, name As InternalSyntax.XmlNameTokenSyntax, equals As InternalSyntax.PunctuationSyntax, value As XmlStringSyntax)
            MyBase.New(kind)

            Init(name)
            Me._name = name
            Init(equals)
            Me._equals = equals
            Init(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), name As InternalSyntax.XmlNameTokenSyntax, equals As InternalSyntax.PunctuationSyntax, value As XmlStringSyntax)
            MyBase.New(kind, errors, annotations)

            Init(name)
            Me._name = name
            Init(equals)
            Me._equals = equals
            Init(value)
            Me._value = value

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._name = DirectCast(reader.ReadValue(), XmlNameTokenSyntax)
          Init(Me._name)
          Me._equals = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._equals)
          Me._value = DirectCast(reader.ReadValue(), XmlStringSyntax)
          Init(Me._value)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._name)
          writer.WriteValue(Me._equals)
          writer.WriteValue(Me._value)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlDeclarationOptionSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property Name As InternalSyntax.XmlNameTokenSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend Shadows  ReadOnly Property Equals As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equals
            End Get
        End Property

        Friend  ReadOnly Property Value As InternalSyntax.XmlStringSyntax
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._name
                Case 1
                    Return Me._equals
                Case 2
                    Return Me._value
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlDeclarationOptionSyntax(kind, newErrors, GetAnnotations, _name, _equals, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlDeclarationOptionSyntax(kind, GetDiagnostics, annotations, _name, _equals, _value)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlDeclarationOption(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML element with content in an XML literal expression.
    ''' </summary>
    Friend NotInheritable Class XmlElementSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _startTag as XmlElementStartTagSyntax
        Friend ReadOnly _content as SyntaxNode
        Friend ReadOnly _endTag as XmlElementEndTagSyntax

        Friend Sub New(ByVal kind As SyntaxKind, startTag As XmlElementStartTagSyntax, content As InternalSyntax.SyntaxNode, endTag As XmlElementEndTagSyntax)
            MyBase.New(kind)

            Init(startTag)
            Me._startTag = startTag
            If content IsNot Nothing Then
                Init(content)
                Me._content = content
            End If
            Init(endTag)
            Me._endTag = endTag

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), startTag As XmlElementStartTagSyntax, content As InternalSyntax.SyntaxNode, endTag As XmlElementEndTagSyntax)
            MyBase.New(kind, errors, annotations)

            Init(startTag)
            Me._startTag = startTag
            If content IsNot Nothing Then
                Init(content)
                Me._content = content
            End If
            Init(endTag)
            Me._endTag = endTag

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._startTag = DirectCast(reader.ReadValue(), XmlElementStartTagSyntax)
          Init(Me._startTag)
          Me._content = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._content)
          Me._endTag = DirectCast(reader.ReadValue(), XmlElementEndTagSyntax)
          Init(Me._endTag)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._startTag)
          writer.WriteValue(Me._content)
          writer.WriteValue(Me._endTag)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlElementSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property StartTag As InternalSyntax.XmlElementStartTagSyntax
            Get
                Return Me._startTag
            End Get
        End Property

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Content As InternalSyntax.SyntaxList(Of XmlNodeSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of XmlNodeSyntax)(Me._content)
            End Get
        End Property

        Friend  ReadOnly Property EndTag As InternalSyntax.XmlElementEndTagSyntax
            Get
                Return Me._endTag
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._startTag
                Case 1
                    Return Me._content
                Case 2
                    Return Me._endTag
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlElementSyntax(kind, newErrors, GetAnnotations, _startTag, _content, _endTag)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlElementSyntax(kind, GetDiagnostics, annotations, _startTag, _content, _endTag)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlElement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents Xml text.
    ''' </summary>
    Friend NotInheritable Class XmlTextSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _textTokens as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, textTokens As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            If textTokens IsNot Nothing Then
                Init(textTokens)
                Me._textTokens = textTokens
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), textTokens As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            If textTokens IsNot Nothing Then
                Init(textTokens)
                Me._textTokens = textTokens
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._textTokens = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._textTokens)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._textTokens)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlTextSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' A list of all the text tokens in the Xml text. This list always contains at
        ''' least one token.
        ''' </summary>
        Friend  ReadOnly Property TextTokens As InternalSyntax.SyntaxList(Of XmlTextTokenSyntax)
            Get
                Return New InternalSyntax.SyntaxList(of XmlTextTokenSyntax)(Me._textTokens)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._textTokens
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlTextSyntax(kind, newErrors, GetAnnotations, _textTokens)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlTextSyntax(kind, GetDiagnostics, annotations, _textTokens)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlText(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the start tag of an XML element of the form &lt;element&gt;.
    ''' </summary>
    Friend NotInheritable Class XmlElementStartTagSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _lessThanToken as PunctuationSyntax
        Friend ReadOnly _name as XmlNodeSyntax
        Friend ReadOnly _attributes as SyntaxNode
        Friend ReadOnly _greaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanToken As InternalSyntax.PunctuationSyntax, name As XmlNodeSyntax, attributes As InternalSyntax.SyntaxNode, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(lessThanToken)
            Me._lessThanToken = lessThanToken
            Init(name)
            Me._name = name
            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            Init(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanToken As InternalSyntax.PunctuationSyntax, name As XmlNodeSyntax, attributes As InternalSyntax.SyntaxNode, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(lessThanToken)
            Me._lessThanToken = lessThanToken
            Init(name)
            Me._name = name
            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            Init(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._lessThanToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._lessThanToken)
          Me._name = DirectCast(reader.ReadValue(), XmlNodeSyntax)
          Init(Me._name)
          Me._attributes = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._attributes)
          Me._greaterThanToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._greaterThanToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._lessThanToken)
          writer.WriteValue(Me._name)
          writer.WriteValue(Me._attributes)
          writer.WriteValue(Me._greaterThanToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlElementStartTagSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property LessThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanToken
            End Get
        End Property

        Friend  ReadOnly Property Name As InternalSyntax.XmlNodeSyntax
            Get
                Return Me._name
            End Get
        End Property

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Attributes As InternalSyntax.SyntaxList(Of XmlNodeSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of XmlNodeSyntax)(Me._attributes)
            End Get
        End Property

        Friend  ReadOnly Property GreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._greaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._lessThanToken
                Case 1
                    Return Me._name
                Case 2
                    Return Me._attributes
                Case 3
                    Return Me._greaterThanToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlElementStartTagSyntax(kind, newErrors, GetAnnotations, _lessThanToken, _name, _attributes, _greaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlElementStartTagSyntax(kind, GetDiagnostics, annotations, _lessThanToken, _name, _attributes, _greaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlElementStartTag(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the end tag of an XML element of the form &lt;/element&gt;.
    ''' </summary>
    Friend NotInheritable Class XmlElementEndTagSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _lessThanSlashToken as PunctuationSyntax
        Friend ReadOnly _name as XmlNameSyntax
        Friend ReadOnly _greaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanSlashToken As InternalSyntax.PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(lessThanSlashToken)
            Me._lessThanSlashToken = lessThanSlashToken
            If name IsNot Nothing Then
                Init(name)
                Me._name = name
            End If
            Init(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanSlashToken As InternalSyntax.PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(lessThanSlashToken)
            Me._lessThanSlashToken = lessThanSlashToken
            If name IsNot Nothing Then
                Init(name)
                Me._name = name
            End If
            Init(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._lessThanSlashToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._lessThanSlashToken)
          Me._name = DirectCast(reader.ReadValue(), XmlNameSyntax)
          Init(Me._name)
          Me._greaterThanToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._greaterThanToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._lessThanSlashToken)
          writer.WriteValue(Me._name)
          writer.WriteValue(Me._greaterThanToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlElementEndTagSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property LessThanSlashToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanSlashToken
            End Get
        End Property

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Name As InternalSyntax.XmlNameSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend  ReadOnly Property GreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._greaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._lessThanSlashToken
                Case 1
                    Return Me._name
                Case 2
                    Return Me._greaterThanToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlElementEndTagSyntax(kind, newErrors, GetAnnotations, _lessThanSlashToken, _name, _greaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlElementEndTagSyntax(kind, GetDiagnostics, annotations, _lessThanSlashToken, _name, _greaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlElementEndTag(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an empty XML element of the form &lt;element /&gt;
    ''' </summary>
    Friend NotInheritable Class XmlEmptyElementSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _lessThanToken as PunctuationSyntax
        Friend ReadOnly _name as XmlNodeSyntax
        Friend ReadOnly _attributes as SyntaxNode
        Friend ReadOnly _slashGreaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanToken As InternalSyntax.PunctuationSyntax, name As XmlNodeSyntax, attributes As InternalSyntax.SyntaxNode, slashGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(lessThanToken)
            Me._lessThanToken = lessThanToken
            Init(name)
            Me._name = name
            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            Init(slashGreaterThanToken)
            Me._slashGreaterThanToken = slashGreaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanToken As InternalSyntax.PunctuationSyntax, name As XmlNodeSyntax, attributes As InternalSyntax.SyntaxNode, slashGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(lessThanToken)
            Me._lessThanToken = lessThanToken
            Init(name)
            Me._name = name
            If attributes IsNot Nothing Then
                Init(attributes)
                Me._attributes = attributes
            End If
            Init(slashGreaterThanToken)
            Me._slashGreaterThanToken = slashGreaterThanToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._lessThanToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._lessThanToken)
          Me._name = DirectCast(reader.ReadValue(), XmlNodeSyntax)
          Init(Me._name)
          Me._attributes = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._attributes)
          Me._slashGreaterThanToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._slashGreaterThanToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._lessThanToken)
          writer.WriteValue(Me._name)
          writer.WriteValue(Me._attributes)
          writer.WriteValue(Me._slashGreaterThanToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlEmptyElementSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property LessThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanToken
            End Get
        End Property

        Friend  ReadOnly Property Name As InternalSyntax.XmlNodeSyntax
            Get
                Return Me._name
            End Get
        End Property

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Attributes As InternalSyntax.SyntaxList(Of XmlNodeSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of XmlNodeSyntax)(Me._attributes)
            End Get
        End Property

        Friend  ReadOnly Property SlashGreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._slashGreaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._lessThanToken
                Case 1
                    Return Me._name
                Case 2
                    Return Me._attributes
                Case 3
                    Return Me._slashGreaterThanToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlEmptyElementSyntax(kind, newErrors, GetAnnotations, _lessThanToken, _name, _attributes, _slashGreaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlEmptyElementSyntax(kind, GetDiagnostics, annotations, _lessThanToken, _name, _attributes, _slashGreaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlEmptyElement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML attribute in an XML literal expression.
    ''' </summary>
    Friend NotInheritable Class XmlAttributeSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _name as XmlNodeSyntax
        Friend ReadOnly _equalsToken as PunctuationSyntax
        Friend ReadOnly _value as XmlNodeSyntax

        Friend Sub New(ByVal kind As SyntaxKind, name As XmlNodeSyntax, equalsToken As InternalSyntax.PunctuationSyntax, value As XmlNodeSyntax)
            MyBase.New(kind)

            Init(name)
            Me._name = name
            Init(equalsToken)
            Me._equalsToken = equalsToken
            Init(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), name As XmlNodeSyntax, equalsToken As InternalSyntax.PunctuationSyntax, value As XmlNodeSyntax)
            MyBase.New(kind, errors, annotations)

            Init(name)
            Me._name = name
            Init(equalsToken)
            Me._equalsToken = equalsToken
            Init(value)
            Me._value = value

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._name = DirectCast(reader.ReadValue(), XmlNodeSyntax)
          Init(Me._name)
          Me._equalsToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._equalsToken)
          Me._value = DirectCast(reader.ReadValue(), XmlNodeSyntax)
          Init(Me._value)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._name)
          writer.WriteValue(Me._equalsToken)
          writer.WriteValue(Me._value)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlAttributeSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property Name As InternalSyntax.XmlNodeSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend  ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        Friend  ReadOnly Property Value As InternalSyntax.XmlNodeSyntax
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._name
                Case 1
                    Return Me._equalsToken
                Case 2
                    Return Me._value
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlAttributeSyntax(kind, newErrors, GetAnnotations, _name, _equalsToken, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlAttributeSyntax(kind, GetDiagnostics, annotations, _name, _equalsToken, _value)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlAttribute(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a string of XML characters embedded as the content of an XML
    ''' element.
    ''' </summary>
    Friend NotInheritable Class XmlStringSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _startQuoteToken as PunctuationSyntax
        Friend ReadOnly _textTokens as SyntaxNode
        Friend ReadOnly _endQuoteToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, startQuoteToken As InternalSyntax.PunctuationSyntax, textTokens As InternalSyntax.SyntaxNode, endQuoteToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(startQuoteToken)
            Me._startQuoteToken = startQuoteToken
            If textTokens IsNot Nothing Then
                Init(textTokens)
                Me._textTokens = textTokens
            End If
            Init(endQuoteToken)
            Me._endQuoteToken = endQuoteToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), startQuoteToken As InternalSyntax.PunctuationSyntax, textTokens As InternalSyntax.SyntaxNode, endQuoteToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(startQuoteToken)
            Me._startQuoteToken = startQuoteToken
            If textTokens IsNot Nothing Then
                Init(textTokens)
                Me._textTokens = textTokens
            End If
            Init(endQuoteToken)
            Me._endQuoteToken = endQuoteToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._startQuoteToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._startQuoteToken)
          Me._textTokens = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._textTokens)
          Me._endQuoteToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._endQuoteToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._startQuoteToken)
          writer.WriteValue(Me._textTokens)
          writer.WriteValue(Me._endQuoteToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlStringSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property StartQuoteToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._startQuoteToken
            End Get
        End Property

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property TextTokens As InternalSyntax.SyntaxList(Of XmlTextTokenSyntax)
            Get
                Return New InternalSyntax.SyntaxList(of XmlTextTokenSyntax)(Me._textTokens)
            End Get
        End Property

        Friend  ReadOnly Property EndQuoteToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._endQuoteToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._startQuoteToken
                Case 1
                    Return Me._textTokens
                Case 2
                    Return Me._endQuoteToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlStringSyntax(kind, newErrors, GetAnnotations, _startQuoteToken, _textTokens, _endQuoteToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlStringSyntax(kind, GetDiagnostics, annotations, _startQuoteToken, _textTokens, _endQuoteToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlString(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML name of the form 'name' or 'namespace:name' appearing in
    ''' source as part of an XML literal or member access expression or an XML
    ''' namespace import clause.
    ''' </summary>
    Friend NotInheritable Class XmlNameSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _prefix as XmlPrefixSyntax
        Friend ReadOnly _localName as XmlNameTokenSyntax

        Friend Sub New(ByVal kind As SyntaxKind, prefix As XmlPrefixSyntax, localName As InternalSyntax.XmlNameTokenSyntax)
            MyBase.New(kind)

            If prefix IsNot Nothing Then
                Init(prefix)
                Me._prefix = prefix
            End If
            Init(localName)
            Me._localName = localName

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), prefix As XmlPrefixSyntax, localName As InternalSyntax.XmlNameTokenSyntax)
            MyBase.New(kind, errors, annotations)

            If prefix IsNot Nothing Then
                Init(prefix)
                Me._prefix = prefix
            End If
            Init(localName)
            Me._localName = localName

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._prefix = DirectCast(reader.ReadValue(), XmlPrefixSyntax)
          Init(Me._prefix)
          Me._localName = DirectCast(reader.ReadValue(), XmlNameTokenSyntax)
          Init(Me._localName)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._prefix)
          writer.WriteValue(Me._localName)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlNameSyntax(Me, parent, startLocation)
        End Function

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property Prefix As InternalSyntax.XmlPrefixSyntax
            Get
                Return Me._prefix
            End Get
        End Property

        Friend  ReadOnly Property LocalName As InternalSyntax.XmlNameTokenSyntax
            Get
                Return Me._localName
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._prefix
                Case 1
                    Return Me._localName
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlNameSyntax(kind, newErrors, GetAnnotations, _prefix, _localName)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlNameSyntax(kind, GetDiagnostics, annotations, _prefix, _localName)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlName(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
    ''' of an XML literal or member access expression or an XML namespace import
    ''' clause.
    ''' </summary>
    Friend NotInheritable Class XmlBracketedNameSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _lessThanToken as PunctuationSyntax
        Friend ReadOnly _name as XmlNameSyntax
        Friend ReadOnly _greaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanToken As InternalSyntax.PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(lessThanToken)
            Me._lessThanToken = lessThanToken
            Init(name)
            Me._name = name
            Init(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanToken As InternalSyntax.PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(lessThanToken)
            Me._lessThanToken = lessThanToken
            Init(name)
            Me._name = name
            Init(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._lessThanToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._lessThanToken)
          Me._name = DirectCast(reader.ReadValue(), XmlNameSyntax)
          Init(Me._name)
          Me._greaterThanToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._greaterThanToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._lessThanToken)
          writer.WriteValue(Me._name)
          writer.WriteValue(Me._greaterThanToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlBracketedNameSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property LessThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanToken
            End Get
        End Property

        Friend  ReadOnly Property Name As InternalSyntax.XmlNameSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend  ReadOnly Property GreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._greaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._lessThanToken
                Case 1
                    Return Me._name
                Case 2
                    Return Me._greaterThanToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlBracketedNameSyntax(kind, newErrors, GetAnnotations, _lessThanToken, _name, _greaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlBracketedNameSyntax(kind, GetDiagnostics, annotations, _lessThanToken, _name, _greaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlBracketedName(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents and XML namespace prefix of the form 'prefix:' as in xml:ns="".
    ''' </summary>
    Friend NotInheritable Class XmlPrefixSyntax
        Inherits SyntaxNode

        Friend ReadOnly _name as XmlNameTokenSyntax
        Friend ReadOnly _colonToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, name As InternalSyntax.XmlNameTokenSyntax, colonToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(name)
            Me._name = name
            Init(colonToken)
            Me._colonToken = colonToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), name As InternalSyntax.XmlNameTokenSyntax, colonToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(name)
            Me._name = name
            Init(colonToken)
            Me._colonToken = colonToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._name = DirectCast(reader.ReadValue(), XmlNameTokenSyntax)
          Init(Me._name)
          Me._colonToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._colonToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._name)
          writer.WriteValue(Me._colonToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlPrefixSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property Name As InternalSyntax.XmlNameTokenSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend  ReadOnly Property ColonToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._colonToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._name
                Case 1
                    Return Me._colonToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlPrefixSyntax(kind, newErrors, GetAnnotations, _name, _colonToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlPrefixSyntax(kind, GetDiagnostics, annotations, _name, _colonToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlPrefix(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML comment of the form &lt;-- Comment --&gt; appearing in an XML
    ''' literal expression.
    ''' </summary>
    Friend NotInheritable Class XmlCommentSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _lessThanMinusMinusToken as PunctuationSyntax
        Friend ReadOnly _textTokens as SyntaxNode
        Friend ReadOnly _minusMinusGreaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanMinusMinusToken As InternalSyntax.PunctuationSyntax, textTokens As InternalSyntax.SyntaxNode, minusMinusGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(lessThanMinusMinusToken)
            Me._lessThanMinusMinusToken = lessThanMinusMinusToken
            If textTokens IsNot Nothing Then
                Init(textTokens)
                Me._textTokens = textTokens
            End If
            Init(minusMinusGreaterThanToken)
            Me._minusMinusGreaterThanToken = minusMinusGreaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanMinusMinusToken As InternalSyntax.PunctuationSyntax, textTokens As InternalSyntax.SyntaxNode, minusMinusGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(lessThanMinusMinusToken)
            Me._lessThanMinusMinusToken = lessThanMinusMinusToken
            If textTokens IsNot Nothing Then
                Init(textTokens)
                Me._textTokens = textTokens
            End If
            Init(minusMinusGreaterThanToken)
            Me._minusMinusGreaterThanToken = minusMinusGreaterThanToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._lessThanMinusMinusToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._lessThanMinusMinusToken)
          Me._textTokens = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._textTokens)
          Me._minusMinusGreaterThanToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._minusMinusGreaterThanToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._lessThanMinusMinusToken)
          writer.WriteValue(Me._textTokens)
          writer.WriteValue(Me._minusMinusGreaterThanToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlCommentSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property LessThanMinusMinusToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanMinusMinusToken
            End Get
        End Property

        Friend  ReadOnly Property TextTokens As InternalSyntax.SyntaxList(Of XmlTextTokenSyntax)
            Get
                Return New InternalSyntax.SyntaxList(of XmlTextTokenSyntax)(Me._textTokens)
            End Get
        End Property

        Friend  ReadOnly Property MinusMinusGreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._minusMinusGreaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._lessThanMinusMinusToken
                Case 1
                    Return Me._textTokens
                Case 2
                    Return Me._minusMinusGreaterThanToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlCommentSyntax(kind, newErrors, GetAnnotations, _lessThanMinusMinusToken, _textTokens, _minusMinusGreaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlCommentSyntax(kind, GetDiagnostics, annotations, _lessThanMinusMinusToken, _textTokens, _minusMinusGreaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlComment(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
    ''' XMLProcessingValue ?&gt;'.
    ''' </summary>
    Friend NotInheritable Class XmlProcessingInstructionSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _lessThanQuestionToken as PunctuationSyntax
        Friend ReadOnly _name as XmlNameTokenSyntax
        Friend ReadOnly _textTokens as SyntaxNode
        Friend ReadOnly _questionGreaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanQuestionToken As InternalSyntax.PunctuationSyntax, name As InternalSyntax.XmlNameTokenSyntax, textTokens As InternalSyntax.SyntaxNode, questionGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(lessThanQuestionToken)
            Me._lessThanQuestionToken = lessThanQuestionToken
            Init(name)
            Me._name = name
            If textTokens IsNot Nothing Then
                Init(textTokens)
                Me._textTokens = textTokens
            End If
            Init(questionGreaterThanToken)
            Me._questionGreaterThanToken = questionGreaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanQuestionToken As InternalSyntax.PunctuationSyntax, name As InternalSyntax.XmlNameTokenSyntax, textTokens As InternalSyntax.SyntaxNode, questionGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(lessThanQuestionToken)
            Me._lessThanQuestionToken = lessThanQuestionToken
            Init(name)
            Me._name = name
            If textTokens IsNot Nothing Then
                Init(textTokens)
                Me._textTokens = textTokens
            End If
            Init(questionGreaterThanToken)
            Me._questionGreaterThanToken = questionGreaterThanToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._lessThanQuestionToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._lessThanQuestionToken)
          Me._name = DirectCast(reader.ReadValue(), XmlNameTokenSyntax)
          Init(Me._name)
          Me._textTokens = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._textTokens)
          Me._questionGreaterThanToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._questionGreaterThanToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._lessThanQuestionToken)
          writer.WriteValue(Me._name)
          writer.WriteValue(Me._textTokens)
          writer.WriteValue(Me._questionGreaterThanToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlProcessingInstructionSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property LessThanQuestionToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanQuestionToken
            End Get
        End Property

        Friend  ReadOnly Property Name As InternalSyntax.XmlNameTokenSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend  ReadOnly Property TextTokens As InternalSyntax.SyntaxList(Of XmlTextTokenSyntax)
            Get
                Return New InternalSyntax.SyntaxList(of XmlTextTokenSyntax)(Me._textTokens)
            End Get
        End Property

        Friend  ReadOnly Property QuestionGreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._questionGreaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._lessThanQuestionToken
                Case 1
                    Return Me._name
                Case 2
                    Return Me._textTokens
                Case 3
                    Return Me._questionGreaterThanToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlProcessingInstructionSyntax(kind, newErrors, GetAnnotations, _lessThanQuestionToken, _name, _textTokens, _questionGreaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlProcessingInstructionSyntax(kind, GetDiagnostics, annotations, _lessThanQuestionToken, _name, _textTokens, _questionGreaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlProcessingInstruction(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML CDATA section in an XML literal expression.
    ''' </summary>
    Friend NotInheritable Class XmlCDataSectionSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _beginCDataToken as PunctuationSyntax
        Friend ReadOnly _textTokens as SyntaxNode
        Friend ReadOnly _endCDataToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, beginCDataToken As InternalSyntax.PunctuationSyntax, textTokens As InternalSyntax.SyntaxNode, endCDataToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(beginCDataToken)
            Me._beginCDataToken = beginCDataToken
            If textTokens IsNot Nothing Then
                Init(textTokens)
                Me._textTokens = textTokens
            End If
            Init(endCDataToken)
            Me._endCDataToken = endCDataToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), beginCDataToken As InternalSyntax.PunctuationSyntax, textTokens As InternalSyntax.SyntaxNode, endCDataToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(beginCDataToken)
            Me._beginCDataToken = beginCDataToken
            If textTokens IsNot Nothing Then
                Init(textTokens)
                Me._textTokens = textTokens
            End If
            Init(endCDataToken)
            Me._endCDataToken = endCDataToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._beginCDataToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._beginCDataToken)
          Me._textTokens = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._textTokens)
          Me._endCDataToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._endCDataToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._beginCDataToken)
          writer.WriteValue(Me._textTokens)
          writer.WriteValue(Me._endCDataToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlCDataSectionSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property BeginCDataToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginCDataToken
            End Get
        End Property

        Friend  ReadOnly Property TextTokens As InternalSyntax.SyntaxList(Of XmlTextTokenSyntax)
            Get
                Return New InternalSyntax.SyntaxList(of XmlTextTokenSyntax)(Me._textTokens)
            End Get
        End Property

        Friend  ReadOnly Property EndCDataToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._endCDataToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._beginCDataToken
                Case 1
                    Return Me._textTokens
                Case 2
                    Return Me._endCDataToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlCDataSectionSyntax(kind, newErrors, GetAnnotations, _beginCDataToken, _textTokens, _endCDataToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlCDataSectionSyntax(kind, GetDiagnostics, annotations, _beginCDataToken, _textTokens, _endCDataToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlCDataSection(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
    ''' obj.Name =%&gt;&lt;/name&gt;'.
    ''' </summary>
    Friend NotInheritable Class XmlEmbeddedExpressionSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _lessThanPercentEqualsToken as PunctuationSyntax
        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _percentGreaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanPercentEqualsToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, percentGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(lessThanPercentEqualsToken)
            Me._lessThanPercentEqualsToken = lessThanPercentEqualsToken
            Init(expression)
            Me._expression = expression
            Init(percentGreaterThanToken)
            Me._percentGreaterThanToken = percentGreaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanPercentEqualsToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, percentGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(lessThanPercentEqualsToken)
            Me._lessThanPercentEqualsToken = lessThanPercentEqualsToken
            Init(expression)
            Me._expression = expression
            Init(percentGreaterThanToken)
            Me._percentGreaterThanToken = percentGreaterThanToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._lessThanPercentEqualsToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._lessThanPercentEqualsToken)
          Me._expression = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._expression)
          Me._percentGreaterThanToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._percentGreaterThanToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._lessThanPercentEqualsToken)
          writer.WriteValue(Me._expression)
          writer.WriteValue(Me._percentGreaterThanToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.XmlEmbeddedExpressionSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property LessThanPercentEqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanPercentEqualsToken
            End Get
        End Property

        Friend  ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend  ReadOnly Property PercentGreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._percentGreaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._lessThanPercentEqualsToken
                Case 1
                    Return Me._expression
                Case 2
                    Return Me._percentGreaterThanToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlEmbeddedExpressionSyntax(kind, newErrors, GetAnnotations, _lessThanPercentEqualsToken, _expression, _percentGreaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlEmbeddedExpressionSyntax(kind, GetDiagnostics, annotations, _lessThanPercentEqualsToken, _expression, _percentGreaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitXmlEmbeddedExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Abstract node class that represents the textual description of a type, possibly
    ''' include generic type arguments, qualified names, array specifiers, nullable
    ''' specifier and the like.
    ''' </summary>
    Friend MustInherit Class TypeSyntax
        Inherits ExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' Represents an array type, such as "A() or "A(,)", without bounds specified for
    ''' the array.
    ''' </summary>
    Friend NotInheritable Class ArrayTypeSyntax
        Inherits TypeSyntax

        Friend ReadOnly _elementType as TypeSyntax
        Friend ReadOnly _rankSpecifiers as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, elementType As TypeSyntax, rankSpecifiers As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            Init(elementType)
            Me._elementType = elementType
            If rankSpecifiers IsNot Nothing Then
                Init(rankSpecifiers)
                Me._rankSpecifiers = rankSpecifiers
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), elementType As TypeSyntax, rankSpecifiers As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            Init(elementType)
            Me._elementType = elementType
            If rankSpecifiers IsNot Nothing Then
                Init(rankSpecifiers)
                Me._rankSpecifiers = rankSpecifiers
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._elementType = DirectCast(reader.ReadValue(), TypeSyntax)
          Init(Me._elementType)
          Me._rankSpecifiers = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._rankSpecifiers)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._elementType)
          writer.WriteValue(Me._rankSpecifiers)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ArrayTypeSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The type of the elements of the array.
        ''' </summary>
        Friend  ReadOnly Property ElementType As InternalSyntax.TypeSyntax
            Get
                Return Me._elementType
            End Get
        End Property

        ''' <summary>
        ''' Represents the list of "()" or "(,,)" modifiers on the array type.
        ''' </summary>
        Friend  ReadOnly Property RankSpecifiers As InternalSyntax.SyntaxList(Of ArrayRankSpecifierSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of ArrayRankSpecifierSyntax)(Me._rankSpecifiers)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._elementType
                Case 1
                    Return Me._rankSpecifiers
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ArrayTypeSyntax(kind, newErrors, GetAnnotations, _elementType, _rankSpecifiers)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ArrayTypeSyntax(kind, GetDiagnostics, annotations, _elementType, _rankSpecifiers)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitArrayType(Me)
        End Function

    End Class

    ''' <summary>
    ''' A type name that represents a nullable type, such as "Integer?".
    ''' </summary>
    Friend NotInheritable Class NullableTypeSyntax
        Inherits TypeSyntax

        Friend ReadOnly _elementType as TypeSyntax
        Friend ReadOnly _questionMarkToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, elementType As TypeSyntax, questionMarkToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(elementType)
            Me._elementType = elementType
            Init(questionMarkToken)
            Me._questionMarkToken = questionMarkToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), elementType As TypeSyntax, questionMarkToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(elementType)
            Me._elementType = elementType
            Init(questionMarkToken)
            Me._questionMarkToken = questionMarkToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._elementType = DirectCast(reader.ReadValue(), TypeSyntax)
          Init(Me._elementType)
          Me._questionMarkToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._questionMarkToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._elementType)
          writer.WriteValue(Me._questionMarkToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.NullableTypeSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The kind of type that is this type is a nullable of. Cannot be an array type or
        ''' a nullable type.
        ''' </summary>
        Friend  ReadOnly Property ElementType As InternalSyntax.TypeSyntax
            Get
                Return Me._elementType
            End Get
        End Property

        ''' <summary>
        ''' The "?" token.
        ''' </summary>
        Friend  ReadOnly Property QuestionMarkToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._questionMarkToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._elementType
                Case 1
                    Return Me._questionMarkToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new NullableTypeSyntax(kind, newErrors, GetAnnotations, _elementType, _questionMarkToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new NullableTypeSyntax(kind, GetDiagnostics, annotations, _elementType, _questionMarkToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitNullableType(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an occurrence of a Visual Basic built-in type such as Integer or
    ''' String in source code.
    ''' </summary>
    Friend NotInheritable Class PredefinedTypeSyntax
        Inherits TypeSyntax

        Friend ReadOnly _keyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(keyword)
            Me._keyword = keyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(keyword)
            Me._keyword = keyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._keyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._keyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._keyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.PredefinedTypeSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The keyword that was used to describe the built-in type.
        ''' </summary>
        Friend  ReadOnly Property Keyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._keyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._keyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new PredefinedTypeSyntax(kind, newErrors, GetAnnotations, _keyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new PredefinedTypeSyntax(kind, GetDiagnostics, annotations, _keyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitPredefinedType(Me)
        End Function

    End Class

    ''' <summary>
    ''' Abstract node class that represents a name, possibly include generic arguments
    ''' and qualified names.
    ''' </summary>
    Friend MustInherit Class NameSyntax
        Inherits TypeSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


    End Class

    ''' <summary>
    ''' Abstract node class that represents a name, possibly include generic arguments.
    ''' </summary>
    Friend MustInherit Class SimpleNameSyntax
        Inherits NameSyntax

        Friend ReadOnly _identifier as IdentifierTokenSyntax

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax)
            MyBase.New(kind)

            Init(identifier)
            Me._identifier = identifier

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifier As InternalSyntax.IdentifierTokenSyntax)
            MyBase.New(kind, errors, annotations)

            Init(identifier)
            Me._identifier = identifier

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._identifier = DirectCast(reader.ReadValue(), IdentifierTokenSyntax)
          Init(Me._identifier)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._identifier)
        End Sub

        ''' <summary>
        ''' The identifier in the name.
        ''' </summary>
        Friend  ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents a type name consisting of a single identifier (which might include
    ''' brackets or a type character).
    ''' </summary>
    Friend NotInheritable Class IdentifierNameSyntax
        Inherits SimpleNameSyntax


        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax)
            MyBase.New(kind, identifier)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifier As InternalSyntax.IdentifierTokenSyntax)
            MyBase.New(kind, errors, annotations, identifier)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.IdentifierNameSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._identifier
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new IdentifierNameSyntax(kind, newErrors, GetAnnotations, _identifier)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new IdentifierNameSyntax(kind, GetDiagnostics, annotations, _identifier)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitIdentifierName(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a simple type name with one or more generic arguments, such as "X(Of
    ''' Y, Z).
    ''' </summary>
    Friend NotInheritable Class GenericNameSyntax
        Inherits SimpleNameSyntax

        Friend ReadOnly _typeArgumentList as TypeArgumentListSyntax

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax, typeArgumentList As TypeArgumentListSyntax)
            MyBase.New(kind, identifier)

            Init(typeArgumentList)
            Me._typeArgumentList = typeArgumentList

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifier As InternalSyntax.IdentifierTokenSyntax, typeArgumentList As TypeArgumentListSyntax)
            MyBase.New(kind, errors, annotations, identifier)

            Init(typeArgumentList)
            Me._typeArgumentList = typeArgumentList

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._typeArgumentList = DirectCast(reader.ReadValue(), TypeArgumentListSyntax)
          Init(Me._typeArgumentList)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._typeArgumentList)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.GenericNameSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The generic argument list.
        ''' </summary>
        Friend  ReadOnly Property TypeArgumentList As InternalSyntax.TypeArgumentListSyntax
            Get
                Return Me._typeArgumentList
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._identifier
                Case 1
                    Return Me._typeArgumentList
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new GenericNameSyntax(kind, newErrors, GetAnnotations, _identifier, _typeArgumentList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new GenericNameSyntax(kind, GetDiagnostics, annotations, _identifier, _typeArgumentList)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitGenericName(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a qualified type name, for example X.Y or X(Of Z).Y.
    ''' </summary>
    Friend NotInheritable Class QualifiedNameSyntax
        Inherits NameSyntax

        Friend ReadOnly _left as NameSyntax
        Friend ReadOnly _dotToken as PunctuationSyntax
        Friend ReadOnly _right as SimpleNameSyntax

        Friend Sub New(ByVal kind As SyntaxKind, left As NameSyntax, dotToken As InternalSyntax.PunctuationSyntax, right As SimpleNameSyntax)
            MyBase.New(kind)

            Init(left)
            Me._left = left
            Init(dotToken)
            Me._dotToken = dotToken
            Init(right)
            Me._right = right

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), left As NameSyntax, dotToken As InternalSyntax.PunctuationSyntax, right As SimpleNameSyntax)
            MyBase.New(kind, errors, annotations)

            Init(left)
            Me._left = left
            Init(dotToken)
            Me._dotToken = dotToken
            Init(right)
            Me._right = right

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._left = DirectCast(reader.ReadValue(), NameSyntax)
          Init(Me._left)
          Me._dotToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._dotToken)
          Me._right = DirectCast(reader.ReadValue(), SimpleNameSyntax)
          Init(Me._right)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._left)
          writer.WriteValue(Me._dotToken)
          writer.WriteValue(Me._right)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.QualifiedNameSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The part of the name that appears to the left of the dot. This can itself be
        ''' any name.
        ''' </summary>
        Friend  ReadOnly Property Left As InternalSyntax.NameSyntax
            Get
                Return Me._left
            End Get
        End Property

        ''' <summary>
        ''' The "." token that separates the names.
        ''' </summary>
        Friend  ReadOnly Property DotToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._dotToken
            End Get
        End Property

        ''' <summary>
        ''' The part of the name that appears to the right of the dot. This must be a
        ''' simple identifier.
        ''' </summary>
        Friend  ReadOnly Property Right As InternalSyntax.SimpleNameSyntax
            Get
                Return Me._right
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._left
                Case 1
                    Return Me._dotToken
                Case 2
                    Return Me._right
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new QualifiedNameSyntax(kind, newErrors, GetAnnotations, _left, _dotToken, _right)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new QualifiedNameSyntax(kind, GetDiagnostics, annotations, _left, _dotToken, _right)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitQualifiedName(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a name in the global namespace.
    ''' </summary>
    Friend NotInheritable Class GlobalNameSyntax
        Inherits NameSyntax

        Friend ReadOnly _globalKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, globalKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            Init(globalKeyword)
            Me._globalKeyword = globalKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), globalKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            Init(globalKeyword)
            Me._globalKeyword = globalKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._globalKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._globalKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._globalKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.GlobalNameSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Global" keyword.
        ''' </summary>
        Friend  ReadOnly Property GlobalKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._globalKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._globalKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new GlobalNameSyntax(kind, newErrors, GetAnnotations, _globalKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new GlobalNameSyntax(kind, GetDiagnostics, annotations, _globalKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitGlobalName(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a parenthesized list of generic type arguments.
    ''' </summary>
    Friend NotInheritable Class TypeArgumentListSyntax
        Inherits SyntaxNode

        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _ofKeyword as KeywordSyntax
        Friend ReadOnly _arguments as SyntaxNode
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, ofKeyword As InternalSyntax.KeywordSyntax, arguments As InternalSyntax.SyntaxNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(ofKeyword)
            Me._ofKeyword = ofKeyword
            If arguments IsNot Nothing Then
                Init(arguments)
                Me._arguments = arguments
            End If
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openParenToken As InternalSyntax.PunctuationSyntax, ofKeyword As InternalSyntax.KeywordSyntax, arguments As InternalSyntax.SyntaxNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(ofKeyword)
            Me._ofKeyword = ofKeyword
            If arguments IsNot Nothing Then
                Init(arguments)
                Me._arguments = arguments
            End If
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._openParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openParenToken)
          Me._ofKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._ofKeyword)
          Me._arguments = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._arguments)
          Me._closeParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeParenToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._openParenToken)
          writer.WriteValue(Me._ofKeyword)
          writer.WriteValue(Me._arguments)
          writer.WriteValue(Me._closeParenToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.TypeArgumentListSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend  ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The "Of" keyword.
        ''' </summary>
        Friend  ReadOnly Property OfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ofKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of all the type arguments.
        ''' </summary>
        Friend  ReadOnly Property Arguments As InternalSyntax.SeparatedSyntaxList(Of TypeSyntax)
            Get
                Return new InternalSyntax.SeparatedSyntaxList(Of TypeSyntax)(New SyntaxList(of TypeSyntax)(Me._arguments))
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend  ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._openParenToken
                Case 1
                    Return Me._ofKeyword
                Case 2
                    Return Me._arguments
                Case 3
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 4
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new TypeArgumentListSyntax(kind, newErrors, GetAnnotations, _openParenToken, _ofKeyword, _arguments, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new TypeArgumentListSyntax(kind, GetDiagnostics, annotations, _openParenToken, _ofKeyword, _arguments, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitTypeArgumentList(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single syntactic token in a VB program. A token is a keyword,
    ''' punctuator, literal, identifier or XML token. The type of keyword or punctuator
    ''' can be determined from the Kind property.
    ''' </summary>
    Friend MustInherit Class SyntaxToken
        Inherits SyntaxNode


    End Class

    ''' <summary>
    ''' Represents a single keyword in a VB program. Which keyword can be determined
    ''' from the Kind property.
    ''' </summary>
    Friend NotInheritable Class KeywordSyntax
        Inherits SyntaxToken


        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function WithLeadingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new KeywordSyntax(kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia)
        End Function

        Friend Overrides Function WithTrailingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new KeywordSyntax(kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new KeywordSyntax(kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new KeywordSyntax(kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single punctuation mark or operator in a VB program. Which one can
    ''' be determined from the Kind property.
    ''' </summary>
    Friend Class PunctuationSyntax
        Inherits SyntaxToken


        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function WithLeadingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new PunctuationSyntax(kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia)
        End Function

        Friend Overrides Function WithTrailingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new PunctuationSyntax(kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new PunctuationSyntax(kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new PunctuationSyntax(kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia)
        End Function

    End Class

    ''' <summary>
    ''' Represents an Xml NCName per Namespaces in XML 1.0
    ''' </summary>
    Friend NotInheritable Class XmlNameTokenSyntax
        Inherits SyntaxToken

        Friend ReadOnly _possibleKeywordKind as SyntaxKind

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode, possibleKeywordKind As SyntaxKind)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me._possibleKeywordKind = possibleKeywordKind
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode, possibleKeywordKind As SyntaxKind)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
            Me._possibleKeywordKind = possibleKeywordKind
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._possibleKeywordKind = CType(reader.ReadValue(), SyntaxKind)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._possibleKeywordKind)
        End Sub

        Friend  ReadOnly Property PossibleKeywordKind As SyntaxKind
            Get
                Return Me._possibleKeywordKind
            End Get
        End Property

        Friend Overrides Function WithLeadingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new XmlNameTokenSyntax(kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia, _possibleKeywordKind)
        End Function

        Friend Overrides Function WithTrailingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new XmlNameTokenSyntax(kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia, _possibleKeywordKind)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlNameTokenSyntax(kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia, _possibleKeywordKind)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlNameTokenSyntax(kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia, _possibleKeywordKind)
        End Function

    End Class

    ''' <summary>
    ''' Represents character data in Xml content also known as PCData or in an Xml
    ''' attribute value. All text is here for now even text that does not need
    ''' normalization such as comment, pi and cdata text.
    ''' </summary>
    Friend NotInheritable Class XmlTextTokenSyntax
        Inherits SyntaxToken

        Friend ReadOnly _value as String

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode, value As String)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode, value As String)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._value = CType(reader.ReadValue(), String)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._value)
        End Sub

        ''' <summary>
        ''' The text of the attribute or pcdata after normalization.
        ''' </summary>
        Friend  ReadOnly Property Value As String
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function WithLeadingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new XmlTextTokenSyntax(kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia, _value)
        End Function

        Friend Overrides Function WithTrailingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new XmlTextTokenSyntax(kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia, _value)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new XmlTextTokenSyntax(kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new XmlTextTokenSyntax(kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Decimal literal token.
    ''' </summary>
    Friend NotInheritable Class DecimalLiteralTokenSyntax
        Inherits SyntaxToken

        Friend ReadOnly _typeSuffix as TypeCharacter
        Friend ReadOnly _value as System.Decimal

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode, typeSuffix As TypeCharacter, value As System.Decimal)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me._typeSuffix = typeSuffix
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode, typeSuffix As TypeCharacter, value As System.Decimal)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
            Me._typeSuffix = typeSuffix
            Me._value = value
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._typeSuffix = CType(reader.ReadValue(), TypeCharacter)
          Me._value = CType(reader.ReadValue(), System.Decimal)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._typeSuffix)
          writer.WriteValue(Me._value)
        End Sub

        ''' <summary>
        ''' The type suffix or type character that was on the literal, if any. If no suffix
        ''' was present, TypeCharacter.None is returned.
        ''' </summary>
        Friend  ReadOnly Property TypeSuffix As TypeCharacter
            Get
                Return Me._typeSuffix
            End Get
        End Property

        ''' <summary>
        ''' The value of the token.
        ''' </summary>
        Friend  ReadOnly Property Value As System.Decimal
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function WithLeadingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new DecimalLiteralTokenSyntax(kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia, _typeSuffix, _value)
        End Function

        Friend Overrides Function WithTrailingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new DecimalLiteralTokenSyntax(kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia, _typeSuffix, _value)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new DecimalLiteralTokenSyntax(kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia, _typeSuffix, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new DecimalLiteralTokenSyntax(kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia, _typeSuffix, _value)
        End Function

    End Class

    ''' <summary>
    ''' Represents an Date literal token.
    ''' </summary>
    Friend NotInheritable Class DateLiteralTokenSyntax
        Inherits SyntaxToken

        Friend ReadOnly _value as DateTime

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode, value As DateTime)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode, value As DateTime)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._value = CType(reader.ReadValue(), DateTime)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._value)
        End Sub

        ''' <summary>
        ''' The value of the token.
        ''' </summary>
        Friend  ReadOnly Property Value As DateTime
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function WithLeadingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new DateLiteralTokenSyntax(kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia, _value)
        End Function

        Friend Overrides Function WithTrailingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new DateLiteralTokenSyntax(kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia, _value)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new DateLiteralTokenSyntax(kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new DateLiteralTokenSyntax(kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

    End Class

    ''' <summary>
    ''' Represents an string literal token.
    ''' </summary>
    Friend NotInheritable Class StringLiteralTokenSyntax
        Inherits SyntaxToken

        Friend ReadOnly _value as String

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode, value As String)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode, value As String)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._value = CType(reader.ReadValue(), String)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._value)
        End Sub

        ''' <summary>
        ''' The value of the string, after removing the quotation marks and combining
        ''' doubled quotation marks.
        ''' </summary>
        Friend  ReadOnly Property Value As String
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function WithLeadingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new StringLiteralTokenSyntax(kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia, _value)
        End Function

        Friend Overrides Function WithTrailingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new StringLiteralTokenSyntax(kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia, _value)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new StringLiteralTokenSyntax(kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new StringLiteralTokenSyntax(kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

    End Class

    ''' <summary>
    ''' Represents an string literal token.
    ''' </summary>
    Friend NotInheritable Class CharacterLiteralTokenSyntax
        Inherits SyntaxToken

        Friend ReadOnly _value as Char

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode, value As Char)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As SyntaxNode, trailingTrivia As SyntaxNode, value As Char)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._value = CType(reader.ReadValue(), Char)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._value)
        End Sub

        ''' <summary>
        ''' The value of the character, after removing the quotation marks.
        ''' </summary>
        Friend  ReadOnly Property Value As Char
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function WithLeadingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new CharacterLiteralTokenSyntax(kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia, _value)
        End Function

        Friend Overrides Function WithTrailingTrivia(ByVal trivia As SyntaxNode) As SyntaxToken
            Return new CharacterLiteralTokenSyntax(kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia, _value)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new CharacterLiteralTokenSyntax(kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new CharacterLiteralTokenSyntax(kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

    End Class

    ''' <summary>
    ''' Abstract class that represent structured trivia.
    ''' </summary>
    Friend MustInherit Class StructuredTriviaSyntax
        Inherits SyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' Represents tokens that were skipped by the parser as part of error recovery,
    ''' and thus are not part of any syntactic structure.
    ''' </summary>
    Friend NotInheritable Class SkippedTokensSyntax
        Inherits StructuredTriviaSyntax

        Friend ReadOnly _tokens as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, tokens As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            If tokens IsNot Nothing Then
                Init(tokens)
                Me._tokens = tokens
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), tokens As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            If tokens IsNot Nothing Then
                Init(tokens)
                Me._tokens = tokens
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._tokens = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._tokens)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._tokens)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.SkippedTokensSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The list of tokens that were skipped by the parser.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Tokens As InternalSyntax.SyntaxList(Of SyntaxToken)
            Get
                Return New InternalSyntax.SyntaxList(of SyntaxToken)(Me._tokens)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._tokens
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new SkippedTokensSyntax(kind, newErrors, GetAnnotations, _tokens)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new SkippedTokensSyntax(kind, GetDiagnostics, annotations, _tokens)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitSkippedTokens(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a documentation comment e.g. ''' &lt;Summary&gt; apearing in source.
    ''' </summary>
    Friend NotInheritable Class DocumentationCommentSyntax
        Inherits StructuredTriviaSyntax

        Friend ReadOnly _content as SyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, content As InternalSyntax.SyntaxNode)
            MyBase.New(kind)

            If content IsNot Nothing Then
                Init(content)
                Me._content = content
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), content As InternalSyntax.SyntaxNode)
            MyBase.New(kind, errors, annotations)

            If content IsNot Nothing Then
                Init(content)
                Me._content = content
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._content = DirectCast(reader.ReadValue(), SyntaxNode)
          Init(Me._content)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._content)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.DocumentationCommentSyntax(Me, parent, startLocation)
        End Function

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend  ReadOnly Property Content As InternalSyntax.SyntaxList(Of XmlNodeSyntax)
            Get
                Return new InternalSyntax.SyntaxList(Of XmlNodeSyntax)(Me._content)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._content
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new DocumentationCommentSyntax(kind, newErrors, GetAnnotations, _content)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new DocumentationCommentSyntax(kind, GetDiagnostics, annotations, _content)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitDocumentationComment(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a preprocessor directive
    ''' </summary>
    Friend NotInheritable Class DirectiveSyntax
        Inherits StructuredTriviaSyntax

        Friend ReadOnly _directive as DirectiveStatementSyntax
        Friend ReadOnly _terminator as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, directive As DirectiveStatementSyntax, terminator As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(directive)
            Me._directive = directive
            Init(terminator)
            Me._terminator = terminator

             SetFlags(SyntaxFlags.HasDirectives)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), directive As DirectiveStatementSyntax, terminator As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(directive)
            Me._directive = directive
            Init(terminator)
            Me._terminator = terminator

             SetFlags(SyntaxFlags.HasDirectives)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._directive = DirectCast(reader.ReadValue(), DirectiveStatementSyntax)
          Init(Me._directive)
          Me._terminator = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._terminator)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._directive)
          writer.WriteValue(Me._terminator)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.DirectiveSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property Directive As InternalSyntax.DirectiveStatementSyntax
            Get
                Return Me._directive
            End Get
        End Property

        ''' <summary>
        ''' The statement terminator token that ended the Directive.
        ''' </summary>
        Friend  ReadOnly Property Terminator As InternalSyntax.PunctuationSyntax
            Get
                Return Me._terminator
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._directive
                Case 1
                    Return Me._terminator
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new DirectiveSyntax(kind, newErrors, GetAnnotations, _directive, _terminator)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new DirectiveSyntax(kind, GetDiagnostics, annotations, _directive, _terminator)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitDirective(Me)
        End Function

    End Class

    ''' <summary>
    ''' Trivia nodes represents parts of the program text that are not parts of the
    ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
    ''' directives, and disabled code.
    ''' </summary>
    Friend NotInheritable Class SyntaxTrivia
        Inherits SyntaxNode


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new SyntaxTrivia(kind, newErrors, GetAnnotations, text)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new SyntaxTrivia(kind, GetDiagnostics, annotations, text)
        End Function

    End Class

    ''' <summary>
    ''' Represents a pre-processing directive (such as #If, #Const or #Region)
    ''' appearing in source.
    ''' </summary>
    Friend MustInherit Class DirectiveStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _hashToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            Init(hashToken)
            Me._hashToken = hashToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            Init(hashToken)
            Me._hashToken = hashToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._hashToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._hashToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._hashToken)
        End Sub

        ''' <summary>
        ''' The "#" token in a preprocessor directive.
        ''' </summary>
        Friend  ReadOnly Property HashToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._hashToken
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents a #Const pre-processing constant declaration appearing in source.
    ''' </summary>
    Friend NotInheritable Class ConstDirectiveSyntax
        Inherits DirectiveStatementSyntax

        Friend ReadOnly _constKeyword as KeywordSyntax
        Friend ReadOnly _name as IdentifierTokenSyntax
        Friend ReadOnly _equalsToken as PunctuationSyntax
        Friend ReadOnly _value as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, constKeyword As InternalSyntax.KeywordSyntax, name As InternalSyntax.IdentifierTokenSyntax, equalsToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax)
            MyBase.New(kind, hashToken)

            Init(constKeyword)
            Me._constKeyword = constKeyword
            Init(name)
            Me._name = name
            Init(equalsToken)
            Me._equalsToken = equalsToken
            Init(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, constKeyword As InternalSyntax.KeywordSyntax, name As InternalSyntax.IdentifierTokenSyntax, equalsToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax)
            MyBase.New(kind, errors, annotations, hashToken)

            Init(constKeyword)
            Me._constKeyword = constKeyword
            Init(name)
            Me._name = name
            Init(equalsToken)
            Me._equalsToken = equalsToken
            Init(value)
            Me._value = value

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._constKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._constKeyword)
          Me._name = DirectCast(reader.ReadValue(), IdentifierTokenSyntax)
          Init(Me._name)
          Me._equalsToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._equalsToken)
          Me._value = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._value)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._constKeyword)
          writer.WriteValue(Me._name)
          writer.WriteValue(Me._equalsToken)
          writer.WriteValue(Me._value)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ConstDirectiveSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Const" keyword.
        ''' </summary>
        Friend  ReadOnly Property ConstKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._constKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the pre-processing constant being defined.
        ''' </summary>
        Friend  ReadOnly Property Name As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._name
            End Get
        End Property

        ''' <summary>
        ''' The "=" token.
        ''' </summary>
        Friend  ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        ''' <summary>
        ''' An expression representing the value of the pre-processing constant being
        ''' defined.
        ''' </summary>
        Friend  ReadOnly Property Value As InternalSyntax.ExpressionSyntax
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._constKeyword
                Case 2
                    Return Me._name
                Case 3
                    Return Me._equalsToken
                Case 4
                    Return Me._value
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ConstDirectiveSyntax(kind, newErrors, GetAnnotations, _hashToken, _constKeyword, _name, _equalsToken, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ConstDirectiveSyntax(kind, GetDiagnostics, annotations, _hashToken, _constKeyword, _name, _equalsToken, _value)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitConstDirective(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning of an #If pre-processing directive appearing in
    ''' source.
    ''' </summary>
    Friend NotInheritable Class IfDirectiveSyntax
        Inherits DirectiveStatementSyntax

        Friend ReadOnly _elseKeyword as KeywordSyntax
        Friend ReadOnly _ifOrElseIfKeyword as KeywordSyntax
        Friend ReadOnly _condition as ExpressionSyntax
        Friend ReadOnly _thenKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, elseKeyword As InternalSyntax.KeywordSyntax, ifOrElseIfKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, hashToken)

            If elseKeyword IsNot Nothing Then
                Init(elseKeyword)
                Me._elseKeyword = elseKeyword
            End If
            Init(ifOrElseIfKeyword)
            Me._ifOrElseIfKeyword = ifOrElseIfKeyword
            Init(condition)
            Me._condition = condition
            If thenKeyword IsNot Nothing Then
                Init(thenKeyword)
                Me._thenKeyword = thenKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, elseKeyword As InternalSyntax.KeywordSyntax, ifOrElseIfKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, hashToken)

            If elseKeyword IsNot Nothing Then
                Init(elseKeyword)
                Me._elseKeyword = elseKeyword
            End If
            Init(ifOrElseIfKeyword)
            Me._ifOrElseIfKeyword = ifOrElseIfKeyword
            Init(condition)
            Me._condition = condition
            If thenKeyword IsNot Nothing Then
                Init(thenKeyword)
                Me._thenKeyword = thenKeyword
            End If

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._elseKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._elseKeyword)
          Me._ifOrElseIfKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._ifOrElseIfKeyword)
          Me._condition = DirectCast(reader.ReadValue(), ExpressionSyntax)
          Init(Me._condition)
          Me._thenKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._thenKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._elseKeyword)
          writer.WriteValue(Me._ifOrElseIfKeyword)
          writer.WriteValue(Me._condition)
          writer.WriteValue(Me._thenKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.IfDirectiveSyntax(Me, parent, startLocation)
        End Function

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ElseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._elseKeyword
            End Get
        End Property

        Friend  ReadOnly Property IfOrElseIfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ifOrElseIfKeyword
            End Get
        End Property

        Friend  ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend  ReadOnly Property ThenKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._thenKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._elseKeyword
                Case 2
                    Return Me._ifOrElseIfKeyword
                Case 3
                    Return Me._condition
                Case 4
                    Return Me._thenKeyword
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 5
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new IfDirectiveSyntax(kind, newErrors, GetAnnotations, _hashToken, _elseKeyword, _ifOrElseIfKeyword, _condition, _thenKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new IfDirectiveSyntax(kind, GetDiagnostics, annotations, _hashToken, _elseKeyword, _ifOrElseIfKeyword, _condition, _thenKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitIfDirective(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an #Else pre-processing directive appearing in source.
    ''' </summary>
    Friend NotInheritable Class ElseDirectiveSyntax
        Inherits DirectiveStatementSyntax

        Friend ReadOnly _elseKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, elseKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, hashToken)

            Init(elseKeyword)
            Me._elseKeyword = elseKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, elseKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, hashToken)

            Init(elseKeyword)
            Me._elseKeyword = elseKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._elseKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._elseKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._elseKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ElseDirectiveSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property ElseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._elseKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._elseKeyword
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 2
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ElseDirectiveSyntax(kind, newErrors, GetAnnotations, _hashToken, _elseKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ElseDirectiveSyntax(kind, GetDiagnostics, annotations, _hashToken, _elseKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitElseDirective(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an #End If pre-processing directive appearing in source.
    ''' </summary>
    Friend NotInheritable Class EndIfDirectiveSyntax
        Inherits DirectiveStatementSyntax

        Friend ReadOnly _endKeyword as KeywordSyntax
        Friend ReadOnly _ifKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, endKeyword As InternalSyntax.KeywordSyntax, ifKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, hashToken)

            Init(endKeyword)
            Me._endKeyword = endKeyword
            Init(ifKeyword)
            Me._ifKeyword = ifKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, endKeyword As InternalSyntax.KeywordSyntax, ifKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, hashToken)

            Init(endKeyword)
            Me._endKeyword = endKeyword
            Init(ifKeyword)
            Me._ifKeyword = ifKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._endKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._endKeyword)
          Me._ifKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._ifKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._endKeyword)
          writer.WriteValue(Me._ifKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.EndIfDirectiveSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property EndKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._endKeyword
            End Get
        End Property

        Friend  ReadOnly Property IfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ifKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._endKeyword
                Case 2
                    Return Me._ifKeyword
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new EndIfDirectiveSyntax(kind, newErrors, GetAnnotations, _hashToken, _endKeyword, _ifKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new EndIfDirectiveSyntax(kind, GetDiagnostics, annotations, _hashToken, _endKeyword, _ifKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitEndIfDirective(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning of a #Region directive appearing in source.
    ''' </summary>
    Friend NotInheritable Class RegionDirectiveSyntax
        Inherits DirectiveStatementSyntax

        Friend ReadOnly _regionKeyword as KeywordSyntax
        Friend ReadOnly _name as StringLiteralTokenSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, regionKeyword As InternalSyntax.KeywordSyntax, name As InternalSyntax.StringLiteralTokenSyntax)
            MyBase.New(kind, hashToken)

            Init(regionKeyword)
            Me._regionKeyword = regionKeyword
            Init(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, regionKeyword As InternalSyntax.KeywordSyntax, name As InternalSyntax.StringLiteralTokenSyntax)
            MyBase.New(kind, errors, annotations, hashToken)

            Init(regionKeyword)
            Me._regionKeyword = regionKeyword
            Init(name)
            Me._name = name

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._regionKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._regionKeyword)
          Me._name = DirectCast(reader.ReadValue(), StringLiteralTokenSyntax)
          Init(Me._name)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._regionKeyword)
          writer.WriteValue(Me._name)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.RegionDirectiveSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Region" keyword.
        ''' </summary>
        Friend  ReadOnly Property RegionKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._regionKeyword
            End Get
        End Property

        ''' <summary>
        ''' The label of the code region being defined.
        ''' </summary>
        Friend  ReadOnly Property Name As InternalSyntax.StringLiteralTokenSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._regionKeyword
                Case 2
                    Return Me._name
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new RegionDirectiveSyntax(kind, newErrors, GetAnnotations, _hashToken, _regionKeyword, _name)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new RegionDirectiveSyntax(kind, GetDiagnostics, annotations, _hashToken, _regionKeyword, _name)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitRegionDirective(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an #End Region directive appearing in source.
    ''' </summary>
    Friend NotInheritable Class EndRegionDirectiveSyntax
        Inherits DirectiveStatementSyntax

        Friend ReadOnly _endKeyword as KeywordSyntax
        Friend ReadOnly _regionKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, endKeyword As InternalSyntax.KeywordSyntax, regionKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, hashToken)

            Init(endKeyword)
            Me._endKeyword = endKeyword
            Init(regionKeyword)
            Me._regionKeyword = regionKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, endKeyword As InternalSyntax.KeywordSyntax, regionKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, hashToken)

            Init(endKeyword)
            Me._endKeyword = endKeyword
            Init(regionKeyword)
            Me._regionKeyword = regionKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._endKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._endKeyword)
          Me._regionKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._regionKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._endKeyword)
          writer.WriteValue(Me._regionKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.EndRegionDirectiveSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "End" keyword.
        ''' </summary>
        Friend  ReadOnly Property EndKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._endKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Region" keyword.
        ''' </summary>
        Friend  ReadOnly Property RegionKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._regionKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._endKeyword
                Case 2
                    Return Me._regionKeyword
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new EndRegionDirectiveSyntax(kind, newErrors, GetAnnotations, _hashToken, _endKeyword, _regionKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new EndRegionDirectiveSyntax(kind, GetDiagnostics, annotations, _hashToken, _endKeyword, _regionKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitEndRegionDirective(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning of a #ExternalSource pre-processing directive
    ''' appearing in source.
    ''' </summary>
    Friend NotInheritable Class ExternalSourceDirectiveSyntax
        Inherits DirectiveStatementSyntax

        Friend ReadOnly _externalSourceKeyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _externalSource as StringLiteralTokenSyntax
        Friend ReadOnly _commaToken as PunctuationSyntax
        Friend ReadOnly _lineStart as IntegerLiteralTokenSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, externalSourceKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, externalSource As InternalSyntax.StringLiteralTokenSyntax, commaToken As InternalSyntax.PunctuationSyntax, lineStart As InternalSyntax.IntegerLiteralTokenSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, hashToken)

            Init(externalSourceKeyword)
            Me._externalSourceKeyword = externalSourceKeyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(externalSource)
            Me._externalSource = externalSource
            Init(commaToken)
            Me._commaToken = commaToken
            Init(lineStart)
            Me._lineStart = lineStart
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, externalSourceKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, externalSource As InternalSyntax.StringLiteralTokenSyntax, commaToken As InternalSyntax.PunctuationSyntax, lineStart As InternalSyntax.IntegerLiteralTokenSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations, hashToken)

            Init(externalSourceKeyword)
            Me._externalSourceKeyword = externalSourceKeyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(externalSource)
            Me._externalSource = externalSource
            Init(commaToken)
            Me._commaToken = commaToken
            Init(lineStart)
            Me._lineStart = lineStart
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._externalSourceKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._externalSourceKeyword)
          Me._openParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openParenToken)
          Me._externalSource = DirectCast(reader.ReadValue(), StringLiteralTokenSyntax)
          Init(Me._externalSource)
          Me._commaToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._commaToken)
          Me._lineStart = DirectCast(reader.ReadValue(), IntegerLiteralTokenSyntax)
          Init(Me._lineStart)
          Me._closeParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeParenToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._externalSourceKeyword)
          writer.WriteValue(Me._openParenToken)
          writer.WriteValue(Me._externalSource)
          writer.WriteValue(Me._commaToken)
          writer.WriteValue(Me._lineStart)
          writer.WriteValue(Me._closeParenToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ExternalSourceDirectiveSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property ExternalSourceKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._externalSourceKeyword
            End Get
        End Property

        Friend  ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        Friend  ReadOnly Property ExternalSource As InternalSyntax.StringLiteralTokenSyntax
            Get
                Return Me._externalSource
            End Get
        End Property

        Friend  ReadOnly Property CommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._commaToken
            End Get
        End Property

        Friend  ReadOnly Property LineStart As InternalSyntax.IntegerLiteralTokenSyntax
            Get
                Return Me._lineStart
            End Get
        End Property

        Friend  ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._externalSourceKeyword
                Case 2
                    Return Me._openParenToken
                Case 3
                    Return Me._externalSource
                Case 4
                    Return Me._commaToken
                Case 5
                    Return Me._lineStart
                Case 6
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 7
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ExternalSourceDirectiveSyntax(kind, newErrors, GetAnnotations, _hashToken, _externalSourceKeyword, _openParenToken, _externalSource, _commaToken, _lineStart, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ExternalSourceDirectiveSyntax(kind, GetDiagnostics, annotations, _hashToken, _externalSourceKeyword, _openParenToken, _externalSource, _commaToken, _lineStart, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitExternalSourceDirective(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an #End ExternalSource pre-processing directive appearing in source.
    ''' </summary>
    Friend NotInheritable Class EndExternalSourceDirective
        Inherits DirectiveStatementSyntax

        Friend ReadOnly _endKeyword as KeywordSyntax
        Friend ReadOnly _externalSourceKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, endKeyword As InternalSyntax.KeywordSyntax, externalSourceKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, hashToken)

            Init(endKeyword)
            Me._endKeyword = endKeyword
            Init(externalSourceKeyword)
            Me._externalSourceKeyword = externalSourceKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, endKeyword As InternalSyntax.KeywordSyntax, externalSourceKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, hashToken)

            Init(endKeyword)
            Me._endKeyword = endKeyword
            Init(externalSourceKeyword)
            Me._externalSourceKeyword = externalSourceKeyword

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._endKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._endKeyword)
          Me._externalSourceKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._externalSourceKeyword)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._endKeyword)
          writer.WriteValue(Me._externalSourceKeyword)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.EndExternalSourceDirective(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property EndKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._endKeyword
            End Get
        End Property

        Friend  ReadOnly Property ExternalSourceKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._externalSourceKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._endKeyword
                Case 2
                    Return Me._externalSourceKeyword
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new EndExternalSourceDirective(kind, newErrors, GetAnnotations, _hashToken, _endKeyword, _externalSourceKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new EndExternalSourceDirective(kind, GetDiagnostics, annotations, _hashToken, _endKeyword, _externalSourceKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitEndExternalSourceDirective(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an #ExternalChecksum pre-processing directive appearing in source.
    ''' </summary>
    Friend NotInheritable Class ExternalChecksumDirectiveSyntax
        Inherits DirectiveStatementSyntax

        Friend ReadOnly _externalChecksumKeyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _externalSource as StringLiteralTokenSyntax
        Friend ReadOnly _firstCommaToken as PunctuationSyntax
        Friend ReadOnly _guid as StringLiteralTokenSyntax
        Friend ReadOnly _secondCommaToken as PunctuationSyntax
        Friend ReadOnly _checksum as StringLiteralTokenSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, externalChecksumKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, externalSource As InternalSyntax.StringLiteralTokenSyntax, firstCommaToken As InternalSyntax.PunctuationSyntax, guid As InternalSyntax.StringLiteralTokenSyntax, secondCommaToken As InternalSyntax.PunctuationSyntax, checksum As InternalSyntax.StringLiteralTokenSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, hashToken)

            Init(externalChecksumKeyword)
            Me._externalChecksumKeyword = externalChecksumKeyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(externalSource)
            Me._externalSource = externalSource
            Init(firstCommaToken)
            Me._firstCommaToken = firstCommaToken
            Init(guid)
            Me._guid = guid
            Init(secondCommaToken)
            Me._secondCommaToken = secondCommaToken
            Init(checksum)
            Me._checksum = checksum
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, externalChecksumKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, externalSource As InternalSyntax.StringLiteralTokenSyntax, firstCommaToken As InternalSyntax.PunctuationSyntax, guid As InternalSyntax.StringLiteralTokenSyntax, secondCommaToken As InternalSyntax.PunctuationSyntax, checksum As InternalSyntax.StringLiteralTokenSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations, hashToken)

            Init(externalChecksumKeyword)
            Me._externalChecksumKeyword = externalChecksumKeyword
            Init(openParenToken)
            Me._openParenToken = openParenToken
            Init(externalSource)
            Me._externalSource = externalSource
            Init(firstCommaToken)
            Me._firstCommaToken = firstCommaToken
            Init(guid)
            Me._guid = guid
            Init(secondCommaToken)
            Me._secondCommaToken = secondCommaToken
            Init(checksum)
            Me._checksum = checksum
            Init(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._externalChecksumKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._externalChecksumKeyword)
          Me._openParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._openParenToken)
          Me._externalSource = DirectCast(reader.ReadValue(), StringLiteralTokenSyntax)
          Init(Me._externalSource)
          Me._firstCommaToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._firstCommaToken)
          Me._guid = DirectCast(reader.ReadValue(), StringLiteralTokenSyntax)
          Init(Me._guid)
          Me._secondCommaToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._secondCommaToken)
          Me._checksum = DirectCast(reader.ReadValue(), StringLiteralTokenSyntax)
          Init(Me._checksum)
          Me._closeParenToken = DirectCast(reader.ReadValue(), PunctuationSyntax)
          Init(Me._closeParenToken)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._externalChecksumKeyword)
          writer.WriteValue(Me._openParenToken)
          writer.WriteValue(Me._externalSource)
          writer.WriteValue(Me._firstCommaToken)
          writer.WriteValue(Me._guid)
          writer.WriteValue(Me._secondCommaToken)
          writer.WriteValue(Me._checksum)
          writer.WriteValue(Me._closeParenToken)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ExternalChecksumDirectiveSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property ExternalChecksumKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._externalChecksumKeyword
            End Get
        End Property

        Friend  ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        Friend  ReadOnly Property ExternalSource As InternalSyntax.StringLiteralTokenSyntax
            Get
                Return Me._externalSource
            End Get
        End Property

        Friend  ReadOnly Property FirstCommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._firstCommaToken
            End Get
        End Property

        Friend  ReadOnly Property Guid As InternalSyntax.StringLiteralTokenSyntax
            Get
                Return Me._guid
            End Get
        End Property

        Friend  ReadOnly Property SecondCommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._secondCommaToken
            End Get
        End Property

        Friend  ReadOnly Property Checksum As InternalSyntax.StringLiteralTokenSyntax
            Get
                Return Me._checksum
            End Get
        End Property

        Friend  ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._externalChecksumKeyword
                Case 2
                    Return Me._openParenToken
                Case 3
                    Return Me._externalSource
                Case 4
                    Return Me._firstCommaToken
                Case 5
                    Return Me._guid
                Case 6
                    Return Me._secondCommaToken
                Case 7
                    Return Me._checksum
                Case 8
                    Return Me._closeParenToken
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 9
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ExternalChecksumDirectiveSyntax(kind, newErrors, GetAnnotations, _hashToken, _externalChecksumKeyword, _openParenToken, _externalSource, _firstCommaToken, _guid, _secondCommaToken, _checksum, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ExternalChecksumDirectiveSyntax(kind, GetDiagnostics, annotations, _hashToken, _externalChecksumKeyword, _openParenToken, _externalSource, _firstCommaToken, _guid, _secondCommaToken, _checksum, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitExternalChecksumDirective(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an #r directive appearing in scripts.
    ''' </summary>
    Friend NotInheritable Class ReferenceDirectiveSyntax
        Inherits DirectiveStatementSyntax

        Friend ReadOnly _referenceKeyword as KeywordSyntax
        Friend ReadOnly _file as StringLiteralTokenSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, referenceKeyword As InternalSyntax.KeywordSyntax, file As InternalSyntax.StringLiteralTokenSyntax)
            MyBase.New(kind, hashToken)

            Init(referenceKeyword)
            Me._referenceKeyword = referenceKeyword
            Init(file)
            Me._file = file

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, referenceKeyword As InternalSyntax.KeywordSyntax, file As InternalSyntax.StringLiteralTokenSyntax)
            MyBase.New(kind, errors, annotations, hashToken)

            Init(referenceKeyword)
            Me._referenceKeyword = referenceKeyword
            Init(file)
            Me._file = file

        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
          Me._referenceKeyword = DirectCast(reader.ReadValue(), KeywordSyntax)
          Init(Me._referenceKeyword)
          Me._file = DirectCast(reader.ReadValue(), StringLiteralTokenSyntax)
          Init(Me._file)
        End Sub

        Friend Overrides Sub WriteTo(writer as ObjectWriter)
          MyBase.WriteTo(writer)
          writer.WriteValue(Me._referenceKeyword)
          writer.WriteValue(Me._file)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.ReferenceDirectiveSyntax(Me, parent, startLocation)
        End Function

        Friend  ReadOnly Property ReferenceKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._referenceKeyword
            End Get
        End Property

        Friend  ReadOnly Property File As InternalSyntax.StringLiteralTokenSyntax
            Get
                Return Me._file
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._referenceKeyword
                Case 2
                    Return Me._file
                Case Else
                     Debug.Assert(false, "child index out of range")
                     Return Nothing
            End Select
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 3
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new ReferenceDirectiveSyntax(kind, newErrors, GetAnnotations, _hashToken, _referenceKeyword, _file)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new ReferenceDirectiveSyntax(kind, GetDiagnostics, annotations, _hashToken, _referenceKeyword, _file)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitReferenceDirective(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an unrecognized pre-processing directive. This occurs when the
    ''' parser encounters a hash '#' token at the beginning of a physical line but does
    ''' recognize the text that follows as a valid Visual Basic pre-processing
    ''' directive.
    ''' </summary>
    Friend NotInheritable Class BadDirectiveSyntax
        Inherits DirectiveStatementSyntax


        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, hashToken)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations, hashToken)
        End Sub

        Friend Sub New(reader as ObjectReader)
          MyBase.New(reader)
        End Sub


        Friend Overrides Function CreateRed(ByVal parent As Roslyn.Compilers.VisualBasic.SyntaxNode, ByVal startLocation As Integer) As Roslyn.Compilers.VisualBasic.SyntaxNode
            Return new Roslyn.Compilers.VisualBasic.BadDirectiveSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as SyntaxNode
            If i = 0 Then
                Return Me._hashToken
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function

        Friend Overrides ReadOnly Property SlotCount() As Integer
            Get
                Return 1
            End Get
        End Property

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) as SyntaxNode
            Return new BadDirectiveSyntax(kind, newErrors, GetAnnotations, _hashToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) as SyntaxNode
            Return new BadDirectiveSyntax(kind, GetDiagnostics, annotations, _hashToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As SyntaxVisitor) As SyntaxNode
            Return visitor.VisitBadDirective(Me)
        End Function

    End Class

    Friend MustInherit Class SyntaxVisitor
        Public Overridable Function Visit(ByVal node As SyntaxNode) As SyntaxNode
            If node IsNot Nothing
                Return node.Accept(Me)
            Else
                Return Nothing
            End If
        End Function
        Public Overridable Function VisitSyntaxNode(ByVal node As SyntaxNode) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return node
        End Function
        Public Overridable Function VisitStatement(ByVal node As StatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitExecutableStatement(ByVal node As ExecutableStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitDeclarationStatement(ByVal node As DeclarationStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitEmptyStatement(ByVal node As EmptyStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitEndBlockStatement(ByVal node As EndBlockStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitCompilationUnit(ByVal node As CompilationUnitSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitOptionStatement(ByVal node As OptionStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitImportsStatement(ByVal node As ImportsStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitImportsClause(ByVal node As ImportsClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitAliasImportsClause(ByVal node As AliasImportsClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitImportsClause(node)
        End Function
        Public Overridable Function VisitMembersImportsClause(ByVal node As MembersImportsClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitImportsClause(node)
        End Function
        Public Overridable Function VisitXmlNamespaceImportsClause(ByVal node As XmlNamespaceImportsClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitImportsClause(node)
        End Function
        Public Overridable Function VisitNamespaceBlock(ByVal node As NamespaceBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitNamespaceStatement(ByVal node As NamespaceStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitTypeBlock(ByVal node As TypeBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitModuleBlock(ByVal node As ModuleBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeBlock(node)
        End Function
        Public Overridable Function VisitStructureBlock(ByVal node As StructureBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeBlock(node)
        End Function
        Public Overridable Function VisitInterfaceBlock(ByVal node As InterfaceBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeBlock(node)
        End Function
        Public Overridable Function VisitClassBlock(ByVal node As ClassBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeBlock(node)
        End Function
        Public Overridable Function VisitEnumBlock(ByVal node As EnumBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitInheritsOrImplementsStatement(ByVal node As InheritsOrImplementsStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitInheritsStatement(ByVal node As InheritsStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitInheritsOrImplementsStatement(node)
        End Function
        Public Overridable Function VisitImplementsStatement(ByVal node As ImplementsStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitInheritsOrImplementsStatement(node)
        End Function
        Public Overridable Function VisitTypeStatement(ByVal node As TypeStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitModuleStatement(ByVal node As ModuleStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeStatement(node)
        End Function
        Public Overridable Function VisitStructureStatement(ByVal node As StructureStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeStatement(node)
        End Function
        Public Overridable Function VisitInterfaceStatement(ByVal node As InterfaceStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeStatement(node)
        End Function
        Public Overridable Function VisitClassStatement(ByVal node As ClassStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeStatement(node)
        End Function
        Public Overridable Function VisitEnumStatement(ByVal node As EnumStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitTypeParameterList(ByVal node As TypeParameterListSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitTypeParameter(ByVal node As TypeParameterSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitTypeParameterConstraintClause(ByVal node As TypeParameterConstraintClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitTypeParameterSingleConstraintClause(ByVal node As TypeParameterSingleConstraintClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeParameterConstraintClause(node)
        End Function
        Public Overridable Function VisitTypeParameterMultipleConstraintClause(ByVal node As TypeParameterMultipleConstraintClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeParameterConstraintClause(node)
        End Function
        Public Overridable Function VisitConstraint(ByVal node As ConstraintSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitSpecialConstraint(ByVal node As SpecialConstraintSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitConstraint(node)
        End Function
        Public Overridable Function VisitTypeConstraint(ByVal node As TypeConstraintSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitConstraint(node)
        End Function
        Public Overridable Function VisitEnumMemberDeclaration(ByVal node As EnumMemberDeclarationSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitMethodBlock(ByVal node As MethodBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitPropertyBlock(ByVal node As PropertyBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitEventBlock(ByVal node As EventBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitMethodBase(ByVal node As MethodBaseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitParameterList(ByVal node As ParameterListSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitMethodStatement(ByVal node As MethodStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitConstructorStatement(ByVal node As ConstructorStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitDeclareStatement(ByVal node As DeclareStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitDelegateStatement(ByVal node As DelegateStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitEventStatement(ByVal node As EventStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitOperatorStatement(ByVal node As OperatorStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitPropertyStatement(ByVal node As PropertyStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitAccessorStatement(ByVal node As AccessorStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitImplementsClause(ByVal node As ImplementsClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitHandlesClause(ByVal node As HandlesClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitHandlesClauseItem(ByVal node As HandlesClauseItemSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitIncompleteMember(ByVal node As IncompleteMemberSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitFieldDeclaration(ByVal node As FieldDeclarationSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitVariableDeclarator(ByVal node As VariableDeclaratorSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitAsClause(ByVal node As AsClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitSimpleAsClause(ByVal node As SimpleAsClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitAsClause(node)
        End Function
        Public Overridable Function VisitAsNewClause(ByVal node As AsNewClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitAsClause(node)
        End Function
        Public Overridable Function VisitObjectCreationInitializer(ByVal node As ObjectCreationInitializerSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitObjectMemberInitializer(ByVal node As ObjectMemberInitializerSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitObjectCreationInitializer(node)
        End Function
        Public Overridable Function VisitObjectCollectionInitializer(ByVal node As ObjectCollectionInitializerSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitObjectCreationInitializer(node)
        End Function
        Public Overridable Function VisitFieldInitializer(ByVal node As FieldInitializerSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitInferredFieldInitializer(ByVal node As InferredFieldInitializerSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitFieldInitializer(node)
        End Function
        Public Overridable Function VisitNamedFieldInitializer(ByVal node As NamedFieldInitializerSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitFieldInitializer(node)
        End Function
        Public Overridable Function VisitEqualsValue(ByVal node As EqualsValueSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitParameter(ByVal node As ParameterSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitModifiedIdentifier(ByVal node As ModifiedIdentifierSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitArrayRankSpecifier(ByVal node As ArrayRankSpecifierSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitAttributeBlock(ByVal node As AttributeBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitAttribute(ByVal node As AttributeSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitAttributeTarget(ByVal node As AttributeTargetSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitAttributesStatement(ByVal node As AttributesStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitExpressionStatement(ByVal node As ExpressionStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitWhileBlock(ByVal node As WhileBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitUsingBlock(ByVal node As UsingBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitSyncLockBlock(ByVal node As SyncLockBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitWithBlock(ByVal node As WithBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitLocalDeclaration(ByVal node As LocalDeclarationSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitLabelStatement(ByVal node As LabelStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitGoToStatement(ByVal node As GoToStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitLabel(ByVal node As LabelSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitStopOrEndStatement(ByVal node As StopOrEndStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitExitStatement(ByVal node As ExitStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitContinueStatement(ByVal node As ContinueStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitReturnStatement(ByVal node As ReturnStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitSingleLineIfStatement(ByVal node As SingleLineIfStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitSingleLineIfPart(ByVal node As SingleLineIfPartSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitSingleLineElsePart(ByVal node As SingleLineElsePartSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitMultiLineIfBlock(ByVal node As MultiLineIfBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitIfPart(ByVal node As IfPartSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitElsePart(ByVal node As ElsePartSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitIfStatement(ByVal node As IfStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitElseStatement(ByVal node As ElseStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitTryBlock(ByVal node As TryBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitTryPart(ByVal node As TryPartSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitCatchPart(ByVal node As CatchPartSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitFinallyPart(ByVal node As FinallyPartSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitTryStatement(ByVal node As TryStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitCatchStatement(ByVal node As CatchStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitCatchFilterClause(ByVal node As CatchFilterClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitFinallyStatement(ByVal node As FinallyStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitErrorStatement(ByVal node As ErrorStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitOnErrorGoToStatement(ByVal node As OnErrorGoToStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitOnErrorResumeNextStatement(ByVal node As OnErrorResumeNextStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitResumeStatement(ByVal node As ResumeStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitSelectBlock(ByVal node As SelectBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitSelectStatement(ByVal node As SelectStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitCaseBlock(ByVal node As CaseBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitCaseStatement(ByVal node As CaseStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitCaseClause(ByVal node As CaseClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitCaseElseClause(ByVal node As CaseElseClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitCaseClause(node)
        End Function
        Public Overridable Function VisitCaseValueClause(ByVal node As CaseValueClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitCaseClause(node)
        End Function
        Public Overridable Function VisitCaseRangeClause(ByVal node As CaseRangeClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitCaseClause(node)
        End Function
        Public Overridable Function VisitCaseRelationalClause(ByVal node As CaseRelationalClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitCaseClause(node)
        End Function
        Public Overridable Function VisitSyncLockStatement(ByVal node As SyncLockStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitDoLoopBlock(ByVal node As DoLoopBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitDoStatement(ByVal node As DoStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitLoopStatement(ByVal node As LoopStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitWhileUntilClause(ByVal node As WhileUntilClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitWhileStatement(ByVal node As WhileStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitForBlock(ByVal node As ForBlockSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitForStatement(ByVal node As ForStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitForStepClause(ByVal node As ForStepClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitForEachStatement(ByVal node As ForEachStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitNextStatement(ByVal node As NextStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitUsingStatement(ByVal node As UsingStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitThrowStatement(ByVal node As ThrowStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitAssignmentStatement(ByVal node As AssignmentStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitCallStatement(ByVal node As CallStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitAddRemoveHandlerStatement(ByVal node As AddRemoveHandlerStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitRaiseEventStatement(ByVal node As RaiseEventStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitWithStatement(ByVal node As WithStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitReDimStatement(ByVal node As ReDimStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitEraseStatement(ByVal node As EraseStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitExpression(ByVal node As ExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitLiteralExpression(ByVal node As LiteralExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitParenthesizedExpression(ByVal node As ParenthesizedExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitInstanceExpression(ByVal node As InstanceExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitMeExpression(ByVal node As MeExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitInstanceExpression(node)
        End Function
        Public Overridable Function VisitMyBaseExpression(ByVal node As MyBaseExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitInstanceExpression(node)
        End Function
        Public Overridable Function VisitMyClassExpression(ByVal node As MyClassExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitInstanceExpression(node)
        End Function
        Public Overridable Function VisitGetTypeExpression(ByVal node As GetTypeExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitTypeOfExpression(ByVal node As TypeOfExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitGetXmlNamespaceExpression(ByVal node As GetXmlNamespaceExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitMemberAccessExpression(ByVal node As MemberAccessExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitXmlMemberAccessExpression(ByVal node As XmlMemberAccessExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitInvocationExpression(ByVal node As InvocationExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitNewExpression(ByVal node As NewExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitObjectCreationExpression(ByVal node As ObjectCreationExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitNewExpression(node)
        End Function
        Public Overridable Function VisitAnonymousObjectCreationExpression(ByVal node As AnonymousObjectCreationExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitNewExpression(node)
        End Function
        Public Overridable Function VisitArrayCreationExpression(ByVal node As ArrayCreationExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitNewExpression(node)
        End Function
        Public Overridable Function VisitCollectionInitializer(ByVal node As CollectionInitializerSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitCastExpression(ByVal node As CastExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitCTypeExpression(ByVal node As CTypeExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitCastExpression(node)
        End Function
        Public Overridable Function VisitDirectCastExpression(ByVal node As DirectCastExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitCastExpression(node)
        End Function
        Public Overridable Function VisitTryCastExpression(ByVal node As TryCastExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitCastExpression(node)
        End Function
        Public Overridable Function VisitPredefinedCastExpression(ByVal node As PredefinedCastExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitBinaryExpression(ByVal node As BinaryExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitUnaryExpression(ByVal node As UnaryExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitBinaryConditionalExpression(ByVal node As BinaryConditionalExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitTernaryConditionalExpression(ByVal node As TernaryConditionalExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitLambdaExpression(ByVal node As LambdaExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitSingleLineLambdaExpression(ByVal node As SingleLineLambdaExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitLambdaExpression(node)
        End Function
        Public Overridable Function VisitMultiLineLambdaExpression(ByVal node As MultiLineLambdaExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitLambdaExpression(node)
        End Function
        Public Overridable Function VisitLambdaHeader(ByVal node As LambdaHeaderSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitArgumentList(ByVal node As ArgumentListSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitArgument(ByVal node As ArgumentSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitOmittedArgument(ByVal node As OmittedArgumentSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitArgument(node)
        End Function
        Public Overridable Function VisitSimpleArgument(ByVal node As SimpleArgumentSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitArgument(node)
        End Function
        Public Overridable Function VisitNamedArgument(ByVal node As NamedArgumentSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitArgument(node)
        End Function
        Public Overridable Function VisitRangeArgument(ByVal node As RangeArgumentSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitArgument(node)
        End Function
        Public Overridable Function VisitQueryExpression(ByVal node As QueryExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitQueryClause(ByVal node As QueryClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitCollectionRangeVariable(ByVal node As CollectionRangeVariableSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitExpressionRangeVariable(ByVal node As ExpressionRangeVariableSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitAggregationRangeVariable(ByVal node As AggregationRangeVariableSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitVariableNameEquals(ByVal node As VariableNameEqualsSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitAggregation(ByVal node As AggregationSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitFunctionAggregation(ByVal node As FunctionAggregationSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitAggregation(node)
        End Function
        Public Overridable Function VisitGroupAggregation(ByVal node As GroupAggregationSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitAggregation(node)
        End Function
        Public Overridable Function VisitFromClause(ByVal node As FromClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitLetClause(ByVal node As LetClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitAggregateClause(ByVal node As AggregateClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitDistinctClause(ByVal node As DistinctClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitWhereClause(ByVal node As WhereClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitPartitionWhileClause(ByVal node As PartitionWhileClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitPartitionClause(ByVal node As PartitionClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitGroupByClause(ByVal node As GroupByClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitJoinClause(ByVal node As JoinClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitJoinCondition(ByVal node As JoinConditionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitGroupJoinClause(ByVal node As GroupJoinClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitJoinClause(node)
        End Function
        Public Overridable Function VisitOrderByClause(ByVal node As OrderByClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitOrdering(ByVal node As OrderingSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitSelectClause(ByVal node As SelectClauseSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitXmlNode(ByVal node As XmlNodeSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitXmlDocument(ByVal node As XmlDocumentSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlDeclaration(ByVal node As XmlDeclarationSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitXmlDeclarationOption(ByVal node As XmlDeclarationOptionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitXmlElement(ByVal node As XmlElementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlText(ByVal node As XmlTextSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlElementStartTag(ByVal node As XmlElementStartTagSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlElementEndTag(ByVal node As XmlElementEndTagSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlEmptyElement(ByVal node As XmlEmptyElementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlAttribute(ByVal node As XmlAttributeSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlString(ByVal node As XmlStringSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlName(ByVal node As XmlNameSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlBracketedName(ByVal node As XmlBracketedNameSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlPrefix(ByVal node As XmlPrefixSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitXmlComment(ByVal node As XmlCommentSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlProcessingInstruction(ByVal node As XmlProcessingInstructionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlCDataSection(ByVal node As XmlCDataSectionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlEmbeddedExpression(ByVal node As XmlEmbeddedExpressionSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitType(ByVal node As TypeSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitArrayType(ByVal node As ArrayTypeSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitType(node)
        End Function
        Public Overridable Function VisitNullableType(ByVal node As NullableTypeSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitType(node)
        End Function
        Public Overridable Function VisitPredefinedType(ByVal node As PredefinedTypeSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitType(node)
        End Function
        Public Overridable Function VisitName(ByVal node As NameSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitType(node)
        End Function
        Public Overridable Function VisitSimpleName(ByVal node As SimpleNameSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitName(node)
        End Function
        Public Overridable Function VisitIdentifierName(ByVal node As IdentifierNameSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSimpleName(node)
        End Function
        Public Overridable Function VisitGenericName(ByVal node As GenericNameSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSimpleName(node)
        End Function
        Public Overridable Function VisitQualifiedName(ByVal node As QualifiedNameSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitName(node)
        End Function
        Public Overridable Function VisitGlobalName(ByVal node As GlobalNameSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitName(node)
        End Function
        Public Overridable Function VisitTypeArgumentList(ByVal node As TypeArgumentListSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitStructuredTrivia(ByVal node As StructuredTriviaSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSyntaxNode(node)
        End Function
        Public Overridable Function VisitSkippedTokens(ByVal node As SkippedTokensSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStructuredTrivia(node)
        End Function
        Public Overridable Function VisitDocumentationComment(ByVal node As DocumentationCommentSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStructuredTrivia(node)
        End Function
        Public Overridable Function VisitDirective(ByVal node As DirectiveSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStructuredTrivia(node)
        End Function
        Public Overridable Function VisitDirectiveStatement(ByVal node As DirectiveStatementSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitConstDirective(ByVal node As ConstDirectiveSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveStatement(node)
        End Function
        Public Overridable Function VisitIfDirective(ByVal node As IfDirectiveSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveStatement(node)
        End Function
        Public Overridable Function VisitElseDirective(ByVal node As ElseDirectiveSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveStatement(node)
        End Function
        Public Overridable Function VisitEndIfDirective(ByVal node As EndIfDirectiveSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveStatement(node)
        End Function
        Public Overridable Function VisitRegionDirective(ByVal node As RegionDirectiveSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveStatement(node)
        End Function
        Public Overridable Function VisitEndRegionDirective(ByVal node As EndRegionDirectiveSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveStatement(node)
        End Function
        Public Overridable Function VisitExternalSourceDirective(ByVal node As ExternalSourceDirectiveSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveStatement(node)
        End Function
        Public Overridable Function VisitEndExternalSourceDirective(ByVal node As EndExternalSourceDirective) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveStatement(node)
        End Function
        Public Overridable Function VisitExternalChecksumDirective(ByVal node As ExternalChecksumDirectiveSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveStatement(node)
        End Function
        Public Overridable Function VisitReferenceDirective(ByVal node As ReferenceDirectiveSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveStatement(node)
        End Function
        Public Overridable Function VisitBadDirective(ByVal node As BadDirectiveSyntax) As SyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveStatement(node)
        End Function
    End Class

    Friend MustInherit Class SyntaxRewriter
        Inherits SyntaxVisitor

        Public Overrides Function VisitEmptyStatement(ByVal node As EmptyStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newEmpty = DirectCast(Visit(node.Empty), PunctuationSyntax)
            If node._empty IsNot newEmpty Then anyChanges = True

            If anyChanges Then
                Return New EmptyStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newEmpty)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEndBlockStatement(ByVal node As EndBlockStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newEndKeyword = DirectCast(Visit(node.EndKeyword), KeywordSyntax)
            If node._endKeyword IsNot newEndKeyword Then anyChanges = True
            Dim newBlockKeyword = DirectCast(Visit(node.BlockKeyword), KeywordSyntax)
            If node._blockKeyword IsNot newBlockKeyword Then anyChanges = True

            If anyChanges Then
                Return New EndBlockStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newEndKeyword, newBlockKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCompilationUnit(ByVal node As CompilationUnitSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOptions = VisitList(node.Options)
            If node._options IsNot newOptions.Node Then anyChanges = True
            Dim newImports = VisitList(node.[Imports])
            If node._imports IsNot newImports.Node Then anyChanges = True
            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newMembers = VisitList(node.Members)
            If node._members IsNot newMembers.Node Then anyChanges = True
            Dim newEndOfFileToken = DirectCast(Visit(node.EndOfFileToken), PunctuationSyntax)
            If node._endOfFileToken IsNot newEndOfFileToken Then anyChanges = True

            If anyChanges Then
                Return New CompilationUnitSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOptions.Node, newImports.Node, newAttributes.Node, newMembers.Node, newEndOfFileToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitOptionStatement(ByVal node As OptionStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOptionKeyword = DirectCast(Visit(node.OptionKeyword), KeywordSyntax)
            If node._optionKeyword IsNot newOptionKeyword Then anyChanges = True
            Dim newNameKeyword = DirectCast(Visit(node.NameKeyword), KeywordSyntax)
            If node._nameKeyword IsNot newNameKeyword Then anyChanges = True
            Dim newValueKeyword = DirectCast(Visit(node.ValueKeyword), KeywordSyntax)
            If node._valueKeyword IsNot newValueKeyword Then anyChanges = True

            If anyChanges Then
                Return New OptionStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOptionKeyword, newNameKeyword, newValueKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitImportsStatement(ByVal node As ImportsStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newImportsKeyword = DirectCast(Visit(node.ImportsKeyword), KeywordSyntax)
            If node._importsKeyword IsNot newImportsKeyword Then anyChanges = True
            Dim newImportsClauses = VisitList(node.ImportsClauses)
            If node._importsClauses IsNot newImportsClauses.Node Then anyChanges = True

            If anyChanges Then
                Return New ImportsStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newImportsKeyword, newImportsClauses.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAliasImportsClause(ByVal node As AliasImportsClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAlias = DirectCast(Visit(node.[Alias]), IdentifierTokenSyntax)
            If node._alias IsNot newAlias Then anyChanges = True
            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), NameSyntax)
            If node._name IsNot newName Then anyChanges = True

            If anyChanges Then
                Return New AliasImportsClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAlias, newEqualsToken, newName)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMembersImportsClause(ByVal node As MembersImportsClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newName = DirectCast(Visit(node._name), NameSyntax)
            If node._name IsNot newName Then anyChanges = True

            If anyChanges Then
                Return New MembersImportsClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newName)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlNamespaceImportsClause(ByVal node As XmlNamespaceImportsClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanToken = DirectCast(Visit(node.LessThanToken), PunctuationSyntax)
            If node._lessThanToken IsNot newLessThanToken Then anyChanges = True
            Dim newXmlNamespace = DirectCast(Visit(node._xmlNamespace), XmlAttributeSyntax)
            If node._xmlNamespace IsNot newXmlNamespace Then anyChanges = True
            Dim newGreaterThanToken = DirectCast(Visit(node.GreaterThanToken), PunctuationSyntax)
            If node._greaterThanToken IsNot newGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlNamespaceImportsClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanToken, newXmlNamespace, newGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitNamespaceBlock(ByVal node As NamespaceBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), NamespaceStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newMembers = VisitList(node.Members)
            If node._members IsNot newMembers.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New NamespaceBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newMembers.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitNamespaceStatement(ByVal node As NamespaceStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNamespaceKeyword = DirectCast(Visit(node.NamespaceKeyword), KeywordSyntax)
            If node._namespaceKeyword IsNot newNamespaceKeyword Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), NameSyntax)
            If node._name IsNot newName Then anyChanges = True

            If anyChanges Then
                Return New NamespaceStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNamespaceKeyword, newName)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitModuleBlock(ByVal node As ModuleBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), ModuleStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newInherits = VisitList(node.[Inherits])
            If node._inherits IsNot newInherits.Node Then anyChanges = True
            Dim newImplements = VisitList(node.[Implements])
            If node._implements IsNot newImplements.Node Then anyChanges = True
            Dim newMembers = VisitList(node.Members)
            If node._members IsNot newMembers.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New ModuleBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newInherits.Node, newImplements.Node, newMembers.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitStructureBlock(ByVal node As StructureBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), StructureStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newInherits = VisitList(node.[Inherits])
            If node._inherits IsNot newInherits.Node Then anyChanges = True
            Dim newImplements = VisitList(node.[Implements])
            If node._implements IsNot newImplements.Node Then anyChanges = True
            Dim newMembers = VisitList(node.Members)
            If node._members IsNot newMembers.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New StructureBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newInherits.Node, newImplements.Node, newMembers.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitInterfaceBlock(ByVal node As InterfaceBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), InterfaceStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newInherits = VisitList(node.[Inherits])
            If node._inherits IsNot newInherits.Node Then anyChanges = True
            Dim newImplements = VisitList(node.[Implements])
            If node._implements IsNot newImplements.Node Then anyChanges = True
            Dim newMembers = VisitList(node.Members)
            If node._members IsNot newMembers.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New InterfaceBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newInherits.Node, newImplements.Node, newMembers.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitClassBlock(ByVal node As ClassBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), ClassStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newInherits = VisitList(node.[Inherits])
            If node._inherits IsNot newInherits.Node Then anyChanges = True
            Dim newImplements = VisitList(node.[Implements])
            If node._implements IsNot newImplements.Node Then anyChanges = True
            Dim newMembers = VisitList(node.Members)
            If node._members IsNot newMembers.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New ClassBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newInherits.Node, newImplements.Node, newMembers.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEnumBlock(ByVal node As EnumBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), EnumStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newMembers = VisitList(node.Members)
            If node._members IsNot newMembers.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New EnumBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newMembers.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitInheritsStatement(ByVal node As InheritsStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newInheritsKeyword = DirectCast(Visit(node.InheritsKeyword), KeywordSyntax)
            If node._inheritsKeyword IsNot newInheritsKeyword Then anyChanges = True
            Dim newTypes = VisitList(node.Types)
            If node._types IsNot newTypes.Node Then anyChanges = True

            If anyChanges Then
                Return New InheritsStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newInheritsKeyword, newTypes.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitImplementsStatement(ByVal node As ImplementsStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newImplementsKeyword = DirectCast(Visit(node.ImplementsKeyword), KeywordSyntax)
            If node._implementsKeyword IsNot newImplementsKeyword Then anyChanges = True
            Dim newTypes = VisitList(node.Types)
            If node._types IsNot newTypes.Node Then anyChanges = True

            If anyChanges Then
                Return New ImplementsStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newImplementsKeyword, newTypes.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitModuleStatement(ByVal node As ModuleStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeParameterList = DirectCast(Visit(node._typeParameterList), TypeParameterListSyntax)
            If node._typeParameterList IsNot newTypeParameterList Then anyChanges = True

            If anyChanges Then
                Return New ModuleStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newKeyword, newIdentifier, newTypeParameterList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitStructureStatement(ByVal node As StructureStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeParameterList = DirectCast(Visit(node._typeParameterList), TypeParameterListSyntax)
            If node._typeParameterList IsNot newTypeParameterList Then anyChanges = True

            If anyChanges Then
                Return New StructureStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newKeyword, newIdentifier, newTypeParameterList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitInterfaceStatement(ByVal node As InterfaceStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeParameterList = DirectCast(Visit(node._typeParameterList), TypeParameterListSyntax)
            If node._typeParameterList IsNot newTypeParameterList Then anyChanges = True

            If anyChanges Then
                Return New InterfaceStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newKeyword, newIdentifier, newTypeParameterList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitClassStatement(ByVal node As ClassStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeParameterList = DirectCast(Visit(node._typeParameterList), TypeParameterListSyntax)
            If node._typeParameterList IsNot newTypeParameterList Then anyChanges = True

            If anyChanges Then
                Return New ClassStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newKeyword, newIdentifier, newTypeParameterList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEnumStatement(ByVal node As EnumStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newEnumKeyword = DirectCast(Visit(node.EnumKeyword), KeywordSyntax)
            If node._enumKeyword IsNot newEnumKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newUnderlyingType = DirectCast(Visit(node._underlyingType), AsClauseSyntax)
            If node._underlyingType IsNot newUnderlyingType Then anyChanges = True

            If anyChanges Then
                Return New EnumStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newEnumKeyword, newIdentifier, newUnderlyingType)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTypeParameterList(ByVal node As TypeParameterListSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newOfKeyword = DirectCast(Visit(node.OfKeyword), KeywordSyntax)
            If node._ofKeyword IsNot newOfKeyword Then anyChanges = True
            Dim newParameters = VisitList(node.Parameters)
            If node._parameters IsNot newParameters.Node Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New TypeParameterListSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenParenToken, newOfKeyword, newParameters.Node, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTypeParameter(ByVal node As TypeParameterSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newVarianceKeyword = DirectCast(Visit(node.VarianceKeyword), KeywordSyntax)
            If node._varianceKeyword IsNot newVarianceKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeParameterConstraintClause = DirectCast(Visit(node._typeParameterConstraintClause), TypeParameterConstraintClauseSyntax)
            If node._typeParameterConstraintClause IsNot newTypeParameterConstraintClause Then anyChanges = True

            If anyChanges Then
                Return New TypeParameterSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newVarianceKeyword, newIdentifier, newTypeParameterConstraintClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTypeParameterSingleConstraintClause(ByVal node As TypeParameterSingleConstraintClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAsKeyword = DirectCast(Visit(node.AsKeyword), KeywordSyntax)
            If node._asKeyword IsNot newAsKeyword Then anyChanges = True
            Dim newConstraint = DirectCast(Visit(node._constraint), ConstraintSyntax)
            If node._constraint IsNot newConstraint Then anyChanges = True

            If anyChanges Then
                Return New TypeParameterSingleConstraintClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAsKeyword, newConstraint)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTypeParameterMultipleConstraintClause(ByVal node As TypeParameterMultipleConstraintClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAsKeyword = DirectCast(Visit(node.AsKeyword), KeywordSyntax)
            If node._asKeyword IsNot newAsKeyword Then anyChanges = True
            Dim newOpenBraceToken = DirectCast(Visit(node.OpenBraceToken), PunctuationSyntax)
            If node._openBraceToken IsNot newOpenBraceToken Then anyChanges = True
            Dim newConstraints = VisitList(node.Constraints)
            If node._constraints IsNot newConstraints.Node Then anyChanges = True
            Dim newCloseBraceToken = DirectCast(Visit(node.CloseBraceToken), PunctuationSyntax)
            If node._closeBraceToken IsNot newCloseBraceToken Then anyChanges = True

            If anyChanges Then
                Return New TypeParameterMultipleConstraintClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAsKeyword, newOpenBraceToken, newConstraints.Node, newCloseBraceToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSpecialConstraint(ByVal node As SpecialConstraintSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newConstraintKeyword = DirectCast(Visit(node.ConstraintKeyword), KeywordSyntax)
            If node._constraintKeyword IsNot newConstraintKeyword Then anyChanges = True

            If anyChanges Then
                Return New SpecialConstraintSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newConstraintKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTypeConstraint(ByVal node As TypeConstraintSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True

            If anyChanges Then
                Return New TypeConstraintSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newType)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEnumMemberDeclaration(ByVal node As EnumMemberDeclarationSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newInitializer = DirectCast(Visit(node._initializer), EqualsValueSyntax)
            If node._initializer IsNot newInitializer Then anyChanges = True

            If anyChanges Then
                Return New EnumMemberDeclarationSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newIdentifier, newInitializer)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMethodBlock(ByVal node As MethodBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), MethodBaseSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New MethodBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newStatements.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitPropertyBlock(ByVal node As PropertyBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), PropertyStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newAccessors = VisitList(node.Accessors)
            If node._accessors IsNot newAccessors.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New PropertyBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newAccessors.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEventBlock(ByVal node As EventBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), EventStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newAccessors = VisitList(node.Accessors)
            If node._accessors IsNot newAccessors.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New EventBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newAccessors.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitParameterList(ByVal node As ParameterListSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newParameters = VisitList(node.Parameters)
            If node._parameters IsNot newParameters.Node Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New ParameterListSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenParenToken, newParameters.Node, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMethodStatement(ByVal node As MethodStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeParameterList = DirectCast(Visit(node._typeParameterList), TypeParameterListSyntax)
            If node._typeParameterList IsNot newTypeParameterList Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), AsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newHandlesClause = DirectCast(Visit(node._handlesClause), HandlesClauseSyntax)
            If node._handlesClause IsNot newHandlesClause Then anyChanges = True
            Dim newImplementsClause = DirectCast(Visit(node._implementsClause), ImplementsClauseSyntax)
            If node._implementsClause IsNot newImplementsClause Then anyChanges = True

            If anyChanges Then
                Return New MethodStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newKeyword, newIdentifier, newTypeParameterList, newParameterList, newAsClause, newHandlesClause, newImplementsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitConstructorStatement(ByVal node As ConstructorStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newNewKeyword = DirectCast(Visit(node.NewKeyword), KeywordSyntax)
            If node._newKeyword IsNot newNewKeyword Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), AsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True

            If anyChanges Then
                Return New ConstructorStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newKeyword, newNewKeyword, newParameterList, newAsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDeclareStatement(ByVal node As DeclareStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newDeclareKeyword = DirectCast(Visit(node.DeclareKeyword), KeywordSyntax)
            If node._declareKeyword IsNot newDeclareKeyword Then anyChanges = True
            Dim newCharsetKeyword = DirectCast(Visit(node.CharsetKeyword), KeywordSyntax)
            If node._charsetKeyword IsNot newCharsetKeyword Then anyChanges = True
            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newLibKeyword = DirectCast(Visit(node.LibKeyword), KeywordSyntax)
            If node._libKeyword IsNot newLibKeyword Then anyChanges = True
            Dim newLibraryName = DirectCast(Visit(node._libraryName), LiteralExpressionSyntax)
            If node._libraryName IsNot newLibraryName Then anyChanges = True
            Dim newAliasKeyword = DirectCast(Visit(node.AliasKeyword), KeywordSyntax)
            If node._aliasKeyword IsNot newAliasKeyword Then anyChanges = True
            Dim newAliasName = DirectCast(Visit(node._aliasName), LiteralExpressionSyntax)
            If node._aliasName IsNot newAliasName Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), AsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True

            If anyChanges Then
                Return New DeclareStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newDeclareKeyword, newCharsetKeyword, newKeyword, newIdentifier, newLibKeyword, newLibraryName, newAliasKeyword, newAliasName, newParameterList, newAsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDelegateStatement(ByVal node As DelegateStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newDelegateKeyword = DirectCast(Visit(node.DelegateKeyword), KeywordSyntax)
            If node._delegateKeyword IsNot newDelegateKeyword Then anyChanges = True
            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeParameterList = DirectCast(Visit(node._typeParameterList), TypeParameterListSyntax)
            If node._typeParameterList IsNot newTypeParameterList Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), AsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True

            If anyChanges Then
                Return New DelegateStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newDelegateKeyword, newKeyword, newIdentifier, newTypeParameterList, newParameterList, newAsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEventStatement(ByVal node As EventStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newCustomKeyword = DirectCast(Visit(node.CustomKeyword), KeywordSyntax)
            If node._customKeyword IsNot newCustomKeyword Then anyChanges = True
            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), AsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newImplementsClause = DirectCast(Visit(node._implementsClause), ImplementsClauseSyntax)
            If node._implementsClause IsNot newImplementsClause Then anyChanges = True

            If anyChanges Then
                Return New EventStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newCustomKeyword, newKeyword, newIdentifier, newParameterList, newAsClause, newImplementsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitOperatorStatement(ByVal node As OperatorStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newOperator = DirectCast(Visit(node.[Operator]), SyntaxToken)
            If node._operator IsNot newOperator Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), AsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True

            If anyChanges Then
                Return New OperatorStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newKeyword, newOperator, newParameterList, newAsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitPropertyStatement(ByVal node As PropertyStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), AsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newInitializer = DirectCast(Visit(node._initializer), EqualsValueSyntax)
            If node._initializer IsNot newInitializer Then anyChanges = True
            Dim newImplementsClause = DirectCast(Visit(node._implementsClause), ImplementsClauseSyntax)
            If node._implementsClause IsNot newImplementsClause Then anyChanges = True

            If anyChanges Then
                Return New PropertyStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newKeyword, newIdentifier, newParameterList, newAsClause, newInitializer, newImplementsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAccessorStatement(ByVal node As AccessorStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), AsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True

            If anyChanges Then
                Return New AccessorStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newKeyword, newParameterList, newAsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitImplementsClause(ByVal node As ImplementsClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newImplementsKeyword = DirectCast(Visit(node.ImplementsKeyword), KeywordSyntax)
            If node._implementsKeyword IsNot newImplementsKeyword Then anyChanges = True
            Dim newInterfaceMembers = VisitList(node.InterfaceMembers)
            If node._interfaceMembers IsNot newInterfaceMembers.Node Then anyChanges = True

            If anyChanges Then
                Return New ImplementsClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newImplementsKeyword, newInterfaceMembers.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitHandlesClause(ByVal node As HandlesClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHandlesKeyword = DirectCast(Visit(node.HandlesKeyword), KeywordSyntax)
            If node._handlesKeyword IsNot newHandlesKeyword Then anyChanges = True
            Dim newEvents = VisitList(node.Events)
            If node._events IsNot newEvents.Node Then anyChanges = True

            If anyChanges Then
                Return New HandlesClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHandlesKeyword, newEvents.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitHandlesClauseItem(ByVal node As HandlesClauseItemSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newEventContainer = DirectCast(Visit(node.EventContainer), SyntaxToken)
            If node._eventContainer IsNot newEventContainer Then anyChanges = True
            Dim newDotToken = DirectCast(Visit(node.DotToken), PunctuationSyntax)
            If node._dotToken IsNot newDotToken Then anyChanges = True
            Dim newEventMember = DirectCast(Visit(node._eventMember), IdentifierNameSyntax)
            If node._eventMember IsNot newEventMember Then anyChanges = True

            If anyChanges Then
                Return New HandlesClauseItemSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newEventContainer, newDotToken, newEventMember)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitIncompleteMember(ByVal node As IncompleteMemberSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newMissingIdentifier = DirectCast(Visit(node.MissingIdentifier), IdentifierTokenSyntax)
            If node._missingIdentifier IsNot newMissingIdentifier Then anyChanges = True

            If anyChanges Then
                Return New IncompleteMemberSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newMissingIdentifier)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitFieldDeclaration(ByVal node As FieldDeclarationSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newDeclarators = VisitList(node.Declarators)
            If node._declarators IsNot newDeclarators.Node Then anyChanges = True

            If anyChanges Then
                Return New FieldDeclarationSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newDeclarators.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitVariableDeclarator(ByVal node As VariableDeclaratorSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNames = VisitList(node.Names)
            If node._names IsNot newNames.Node Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), AsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newInitializer = DirectCast(Visit(node._initializer), EqualsValueSyntax)
            If node._initializer IsNot newInitializer Then anyChanges = True

            If anyChanges Then
                Return New VariableDeclaratorSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNames.Node, newAsClause, newInitializer)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSimpleAsClause(ByVal node As SimpleAsClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAsKeyword = DirectCast(Visit(node.AsKeyword), KeywordSyntax)
            If node._asKeyword IsNot newAsKeyword Then anyChanges = True
            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True

            If anyChanges Then
                Return New SimpleAsClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAsKeyword, newAttributes.Node, newType)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAsNewClause(ByVal node As AsNewClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAsKeyword = DirectCast(Visit(node.AsKeyword), KeywordSyntax)
            If node._asKeyword IsNot newAsKeyword Then anyChanges = True
            Dim newNewExpression = DirectCast(Visit(node._newExpression), NewExpressionSyntax)
            If node._newExpression IsNot newNewExpression Then anyChanges = True

            If anyChanges Then
                Return New AsNewClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAsKeyword, newNewExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitObjectMemberInitializer(ByVal node As ObjectMemberInitializerSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newWithKeyword = DirectCast(Visit(node.WithKeyword), KeywordSyntax)
            If node._withKeyword IsNot newWithKeyword Then anyChanges = True
            Dim newOpenBraceToken = DirectCast(Visit(node.OpenBraceToken), PunctuationSyntax)
            If node._openBraceToken IsNot newOpenBraceToken Then anyChanges = True
            Dim newInitializers = VisitList(node.Initializers)
            If node._initializers IsNot newInitializers.Node Then anyChanges = True
            Dim newCloseBraceToken = DirectCast(Visit(node.CloseBraceToken), PunctuationSyntax)
            If node._closeBraceToken IsNot newCloseBraceToken Then anyChanges = True

            If anyChanges Then
                Return New ObjectMemberInitializerSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newWithKeyword, newOpenBraceToken, newInitializers.Node, newCloseBraceToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitObjectCollectionInitializer(ByVal node As ObjectCollectionInitializerSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newFromKeyword = DirectCast(Visit(node.FromKeyword), KeywordSyntax)
            If node._fromKeyword IsNot newFromKeyword Then anyChanges = True
            Dim newInitializer = DirectCast(Visit(node._initializer), CollectionInitializerSyntax)
            If node._initializer IsNot newInitializer Then anyChanges = True

            If anyChanges Then
                Return New ObjectCollectionInitializerSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newFromKeyword, newInitializer)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitInferredFieldInitializer(ByVal node As InferredFieldInitializerSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyKeyword = DirectCast(Visit(node.KeyKeyword), KeywordSyntax)
            If node._keyKeyword IsNot newKeyKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New InferredFieldInitializerSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitNamedFieldInitializer(ByVal node As NamedFieldInitializerSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyKeyword = DirectCast(Visit(node.KeyKeyword), KeywordSyntax)
            If node._keyKeyword IsNot newKeyKeyword Then anyChanges = True
            Dim newDotToken = DirectCast(Visit(node.DotToken), PunctuationSyntax)
            If node._dotToken IsNot newDotToken Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node._identifier), IdentifierNameSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New NamedFieldInitializerSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyKeyword, newDotToken, newIdentifier, newEqualsToken, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEqualsValue(ByVal node As EqualsValueSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True
            Dim newValue = DirectCast(Visit(node._value), ExpressionSyntax)
            If node._value IsNot newValue Then anyChanges = True

            If anyChanges Then
                Return New EqualsValueSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newEqualsToken, newValue)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitParameter(ByVal node As ParameterSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node._identifier), ModifiedIdentifierSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newDefault = DirectCast(Visit(node._default), EqualsValueSyntax)
            If node._default IsNot newDefault Then anyChanges = True

            If anyChanges Then
                Return New ParameterSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newIdentifier, newAsClause, newDefault)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitModifiedIdentifier(ByVal node As ModifiedIdentifierSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newNullable = DirectCast(Visit(node.Nullable), PunctuationSyntax)
            If node._nullable IsNot newNullable Then anyChanges = True
            Dim newArrayBounds = DirectCast(Visit(node._arrayBounds), ArgumentListSyntax)
            If node._arrayBounds IsNot newArrayBounds Then anyChanges = True
            Dim newArrayRankSpecifiers = VisitList(node.ArrayRankSpecifiers)
            If node._arrayRankSpecifiers IsNot newArrayRankSpecifiers.Node Then anyChanges = True

            If anyChanges Then
                Return New ModifiedIdentifierSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIdentifier, newNullable, newArrayBounds, newArrayRankSpecifiers.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitArrayRankSpecifier(ByVal node As ArrayRankSpecifierSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newCommaTokens = VisitList(node.CommaTokens)
            If node._commaTokens IsNot newCommaTokens.Node Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New ArrayRankSpecifierSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenParenToken, newCommaTokens.Node, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAttributeBlock(ByVal node As AttributeBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanToken = DirectCast(Visit(node.LessThanToken), PunctuationSyntax)
            If node._lessThanToken IsNot newLessThanToken Then anyChanges = True
            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newGreaterThanToken = DirectCast(Visit(node.GreaterThanToken), PunctuationSyntax)
            If node._greaterThanToken IsNot newGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New AttributeBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanToken, newAttributes.Node, newGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAttribute(ByVal node As AttributeSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newTarget = DirectCast(Visit(node._target), AttributeTargetSyntax)
            If node._target IsNot newTarget Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), TypeSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newArgumentList = DirectCast(Visit(node._argumentList), ArgumentListSyntax)
            If node._argumentList IsNot newArgumentList Then anyChanges = True

            If anyChanges Then
                Return New AttributeSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newTarget, newName, newArgumentList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAttributeTarget(ByVal node As AttributeTargetSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeModifier = DirectCast(Visit(node.AttributeModifier), KeywordSyntax)
            If node._attributeModifier IsNot newAttributeModifier Then anyChanges = True
            Dim newColonToken = DirectCast(Visit(node.ColonToken), PunctuationSyntax)
            If node._colonToken IsNot newColonToken Then anyChanges = True

            If anyChanges Then
                Return New AttributeTargetSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeModifier, newColonToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAttributesStatement(ByVal node As AttributesStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True

            If anyChanges Then
                Return New AttributesStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitExpressionStatement(ByVal node As ExpressionStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newQuestionToken = DirectCast(Visit(node.QuestionToken), PunctuationSyntax)
            If node._questionToken IsNot newQuestionToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New ExpressionStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newQuestionToken, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitWhileBlock(ByVal node As WhileBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), WhileStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New WhileBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newStatements.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitUsingBlock(ByVal node As UsingBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), UsingStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New UsingBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newStatements.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSyncLockBlock(ByVal node As SyncLockBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), SyncLockStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New SyncLockBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newStatements.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitWithBlock(ByVal node As WithBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), WithStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New WithBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newStatements.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitLocalDeclaration(ByVal node As LocalDeclarationSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newDeclarators = VisitList(node.Declarators)
            If node._declarators IsNot newDeclarators.Node Then anyChanges = True

            If anyChanges Then
                Return New LocalDeclarationSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newModifiers.Node, newDeclarators.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitLabelStatement(ByVal node As LabelStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLabelToken = DirectCast(Visit(node.LabelToken), SyntaxToken)
            If node._labelToken IsNot newLabelToken Then anyChanges = True

            If anyChanges Then
                Return New LabelStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLabelToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGoToStatement(ByVal node As GoToStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newGoToKeyword = DirectCast(Visit(node.GoToKeyword), KeywordSyntax)
            If node._goToKeyword IsNot newGoToKeyword Then anyChanges = True
            Dim newLabel = DirectCast(Visit(node._label), LabelSyntax)
            If node._label IsNot newLabel Then anyChanges = True

            If anyChanges Then
                Return New GoToStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newGoToKeyword, newLabel)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitLabel(ByVal node As LabelSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLabelToken = DirectCast(Visit(node.LabelToken), SyntaxToken)
            If node._labelToken IsNot newLabelToken Then anyChanges = True

            If anyChanges Then
                Return New LabelSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLabelToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitStopOrEndStatement(ByVal node As StopOrEndStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newStopOrEndKeyword = DirectCast(Visit(node.StopOrEndKeyword), KeywordSyntax)
            If node._stopOrEndKeyword IsNot newStopOrEndKeyword Then anyChanges = True

            If anyChanges Then
                Return New StopOrEndStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newStopOrEndKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitExitStatement(ByVal node As ExitStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newExitKeyword = DirectCast(Visit(node.ExitKeyword), KeywordSyntax)
            If node._exitKeyword IsNot newExitKeyword Then anyChanges = True
            Dim newBlockKeyword = DirectCast(Visit(node.BlockKeyword), KeywordSyntax)
            If node._blockKeyword IsNot newBlockKeyword Then anyChanges = True

            If anyChanges Then
                Return New ExitStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newExitKeyword, newBlockKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitContinueStatement(ByVal node As ContinueStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newContinueKeyword = DirectCast(Visit(node.ContinueKeyword), KeywordSyntax)
            If node._continueKeyword IsNot newContinueKeyword Then anyChanges = True
            Dim newBlockKeyword = DirectCast(Visit(node.BlockKeyword), KeywordSyntax)
            If node._blockKeyword IsNot newBlockKeyword Then anyChanges = True

            If anyChanges Then
                Return New ContinueStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newContinueKeyword, newBlockKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitReturnStatement(ByVal node As ReturnStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newReturnKeyword = DirectCast(Visit(node.ReturnKeyword), KeywordSyntax)
            If node._returnKeyword IsNot newReturnKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New ReturnStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newReturnKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSingleLineIfStatement(ByVal node As SingleLineIfStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIfPart = DirectCast(Visit(node._ifPart), SingleLineIfPartSyntax)
            If node._ifPart IsNot newIfPart Then anyChanges = True
            Dim newElsePart = DirectCast(Visit(node._elsePart), SingleLineElsePartSyntax)
            If node._elsePart IsNot newElsePart Then anyChanges = True

            If anyChanges Then
                Return New SingleLineIfStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIfPart, newElsePart)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSingleLineIfPart(ByVal node As SingleLineIfPartSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), IfStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True

            If anyChanges Then
                Return New SingleLineIfPartSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newStatements.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSingleLineElsePart(ByVal node As SingleLineElsePartSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), ElseStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True

            If anyChanges Then
                Return New SingleLineElsePartSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newStatements.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMultiLineIfBlock(ByVal node As MultiLineIfBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIfPart = DirectCast(Visit(node._ifPart), IfPartSyntax)
            If node._ifPart IsNot newIfPart Then anyChanges = True
            Dim newElseIfParts = VisitList(node.ElseIfParts)
            If node._elseIfParts IsNot newElseIfParts.Node Then anyChanges = True
            Dim newElsePart = DirectCast(Visit(node._elsePart), ElsePartSyntax)
            If node._elsePart IsNot newElsePart Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New MultiLineIfBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIfPart, newElseIfParts.Node, newElsePart, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitIfPart(ByVal node As IfPartSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), IfStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True

            If anyChanges Then
                Return New IfPartSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newStatements.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitElsePart(ByVal node As ElsePartSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), ElseStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True

            If anyChanges Then
                Return New ElsePartSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newStatements.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitIfStatement(ByVal node As IfStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newElseKeyword = DirectCast(Visit(node.ElseKeyword), KeywordSyntax)
            If node._elseKeyword IsNot newElseKeyword Then anyChanges = True
            Dim newIfOrElseIfKeyword = DirectCast(Visit(node.IfOrElseIfKeyword), KeywordSyntax)
            If node._ifOrElseIfKeyword IsNot newIfOrElseIfKeyword Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True
            Dim newThenKeyword = DirectCast(Visit(node.ThenKeyword), KeywordSyntax)
            If node._thenKeyword IsNot newThenKeyword Then anyChanges = True

            If anyChanges Then
                Return New IfStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newElseKeyword, newIfOrElseIfKeyword, newCondition, newThenKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitElseStatement(ByVal node As ElseStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newElseKeyword = DirectCast(Visit(node.ElseKeyword), KeywordSyntax)
            If node._elseKeyword IsNot newElseKeyword Then anyChanges = True

            If anyChanges Then
                Return New ElseStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newElseKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTryBlock(ByVal node As TryBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newTryPart = DirectCast(Visit(node._tryPart), TryPartSyntax)
            If node._tryPart IsNot newTryPart Then anyChanges = True
            Dim newCatchParts = VisitList(node.CatchParts)
            If node._catchParts IsNot newCatchParts.Node Then anyChanges = True
            Dim newFinallyPart = DirectCast(Visit(node._finallyPart), FinallyPartSyntax)
            If node._finallyPart IsNot newFinallyPart Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New TryBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newTryPart, newCatchParts.Node, newFinallyPart, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTryPart(ByVal node As TryPartSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), TryStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True

            If anyChanges Then
                Return New TryPartSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newStatements.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCatchPart(ByVal node As CatchPartSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), CatchStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True

            If anyChanges Then
                Return New CatchPartSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newStatements.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitFinallyPart(ByVal node As FinallyPartSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), FinallyStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True

            If anyChanges Then
                Return New FinallyPartSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newStatements.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTryStatement(ByVal node As TryStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newTryKeyword = DirectCast(Visit(node.TryKeyword), KeywordSyntax)
            If node._tryKeyword IsNot newTryKeyword Then anyChanges = True

            If anyChanges Then
                Return New TryStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newTryKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCatchStatement(ByVal node As CatchStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newCatchKeyword = DirectCast(Visit(node.CatchKeyword), KeywordSyntax)
            If node._catchKeyword IsNot newCatchKeyword Then anyChanges = True
            Dim newIdentifierName = DirectCast(Visit(node._identifierName), IdentifierNameSyntax)
            If node._identifierName IsNot newIdentifierName Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newWhenClause = DirectCast(Visit(node._whenClause), CatchFilterClauseSyntax)
            If node._whenClause IsNot newWhenClause Then anyChanges = True

            If anyChanges Then
                Return New CatchStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newCatchKeyword, newIdentifierName, newAsClause, newWhenClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCatchFilterClause(ByVal node As CatchFilterClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newWhenKeyword = DirectCast(Visit(node.WhenKeyword), KeywordSyntax)
            If node._whenKeyword IsNot newWhenKeyword Then anyChanges = True
            Dim newFilter = DirectCast(Visit(node._filter), ExpressionSyntax)
            If node._filter IsNot newFilter Then anyChanges = True

            If anyChanges Then
                Return New CatchFilterClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newWhenKeyword, newFilter)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitFinallyStatement(ByVal node As FinallyStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newFinallyKeyword = DirectCast(Visit(node.FinallyKeyword), KeywordSyntax)
            If node._finallyKeyword IsNot newFinallyKeyword Then anyChanges = True

            If anyChanges Then
                Return New FinallyStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newFinallyKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitErrorStatement(ByVal node As ErrorStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newErrorKeyword = DirectCast(Visit(node.ErrorKeyword), KeywordSyntax)
            If node._errorKeyword IsNot newErrorKeyword Then anyChanges = True
            Dim newErrorNumber = DirectCast(Visit(node._errorNumber), ExpressionSyntax)
            If node._errorNumber IsNot newErrorNumber Then anyChanges = True

            If anyChanges Then
                Return New ErrorStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newErrorKeyword, newErrorNumber)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitOnErrorGoToStatement(ByVal node As OnErrorGoToStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOnKeyword = DirectCast(Visit(node.OnKeyword), KeywordSyntax)
            If node._onKeyword IsNot newOnKeyword Then anyChanges = True
            Dim newErrorKeyword = DirectCast(Visit(node.ErrorKeyword), KeywordSyntax)
            If node._errorKeyword IsNot newErrorKeyword Then anyChanges = True
            Dim newGoToKeyword = DirectCast(Visit(node.GoToKeyword), KeywordSyntax)
            If node._goToKeyword IsNot newGoToKeyword Then anyChanges = True
            Dim newMinus = DirectCast(Visit(node.Minus), PunctuationSyntax)
            If node._minus IsNot newMinus Then anyChanges = True
            Dim newLabel = DirectCast(Visit(node._label), LabelSyntax)
            If node._label IsNot newLabel Then anyChanges = True

            If anyChanges Then
                Return New OnErrorGoToStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOnKeyword, newErrorKeyword, newGoToKeyword, newMinus, newLabel)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitOnErrorResumeNextStatement(ByVal node As OnErrorResumeNextStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOnKeyword = DirectCast(Visit(node.OnKeyword), KeywordSyntax)
            If node._onKeyword IsNot newOnKeyword Then anyChanges = True
            Dim newErrorKeyword = DirectCast(Visit(node.ErrorKeyword), KeywordSyntax)
            If node._errorKeyword IsNot newErrorKeyword Then anyChanges = True
            Dim newResumeKeyword = DirectCast(Visit(node.ResumeKeyword), KeywordSyntax)
            If node._resumeKeyword IsNot newResumeKeyword Then anyChanges = True
            Dim newNextKeyword = DirectCast(Visit(node.NextKeyword), KeywordSyntax)
            If node._nextKeyword IsNot newNextKeyword Then anyChanges = True

            If anyChanges Then
                Return New OnErrorResumeNextStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOnKeyword, newErrorKeyword, newResumeKeyword, newNextKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitResumeStatement(ByVal node As ResumeStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newResumeKeyword = DirectCast(Visit(node.ResumeKeyword), KeywordSyntax)
            If node._resumeKeyword IsNot newResumeKeyword Then anyChanges = True
            Dim newLabel = DirectCast(Visit(node._label), LabelSyntax)
            If node._label IsNot newLabel Then anyChanges = True

            If anyChanges Then
                Return New ResumeStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newResumeKeyword, newLabel)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSelectBlock(ByVal node As SelectBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), SelectStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newCaseBlocks = VisitList(node.CaseBlocks)
            If node._caseBlocks IsNot newCaseBlocks.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New SelectBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newCaseBlocks.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSelectStatement(ByVal node As SelectStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSelectKeyword = DirectCast(Visit(node.SelectKeyword), KeywordSyntax)
            If node._selectKeyword IsNot newSelectKeyword Then anyChanges = True
            Dim newCaseKeyword = DirectCast(Visit(node.CaseKeyword), KeywordSyntax)
            If node._caseKeyword IsNot newCaseKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New SelectStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSelectKeyword, newCaseKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCaseBlock(ByVal node As CaseBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), CaseStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True

            If anyChanges Then
                Return New CaseBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newStatements.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCaseStatement(ByVal node As CaseStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newCaseKeyword = DirectCast(Visit(node.CaseKeyword), KeywordSyntax)
            If node._caseKeyword IsNot newCaseKeyword Then anyChanges = True
            Dim newCases = VisitList(node.Cases)
            If node._cases IsNot newCases.Node Then anyChanges = True

            If anyChanges Then
                Return New CaseStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newCaseKeyword, newCases.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCaseElseClause(ByVal node As CaseElseClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newElseKeyword = DirectCast(Visit(node.ElseKeyword), KeywordSyntax)
            If node._elseKeyword IsNot newElseKeyword Then anyChanges = True

            If anyChanges Then
                Return New CaseElseClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newElseKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCaseValueClause(ByVal node As CaseValueClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newValue = DirectCast(Visit(node._value), ExpressionSyntax)
            If node._value IsNot newValue Then anyChanges = True

            If anyChanges Then
                Return New CaseValueClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newValue)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCaseRangeClause(ByVal node As CaseRangeClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLowerBound = DirectCast(Visit(node._lowerBound), ExpressionSyntax)
            If node._lowerBound IsNot newLowerBound Then anyChanges = True
            Dim newToKeyword = DirectCast(Visit(node.ToKeyword), KeywordSyntax)
            If node._toKeyword IsNot newToKeyword Then anyChanges = True
            Dim newUpperBound = DirectCast(Visit(node._upperBound), ExpressionSyntax)
            If node._upperBound IsNot newUpperBound Then anyChanges = True

            If anyChanges Then
                Return New CaseRangeClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLowerBound, newToKeyword, newUpperBound)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCaseRelationalClause(ByVal node As CaseRelationalClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIsKeyword = DirectCast(Visit(node.IsKeyword), KeywordSyntax)
            If node._isKeyword IsNot newIsKeyword Then anyChanges = True
            Dim newOperatorToken = DirectCast(Visit(node.OperatorToken), PunctuationSyntax)
            If node._operatorToken IsNot newOperatorToken Then anyChanges = True
            Dim newValue = DirectCast(Visit(node._value), ExpressionSyntax)
            If node._value IsNot newValue Then anyChanges = True

            If anyChanges Then
                Return New CaseRelationalClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIsKeyword, newOperatorToken, newValue)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSyncLockStatement(ByVal node As SyncLockStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSyncLockKeyword = DirectCast(Visit(node.SyncLockKeyword), KeywordSyntax)
            If node._syncLockKeyword IsNot newSyncLockKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New SyncLockStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSyncLockKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDoLoopBlock(ByVal node As DoLoopBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), DoStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), LoopStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New DoLoopBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newStatements.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDoStatement(ByVal node As DoStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newDoKeyword = DirectCast(Visit(node.DoKeyword), KeywordSyntax)
            If node._doKeyword IsNot newDoKeyword Then anyChanges = True
            Dim newWhileUntilClause = DirectCast(Visit(node._whileUntilClause), WhileUntilClauseSyntax)
            If node._whileUntilClause IsNot newWhileUntilClause Then anyChanges = True

            If anyChanges Then
                Return New DoStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newDoKeyword, newWhileUntilClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitLoopStatement(ByVal node As LoopStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLoopKeyword = DirectCast(Visit(node.LoopKeyword), KeywordSyntax)
            If node._loopKeyword IsNot newLoopKeyword Then anyChanges = True
            Dim newWhileUntilClause = DirectCast(Visit(node._whileUntilClause), WhileUntilClauseSyntax)
            If node._whileUntilClause IsNot newWhileUntilClause Then anyChanges = True

            If anyChanges Then
                Return New LoopStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLoopKeyword, newWhileUntilClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitWhileUntilClause(ByVal node As WhileUntilClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newWhileOrUntilKeyword = DirectCast(Visit(node.WhileOrUntilKeyword), KeywordSyntax)
            If node._whileOrUntilKeyword IsNot newWhileOrUntilKeyword Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True

            If anyChanges Then
                Return New WhileUntilClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newWhileOrUntilKeyword, newCondition)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitWhileStatement(ByVal node As WhileStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newWhileKeyword = DirectCast(Visit(node.WhileKeyword), KeywordSyntax)
            If node._whileKeyword IsNot newWhileKeyword Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True

            If anyChanges Then
                Return New WhileStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newWhileKeyword, newCondition)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitForBlock(ByVal node As ForBlockSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), ExecutableStatementSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), NextStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New ForBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newStatements.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitForStatement(ByVal node As ForStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newForKeyword = DirectCast(Visit(node.ForKeyword), KeywordSyntax)
            If node._forKeyword IsNot newForKeyword Then anyChanges = True
            Dim newControlVariable = DirectCast(Visit(node._controlVariable), SyntaxNode)
            If node._controlVariable IsNot newControlVariable Then anyChanges = True
            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True
            Dim newFromValue = DirectCast(Visit(node._fromValue), ExpressionSyntax)
            If node._fromValue IsNot newFromValue Then anyChanges = True
            Dim newToKeyword = DirectCast(Visit(node.ToKeyword), KeywordSyntax)
            If node._toKeyword IsNot newToKeyword Then anyChanges = True
            Dim newToValue = DirectCast(Visit(node._toValue), ExpressionSyntax)
            If node._toValue IsNot newToValue Then anyChanges = True
            Dim newStepClause = DirectCast(Visit(node._stepClause), ForStepClauseSyntax)
            If node._stepClause IsNot newStepClause Then anyChanges = True

            If anyChanges Then
                Return New ForStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newForKeyword, newControlVariable, newEqualsToken, newFromValue, newToKeyword, newToValue, newStepClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitForStepClause(ByVal node As ForStepClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newStepKeyword = DirectCast(Visit(node.StepKeyword), KeywordSyntax)
            If node._stepKeyword IsNot newStepKeyword Then anyChanges = True
            Dim newStepValue = DirectCast(Visit(node._stepValue), ExpressionSyntax)
            If node._stepValue IsNot newStepValue Then anyChanges = True

            If anyChanges Then
                Return New ForStepClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newStepKeyword, newStepValue)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitForEachStatement(ByVal node As ForEachStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newForKeyword = DirectCast(Visit(node.ForKeyword), KeywordSyntax)
            If node._forKeyword IsNot newForKeyword Then anyChanges = True
            Dim newEachKeyword = DirectCast(Visit(node.EachKeyword), KeywordSyntax)
            If node._eachKeyword IsNot newEachKeyword Then anyChanges = True
            Dim newControlVariable = DirectCast(Visit(node._controlVariable), SyntaxNode)
            If node._controlVariable IsNot newControlVariable Then anyChanges = True
            Dim newInKeyword = DirectCast(Visit(node.InKeyword), KeywordSyntax)
            If node._inKeyword IsNot newInKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New ForEachStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newForKeyword, newEachKeyword, newControlVariable, newInKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitNextStatement(ByVal node As NextStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNextKeyword = DirectCast(Visit(node.NextKeyword), KeywordSyntax)
            If node._nextKeyword IsNot newNextKeyword Then anyChanges = True
            Dim newControlVariables = VisitList(node.ControlVariables)
            If node._controlVariables IsNot newControlVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New NextStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNextKeyword, newControlVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitUsingStatement(ByVal node As UsingStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newUsingKeyword = DirectCast(Visit(node.UsingKeyword), KeywordSyntax)
            If node._usingKeyword IsNot newUsingKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newVariables = VisitList(node.Variables)
            If node._variables IsNot newVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New UsingStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newUsingKeyword, newExpression, newVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitThrowStatement(ByVal node As ThrowStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newThrowKeyword = DirectCast(Visit(node.ThrowKeyword), KeywordSyntax)
            If node._throwKeyword IsNot newThrowKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New ThrowStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newThrowKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAssignmentStatement(ByVal node As AssignmentStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLeft = DirectCast(Visit(node._left), ExpressionSyntax)
            If node._left IsNot newLeft Then anyChanges = True
            Dim newOperatorToken = DirectCast(Visit(node.OperatorToken), PunctuationSyntax)
            If node._operatorToken IsNot newOperatorToken Then anyChanges = True
            Dim newRight = DirectCast(Visit(node._right), ExpressionSyntax)
            If node._right IsNot newRight Then anyChanges = True

            If anyChanges Then
                Return New AssignmentStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLeft, newOperatorToken, newRight)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCallStatement(ByVal node As CallStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newCallKeyword = DirectCast(Visit(node.CallKeyword), KeywordSyntax)
            If node._callKeyword IsNot newCallKeyword Then anyChanges = True
            Dim newInvocation = DirectCast(Visit(node._invocation), ExpressionSyntax)
            If node._invocation IsNot newInvocation Then anyChanges = True

            If anyChanges Then
                Return New CallStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newCallKeyword, newInvocation)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAddRemoveHandlerStatement(ByVal node As AddRemoveHandlerStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAddHandlerOrRemoveHandlerKeyword = DirectCast(Visit(node.AddHandlerOrRemoveHandlerKeyword), KeywordSyntax)
            If node._addHandlerOrRemoveHandlerKeyword IsNot newAddHandlerOrRemoveHandlerKeyword Then anyChanges = True
            Dim newEventExpression = DirectCast(Visit(node._eventExpression), ExpressionSyntax)
            If node._eventExpression IsNot newEventExpression Then anyChanges = True
            Dim newCommaToken = DirectCast(Visit(node.CommaToken), PunctuationSyntax)
            If node._commaToken IsNot newCommaToken Then anyChanges = True
            Dim newDelegateExpression = DirectCast(Visit(node._delegateExpression), ExpressionSyntax)
            If node._delegateExpression IsNot newDelegateExpression Then anyChanges = True

            If anyChanges Then
                Return New AddRemoveHandlerStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAddHandlerOrRemoveHandlerKeyword, newEventExpression, newCommaToken, newDelegateExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitRaiseEventStatement(ByVal node As RaiseEventStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newRaiseEventKeyword = DirectCast(Visit(node.RaiseEventKeyword), KeywordSyntax)
            If node._raiseEventKeyword IsNot newRaiseEventKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node._identifier), IdentifierNameSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newArgumentList = DirectCast(Visit(node._argumentList), ArgumentListSyntax)
            If node._argumentList IsNot newArgumentList Then anyChanges = True

            If anyChanges Then
                Return New RaiseEventStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newRaiseEventKeyword, newIdentifier, newArgumentList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitWithStatement(ByVal node As WithStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newWithKeyword = DirectCast(Visit(node.WithKeyword), KeywordSyntax)
            If node._withKeyword IsNot newWithKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New WithStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newWithKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitReDimStatement(ByVal node As ReDimStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newReDimKeyword = DirectCast(Visit(node.ReDimKeyword), KeywordSyntax)
            If node._reDimKeyword IsNot newReDimKeyword Then anyChanges = True
            Dim newPreserveKeyword = DirectCast(Visit(node.PreserveKeyword), KeywordSyntax)
            If node._preserveKeyword IsNot newPreserveKeyword Then anyChanges = True
            Dim newClauses = VisitList(node.Clauses)
            If node._clauses IsNot newClauses.Node Then anyChanges = True

            If anyChanges Then
                Return New ReDimStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newReDimKeyword, newPreserveKeyword, newClauses.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEraseStatement(ByVal node As EraseStatementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newEraseKeyword = DirectCast(Visit(node.EraseKeyword), KeywordSyntax)
            If node._eraseKeyword IsNot newEraseKeyword Then anyChanges = True
            Dim newExpressions = VisitList(node.Expressions)
            If node._expressions IsNot newExpressions.Node Then anyChanges = True

            If anyChanges Then
                Return New EraseStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newEraseKeyword, newExpressions.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitLiteralExpression(ByVal node As LiteralExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newToken = DirectCast(Visit(node.Token), SyntaxToken)
            If node._token IsNot newToken Then anyChanges = True

            If anyChanges Then
                Return New LiteralExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitParenthesizedExpression(ByVal node As ParenthesizedExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New ParenthesizedExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenParenToken, newExpression, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMeExpression(ByVal node As MeExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True

            If anyChanges Then
                Return New MeExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMyBaseExpression(ByVal node As MyBaseExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True

            If anyChanges Then
                Return New MyBaseExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMyClassExpression(ByVal node As MyClassExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True

            If anyChanges Then
                Return New MyClassExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGetTypeExpression(ByVal node As GetTypeExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newGetTypeKeyword = DirectCast(Visit(node.GetTypeKeyword), KeywordSyntax)
            If node._getTypeKeyword IsNot newGetTypeKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New GetTypeExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newGetTypeKeyword, newOpenParenToken, newType, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTypeOfExpression(ByVal node As TypeOfExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newTypeOfKeyword = DirectCast(Visit(node.TypeOfKeyword), KeywordSyntax)
            If node._typeOfKeyword IsNot newTypeOfKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newOperatorToken = DirectCast(Visit(node.OperatorToken), KeywordSyntax)
            If node._operatorToken IsNot newOperatorToken Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True

            If anyChanges Then
                Return New TypeOfExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newTypeOfKeyword, newExpression, newOperatorToken, newType)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGetXmlNamespaceExpression(ByVal node As GetXmlNamespaceExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newGetXmlNamespaceKeyword = DirectCast(Visit(node.GetXmlNamespaceKeyword), KeywordSyntax)
            If node._getXmlNamespaceKeyword IsNot newGetXmlNamespaceKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node.Name), XmlNameTokenSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New GetXmlNamespaceExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newGetXmlNamespaceKeyword, newOpenParenToken, newName, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMemberAccessExpression(ByVal node As MemberAccessExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newOperatorToken = DirectCast(Visit(node.OperatorToken), PunctuationSyntax)
            If node._operatorToken IsNot newOperatorToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), SimpleNameSyntax)
            If node._name IsNot newName Then anyChanges = True

            If anyChanges Then
                Return New MemberAccessExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newExpression, newOperatorToken, newName)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlMemberAccessExpression(ByVal node As XmlMemberAccessExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBase = DirectCast(Visit(node._base), ExpressionSyntax)
            If node._base IsNot newBase Then anyChanges = True
            Dim newToken1 = DirectCast(Visit(node.Token1), PunctuationSyntax)
            If node._token1 IsNot newToken1 Then anyChanges = True
            Dim newToken2 = DirectCast(Visit(node.Token2), PunctuationSyntax)
            If node._token2 IsNot newToken2 Then anyChanges = True
            Dim newToken3 = DirectCast(Visit(node.Token3), PunctuationSyntax)
            If node._token3 IsNot newToken3 Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), XmlNodeSyntax)
            If node._name IsNot newName Then anyChanges = True

            If anyChanges Then
                Return New XmlMemberAccessExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBase, newToken1, newToken2, newToken3, newName)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitInvocationExpression(ByVal node As InvocationExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newArgumentList = DirectCast(Visit(node._argumentList), ArgumentListSyntax)
            If node._argumentList IsNot newArgumentList Then anyChanges = True

            If anyChanges Then
                Return New InvocationExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newExpression, newArgumentList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitObjectCreationExpression(ByVal node As ObjectCreationExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNewKeyword = DirectCast(Visit(node.NewKeyword), KeywordSyntax)
            If node._newKeyword IsNot newNewKeyword Then anyChanges = True
            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True
            Dim newArgumentList = DirectCast(Visit(node._argumentList), ArgumentListSyntax)
            If node._argumentList IsNot newArgumentList Then anyChanges = True
            Dim newInitializer = DirectCast(Visit(node._initializer), ObjectCreationInitializerSyntax)
            If node._initializer IsNot newInitializer Then anyChanges = True

            If anyChanges Then
                Return New ObjectCreationExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNewKeyword, newAttributes.Node, newType, newArgumentList, newInitializer)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAnonymousObjectCreationExpression(ByVal node As AnonymousObjectCreationExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNewKeyword = DirectCast(Visit(node.NewKeyword), KeywordSyntax)
            If node._newKeyword IsNot newNewKeyword Then anyChanges = True
            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newInitializer = DirectCast(Visit(node._initializer), ObjectMemberInitializerSyntax)
            If node._initializer IsNot newInitializer Then anyChanges = True

            If anyChanges Then
                Return New AnonymousObjectCreationExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNewKeyword, newAttributes.Node, newInitializer)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitArrayCreationExpression(ByVal node As ArrayCreationExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNewKeyword = DirectCast(Visit(node.NewKeyword), KeywordSyntax)
            If node._newKeyword IsNot newNewKeyword Then anyChanges = True
            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True
            Dim newArrayBounds = DirectCast(Visit(node._arrayBounds), ArgumentListSyntax)
            If node._arrayBounds IsNot newArrayBounds Then anyChanges = True
            Dim newRankSpecifiers = VisitList(node.RankSpecifiers)
            If node._rankSpecifiers IsNot newRankSpecifiers.Node Then anyChanges = True
            Dim newInitializer = DirectCast(Visit(node._initializer), CollectionInitializerSyntax)
            If node._initializer IsNot newInitializer Then anyChanges = True

            If anyChanges Then
                Return New ArrayCreationExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNewKeyword, newAttributes.Node, newType, newArrayBounds, newRankSpecifiers.Node, newInitializer)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCollectionInitializer(ByVal node As CollectionInitializerSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenBraceToken = DirectCast(Visit(node.OpenBraceToken), PunctuationSyntax)
            If node._openBraceToken IsNot newOpenBraceToken Then anyChanges = True
            Dim newInitializers = VisitList(node.Initializers)
            If node._initializers IsNot newInitializers.Node Then anyChanges = True
            Dim newCloseBraceToken = DirectCast(Visit(node.CloseBraceToken), PunctuationSyntax)
            If node._closeBraceToken IsNot newCloseBraceToken Then anyChanges = True

            If anyChanges Then
                Return New CollectionInitializerSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenBraceToken, newInitializers.Node, newCloseBraceToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCTypeExpression(ByVal node As CTypeExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newCommaToken = DirectCast(Visit(node.CommaToken), PunctuationSyntax)
            If node._commaToken IsNot newCommaToken Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New CTypeExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword, newOpenParenToken, newExpression, newCommaToken, newType, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDirectCastExpression(ByVal node As DirectCastExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newCommaToken = DirectCast(Visit(node.CommaToken), PunctuationSyntax)
            If node._commaToken IsNot newCommaToken Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New DirectCastExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword, newOpenParenToken, newExpression, newCommaToken, newType, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTryCastExpression(ByVal node As TryCastExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newCommaToken = DirectCast(Visit(node.CommaToken), PunctuationSyntax)
            If node._commaToken IsNot newCommaToken Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New TryCastExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword, newOpenParenToken, newExpression, newCommaToken, newType, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitPredefinedCastExpression(ByVal node As PredefinedCastExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New PredefinedCastExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword, newOpenParenToken, newExpression, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitBinaryExpression(ByVal node As BinaryExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLeft = DirectCast(Visit(node._left), ExpressionSyntax)
            If node._left IsNot newLeft Then anyChanges = True
            Dim newOperatorToken = DirectCast(Visit(node.OperatorToken), SyntaxToken)
            If node._operatorToken IsNot newOperatorToken Then anyChanges = True
            Dim newRight = DirectCast(Visit(node._right), ExpressionSyntax)
            If node._right IsNot newRight Then anyChanges = True

            If anyChanges Then
                Return New BinaryExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLeft, newOperatorToken, newRight)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitUnaryExpression(ByVal node As UnaryExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOperatorToken = DirectCast(Visit(node.OperatorToken), SyntaxToken)
            If node._operatorToken IsNot newOperatorToken Then anyChanges = True
            Dim newOperand = DirectCast(Visit(node._operand), ExpressionSyntax)
            If node._operand IsNot newOperand Then anyChanges = True

            If anyChanges Then
                Return New UnaryExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOperatorToken, newOperand)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitBinaryConditionalExpression(ByVal node As BinaryConditionalExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIfKeyword = DirectCast(Visit(node.IfKeyword), KeywordSyntax)
            If node._ifKeyword IsNot newIfKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newFirstExpression = DirectCast(Visit(node._firstExpression), ExpressionSyntax)
            If node._firstExpression IsNot newFirstExpression Then anyChanges = True
            Dim newCommaToken = DirectCast(Visit(node.CommaToken), PunctuationSyntax)
            If node._commaToken IsNot newCommaToken Then anyChanges = True
            Dim newSecondExpression = DirectCast(Visit(node._secondExpression), ExpressionSyntax)
            If node._secondExpression IsNot newSecondExpression Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New BinaryConditionalExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIfKeyword, newOpenParenToken, newFirstExpression, newCommaToken, newSecondExpression, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTernaryConditionalExpression(ByVal node As TernaryConditionalExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIfKeyword = DirectCast(Visit(node.IfKeyword), KeywordSyntax)
            If node._ifKeyword IsNot newIfKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True
            Dim newFirstCommaToken = DirectCast(Visit(node.FirstCommaToken), PunctuationSyntax)
            If node._firstCommaToken IsNot newFirstCommaToken Then anyChanges = True
            Dim newWhenTrue = DirectCast(Visit(node._whenTrue), ExpressionSyntax)
            If node._whenTrue IsNot newWhenTrue Then anyChanges = True
            Dim newSecondCommaToken = DirectCast(Visit(node.SecondCommaToken), PunctuationSyntax)
            If node._secondCommaToken IsNot newSecondCommaToken Then anyChanges = True
            Dim newWhenFalse = DirectCast(Visit(node._whenFalse), ExpressionSyntax)
            If node._whenFalse IsNot newWhenFalse Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New TernaryConditionalExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIfKeyword, newOpenParenToken, newCondition, newFirstCommaToken, newWhenTrue, newSecondCommaToken, newWhenFalse, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSingleLineLambdaExpression(ByVal node As SingleLineLambdaExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), LambdaHeaderSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newBody = DirectCast(Visit(node._body), SyntaxNode)
            If node._body IsNot newBody Then anyChanges = True

            If anyChanges Then
                Return New SingleLineLambdaExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newBody)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMultiLineLambdaExpression(ByVal node As MultiLineLambdaExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBegin = DirectCast(Visit(node._begin), LambdaHeaderSyntax)
            If node._begin IsNot newBegin Then anyChanges = True
            Dim newBeginTerminator = DirectCast(Visit(node.BeginTerminator), PunctuationSyntax)
            If node._beginTerminator IsNot newBeginTerminator Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEnd = DirectCast(Visit(node._end), EndBlockStatementSyntax)
            If node._end IsNot newEnd Then anyChanges = True

            If anyChanges Then
                Return New MultiLineLambdaExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBegin, newBeginTerminator, newStatements.Node, newEnd)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitLambdaHeader(ByVal node As LambdaHeaderSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), AsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True

            If anyChanges Then
                Return New LambdaHeaderSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributes.Node, newModifiers.Node, newKeyword, newParameterList, newAsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitArgumentList(ByVal node As ArgumentListSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newArguments = VisitList(node.Arguments)
            If node._arguments IsNot newArguments.Node Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New ArgumentListSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenParenToken, newArguments.Node, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitOmittedArgument(ByVal node As OmittedArgumentSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newEmpty = DirectCast(Visit(node.Empty), PunctuationSyntax)
            If node._empty IsNot newEmpty Then anyChanges = True

            If anyChanges Then
                Return New OmittedArgumentSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newEmpty)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSimpleArgument(ByVal node As SimpleArgumentSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New SimpleArgumentSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitNamedArgument(ByVal node As NamedArgumentSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIdentifierName = DirectCast(Visit(node._identifierName), IdentifierNameSyntax)
            If node._identifierName IsNot newIdentifierName Then anyChanges = True
            Dim newColonEqualsToken = DirectCast(Visit(node.ColonEqualsToken), PunctuationSyntax)
            If node._colonEqualsToken IsNot newColonEqualsToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New NamedArgumentSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIdentifierName, newColonEqualsToken, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitRangeArgument(ByVal node As RangeArgumentSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLowerBound = DirectCast(Visit(node._lowerBound), ExpressionSyntax)
            If node._lowerBound IsNot newLowerBound Then anyChanges = True
            Dim newToKeyword = DirectCast(Visit(node.ToKeyword), KeywordSyntax)
            If node._toKeyword IsNot newToKeyword Then anyChanges = True
            Dim newUpperBound = DirectCast(Visit(node._upperBound), ExpressionSyntax)
            If node._upperBound IsNot newUpperBound Then anyChanges = True

            If anyChanges Then
                Return New RangeArgumentSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLowerBound, newToKeyword, newUpperBound)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitQueryExpression(ByVal node As QueryExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newClauses = VisitList(node.Clauses)
            If node._clauses IsNot newClauses.Node Then anyChanges = True

            If anyChanges Then
                Return New QueryExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newClauses.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCollectionRangeVariable(ByVal node As CollectionRangeVariableSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIdentifier = DirectCast(Visit(node._identifier), ModifiedIdentifierSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newInKeyword = DirectCast(Visit(node.InKeyword), KeywordSyntax)
            If node._inKeyword IsNot newInKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New CollectionRangeVariableSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIdentifier, newAsClause, newInKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitExpressionRangeVariable(ByVal node As ExpressionRangeVariableSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNameEquals = DirectCast(Visit(node._nameEquals), VariableNameEqualsSyntax)
            If node._nameEquals IsNot newNameEquals Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New ExpressionRangeVariableSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNameEquals, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAggregationRangeVariable(ByVal node As AggregationRangeVariableSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNameEquals = DirectCast(Visit(node._nameEquals), VariableNameEqualsSyntax)
            If node._nameEquals IsNot newNameEquals Then anyChanges = True
            Dim newAggregation = DirectCast(Visit(node._aggregation), AggregationSyntax)
            If node._aggregation IsNot newAggregation Then anyChanges = True

            If anyChanges Then
                Return New AggregationRangeVariableSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNameEquals, newAggregation)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitVariableNameEquals(ByVal node As VariableNameEqualsSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIdentifier = DirectCast(Visit(node._identifier), ModifiedIdentifierSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True

            If anyChanges Then
                Return New VariableNameEqualsSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIdentifier, newAsClause, newEqualsToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitFunctionAggregation(ByVal node As FunctionAggregationSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newFunctionName = DirectCast(Visit(node.FunctionName), IdentifierTokenSyntax)
            If node._functionName IsNot newFunctionName Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newArgument = DirectCast(Visit(node._argument), ExpressionSyntax)
            If node._argument IsNot newArgument Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New FunctionAggregationSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newFunctionName, newOpenParenToken, newArgument, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGroupAggregation(ByVal node As GroupAggregationSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newGroupKeyword = DirectCast(Visit(node.GroupKeyword), KeywordSyntax)
            If node._groupKeyword IsNot newGroupKeyword Then anyChanges = True

            If anyChanges Then
                Return New GroupAggregationSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newGroupKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitFromClause(ByVal node As FromClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newFromKeyword = DirectCast(Visit(node.FromKeyword), KeywordSyntax)
            If node._fromKeyword IsNot newFromKeyword Then anyChanges = True
            Dim newVariables = VisitList(node.Variables)
            If node._variables IsNot newVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New FromClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newFromKeyword, newVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitLetClause(ByVal node As LetClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLetKeyword = DirectCast(Visit(node.LetKeyword), KeywordSyntax)
            If node._letKeyword IsNot newLetKeyword Then anyChanges = True
            Dim newVariables = VisitList(node.Variables)
            If node._variables IsNot newVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New LetClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLetKeyword, newVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAggregateClause(ByVal node As AggregateClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAggregateKeyword = DirectCast(Visit(node.AggregateKeyword), KeywordSyntax)
            If node._aggregateKeyword IsNot newAggregateKeyword Then anyChanges = True
            Dim newVariables = VisitList(node.Variables)
            If node._variables IsNot newVariables.Node Then anyChanges = True
            Dim newAdditionalQueryOperators = VisitList(node.AdditionalQueryOperators)
            If node._additionalQueryOperators IsNot newAdditionalQueryOperators.Node Then anyChanges = True
            Dim newIntoKeyword = DirectCast(Visit(node.IntoKeyword), KeywordSyntax)
            If node._intoKeyword IsNot newIntoKeyword Then anyChanges = True
            Dim newAggregationVariables = VisitList(node.AggregationVariables)
            If node._aggregationVariables IsNot newAggregationVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New AggregateClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAggregateKeyword, newVariables.Node, newAdditionalQueryOperators.Node, newIntoKeyword, newAggregationVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDistinctClause(ByVal node As DistinctClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newDistinctKeyword = DirectCast(Visit(node.DistinctKeyword), KeywordSyntax)
            If node._distinctKeyword IsNot newDistinctKeyword Then anyChanges = True

            If anyChanges Then
                Return New DistinctClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newDistinctKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitWhereClause(ByVal node As WhereClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newWhereKeyword = DirectCast(Visit(node.WhereKeyword), KeywordSyntax)
            If node._whereKeyword IsNot newWhereKeyword Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True

            If anyChanges Then
                Return New WhereClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newWhereKeyword, newCondition)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitPartitionWhileClause(ByVal node As PartitionWhileClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSkipOrTakeKeyword = DirectCast(Visit(node.SkipOrTakeKeyword), KeywordSyntax)
            If node._skipOrTakeKeyword IsNot newSkipOrTakeKeyword Then anyChanges = True
            Dim newWhileKeyword = DirectCast(Visit(node.WhileKeyword), KeywordSyntax)
            If node._whileKeyword IsNot newWhileKeyword Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True

            If anyChanges Then
                Return New PartitionWhileClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSkipOrTakeKeyword, newWhileKeyword, newCondition)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitPartitionClause(ByVal node As PartitionClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSkipOrTakeKeyword = DirectCast(Visit(node.SkipOrTakeKeyword), KeywordSyntax)
            If node._skipOrTakeKeyword IsNot newSkipOrTakeKeyword Then anyChanges = True
            Dim newCount = DirectCast(Visit(node._count), ExpressionSyntax)
            If node._count IsNot newCount Then anyChanges = True

            If anyChanges Then
                Return New PartitionClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSkipOrTakeKeyword, newCount)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGroupByClause(ByVal node As GroupByClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newGroupKeyword = DirectCast(Visit(node.GroupKeyword), KeywordSyntax)
            If node._groupKeyword IsNot newGroupKeyword Then anyChanges = True
            Dim newItems = VisitList(node.Items)
            If node._items IsNot newItems.Node Then anyChanges = True
            Dim newByKeyword = DirectCast(Visit(node.ByKeyword), KeywordSyntax)
            If node._byKeyword IsNot newByKeyword Then anyChanges = True
            Dim newKeys = VisitList(node.Keys)
            If node._keys IsNot newKeys.Node Then anyChanges = True
            Dim newIntoKeyword = DirectCast(Visit(node.IntoKeyword), KeywordSyntax)
            If node._intoKeyword IsNot newIntoKeyword Then anyChanges = True
            Dim newAggregationVariables = VisitList(node.AggregationVariables)
            If node._aggregationVariables IsNot newAggregationVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New GroupByClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newGroupKeyword, newItems.Node, newByKeyword, newKeys.Node, newIntoKeyword, newAggregationVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitJoinClause(ByVal node As JoinClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newJoinKeyword = DirectCast(Visit(node.JoinKeyword), KeywordSyntax)
            If node._joinKeyword IsNot newJoinKeyword Then anyChanges = True
            Dim newJoinedVariables = VisitList(node.JoinedVariables)
            If node._joinedVariables IsNot newJoinedVariables.Node Then anyChanges = True
            Dim newAdditionalJoins = VisitList(node.AdditionalJoins)
            If node._additionalJoins IsNot newAdditionalJoins.Node Then anyChanges = True
            Dim newOnKeyword = DirectCast(Visit(node.OnKeyword), KeywordSyntax)
            If node._onKeyword IsNot newOnKeyword Then anyChanges = True
            Dim newJoinConditions = VisitList(node.JoinConditions)
            If node._joinConditions IsNot newJoinConditions.Node Then anyChanges = True

            If anyChanges Then
                Return New JoinClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newJoinKeyword, newJoinedVariables.Node, newAdditionalJoins.Node, newOnKeyword, newJoinConditions.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitJoinCondition(ByVal node As JoinConditionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLeft = DirectCast(Visit(node._left), ExpressionSyntax)
            If node._left IsNot newLeft Then anyChanges = True
            Dim newEqualsKeyword = DirectCast(Visit(node.EqualsKeyword), KeywordSyntax)
            If node._equalsKeyword IsNot newEqualsKeyword Then anyChanges = True
            Dim newRight = DirectCast(Visit(node._right), ExpressionSyntax)
            If node._right IsNot newRight Then anyChanges = True

            If anyChanges Then
                Return New JoinConditionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLeft, newEqualsKeyword, newRight)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGroupJoinClause(ByVal node As GroupJoinClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newGroupKeyword = DirectCast(Visit(node.GroupKeyword), KeywordSyntax)
            If node._groupKeyword IsNot newGroupKeyword Then anyChanges = True
            Dim newJoinKeyword = DirectCast(Visit(node.JoinKeyword), KeywordSyntax)
            If node._joinKeyword IsNot newJoinKeyword Then anyChanges = True
            Dim newJoinedVariables = VisitList(node.JoinedVariables)
            If node._joinedVariables IsNot newJoinedVariables.Node Then anyChanges = True
            Dim newAdditionalJoins = VisitList(node.AdditionalJoins)
            If node._additionalJoins IsNot newAdditionalJoins.Node Then anyChanges = True
            Dim newOnKeyword = DirectCast(Visit(node.OnKeyword), KeywordSyntax)
            If node._onKeyword IsNot newOnKeyword Then anyChanges = True
            Dim newJoinConditions = VisitList(node.JoinConditions)
            If node._joinConditions IsNot newJoinConditions.Node Then anyChanges = True
            Dim newIntoKeyword = DirectCast(Visit(node.IntoKeyword), KeywordSyntax)
            If node._intoKeyword IsNot newIntoKeyword Then anyChanges = True
            Dim newAggregationVariables = VisitList(node.AggregationVariables)
            If node._aggregationVariables IsNot newAggregationVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New GroupJoinClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newGroupKeyword, newJoinKeyword, newJoinedVariables.Node, newAdditionalJoins.Node, newOnKeyword, newJoinConditions.Node, newIntoKeyword, newAggregationVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitOrderByClause(ByVal node As OrderByClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOrderKeyword = DirectCast(Visit(node.OrderKeyword), KeywordSyntax)
            If node._orderKeyword IsNot newOrderKeyword Then anyChanges = True
            Dim newByKeyword = DirectCast(Visit(node.ByKeyword), KeywordSyntax)
            If node._byKeyword IsNot newByKeyword Then anyChanges = True
            Dim newOrderings = VisitList(node.Orderings)
            If node._orderings IsNot newOrderings.Node Then anyChanges = True

            If anyChanges Then
                Return New OrderByClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOrderKeyword, newByKeyword, newOrderings.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitOrdering(ByVal node As OrderingSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newAscendingOrDescendingKeyword = DirectCast(Visit(node.AscendingOrDescendingKeyword), KeywordSyntax)
            If node._ascendingOrDescendingKeyword IsNot newAscendingOrDescendingKeyword Then anyChanges = True

            If anyChanges Then
                Return New OrderingSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newExpression, newAscendingOrDescendingKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSelectClause(ByVal node As SelectClauseSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSelectKeyword = DirectCast(Visit(node.SelectKeyword), KeywordSyntax)
            If node._selectKeyword IsNot newSelectKeyword Then anyChanges = True
            Dim newVariables = VisitList(node.Variables)
            If node._variables IsNot newVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New SelectClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSelectKeyword, newVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlDocument(ByVal node As XmlDocumentSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newDeclaration = DirectCast(Visit(node._declaration), XmlDeclarationSyntax)
            If node._declaration IsNot newDeclaration Then anyChanges = True
            Dim newPrecedingMisc = VisitList(node.PrecedingMisc)
            If node._precedingMisc IsNot newPrecedingMisc.Node Then anyChanges = True
            Dim newRoot = DirectCast(Visit(node._root), XmlNodeSyntax)
            If node._root IsNot newRoot Then anyChanges = True
            Dim newFollowingMisc = VisitList(node.FollowingMisc)
            If node._followingMisc IsNot newFollowingMisc.Node Then anyChanges = True

            If anyChanges Then
                Return New XmlDocumentSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newDeclaration, newPrecedingMisc.Node, newRoot, newFollowingMisc.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlDeclaration(ByVal node As XmlDeclarationSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanQuestionToken = DirectCast(Visit(node.LessThanQuestionToken), PunctuationSyntax)
            If node._lessThanQuestionToken IsNot newLessThanQuestionToken Then anyChanges = True
            Dim newXmlKeyword = DirectCast(Visit(node.XmlKeyword), KeywordSyntax)
            If node._xmlKeyword IsNot newXmlKeyword Then anyChanges = True
            Dim newVersion = DirectCast(Visit(node._version), XmlDeclarationOptionSyntax)
            If node._version IsNot newVersion Then anyChanges = True
            Dim newEncoding = DirectCast(Visit(node._encoding), XmlDeclarationOptionSyntax)
            If node._encoding IsNot newEncoding Then anyChanges = True
            Dim newStandalone = DirectCast(Visit(node._standalone), XmlDeclarationOptionSyntax)
            If node._standalone IsNot newStandalone Then anyChanges = True
            Dim newQuestionGreaterThanToken = DirectCast(Visit(node.QuestionGreaterThanToken), PunctuationSyntax)
            If node._questionGreaterThanToken IsNot newQuestionGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlDeclarationSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanQuestionToken, newXmlKeyword, newVersion, newEncoding, newStandalone, newQuestionGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlDeclarationOption(ByVal node As XmlDeclarationOptionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newName = DirectCast(Visit(node.Name), XmlNameTokenSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newEquals = DirectCast(Visit(node.Equals), PunctuationSyntax)
            If node._equals IsNot newEquals Then anyChanges = True
            Dim newValue = DirectCast(Visit(node._value), XmlStringSyntax)
            If node._value IsNot newValue Then anyChanges = True

            If anyChanges Then
                Return New XmlDeclarationOptionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newName, newEquals, newValue)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlElement(ByVal node As XmlElementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newStartTag = DirectCast(Visit(node._startTag), XmlElementStartTagSyntax)
            If node._startTag IsNot newStartTag Then anyChanges = True
            Dim newContent = VisitList(node.Content)
            If node._content IsNot newContent.Node Then anyChanges = True
            Dim newEndTag = DirectCast(Visit(node._endTag), XmlElementEndTagSyntax)
            If node._endTag IsNot newEndTag Then anyChanges = True

            If anyChanges Then
                Return New XmlElementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newStartTag, newContent.Node, newEndTag)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlText(ByVal node As XmlTextSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newTextTokens = VisitList(node.TextTokens)
            If node._textTokens IsNot newTextTokens.Node Then anyChanges = True

            If anyChanges Then
                Return New XmlTextSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newTextTokens.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlElementStartTag(ByVal node As XmlElementStartTagSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanToken = DirectCast(Visit(node.LessThanToken), PunctuationSyntax)
            If node._lessThanToken IsNot newLessThanToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), XmlNodeSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newGreaterThanToken = DirectCast(Visit(node.GreaterThanToken), PunctuationSyntax)
            If node._greaterThanToken IsNot newGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlElementStartTagSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanToken, newName, newAttributes.Node, newGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlElementEndTag(ByVal node As XmlElementEndTagSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanSlashToken = DirectCast(Visit(node.LessThanSlashToken), PunctuationSyntax)
            If node._lessThanSlashToken IsNot newLessThanSlashToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), XmlNameSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newGreaterThanToken = DirectCast(Visit(node.GreaterThanToken), PunctuationSyntax)
            If node._greaterThanToken IsNot newGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlElementEndTagSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanSlashToken, newName, newGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlEmptyElement(ByVal node As XmlEmptyElementSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanToken = DirectCast(Visit(node.LessThanToken), PunctuationSyntax)
            If node._lessThanToken IsNot newLessThanToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), XmlNodeSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newSlashGreaterThanToken = DirectCast(Visit(node.SlashGreaterThanToken), PunctuationSyntax)
            If node._slashGreaterThanToken IsNot newSlashGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlEmptyElementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanToken, newName, newAttributes.Node, newSlashGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlAttribute(ByVal node As XmlAttributeSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newName = DirectCast(Visit(node._name), XmlNodeSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True
            Dim newValue = DirectCast(Visit(node._value), XmlNodeSyntax)
            If node._value IsNot newValue Then anyChanges = True

            If anyChanges Then
                Return New XmlAttributeSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newName, newEqualsToken, newValue)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlString(ByVal node As XmlStringSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newStartQuoteToken = DirectCast(Visit(node.StartQuoteToken), PunctuationSyntax)
            If node._startQuoteToken IsNot newStartQuoteToken Then anyChanges = True
            Dim newTextTokens = VisitList(node.TextTokens)
            If node._textTokens IsNot newTextTokens.Node Then anyChanges = True
            Dim newEndQuoteToken = DirectCast(Visit(node.EndQuoteToken), PunctuationSyntax)
            If node._endQuoteToken IsNot newEndQuoteToken Then anyChanges = True

            If anyChanges Then
                Return New XmlStringSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newStartQuoteToken, newTextTokens.Node, newEndQuoteToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlName(ByVal node As XmlNameSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newPrefix = DirectCast(Visit(node._prefix), XmlPrefixSyntax)
            If node._prefix IsNot newPrefix Then anyChanges = True
            Dim newLocalName = DirectCast(Visit(node.LocalName), XmlNameTokenSyntax)
            If node._localName IsNot newLocalName Then anyChanges = True

            If anyChanges Then
                Return New XmlNameSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newPrefix, newLocalName)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlBracketedName(ByVal node As XmlBracketedNameSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanToken = DirectCast(Visit(node.LessThanToken), PunctuationSyntax)
            If node._lessThanToken IsNot newLessThanToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), XmlNameSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newGreaterThanToken = DirectCast(Visit(node.GreaterThanToken), PunctuationSyntax)
            If node._greaterThanToken IsNot newGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlBracketedNameSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanToken, newName, newGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlPrefix(ByVal node As XmlPrefixSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newName = DirectCast(Visit(node.Name), XmlNameTokenSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newColonToken = DirectCast(Visit(node.ColonToken), PunctuationSyntax)
            If node._colonToken IsNot newColonToken Then anyChanges = True

            If anyChanges Then
                Return New XmlPrefixSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newName, newColonToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlComment(ByVal node As XmlCommentSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanMinusMinusToken = DirectCast(Visit(node.LessThanMinusMinusToken), PunctuationSyntax)
            If node._lessThanMinusMinusToken IsNot newLessThanMinusMinusToken Then anyChanges = True
            Dim newTextTokens = VisitList(node.TextTokens)
            If node._textTokens IsNot newTextTokens.Node Then anyChanges = True
            Dim newMinusMinusGreaterThanToken = DirectCast(Visit(node.MinusMinusGreaterThanToken), PunctuationSyntax)
            If node._minusMinusGreaterThanToken IsNot newMinusMinusGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlCommentSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanMinusMinusToken, newTextTokens.Node, newMinusMinusGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlProcessingInstruction(ByVal node As XmlProcessingInstructionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanQuestionToken = DirectCast(Visit(node.LessThanQuestionToken), PunctuationSyntax)
            If node._lessThanQuestionToken IsNot newLessThanQuestionToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node.Name), XmlNameTokenSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newTextTokens = VisitList(node.TextTokens)
            If node._textTokens IsNot newTextTokens.Node Then anyChanges = True
            Dim newQuestionGreaterThanToken = DirectCast(Visit(node.QuestionGreaterThanToken), PunctuationSyntax)
            If node._questionGreaterThanToken IsNot newQuestionGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlProcessingInstructionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanQuestionToken, newName, newTextTokens.Node, newQuestionGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlCDataSection(ByVal node As XmlCDataSectionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBeginCDataToken = DirectCast(Visit(node.BeginCDataToken), PunctuationSyntax)
            If node._beginCDataToken IsNot newBeginCDataToken Then anyChanges = True
            Dim newTextTokens = VisitList(node.TextTokens)
            If node._textTokens IsNot newTextTokens.Node Then anyChanges = True
            Dim newEndCDataToken = DirectCast(Visit(node.EndCDataToken), PunctuationSyntax)
            If node._endCDataToken IsNot newEndCDataToken Then anyChanges = True

            If anyChanges Then
                Return New XmlCDataSectionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBeginCDataToken, newTextTokens.Node, newEndCDataToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlEmbeddedExpression(ByVal node As XmlEmbeddedExpressionSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanPercentEqualsToken = DirectCast(Visit(node.LessThanPercentEqualsToken), PunctuationSyntax)
            If node._lessThanPercentEqualsToken IsNot newLessThanPercentEqualsToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newPercentGreaterThanToken = DirectCast(Visit(node.PercentGreaterThanToken), PunctuationSyntax)
            If node._percentGreaterThanToken IsNot newPercentGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlEmbeddedExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanPercentEqualsToken, newExpression, newPercentGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitArrayType(ByVal node As ArrayTypeSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newElementType = DirectCast(Visit(node._elementType), TypeSyntax)
            If node._elementType IsNot newElementType Then anyChanges = True
            Dim newRankSpecifiers = VisitList(node.RankSpecifiers)
            If node._rankSpecifiers IsNot newRankSpecifiers.Node Then anyChanges = True

            If anyChanges Then
                Return New ArrayTypeSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newElementType, newRankSpecifiers.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitNullableType(ByVal node As NullableTypeSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newElementType = DirectCast(Visit(node._elementType), TypeSyntax)
            If node._elementType IsNot newElementType Then anyChanges = True
            Dim newQuestionMarkToken = DirectCast(Visit(node.QuestionMarkToken), PunctuationSyntax)
            If node._questionMarkToken IsNot newQuestionMarkToken Then anyChanges = True

            If anyChanges Then
                Return New NullableTypeSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newElementType, newQuestionMarkToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitPredefinedType(ByVal node As PredefinedTypeSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True

            If anyChanges Then
                Return New PredefinedTypeSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitIdentifierName(ByVal node As IdentifierNameSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True

            If anyChanges Then
                Return New IdentifierNameSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIdentifier)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGenericName(ByVal node As GenericNameSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeArgumentList = DirectCast(Visit(node._typeArgumentList), TypeArgumentListSyntax)
            If node._typeArgumentList IsNot newTypeArgumentList Then anyChanges = True

            If anyChanges Then
                Return New GenericNameSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIdentifier, newTypeArgumentList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitQualifiedName(ByVal node As QualifiedNameSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLeft = DirectCast(Visit(node._left), NameSyntax)
            If node._left IsNot newLeft Then anyChanges = True
            Dim newDotToken = DirectCast(Visit(node.DotToken), PunctuationSyntax)
            If node._dotToken IsNot newDotToken Then anyChanges = True
            Dim newRight = DirectCast(Visit(node._right), SimpleNameSyntax)
            If node._right IsNot newRight Then anyChanges = True

            If anyChanges Then
                Return New QualifiedNameSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLeft, newDotToken, newRight)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGlobalName(ByVal node As GlobalNameSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newGlobalKeyword = DirectCast(Visit(node.GlobalKeyword), KeywordSyntax)
            If node._globalKeyword IsNot newGlobalKeyword Then anyChanges = True

            If anyChanges Then
                Return New GlobalNameSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newGlobalKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTypeArgumentList(ByVal node As TypeArgumentListSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newOfKeyword = DirectCast(Visit(node.OfKeyword), KeywordSyntax)
            If node._ofKeyword IsNot newOfKeyword Then anyChanges = True
            Dim newArguments = VisitList(node.Arguments)
            If node._arguments IsNot newArguments.Node Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New TypeArgumentListSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenParenToken, newOfKeyword, newArguments.Node, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSkippedTokens(ByVal node As SkippedTokensSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newTokens = VisitList(node.Tokens)
            If node._tokens IsNot newTokens.Node Then anyChanges = True

            If anyChanges Then
                Return New SkippedTokensSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newTokens.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDocumentationComment(ByVal node As DocumentationCommentSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newContent = VisitList(node.Content)
            If node._content IsNot newContent.Node Then anyChanges = True

            If anyChanges Then
                Return New DocumentationCommentSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newContent.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDirective(ByVal node As DirectiveSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newDirective = DirectCast(Visit(node._directive), DirectiveStatementSyntax)
            If node._directive IsNot newDirective Then anyChanges = True
            Dim newTerminator = DirectCast(Visit(node.Terminator), PunctuationSyntax)
            If node._terminator IsNot newTerminator Then anyChanges = True

            If anyChanges Then
                Return New DirectiveSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newDirective, newTerminator)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitConstDirective(ByVal node As ConstDirectiveSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newConstKeyword = DirectCast(Visit(node.ConstKeyword), KeywordSyntax)
            If node._constKeyword IsNot newConstKeyword Then anyChanges = True
            Dim newName = DirectCast(Visit(node.Name), IdentifierTokenSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True
            Dim newValue = DirectCast(Visit(node._value), ExpressionSyntax)
            If node._value IsNot newValue Then anyChanges = True

            If anyChanges Then
                Return New ConstDirectiveSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newConstKeyword, newName, newEqualsToken, newValue)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitIfDirective(ByVal node As IfDirectiveSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newElseKeyword = DirectCast(Visit(node.ElseKeyword), KeywordSyntax)
            If node._elseKeyword IsNot newElseKeyword Then anyChanges = True
            Dim newIfOrElseIfKeyword = DirectCast(Visit(node.IfOrElseIfKeyword), KeywordSyntax)
            If node._ifOrElseIfKeyword IsNot newIfOrElseIfKeyword Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True
            Dim newThenKeyword = DirectCast(Visit(node.ThenKeyword), KeywordSyntax)
            If node._thenKeyword IsNot newThenKeyword Then anyChanges = True

            If anyChanges Then
                Return New IfDirectiveSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newElseKeyword, newIfOrElseIfKeyword, newCondition, newThenKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitElseDirective(ByVal node As ElseDirectiveSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newElseKeyword = DirectCast(Visit(node.ElseKeyword), KeywordSyntax)
            If node._elseKeyword IsNot newElseKeyword Then anyChanges = True

            If anyChanges Then
                Return New ElseDirectiveSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newElseKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEndIfDirective(ByVal node As EndIfDirectiveSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newEndKeyword = DirectCast(Visit(node.EndKeyword), KeywordSyntax)
            If node._endKeyword IsNot newEndKeyword Then anyChanges = True
            Dim newIfKeyword = DirectCast(Visit(node.IfKeyword), KeywordSyntax)
            If node._ifKeyword IsNot newIfKeyword Then anyChanges = True

            If anyChanges Then
                Return New EndIfDirectiveSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newEndKeyword, newIfKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitRegionDirective(ByVal node As RegionDirectiveSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newRegionKeyword = DirectCast(Visit(node.RegionKeyword), KeywordSyntax)
            If node._regionKeyword IsNot newRegionKeyword Then anyChanges = True
            Dim newName = DirectCast(Visit(node.Name), StringLiteralTokenSyntax)
            If node._name IsNot newName Then anyChanges = True

            If anyChanges Then
                Return New RegionDirectiveSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newRegionKeyword, newName)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEndRegionDirective(ByVal node As EndRegionDirectiveSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newEndKeyword = DirectCast(Visit(node.EndKeyword), KeywordSyntax)
            If node._endKeyword IsNot newEndKeyword Then anyChanges = True
            Dim newRegionKeyword = DirectCast(Visit(node.RegionKeyword), KeywordSyntax)
            If node._regionKeyword IsNot newRegionKeyword Then anyChanges = True

            If anyChanges Then
                Return New EndRegionDirectiveSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newEndKeyword, newRegionKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitExternalSourceDirective(ByVal node As ExternalSourceDirectiveSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newExternalSourceKeyword = DirectCast(Visit(node.ExternalSourceKeyword), KeywordSyntax)
            If node._externalSourceKeyword IsNot newExternalSourceKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newExternalSource = DirectCast(Visit(node.ExternalSource), StringLiteralTokenSyntax)
            If node._externalSource IsNot newExternalSource Then anyChanges = True
            Dim newCommaToken = DirectCast(Visit(node.CommaToken), PunctuationSyntax)
            If node._commaToken IsNot newCommaToken Then anyChanges = True
            Dim newLineStart = DirectCast(Visit(node.LineStart), IntegerLiteralTokenSyntax)
            If node._lineStart IsNot newLineStart Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New ExternalSourceDirectiveSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newExternalSourceKeyword, newOpenParenToken, newExternalSource, newCommaToken, newLineStart, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEndExternalSourceDirective(ByVal node As EndExternalSourceDirective) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newEndKeyword = DirectCast(Visit(node.EndKeyword), KeywordSyntax)
            If node._endKeyword IsNot newEndKeyword Then anyChanges = True
            Dim newExternalSourceKeyword = DirectCast(Visit(node.ExternalSourceKeyword), KeywordSyntax)
            If node._externalSourceKeyword IsNot newExternalSourceKeyword Then anyChanges = True

            If anyChanges Then
                Return New EndExternalSourceDirective(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newEndKeyword, newExternalSourceKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitExternalChecksumDirective(ByVal node As ExternalChecksumDirectiveSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newExternalChecksumKeyword = DirectCast(Visit(node.ExternalChecksumKeyword), KeywordSyntax)
            If node._externalChecksumKeyword IsNot newExternalChecksumKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newExternalSource = DirectCast(Visit(node.ExternalSource), StringLiteralTokenSyntax)
            If node._externalSource IsNot newExternalSource Then anyChanges = True
            Dim newFirstCommaToken = DirectCast(Visit(node.FirstCommaToken), PunctuationSyntax)
            If node._firstCommaToken IsNot newFirstCommaToken Then anyChanges = True
            Dim newGuid = DirectCast(Visit(node.Guid), StringLiteralTokenSyntax)
            If node._guid IsNot newGuid Then anyChanges = True
            Dim newSecondCommaToken = DirectCast(Visit(node.SecondCommaToken), PunctuationSyntax)
            If node._secondCommaToken IsNot newSecondCommaToken Then anyChanges = True
            Dim newChecksum = DirectCast(Visit(node.Checksum), StringLiteralTokenSyntax)
            If node._checksum IsNot newChecksum Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New ExternalChecksumDirectiveSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newExternalChecksumKeyword, newOpenParenToken, newExternalSource, newFirstCommaToken, newGuid, newSecondCommaToken, newChecksum, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitReferenceDirective(ByVal node As ReferenceDirectiveSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newReferenceKeyword = DirectCast(Visit(node.ReferenceKeyword), KeywordSyntax)
            If node._referenceKeyword IsNot newReferenceKeyword Then anyChanges = True
            Dim newFile = DirectCast(Visit(node.File), StringLiteralTokenSyntax)
            If node._file IsNot newFile Then anyChanges = True

            If anyChanges Then
                Return New ReferenceDirectiveSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newReferenceKeyword, newFile)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitBadDirective(ByVal node As BadDirectiveSyntax) As SyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True

            If anyChanges Then
                Return New BadDirectiveSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken)
            Else
                Return node
            End If
        End Function

    End Class

End Namespace
