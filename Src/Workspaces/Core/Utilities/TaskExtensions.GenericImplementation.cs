// <auto-generated/>

using System.Threading;
using System.Threading.Tasks;

namespace Roslyn.Utilities
{
    partial class TaskExtensions
    {
        // Implementation is separated out here to allow the C# compiler to cache the necessary generic
        // methods onto this GenericHelpers<TResult> type.  The compiler can't currently cache a generic 
        // anonymous method used in a non-generic class.
#if !COMPILERCORE
        [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
        private static class GenericImplementation<TResult>
        {
            /// <summary>Processes an outer task of task, transferring the appropriate results to the TCS.</summary>
            /// <param name="tcs">The TCS for the proxy task returned to the user.</param>
            /// <param name="task">The outer Task{Task} or Task{Task{TResult}} provided by the user.</param>
            internal static void ProcessOuterTask(TaskCompletionSource<TResult> tcs, Task task)
            {
                Contract.Assert(tcs != null);
                Contract.Assert(task != null);

                // If the outer task has already completed, take the fast path
                // of immediately transferring its results or processing the inner task.
                if (task.IsCompleted)
                {
                    ProcessCompletedOuterTask(tcs, task);
                }
                else // Otherwise, process its completion asynchronously.
                {
                    var scheduler = TaskScheduler.Default;
                    task.SafeContinueWith(
                        antecedent => ProcessCompletedOuterTask(tcs, antecedent),
                        CancellationToken.None, TaskContinuationOptions.ExecuteSynchronously, scheduler);
                }
            }

            /// <summary>Processes the outer task once it's completed.</summary>
            /// <param name="tcs">The TCS for the proxy task returned to the user.</param>
            /// <param name="task">The outer Task{Task} or Task{Task{TResult}} provided by the user.</param>
            private static void ProcessCompletedOuterTask(TaskCompletionSource<TResult> tcs, Task task)
            {
                Contract.Assert(tcs != null);
                Contract.Assert(task != null && task.IsCompleted);

                switch (task.Status)
                {
                    // If the outer task did not complete successfully, then record the 
                    // cancellation/fault information to tcs.Task.
                    case TaskStatus.Canceled:
                    case TaskStatus.Faulted:
                        var result = TrySetFromTask(tcs, task);
                        Contract.Assert(result, "Expected TrySetFromTask from outer task to succeed");
                        break;

                        // Otherwise, process the inner task it returned.
                    case TaskStatus.RanToCompletion:
                        var taskOfTaskOfTResult = task as Task<Task<TResult>>; // it's either a Task<Task> or Task<Task<TResult>>
                        ProcessInnerTask(tcs, taskOfTaskOfTResult != null ?
                            taskOfTaskOfTResult.Result : ((Task<Task>)task).Result);
                        break;
                }
            }

            /// <summary>
            /// Processes the inner task of a Task{Task} or Task{Task{TResult}}, 
            /// transferring the appropriate results to the TCS.
            /// </summary>
            /// <param name="tcs">The TCS for the proxy task returned to the user.</param>
            /// <param name="task">The inner task returned by the task provided by the user.</param>
            private static void ProcessInnerTask(TaskCompletionSource<TResult> tcs, Task task)
            {
                Contract.Assert(tcs != null);

                // If the inner task is null, the proxy should be canceled.
                if (task == null) tcs.TrySetCanceled();

                // Fast path for if the inner task is already completed
                else if (task.IsCompleted) TrySetFromTask(tcs, task);

                // The inner task exists but is not yet complete, so when it does complete,
                // take some action to set the completion state of tcs.Task.
                else
                {
                    var scheduler = TaskScheduler.Default;
                    task.SafeContinueWith(antecedent =>
                    {
                        // Copy completion/cancellation/exception info from task.Result to tcs.Task.
                        var result = TrySetFromTask(tcs, antecedent);
                        Contract.Assert(result, "Expected TrySetFromTask from inner task to succeed");
                    }, CancellationToken.None, TaskContinuationOptions.ExecuteSynchronously, scheduler);
                }
            }

            /// <summary>Transfer the completion status from "task" to "tcs".</summary>
            /// <param name="tcs">The target TCS to which the results of <paramref name="task"/> should be transfered.</param>
            /// <param name="task">The source task whose results should be transfered to <paramref name="tcs"/>.</param>
            /// <returns>true if the transfer was successful; otherwise, false.</returns>
            private static bool TrySetFromTask(TaskCompletionSource<TResult> tcs, Task task)
            {
                Contract.Assert(tcs != null);
                Contract.Assert(task != null && task.IsCompleted, "TrySetFromTask: Expected task to have completed.");

                var result = false;
                switch (task.Status)
                {
                    case TaskStatus.Canceled:
                        result = tcs.TrySetCanceled();
                        break;

                    case TaskStatus.Faulted:
                        result = tcs.TrySetException(task.Exception.InnerExceptions);
                        break;

                    case TaskStatus.RanToCompletion:
                        var taskTResult = task as Task<TResult>;
                        result = tcs.TrySetResult(taskTResult != null ? taskTResult.Result : default(TResult));
                        break;
                }
                return result;
            }
        }
    }
}